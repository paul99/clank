Index: src/base/sys_info.h
===================================================================
--- src/base/sys_info.h	(revision 184497)
+++ src/base/sys_info.h	(working copy)
@@ -104,6 +104,7 @@
   static std::string GetDeviceName();
 
   static int DalvikHeapSizeMB();
+  static int DalvikHeapGrowthLimitMB();
 #endif  // defined(OS_ANDROID)
 };
 
Index: src/base/base.gypi
===================================================================
--- src/base/base.gypi	(revision 184497)
+++ src/base/base.gypi	(working copy)
@@ -240,6 +240,10 @@
           'mach_ipc_mac.mm',
           'memory/aligned_memory.cc',
           'memory/aligned_memory.h',
+          'memory/discardable_memory.cc',
+          'memory/discardable_memory.h',
+          'memory/discardable_memory_android.cc',
+          'memory/discardable_memory_mac.cc',
           'memory/linked_ptr.h',
           'memory/manual_constructor.h',
           'memory/raw_scoped_refptr_mismatch_checker.h',
@@ -638,6 +642,7 @@
               ['include', '^mac/objc_property_releaser\\.'],
               ['include', '^mac/scoped_mach_port\\.'],
               ['include', '^mac/scoped_nsautorelease_pool\\.'],
+              ['include', '^memory/discardable_memory_mac\\.'],
               ['include', '^message_pump_mac\\.'],
               ['include', '^threading/platform_thread_mac\\.'],
               ['include', '^sys_string_conversions_mac\\.'],
Index: src/base/sys_info_android.cc
===================================================================
--- src/base/sys_info_android.cc	(revision 184497)
+++ src/base/sys_info_android.cc	(working copy)
@@ -44,41 +44,70 @@
   *bugfix_version = kDefaultAndroidBugfixVersion;
 }
 
-int ParseHeapSize(const base::StringPiece& str) {
+// Parses a system property (specified with unit 'k','m' or 'g').
+// Returns a value in bytes.
+// Returns -1 if the string could not be parsed.
+int64 ParseSystemPropertyBytes(const base::StringPiece& str) {
   const int64 KB = 1024;
   const int64 MB = 1024 * KB;
   const int64 GB = 1024 * MB;
-  CHECK_GT(str.size(), 0u);
-  int64 factor = 1;
+  if (str.size() == 0u)
+    return -1;
+  int64 unit_multiplier = 1;
   size_t length = str.size();
   if (str[length - 1] == 'k') {
-    factor = KB;
+    unit_multiplier = KB;
     length--;
   } else if (str[length - 1] == 'm') {
-    factor = MB;
+    unit_multiplier = MB;
     length--;
   } else if (str[length - 1] == 'g') {
-    factor = GB;
+    unit_multiplier = GB;
     length--;
-  } else {
-    CHECK('0' <= str[length - 1] && str[length - 1] <= '9');
   }
   int64 result = 0;
   bool parsed = base::StringToInt64(str.substr(0, length), &result);
-  CHECK(parsed);
-  result = result * factor / MB;
-  // dalvik.vm.heapsize property is writable by user,
-  // truncate it to reasonable value to avoid overflows later.
-  result = std::min<int64>(std::max<int64>(32, result), 1024);
-  return static_cast<int>(result);
+  bool negative = result <= 0;
+  bool overflow = result >= std::numeric_limits<int64>::max() / unit_multiplier;
+  if (!parsed || negative || overflow)
+    return -1;
+  return result * unit_multiplier;
 }
 
 int GetDalvikHeapSizeMB() {
   char heap_size_str[PROP_VALUE_MAX];
   __system_property_get("dalvik.vm.heapsize", heap_size_str);
-  return ParseHeapSize(heap_size_str);
+  // dalvik.vm.heapsize property is writable by a root user.
+  // Clamp it to reasonable range as a sanity check,
+  // a typical android device will never have less than 48MB.
+  const int64 MB = 1024 * 1024;
+  int64 result = ParseSystemPropertyBytes(heap_size_str);
+  if (result == -1) {
+     // We should consider not exposing these values if they are not reliable.
+     LOG(ERROR) << "Can't parse dalvik.vm.heapsize: " << heap_size_str;
+     result = base::SysInfo::AmountOfPhysicalMemoryMB() / 3;
+  }
+  result = std::min<int64>(std::max<int64>(32 * MB, result), 1024 * MB) / MB;
+  return static_cast<int>(result);
 }
 
+int GetDalvikHeapGrowthLimitMB() {
+  char heap_size_str[PROP_VALUE_MAX];
+  __system_property_get("dalvik.vm.heapgrowthlimit", heap_size_str);
+  // dalvik.vm.heapgrowthlimit property is writable by a root user.
+  // Clamp it to reasonable range as a sanity check,
+  // a typical android device will never have less than 24MB.
+  const int64 MB = 1024 * 1024;
+  int64 result = ParseSystemPropertyBytes(heap_size_str);
+  if (result == -1) {
+     // We should consider not exposing these values if they are not reliable.
+     LOG(ERROR) << "Can't parse dalvik.vm.heapgrowthlimit: " << heap_size_str;
+     result = base::SysInfo::AmountOfPhysicalMemoryMB() / 6;
+  }
+  result = std::min<int64>(std::max<int64>(16 * MB, result), 512 * MB) / MB;
+  return static_cast<int>(result);
+}
+
 }  // anonymous namespace
 
 namespace base {
@@ -122,4 +151,10 @@
   return heap_size;
 }
 
+int SysInfo::DalvikHeapGrowthLimitMB() {
+  static int heap_growth_limit = GetDalvikHeapGrowthLimitMB();
+  return heap_growth_limit;
+}
+
+
 }  // namespace base
Index: src/base/base.gyp
===================================================================
--- src/base/base.gyp	(revision 184497)
+++ src/base/base.gyp	(working copy)
@@ -476,6 +476,7 @@
         'mac/scoped_sending_event_unittest.mm',
         'md5_unittest.cc',
         'memory/aligned_memory_unittest.cc',
+        'memory/discardable_memory_unittest.cc',
         'memory/linked_ptr_unittest.cc',
         'memory/ref_counted_memory_unittest.cc',
         'memory/ref_counted_unittest.cc',
Index: src/base/threading/platform_thread_posix.cc
===================================================================
--- src/base/threading/platform_thread_posix.cc	(revision 184497)
+++ src/base/threading/platform_thread_posix.cc	(working copy)
@@ -29,6 +29,7 @@
 #endif
 
 #if defined(OS_ANDROID)
+#include <sys/resource.h>
 #include "base/android/jni_android.h"
 #endif
 
@@ -57,6 +58,13 @@
 };
 
 void* ThreadFunc(void* params) {
+#if defined(OS_ANDROID)
+  // Threads on linux/android may inherit their priority from the thread
+  // where they were created. This sets all threads to the default.
+  // TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  if (setpriority(PRIO_PROCESS, PlatformThread::CurrentId(), 0))
+    DVLOG(1) << "Failed to reset initial thread nice value to zero.";
+#endif
   ThreadParams* thread_params = static_cast<ThreadParams*>(params);
   PlatformThread::Delegate* delegate = thread_params->delegate;
   if (!thread_params->joinable)
Index: src/chrome/android/java/src/org/chromium/chrome/browser/autofill/AutofillPopup.java
===================================================================
--- src/chrome/android/java/src/org/chromium/chrome/browser/autofill/AutofillPopup.java	(revision 184497)
+++ src/chrome/android/java/src/org/chromium/chrome/browser/autofill/AutofillPopup.java	(working copy)
@@ -24,6 +24,7 @@
 
 import org.chromium.chrome.R;
 import org.chromium.content.browser.ContainerViewDelegate;
+import org.chromium.content.common.DeviceInfo;
 import org.chromium.ui.gfx.NativeWindow;
 
 /**
@@ -152,7 +153,9 @@
      * @param height The height of the anchor view.
      */
     public void setAnchorRect(float x, float y, float width, float height) {
-        mAnchorRect = new Rect((int) x, (int) y, (int) (x + width), (int) (y + height));
+        float scale = (float) DeviceInfo.create(mNativeWindow.getContext()).getDPIScale();
+        mAnchorRect = new Rect(Math.round(x * scale), Math.round(y * scale),
+                Math.round((x + width) * scale), Math.round((y + height) * scale));
     }
 
     /**
Index: src/chrome/android/javatests/src/org/chromium/chrome/browser/test/SelectPopupOtherContentViewTest.java
===================================================================
--- src/chrome/android/javatests/src/org/chromium/chrome/browser/test/SelectPopupOtherContentViewTest.java	(revision 184497)
+++ src/chrome/android/javatests/src/org/chromium/chrome/browser/test/SelectPopupOtherContentViewTest.java	(working copy)
@@ -6,6 +6,7 @@
 
 import android.test.suitebuilder.annotation.LargeTest;
 
+import org.chromium.base.test.util.DisabledTest;
 import org.chromium.base.test.util.Feature;
 import org.chromium.content.browser.ContentView;
 import org.chromium.content.browser.SelectPopupDialog;
@@ -49,9 +50,12 @@
     /**
      * Tests that the showing select popup does not get closed because an unrelated ContentView
      * gets destroyed.
+     *
+     * @LargeTest
+     * @Feature({"Browser"})
+     * BUG 172967
     */
-    @LargeTest
-    @Feature({"Browser"})
+    @DisabledTest
     public void testPopupNotClosedByOtherContentView()
             throws InterruptedException, Exception, Throwable {
         // Load the test page.
Index: src/chrome/browser/ui/extensions/shell_window.cc
===================================================================
--- src/chrome/browser/ui/extensions/shell_window.cc	(revision 184497)
+++ src/chrome/browser/ui/extensions/shell_window.cc	(working copy)
@@ -89,7 +89,7 @@
 ShellWindow::CreateParams::CreateParams()
   : window_type(ShellWindow::WINDOW_TYPE_DEFAULT),
     frame(ShellWindow::FRAME_CHROME),
-    bounds(INT_MIN, INT_MIN, INT_MIN, INT_MIN),
+    bounds(INT_MIN, INT_MIN, 0, 0),
     creator_process_id(0), hidden(false) {
 }
 
@@ -137,9 +137,9 @@
 
   gfx::Rect bounds = params.bounds;
 
-  if (bounds.width() == INT_MIN)
+  if (bounds.width() == 0)
     bounds.set_width(kDefaultWidth);
-  if (bounds.height() == INT_MIN)
+  if (bounds.height() == 0)
     bounds.set_height(kDefaultHeight);
 
   // If left and top are left undefined, the native shell window will center
Index: src/chrome/browser/ui/extensions/shell_window.h
===================================================================
--- src/chrome/browser/ui/extensions/shell_window.h	(revision 184497)
+++ src/chrome/browser/ui/extensions/shell_window.h	(working copy)
@@ -62,8 +62,9 @@
     Frame frame;
 
     // Specify the initial content bounds of the window (excluding any window
-    // decorations). INT_MIN designates 'unspecified' for any coordinate, and
-    // should be replaced with a default value.
+    // decorations). INT_MIN designates 'unspecified' for the position
+    // components, and 0 for the size components. When unspecified, they should
+    // be replaced with a default value.
     gfx::Rect bounds;
 
     gfx::Size minimum_size;
Index: src/chrome/browser/ui/autofill/autofill_popup_controller_impl.cc
===================================================================
--- src/chrome/browser/ui/autofill/autofill_popup_controller_impl.cc	(revision 184497)
+++ src/chrome/browser/ui/autofill/autofill_popup_controller_impl.cc	(working copy)
@@ -63,7 +63,7 @@
 AutofillPopupControllerImpl::AutofillPopupControllerImpl(
     AutofillPopupDelegate* delegate,
     gfx::NativeView container_view,
-    const gfx::Rect& element_bounds)
+    const gfx::RectF& element_bounds)
     : view_(NULL),
       delegate_(delegate),
       container_view_(container_view),
@@ -258,7 +258,7 @@
   return container_view_;
 }
 
-const gfx::Rect& AutofillPopupControllerImpl::element_bounds() const {
+const gfx::RectF& AutofillPopupControllerImpl::element_bounds() const {
   return element_bounds_;
 }
 
Index: src/chrome/browser/ui/autofill/autofill_popup_controller_impl.h
===================================================================
--- src/chrome/browser/ui/autofill/autofill_popup_controller_impl.h	(revision 184497)
+++ src/chrome/browser/ui/autofill/autofill_popup_controller_impl.h	(working copy)
@@ -27,7 +27,7 @@
  public:
   AutofillPopupControllerImpl(AutofillPopupDelegate* delegate,
                               gfx::NativeView container_view,
-                              const gfx::Rect& element_bounds);
+                              const gfx::RectF& element_bounds);
 
   // Shows the popup, or updates the existing popup with the given values.
   void Show(const std::vector<string16>& autofill_values,
@@ -66,7 +66,7 @@
   virtual void SetPopupBounds(const gfx::Rect& bounds) OVERRIDE;
   virtual const gfx::Rect& popup_bounds() const OVERRIDE;
   virtual gfx::NativeView container_view() const OVERRIDE;
-  virtual const gfx::Rect& element_bounds() const OVERRIDE;
+  virtual const gfx::RectF& element_bounds() const OVERRIDE;
   virtual const std::vector<string16>& autofill_values() const OVERRIDE;
   virtual const std::vector<string16>& autofill_labels() const OVERRIDE;
   virtual const std::vector<string16>& autofill_icons() const OVERRIDE;
@@ -122,7 +122,7 @@
   gfx::NativeView container_view_;  // Weak reference.
 
   // The bounds of the text element that is the focus of the Autofill.
-  const gfx::Rect element_bounds_;
+  const gfx::RectF element_bounds_;
 
   // The bounds of the Autofill popup.
   gfx::Rect popup_bounds_;
Index: src/chrome/browser/ui/autofill/autofill_popup_controller_unittest.cc
===================================================================
--- src/chrome/browser/ui/autofill/autofill_popup_controller_unittest.cc	(revision 184497)
+++ src/chrome/browser/ui/autofill/autofill_popup_controller_unittest.cc	(working copy)
@@ -35,7 +35,7 @@
  public:
   explicit TestAutofillPopupController(
       AutofillExternalDelegate* external_delegate)
-      : AutofillPopupControllerImpl(external_delegate, NULL, gfx::Rect()) {}
+      : AutofillPopupControllerImpl(external_delegate, NULL, gfx::RectF()) {}
   virtual ~TestAutofillPopupController() {}
 
   // Making protected functions public for testing
Index: src/chrome/browser/ui/autofill/autofill_popup_controller.h
===================================================================
--- src/chrome/browser/ui/autofill/autofill_popup_controller.h	(revision 184497)
+++ src/chrome/browser/ui/autofill/autofill_popup_controller.h	(working copy)
@@ -14,6 +14,7 @@
 class Font;
 class Point;
 class Rect;
+class RectF;
 }
 
 // This interface provides data to an AutofillPopupView.
@@ -71,7 +72,7 @@
   virtual gfx::NativeView container_view() const = 0;
 
   // The bounds of the form field element (relative to |container_origin|).
-  virtual const gfx::Rect& element_bounds() const = 0;
+  virtual const gfx::RectF& element_bounds() const = 0;
 
   virtual const std::vector<string16>& autofill_values() const = 0;
   virtual const std::vector<string16>& autofill_labels() const = 0;
Index: src/chrome/browser/autofill/autofill_external_delegate.h
===================================================================
--- src/chrome/browser/autofill/autofill_external_delegate.h	(revision 184497)
+++ src/chrome/browser/autofill/autofill_external_delegate.h	(working copy)
@@ -66,7 +66,7 @@
   virtual void OnQuery(int query_id,
                        const FormData& form,
                        const FormFieldData& field,
-                       const gfx::Rect& element_bounds,
+                       const gfx::RectF& element_bounds,
                        bool display_warning_if_disabled);
 
   // Records query results and correctly formats them before sending them off
@@ -81,7 +81,7 @@
   // Show password suggestions in the popup.
   void OnShowPasswordSuggestions(const std::vector<string16>& suggestions,
                                  const FormFieldData& field,
-                                 const gfx::Rect& bounds);
+                                 const gfx::RectF& bounds);
 
   // Set the data list value associated with the current field.
   void SetCurrentDataListValues(const std::vector<string16>& autofill_values,
@@ -121,7 +121,7 @@
 
   // Create the popup if it doesn't already exist. |element_bounds| is the
   // bounding rect for the element it is popping up for.
-  virtual void EnsurePopupForElement(const gfx::Rect& element_bounds);
+  virtual void EnsurePopupForElement(const gfx::RectF& element_bounds);
 
   content::WebContents* web_contents() { return web_contents_; }
 
Index: src/chrome/browser/autofill/test_autofill_external_delegate.h
===================================================================
--- src/chrome/browser/autofill/test_autofill_external_delegate.h	(revision 184497)
+++ src/chrome/browser/autofill/test_autofill_external_delegate.h	(working copy)
@@ -33,7 +33,7 @@
 
   virtual void HideAutofillPopup() OVERRIDE;
 
-  virtual void EnsurePopupForElement(const gfx::Rect& element_bounds) OVERRIDE;
+  virtual void EnsurePopupForElement(const gfx::RectF& element_bounds) OVERRIDE;
 
   virtual void ControllerDestroyed() OVERRIDE;
 
Index: src/chrome/browser/autofill/autofill_manager.h
===================================================================
--- src/chrome/browser/autofill/autofill_manager.h	(revision 184497)
+++ src/chrome/browser/autofill/autofill_manager.h	(working copy)
@@ -58,6 +58,7 @@
 
 namespace gfx {
 class Rect;
+class RectF;
 }
 
 namespace IPC {
@@ -216,7 +217,7 @@
   void OnQueryFormFieldAutofill(int query_id,
                                 const FormData& form,
                                 const FormFieldData& field,
-                                const gfx::Rect& bounding_box,
+                                const gfx::RectF& bounding_box,
                                 bool display_warning);
   void OnDidEndTextFieldEditing();
   void OnHideAutofillPopup();
@@ -224,7 +225,7 @@
       const FormFieldData& form,
       const PasswordFormFillData& fill_data);
   void OnShowPasswordSuggestions(const FormFieldData& field,
-                                 const gfx::Rect& bounds,
+                                 const gfx::RectF& bounds,
                                  const std::vector<string16>& suggestions);
   void OnSetDataList(const std::vector<string16>& values,
                      const std::vector<string16>& labels,
Index: src/chrome/browser/autofill/autofill_manager.cc
===================================================================
--- src/chrome/browser/autofill/autofill_manager.cc	(revision 184497)
+++ src/chrome/browser/autofill/autofill_manager.cc	(working copy)
@@ -493,7 +493,7 @@
 void AutofillManager::OnQueryFormFieldAutofill(int query_id,
                                                const FormData& form,
                                                const FormFieldData& field,
-                                               const gfx::Rect& bounding_box,
+                                               const gfx::RectF& bounding_box,
                                                bool display_warning) {
   std::vector<string16> values;
   std::vector<string16> labels;
@@ -756,7 +756,7 @@
 
 void AutofillManager::OnShowPasswordSuggestions(
     const FormFieldData& field,
-    const gfx::Rect& bounds,
+    const gfx::RectF& bounds,
     const std::vector<string16>& suggestions) {
   if (external_delegate_)
     external_delegate_->OnShowPasswordSuggestions(suggestions, field, bounds);
Index: src/chrome/browser/autofill/test_autofill_external_delegate.cc
===================================================================
--- src/chrome/browser/autofill/test_autofill_external_delegate.cc	(revision 184497)
+++ src/chrome/browser/autofill/test_autofill_external_delegate.cc	(working copy)
@@ -15,7 +15,7 @@
   FormFieldData field;
   field.is_focusable = true;
   field.should_autocomplete = true;
-  gfx::Rect bounds(100, 100);
+  gfx::RectF bounds(100.f, 100.f);
   autofill_external_delegate->OnQuery(query_id, form, field, bounds, false);
 
   std::vector<string16> autofill_item;
@@ -31,7 +31,7 @@
     AutofillManager* autofill_manager)
     : AutofillExternalDelegate(web_contents, autofill_manager) {
   // Initialize Controller.
-  const gfx::Rect element_bounds;
+  const gfx::RectF element_bounds;
   AutofillExternalDelegate::EnsurePopupForElement(element_bounds);
 }
 
@@ -46,7 +46,7 @@
 void TestAutofillExternalDelegate::HideAutofillPopup() {}
 
 void TestAutofillExternalDelegate::EnsurePopupForElement(
-    const gfx::Rect& element_bounds) {}
+    const gfx::RectF& element_bounds) {}
 
 void TestAutofillExternalDelegate::ControllerDestroyed() {}
 
Index: src/chrome/browser/autofill/autofill_external_delegate_unittest.cc
===================================================================
--- src/chrome/browser/autofill/autofill_external_delegate_unittest.cc	(revision 184497)
+++ src/chrome/browser/autofill/autofill_external_delegate_unittest.cc	(working copy)
@@ -48,7 +48,7 @@
 
   MOCK_METHOD0(ClearPreviewedForm, void());
 
-  MOCK_METHOD1(EnsurePopupForElement, void(const gfx::Rect& element_bounds));
+  MOCK_METHOD1(EnsurePopupForElement, void(const gfx::RectF& element_bounds));
 
   MOCK_METHOD0(HideAutofillPopup, void());
 };
@@ -89,7 +89,7 @@
     FormFieldData field;
     field.is_focusable = true;
     field.should_autocomplete = true;
-    const gfx::Rect element_bounds;
+    const gfx::RectF element_bounds;
 
     EXPECT_CALL(*external_delegate_, EnsurePopupForElement(element_bounds));
     external_delegate_->OnQuery(query_id, form, field, element_bounds, false);
@@ -267,7 +267,7 @@
   FormFieldData field;
   field.is_focusable = true;
   field.should_autocomplete = true;
-  const gfx::Rect element_bounds;
+  const gfx::RectF element_bounds;
 
   EXPECT_CALL(*external_delegate_, EnsurePopupForElement(element_bounds));
 
Index: src/chrome/browser/autofill/autofill_external_delegate.cc
===================================================================
--- src/chrome/browser/autofill/autofill_external_delegate.cc	(revision 184497)
+++ src/chrome/browser/autofill/autofill_external_delegate.cc	(working copy)
@@ -79,7 +79,7 @@
 void AutofillExternalDelegate::OnQuery(int query_id,
                                        const FormData& form,
                                        const FormFieldData& field,
-                                       const gfx::Rect& element_bounds,
+                                       const gfx::RectF& element_bounds,
                                        bool display_warning_if_disabled) {
   autofill_query_form_ = form;
   autofill_query_field_ = field;
@@ -155,7 +155,7 @@
 void AutofillExternalDelegate::OnShowPasswordSuggestions(
     const std::vector<string16>& suggestions,
     const FormFieldData& field,
-    const gfx::Rect& element_bounds) {
+    const gfx::RectF& element_bounds) {
   autofill_query_field_ = field;
   EnsurePopupForElement(element_bounds);
 
@@ -171,7 +171,7 @@
 }
 
 void AutofillExternalDelegate::EnsurePopupForElement(
-    const gfx::Rect& element_bounds) {
+    const gfx::RectF& element_bounds) {
   if (controller_)
     return;
 
Index: src/chrome/browser/resources/ntp_android/ntp_android.js
===================================================================
--- src/chrome/browser/resources/ntp_android/ntp_android.js	(revision 184497)
+++ src/chrome/browser/resources/ntp_android/ntp_android.js	(working copy)
@@ -1821,20 +1821,25 @@
     var zoom = window.getComputedStyle(fold).zoom;
     var scale = 1 / window.getComputedStyle(fold).zoom;
 
+    // The width/height of the canvas.  Set to 24 so it looks good across all
+    // resolutions.
+    var cw = 24;
+    var ch = 24;
+
     // Get the fold canvas and create a path for the fold shape
     var ctx = document.getCSSCanvasContext(
-        '2d', 'fold_' + index, 12 * scale, 12 * scale);
+        '2d', 'fold_' + index, cw * scale, ch * scale);
     ctx.beginPath();
     ctx.moveTo(0, 0);
-    ctx.lineTo(0, 9 * scale);
+    ctx.lineTo(0, ch * 0.75 * scale);
     ctx.quadraticCurveTo(
-        0, 12 * scale,
-        3 * scale, 12 * scale);
-    ctx.lineTo(12 * scale, 12 * scale);
+        0, ch * scale,
+        cw * .25 * scale, ch * scale);
+    ctx.lineTo(cw * scale, ch * scale);
     ctx.closePath();
 
     // Create a gradient for the fold and fill it
-    var gradient = ctx.createLinearGradient(12 * scale, 0, 0, 12 * scale);
+    var gradient = ctx.createLinearGradient(cw * scale, 0, 0, ch * scale);
     if (color.indexOf('#') == 0) {
       var r = parseInt(color.substring(1, 3), 16);
       var g = parseInt(color.substring(3, 5), 16);
Index: src/chrome/browser/resources/ntp_android/bookmarks.css
===================================================================
--- src/chrome/browser/resources/ntp_android/bookmarks.css	(revision 184497)
+++ src/chrome/browser/resources/ntp_android/bookmarks.css	(working copy)
@@ -207,12 +207,6 @@
 }
 
 @media screen and (-webkit-min-device-pixel-ratio: 1.32) {
-  .favicon-box.document .fold {
-    /* this is to make the canvas scale properly */
-    height: 16px;
-    width: 16px;
-    zoom: 0.75;
-  }
   .favicon-box.document {
     background-image: url(images/bookmark_bg_tvdpi.png);
   }
@@ -240,12 +234,6 @@
 }
 
 @media screen and (-webkit-min-device-pixel-ratio: 1.5) {
-  .favicon-box.document .fold {
-    /* this is to make the canvas scale properly */
-    height: 18px;
-    width: 18px;
-    zoom: 0.66;
-  }
   .favicon-box.document {
     background-image: url(images/bookmark_bg_hdpi.png);
   }
@@ -261,12 +249,6 @@
 }
 
 @media screen and (-webkit-min-device-pixel-ratio: 2.0) {
-  .favicon-box.document .fold {
-    /* this is to make the canvas scale properly */
-    height: 24px;
-    width: 24px;
-    zoom: 0.5;
-  }
   .favicon-box.document {
     background-image: url(images/bookmark_bg_xhdpi.png);
   }
Index: src/chrome/browser/chromeos/login/login_utils.cc
===================================================================
--- src/chrome/browser/chromeos/login/login_utils.cc	(revision 184497)
+++ src/chrome/browser/chromeos/login/login_utils.cc	(working copy)
@@ -82,6 +82,7 @@
 #include "google_apis/gaia/gaia_constants.h"
 #include "google_apis/gaia/gaia_urls.h"
 #include "googleurl/src/gurl.h"
+#include "gpu/command_buffer/service/gpu_switches.h"
 #include "media/base/media_switches.h"
 #include "net/base/network_change_notifier.h"
 #include "net/url_request/url_request_context.h"
@@ -703,6 +704,7 @@
       ::switches::kDisableAcceleratedVideoDecode,
       ::switches::kDisableGpuWatchdog,
       ::switches::kDisableLoginAnimations,
+      ::switches::kDisableNonuniformGpuMemPolicy,
       ::switches::kDisableOobeAnimation,
       ::switches::kDisableSeccompFilterSandbox,
       ::switches::kDisableSeccompSandbox,
Index: src/chrome/renderer/chrome_render_view_observer.cc
===================================================================
--- src/chrome/renderer/chrome_render_view_observer.cc	(revision 184497)
+++ src/chrome/renderer/chrome_render_view_observer.cc	(working copy)
@@ -819,7 +819,7 @@
   if (!bitmap.copyTo(snapshot, SkBitmap::kARGB_8888_Config))
     return false;
 
-  HISTOGRAM_TIMES("Renderer4.Snapshot",
+  UMA_HISTOGRAM_TIMES("Renderer4.Snapshot",
                   base::TimeTicks::Now() - beginning_time);
   return true;
 }
Index: src/chrome/renderer/resources/mobile_youtube_plugin.html
===================================================================
--- src/chrome/renderer/resources/mobile_youtube_plugin.html	(revision 184497)
+++ src/chrome/renderer/resources/mobile_youtube_plugin.html	(working copy)
@@ -13,6 +13,7 @@
   background-color: black;
   background-repeat: no-repeat;
   background-size: cover;
+  overflow: hidden;
 }
 
 #main {
@@ -32,8 +33,8 @@
 
 #logo {
   position: absolute;
-  right: 0px;
-  bottom: 0px;
+  right: 5px;
+  bottom: 5px;
 }
 
 #play {
Index: src/chrome/renderer/autofill/password_autofill_manager.cc
===================================================================
--- src/chrome/renderer/autofill/password_autofill_manager.cc	(revision 184497)
+++ src/chrome/renderer/autofill/password_autofill_manager.cc	(working copy)
@@ -208,6 +208,7 @@
     content::RenderView* render_view)
     : content::RenderViewObserver(render_view),
       disable_popup_(false),
+      web_view_(render_view->GetWebView()),
       ALLOW_THIS_IN_INITIALIZER_LIST(weak_ptr_factory_(this)) {
 }
 
@@ -511,9 +512,15 @@
 
     WebKit::WebInputElement selected_element = user_input;
     gfx::Rect bounding_box(selected_element.boundsInViewportSpace());
+
+    float scale = web_view_->pageScaleFactor();
+    gfx::RectF bounding_box_scaled(bounding_box.x() * scale,
+                                   bounding_box.y() * scale,
+                                   bounding_box.width() * scale,
+                                   bounding_box.height() * scale);
     Send(new AutofillHostMsg_ShowPasswordSuggestions(routing_id(),
                                                      field,
-                                                     bounding_box,
+                                                     bounding_box_scaled,
                                                      suggestions));
     return !suggestions.empty();
   }
Index: src/chrome/renderer/autofill/password_autofill_manager.h
===================================================================
--- src/chrome/renderer/autofill/password_autofill_manager.h	(revision 184497)
+++ src/chrome/renderer/autofill/password_autofill_manager.h	(working copy)
@@ -17,6 +17,7 @@
 namespace WebKit {
 class WebInputElement;
 class WebKeyboardEvent;
+class WebView;
 }
 
 namespace autofill {
@@ -117,6 +118,9 @@
   // Used to disable and hide the popup.
   bool disable_popup_;
 
+  // Pointer to the WebView. Used to access page scale factor.
+  WebKit::WebView* web_view_;
+
   base::WeakPtrFactory<PasswordAutofillManager> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(PasswordAutofillManager);
Index: src/chrome/renderer/autofill/autofill_agent.cc
===================================================================
--- src/chrome/renderer/autofill/autofill_agent.cc	(revision 184497)
+++ src/chrome/renderer/autofill/autofill_agent.cc	(working copy)
@@ -129,10 +129,12 @@
       password_autofill_manager_(password_autofill_manager),
       autofill_query_id_(0),
       autofill_action_(AUTOFILL_NONE),
+      web_view_(render_view->GetWebView()),
       display_warning_if_disabled_(false),
       was_query_node_autofilled_(false),
       has_shown_autofill_popup_for_current_edit_(false),
       did_set_node_text_(false),
+      ignore_text_changes_(false),
       ALLOW_THIS_IN_INITIALIZER_LIST(weak_ptr_factory_(this)) {
   render_view->GetWebView()->setAutofillClient(this);
 }
@@ -242,6 +244,10 @@
       render_view()->GetSSLStatusOfFrame(frame)));
 }
 
+void AutofillAgent::setIgnoreTextChanges(bool ignore) {
+  ignore_text_changes_ = ignore;
+}
+
 bool AutofillAgent::InputElementClicked(const WebInputElement& element,
                                         bool was_focused,
                                         bool is_focused) {
@@ -338,6 +344,9 @@
 }
 
 void AutofillAgent::textFieldDidChange(const WebInputElement& element) {
+  if (ignore_text_changes_)
+    return;
+
   if (did_set_node_text_) {
     did_set_node_text_ = false;
     return;
@@ -689,6 +698,12 @@
 
   gfx::Rect bounding_box(element_.boundsInViewportSpace());
 
+  float scale = web_view_->pageScaleFactor();
+  gfx::RectF bounding_box_scaled(bounding_box.x() * scale,
+                                 bounding_box.y() * scale,
+                                 bounding_box.width() * scale,
+                                 bounding_box.height() * scale);
+
   // Find the datalist values and send them to the browser process.
   std::vector<string16> data_list_values;
   std::vector<string16> data_list_labels;
@@ -715,7 +730,7 @@
                                                   autofill_query_id_,
                                                   form,
                                                   field,
-                                                  bounding_box,
+                                                  bounding_box_scaled,
                                                   display_warning_if_disabled));
 }
 
Index: src/chrome/renderer/autofill/autofill_agent.h
===================================================================
--- src/chrome/renderer/autofill/autofill_agent.h	(revision 184497)
+++ src/chrome/renderer/autofill/autofill_agent.h	(working copy)
@@ -22,6 +22,7 @@
 
 namespace WebKit {
 class WebNode;
+class WebView;
 }
 
 namespace autofill {
@@ -92,6 +93,7 @@
   virtual void didRequestAutocomplete(
       WebKit::WebFrame* frame,
       const WebKit::WebFormElement& form) OVERRIDE;
+  virtual void setIgnoreTextChanges(bool ignore) OVERRIDE;
 
   void OnSuggestionsReturned(int query_id,
                              const std::vector<string16>& values,
@@ -197,6 +199,9 @@
   // The action to take when receiving Autofill data from the AutofillManager.
   AutofillAction autofill_action_;
 
+  // Pointer to the WebView. Used to access page scale factor.
+  WebKit::WebView* web_view_;
+
   // Should we display a warning if autofill is disabled?
   bool display_warning_if_disabled_;
 
@@ -210,6 +215,11 @@
   // If true we just set the node text so we shouldn't show the popup.
   bool did_set_node_text_;
 
+  // Whether or not to ignore text changes.  Useful for when we're committing
+  // a composition when we are defocusing the WebView and we don't want to
+  // trigger an autofill popup to show.
+  bool ignore_text_changes_;
+
   base::WeakPtrFactory<AutofillAgent> weak_ptr_factory_;
 
   friend class PasswordAutofillManagerTest;
Index: src/chrome/common/autofill_messages.h
===================================================================
--- src/chrome/common/autofill_messages.h	(revision 184497)
+++ src/chrome/common/autofill_messages.h	(working copy)
@@ -185,7 +185,7 @@
                     int /* id of this message */,
                     FormData /* the form */,
                     FormFieldData /* the form field */,
-                    gfx::Rect /* input field bounds, window-relative */,
+                    gfx::RectF /* input field bounds, window-relative */,
                     bool /* display warning if autofill disabled */)
 
 // Sent when the popup with Autofill suggestions for a form is shown.
@@ -245,7 +245,7 @@
 // password manager.
 IPC_MESSAGE_ROUTED3(AutofillHostMsg_ShowPasswordSuggestions,
                     FormFieldData /* the form field */,
-                    gfx::Rect /* input field bounds, window-relative */,
+                    gfx::RectF /* input field bounds, window-relative */,
                     std::vector<string16> /* suggestions */)
 
 // Inform browser of data list values for the curent field.
Index: src/ui/android/ui_jni_registrar.cc
===================================================================
--- src/ui/android/ui_jni_registrar.cc	(revision 184497)
+++ src/ui/android/ui_jni_registrar.cc	(working copy)
@@ -7,11 +7,13 @@
 #include "base/android/jni_android.h"
 #include "base/android/jni_registrar.h"
 #include "ui/base/dialogs/select_file_dialog_android.h"
+#include "ui/gfx/android/device_display_info.h"
 #include "ui/gfx/android/window_android.h"
 
 namespace ui {
 
 static base::android::RegistrationMethod kUiRegisteredMethods[] = {
+  { "DeviceDisplayInfo", gfx::DeviceDisplayInfo::RegisterDeviceDisplayInfo },
   { "NativeWindow", WindowAndroid::RegisterWindowAndroid },
   { "SelectFileDialog", SelectFileDialogImpl::RegisterSelectFileDialog },
 };
Index: src/ui/gfx/screen_android.cc
===================================================================
--- src/ui/gfx/screen_android.cc	(revision 184497)
+++ src/ui/gfx/screen_android.cc	(working copy)
@@ -5,7 +5,9 @@
 #include "ui/gfx/screen.h"
 
 #include "base/logging.h"
+#include "ui/gfx/android/device_display_info.h"
 #include "ui/gfx/display.h"
+#include "ui/gfx/size_conversions.h"
 
 namespace gfx {
 
@@ -14,7 +16,7 @@
   ScreenAndroid() {}
 
   bool IsDIPEnabled() OVERRIDE {
-    return false;
+    return true;
   }
 
   gfx::Point GetCursorScreenPoint() OVERRIDE {
@@ -27,8 +29,18 @@
   }
 
   gfx::Display GetPrimaryDisplay() const OVERRIDE {
-    NOTIMPLEMENTED() << "crbug.com/117839 tracks implementation";
-    return gfx::Display(0, gfx::Rect(0, 0, 1, 1));
+    gfx::DeviceDisplayInfo device_info;
+    const float device_scale_factor = device_info.GetDIPScale();
+    const gfx::Rect bounds_in_pixels =
+        gfx::Rect(
+            device_info.GetDisplayWidth(),
+            device_info.GetDisplayHeight());
+    const gfx::Rect bounds_in_dip =
+        gfx::Rect(gfx::ToCeiledSize(gfx::ScaleSize(
+            bounds_in_pixels.size(), 1.0f / device_scale_factor)));
+    gfx::Display display(0, bounds_in_dip);
+    display.set_device_scale_factor(device_scale_factor);
+    return display;
   }
 
   gfx::Display GetDisplayNearestWindow(gfx::NativeView view) const OVERRIDE {
Index: src/ui/gfx/size_unittest.cc
===================================================================
--- src/ui/gfx/size_unittest.cc	(revision 184497)
+++ src/ui/gfx/size_unittest.cc	(working copy)
@@ -43,12 +43,6 @@
   EXPECT_EQ(Size(10, 10), ToFlooredSize(SizeF(10.4999f, 10.4999f)));
   EXPECT_EQ(Size(10, 10), ToFlooredSize(SizeF(10.5f, 10.5f)));
   EXPECT_EQ(Size(10, 10), ToFlooredSize(SizeF(10.9999f, 10.9999f)));
-
-  EXPECT_EQ(Size(-10, -10), ToFlooredSize(SizeF(-10, -10)));
-  EXPECT_EQ(Size(-11, -11), ToFlooredSize(SizeF(-10.0001f, -10.0001f)));
-  EXPECT_EQ(Size(-11, -11), ToFlooredSize(SizeF(-10.4999f, -10.4999f)));
-  EXPECT_EQ(Size(-11, -11), ToFlooredSize(SizeF(-10.5f, -10.5f)));
-  EXPECT_EQ(Size(-11, -11), ToFlooredSize(SizeF(-10.9999f, -10.9999f)));
 }
 
 TEST(SizeTest, ToCeiledSize) {
@@ -63,12 +57,6 @@
   EXPECT_EQ(Size(11, 11), ToCeiledSize(SizeF(10.4999f, 10.4999f)));
   EXPECT_EQ(Size(11, 11), ToCeiledSize(SizeF(10.5f, 10.5f)));
   EXPECT_EQ(Size(11, 11), ToCeiledSize(SizeF(10.9999f, 10.9999f)));
-
-  EXPECT_EQ(Size(-10, -10), ToCeiledSize(SizeF(-10, -10)));
-  EXPECT_EQ(Size(-10, -10), ToCeiledSize(SizeF(-10.0001f, -10.0001f)));
-  EXPECT_EQ(Size(-10, -10), ToCeiledSize(SizeF(-10.4999f, -10.4999f)));
-  EXPECT_EQ(Size(-10, -10), ToCeiledSize(SizeF(-10.5f, -10.5f)));
-  EXPECT_EQ(Size(-10, -10), ToCeiledSize(SizeF(-10.9999f, -10.9999f)));
 }
 
 TEST(SizeTest, ToRoundedSize) {
@@ -83,12 +71,6 @@
   EXPECT_EQ(Size(10, 10), ToRoundedSize(SizeF(10.4999f, 10.4999f)));
   EXPECT_EQ(Size(11, 11), ToRoundedSize(SizeF(10.5f, 10.5f)));
   EXPECT_EQ(Size(11, 11), ToRoundedSize(SizeF(10.9999f, 10.9999f)));
-
-  EXPECT_EQ(Size(-10, -10), ToRoundedSize(SizeF(-10, -10)));
-  EXPECT_EQ(Size(-10, -10), ToRoundedSize(SizeF(-10.0001f, -10.0001f)));
-  EXPECT_EQ(Size(-10, -10), ToRoundedSize(SizeF(-10.4999f, -10.4999f)));
-  EXPECT_EQ(Size(-11, -11), ToRoundedSize(SizeF(-10.5f, -10.5f)));
-  EXPECT_EQ(Size(-11, -11), ToRoundedSize(SizeF(-10.9999f, -10.9999f)));
 }
 
 TEST(SizeTest, ClampSize) {
Index: src/ui/gfx/transform.h
===================================================================
--- src/ui/gfx/transform.h	(revision 184497)
+++ src/ui/gfx/transform.h	(working copy)
@@ -35,6 +35,18 @@
   // Initialize with the concatenation of lhs * rhs.
   Transform(const Transform& lhs, const Transform& rhs)
       : matrix_(lhs.matrix_, rhs.matrix_) {}
+  // Constructs a transform from explicit 16 matrix elements. Elements
+  // should be given in row-major order.
+  Transform(double col1row1, double col2row1, double col3row1, double col4row1,
+            double col1row2, double col2row2, double col3row2, double col4row2,
+            double col1row3, double col2row3, double col3row3, double col4row3,
+            double col1row4, double col2row4, double col3row4, double col4row4);
+  // Constructs a transform from explicit 2d elements. All other matrix
+  // elements remain the same as the corresponding elements of an identity
+  // matrix.
+  Transform(double col1row1, double col2row1,
+            double col1row2, double col2row2,
+            double x_translation, double y_translation);
   ~Transform() {}
 
   bool operator==(const Transform& rhs) const { return matrix_ == rhs.matrix_; }
@@ -89,6 +101,15 @@
     return !(matrix_.getType() & ~SkMatrix44::kTranslate_Mask);
   }
 
+  // Returns true if the matrix is either a positive scale and/or a translation.
+  bool IsPositiveScaleOrTranslation() const {
+    if (!IsScaleOrTranslation())
+      return false;
+    return matrix_.getDouble(0, 0) > 0.0 &&
+        matrix_.getDouble(1, 1) > 0.0 &&
+        matrix_.getDouble(2, 2) > 0.0;
+  }
+
   // Returns true if the matrix is either identity or pure, non-fractional
   // translation.
   bool IsIdentityOrIntegerTranslation() const;
@@ -118,6 +139,22 @@
   // Transposes this transform in place.
   void Transpose();
 
+  // Set 3rd row and 3rd colum to (0, 0, 1, 0). Note that this flattening
+  // operation is not quite the same as an orthographic projection and is
+  // technically not a linear operation.
+  //
+  // One useful interpretation of doing this operation:
+  //  - For x and y values, the new transform behaves effectively like an
+  //    orthographic projection was added to the matrix sequence.
+  //  - For z values, the new transform overrides any effect that the transform
+  //    had on z, and instead it preserves the z value for any points that are
+  //    transformed.
+  //  - Because of linearity of transforms, this flattened transform also
+  //    preserves the effect that any subsequent (multiplied from the right)
+  //    transforms would have on z values.
+  //
+  void FlattenTo2d();
+
   // Applies the transformation on the point. Returns true if the point is
   // transformed successfully.
   void TransformPoint(Point3F& point) const;
Index: src/ui/gfx/rect_unittest.cc
===================================================================
--- src/ui/gfx/rect_unittest.cc	(revision 184497)
+++ src/ui/gfx/rect_unittest.cc	(working copy)
@@ -441,10 +441,7 @@
       std::numeric_limits<float>::max(),
       std::numeric_limits<float>::max(),
       std::numeric_limits<float>::max(),
-      std::numeric_limits<float>::max() },
-    { 3, 3, 3, 3,
-      -1.0f,
-      -3.0f, -3.0f, 0.0f, 0.0f }
+      std::numeric_limits<float>::max() }
   };
 
   for (size_t i = 0; i < ARRAYSIZE_UNSAFE(tests); ++i) {
Index: src/ui/gfx/rect_f.cc
===================================================================
--- src/ui/gfx/rect_f.cc	(revision 184497)
+++ src/ui/gfx/rect_f.cc	(working copy)
@@ -31,18 +31,6 @@
                             size().ToString().c_str());
 }
 
-RectF operator+(const RectF& lhs, const Vector2dF& rhs) {
-  RectF result(lhs);
-  result += rhs;
-  return result;
-}
-
-RectF operator-(const RectF& lhs, const Vector2dF& rhs) {
-  RectF result(lhs);
-  result -= rhs;
-  return result;
-}
-
 RectF IntersectRects(const RectF& a, const RectF& b) {
   RectF result = a;
   result.Intersect(b);
@@ -61,12 +49,6 @@
   return result;
 }
 
-RectF ScaleRect(const RectF& r, float x_scale, float y_scale) {
-  RectF result = r;
-  result.Scale(x_scale, y_scale);
-  return result;
-}
-
 RectF BoundingRect(const PointF& p1, const PointF& p2) {
   float rx = std::min(p1.x(), p2.x());
   float ry = std::min(p1.y(), p2.y());
Index: src/ui/gfx/quad_f.h
===================================================================
--- src/ui/gfx/quad_f.h	(revision 184497)
+++ src/ui/gfx/quad_f.h	(working copy)
@@ -22,7 +22,6 @@
   explicit QuadF(const RectF& rect);
   ~QuadF();
 
-  void operator=(const QuadF& quad);
   void operator=(const RectF& rect);
 
   void set_p1(const PointF& p) { p1_ = p; }
Index: src/ui/gfx/transform_util_unittest.cc
===================================================================
--- src/ui/gfx/transform_util_unittest.cc	(revision 184497)
+++ src/ui/gfx/transform_util_unittest.cc	(working copy)
@@ -4,8 +4,8 @@
 
 #include "ui/gfx/transform_util.h"
 
+#include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/point.h"
-#include "testing/gtest/include/gtest/gtest.h"
 
 namespace gfx {
 namespace {
Index: src/ui/gfx/transform_unittest.cc
===================================================================
--- src/ui/gfx/transform_unittest.cc	(revision 184497)
+++ src/ui/gfx/transform_unittest.cc	(working copy)
@@ -22,25 +22,6 @@
 
 namespace {
 
-bool PointsAreNearlyEqual(const Point3F& lhs,
-                          const Point3F& rhs) {
-  float epsilon = 0.0001f;
-  return lhs.SquaredDistanceTo(rhs) < epsilon;
-}
-
-bool MatricesAreNearlyEqual(const Transform& lhs,
-                            const Transform& rhs) {
-  float epsilon = 0.0001f;
-  for (int row = 0; row < 4; ++row) {
-    for (int col = 0; col < 4; ++col) {
-      if (std::abs(lhs.matrix().get(row, col) -
-                   rhs.matrix().get(row, col)) > epsilon)
-        return false;
-    }
-  }
-  return true;
-}
-
 #define EXPECT_ROW1_EQ(a, b, c, d, transform)               \
     EXPECT_FLOAT_EQ((a), (transform).matrix().get(0, 0));   \
     EXPECT_FLOAT_EQ((b), (transform).matrix().get(0, 1));   \
@@ -68,24 +49,95 @@
 // Checking float values for equality close to zero is not robust using
 // EXPECT_FLOAT_EQ (see gtest documentation). So, to verify rotation matrices,
 // we must use a looser absolute error threshold in some places.
-#define EXPECT_ROW1_NEAR(a, b, c, d, transform, errorThreshold)               \
-    EXPECT_NEAR((a), (transform).matrix().get(0, 0), (errorThreshold));       \
-    EXPECT_NEAR((b), (transform).matrix().get(0, 1), (errorThreshold));       \
-    EXPECT_NEAR((c), (transform).matrix().get(0, 2), (errorThreshold));       \
+#define EXPECT_ROW1_NEAR(a, b, c, d, transform, errorThreshold)         \
+    EXPECT_NEAR((a), (transform).matrix().get(0, 0), (errorThreshold)); \
+    EXPECT_NEAR((b), (transform).matrix().get(0, 1), (errorThreshold)); \
+    EXPECT_NEAR((c), (transform).matrix().get(0, 2), (errorThreshold)); \
     EXPECT_NEAR((d), (transform).matrix().get(0, 3), (errorThreshold));
 
-#define EXPECT_ROW2_NEAR(a, b, c, d, transform, errorThreshold)               \
-    EXPECT_NEAR((a), (transform).matrix().get(1, 0), (errorThreshold));       \
-    EXPECT_NEAR((b), (transform).matrix().get(1, 1), (errorThreshold));       \
-    EXPECT_NEAR((c), (transform).matrix().get(1, 2), (errorThreshold));       \
+#define EXPECT_ROW2_NEAR(a, b, c, d, transform, errorThreshold)         \
+    EXPECT_NEAR((a), (transform).matrix().get(1, 0), (errorThreshold)); \
+    EXPECT_NEAR((b), (transform).matrix().get(1, 1), (errorThreshold)); \
+    EXPECT_NEAR((c), (transform).matrix().get(1, 2), (errorThreshold)); \
     EXPECT_NEAR((d), (transform).matrix().get(1, 3), (errorThreshold));
 
-#define EXPECT_ROW3_NEAR(a, b, c, d, transform, errorThreshold)               \
-    EXPECT_NEAR((a), (transform).matrix().get(2, 0), (errorThreshold));       \
-    EXPECT_NEAR((b), (transform).matrix().get(2, 1), (errorThreshold));       \
-    EXPECT_NEAR((c), (transform).matrix().get(2, 2), (errorThreshold));       \
+#define EXPECT_ROW3_NEAR(a, b, c, d, transform, errorThreshold)         \
+    EXPECT_NEAR((a), (transform).matrix().get(2, 0), (errorThreshold)); \
+    EXPECT_NEAR((b), (transform).matrix().get(2, 1), (errorThreshold)); \
+    EXPECT_NEAR((c), (transform).matrix().get(2, 2), (errorThreshold)); \
     EXPECT_NEAR((d), (transform).matrix().get(2, 3), (errorThreshold));
 
+bool PointsAreNearlyEqual(const Point3F& lhs,
+                          const Point3F& rhs) {
+  float epsilon = 0.0001f;
+  return lhs.SquaredDistanceTo(rhs) < epsilon;
+}
+
+bool MatricesAreNearlyEqual(const Transform& lhs,
+                            const Transform& rhs) {
+  float epsilon = 0.0001f;
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      if (std::abs(lhs.matrix().get(row, col) -
+                   rhs.matrix().get(row, col)) > epsilon)
+        return false;
+    }
+  }
+  return true;
+}
+
+void InitializeTestMatrix(Transform* transform) {
+  SkMatrix44& matrix = transform->matrix();
+  matrix.setDouble(0, 0, 10.0);
+  matrix.setDouble(1, 0, 11.0);
+  matrix.setDouble(2, 0, 12.0);
+  matrix.setDouble(3, 0, 13.0);
+  matrix.setDouble(0, 1, 14.0);
+  matrix.setDouble(1, 1, 15.0);
+  matrix.setDouble(2, 1, 16.0);
+  matrix.setDouble(3, 1, 17.0);
+  matrix.setDouble(0, 2, 18.0);
+  matrix.setDouble(1, 2, 19.0);
+  matrix.setDouble(2, 2, 20.0);
+  matrix.setDouble(3, 2, 21.0);
+  matrix.setDouble(0, 3, 22.0);
+  matrix.setDouble(1, 3, 23.0);
+  matrix.setDouble(2, 3, 24.0);
+  matrix.setDouble(3, 3, 25.0);
+
+  // Sanity check
+  EXPECT_ROW1_EQ(10.0f, 14.0f, 18.0f, 22.0f, (*transform));
+  EXPECT_ROW2_EQ(11.0f, 15.0f, 19.0f, 23.0f, (*transform));
+  EXPECT_ROW3_EQ(12.0f, 16.0f, 20.0f, 24.0f, (*transform));
+  EXPECT_ROW4_EQ(13.0f, 17.0f, 21.0f, 25.0f, (*transform));
+}
+
+void InitializeTestMatrix2(Transform* transform) {
+  SkMatrix44& matrix = transform->matrix();
+  matrix.setDouble(0, 0, 30.0);
+  matrix.setDouble(1, 0, 31.0);
+  matrix.setDouble(2, 0, 32.0);
+  matrix.setDouble(3, 0, 33.0);
+  matrix.setDouble(0, 1, 34.0);
+  matrix.setDouble(1, 1, 35.0);
+  matrix.setDouble(2, 1, 36.0);
+  matrix.setDouble(3, 1, 37.0);
+  matrix.setDouble(0, 2, 38.0);
+  matrix.setDouble(1, 2, 39.0);
+  matrix.setDouble(2, 2, 40.0);
+  matrix.setDouble(3, 2, 41.0);
+  matrix.setDouble(0, 3, 42.0);
+  matrix.setDouble(1, 3, 43.0);
+  matrix.setDouble(2, 3, 44.0);
+  matrix.setDouble(3, 3, 45.0);
+
+  // Sanity check
+  EXPECT_ROW1_EQ(30.0f, 34.0f, 38.0f, 42.0f, (*transform));
+  EXPECT_ROW2_EQ(31.0f, 35.0f, 39.0f, 43.0f, (*transform));
+  EXPECT_ROW3_EQ(32.0f, 36.0f, 40.0f, 44.0f, (*transform));
+  EXPECT_ROW4_EQ(33.0f, 37.0f, 41.0f, 45.0f, (*transform));
+}
+
 #ifdef SK_MSCALAR_IS_DOUBLE
 #define ERROR_THRESHOLD 1e-14
 #else
@@ -707,116 +759,112 @@
   EXPECT_FALSE(to.Blend(from, 0.5));
 }
 
-TEST(XFormTest, VerifyBlendForTranslation)
-{
+TEST(XFormTest, VerifyBlendForTranslation) {
   Transform from;
-  from.Translate3d(100, 200, 100);
+  from.Translate3d(100.0, 200.0, 100.0);
 
   Transform to;
 
-  to.Translate3d(200, 100, 300);
-  to.Blend(from, 0);
+  to.Translate3d(200.0, 100.0, 300.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   to = Transform();
-  to.Translate3d(200, 100, 300);
+  to.Translate3d(200.0, 100.0, 300.0);
   to.Blend(from, 0.25);
-  EXPECT_ROW1_EQ(1, 0, 0, 125, to);
-  EXPECT_ROW2_EQ(0, 1, 0, 175, to);
-  EXPECT_ROW3_EQ(0, 0, 1, 150, to);
-  EXPECT_ROW4_EQ(0, 0, 0,  1,  to);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 125.0f, to);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 175.0f, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 150.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f,  1.0f,  to);
 
   to = Transform();
-  to.Translate3d(200, 100, 300);
+  to.Translate3d(200.0, 100.0, 300.0);
   to.Blend(from, 0.5);
-  EXPECT_ROW1_EQ(1, 0, 0, 150, to);
-  EXPECT_ROW2_EQ(0, 1, 0, 150, to);
-  EXPECT_ROW3_EQ(0, 0, 1, 200, to);
-  EXPECT_ROW4_EQ(0, 0, 0,  1,  to);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 150.0f, to);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 150.0f, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 200.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f,  1.0f,  to);
 
   to = Transform();
-  to.Translate3d(200, 100, 300);
-  to.Blend(from, 1);
-  EXPECT_ROW1_EQ(1, 0, 0, 200, to);
-  EXPECT_ROW2_EQ(0, 1, 0, 100, to);
-  EXPECT_ROW3_EQ(0, 0, 1, 300, to);
-  EXPECT_ROW4_EQ(0, 0, 0,  1,  to);
+  to.Translate3d(200.0, 100.0, 300.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 200.0f, to);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 100.0f, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 300.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f,  1.0f,  to);
 }
 
-TEST(XFormTest, VerifyBlendForScale)
-{
+TEST(XFormTest, VerifyBlendForScale) {
   Transform from;
-  from.Scale3d(100, 200, 100);
+  from.Scale3d(100.0, 200.0, 100.0);
 
   Transform to;
 
-  to.Scale3d(200, 100, 300);
-  to.Blend(from, 0);
+  to.Scale3d(200.0, 100.0, 300.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   to = Transform();
-  to.Scale3d(200, 100, 300);
+  to.Scale3d(200.0, 100.0, 300.0);
   to.Blend(from, 0.25);
-  EXPECT_ROW1_EQ(125, 0,  0,  0, to);
-  EXPECT_ROW2_EQ(0,  175, 0,  0, to);
-  EXPECT_ROW3_EQ(0,   0, 150, 0, to);
-  EXPECT_ROW4_EQ(0,   0,  0,  1, to);
+  EXPECT_ROW1_EQ(125.0f, 0.0f,  0.0f,  0.0f, to);
+  EXPECT_ROW2_EQ(0.0f,  175.0f, 0.0f,  0.0f, to);
+  EXPECT_ROW3_EQ(0.0f,   0.0f, 150.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f,   0.0f,  0.0f,  1.0f, to);
 
   to = Transform();
-  to.Scale3d(200, 100, 300);
+  to.Scale3d(200.0, 100.0, 300.0);
   to.Blend(from, 0.5);
-  EXPECT_ROW1_EQ(150, 0,  0,  0, to);
-  EXPECT_ROW2_EQ(0,  150, 0,  0, to);
-  EXPECT_ROW3_EQ(0,   0, 200, 0, to);
-  EXPECT_ROW4_EQ(0,   0,  0,  1, to);
+  EXPECT_ROW1_EQ(150.0f, 0.0f,  0.0f,  0.0f, to);
+  EXPECT_ROW2_EQ(0.0f,  150.0f, 0.0f,  0.0f, to);
+  EXPECT_ROW3_EQ(0.0f,   0.0f, 200.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f,   0.0f,  0.0f,  1.0f, to);
 
   to = Transform();
-  to.Scale3d(200, 100, 300);
-  to.Blend(from, 1);
-  EXPECT_ROW1_EQ(200, 0,  0,  0, to);
-  EXPECT_ROW2_EQ(0,  100, 0,  0, to);
-  EXPECT_ROW3_EQ(0,   0, 300, 0, to);
-  EXPECT_ROW4_EQ(0,   0,  0,  1, to);
+  to.Scale3d(200.0, 100.0, 300.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_EQ(200.0f, 0.0f,  0.0f,  0.0f, to);
+  EXPECT_ROW2_EQ(0.0f,  100.0f, 0.0f,  0.0f, to);
+  EXPECT_ROW3_EQ(0.0f,   0.0f, 300.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f,   0.0f,  0.0f,  1.0f, to);
 }
 
-TEST(XFormTest, VerifyBlendForSkewX)
-{
+TEST(XFormTest, VerifyBlendForSkewX) {
   Transform from;
-  from.SkewX(0);
+  from.SkewX(0.0);
 
   Transform to;
 
-  to.SkewX(45);
-  to.Blend(from, 0);
+  to.SkewX(45.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   to = Transform();
-  to.SkewX(45);
+  to.SkewX(45.0);
   to.Blend(from, 0.5);
-  EXPECT_ROW1_EQ(1, 0.5, 0, 0, to);
-  EXPECT_ROW2_EQ(0,  1,  0, 0, to);
-  EXPECT_ROW3_EQ(0,  0,  1, 0, to);
-  EXPECT_ROW4_EQ(0,  0,  0, 1, to);
+  EXPECT_ROW1_EQ(1.0f, 0.5f, 0.0f, 0.0f, to);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
   to = Transform();
-  to.SkewX(45);
+  to.SkewX(45.0);
   to.Blend(from, 0.25);
-  EXPECT_ROW1_EQ(1, 0.25, 0, 0, to);
-  EXPECT_ROW2_EQ(0,   1,  0, 0, to);
-  EXPECT_ROW3_EQ(0,   0,  1, 0, to);
-  EXPECT_ROW4_EQ(0,   0,  0, 1, to);
+  EXPECT_ROW1_EQ(1.0f, 0.25f, 0.0f, 0.0f, to);
+  EXPECT_ROW2_EQ(0.0f, 1.0f,  0.0f, 0.0f, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f,  1.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f,  0.0f, 1.0f, to);
 
   to = Transform();
-  to.SkewX(45);
-  to.Blend(from, 1);
-  EXPECT_ROW1_EQ(1, 1, 0, 0, to);
-  EXPECT_ROW2_EQ(0, 1, 0, 0, to);
-  EXPECT_ROW3_EQ(0, 0, 1, 0, to);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  to.SkewX(45.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_EQ(1.0f, 1.0f, 0.0f, 0.0f, to);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 }
 
-TEST(XFormTest, VerifyBlendForSkewY)
-{
+TEST(XFormTest, VerifyBlendForSkewY) {
   // NOTE CAREFULLY: Decomposition of skew and rotation terms of the matrix
   // is inherently underconstrained, and so it does not always compute the
   // originally intended skew parameters. The current implementation uses QR
@@ -835,240 +883,236 @@
   // error.
 
   Transform from;
-  from.SkewY(0);
+  from.SkewY(0.0);
 
   Transform to;
 
-  to.SkewY(45);
-  to.Blend(from, 0);
+  to.SkewY(45.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   to = Transform();
-  to.SkewY(45);
+  to.SkewY(45.0);
   to.Blend(from, 0.25);
   EXPECT_ROW1_NEAR(1.0823489449280947471976333,
                    0.0464370719145053845178239,
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    LOOSE_ERROR_THRESHOLD);
   EXPECT_ROW2_NEAR(0.2152925909665224513123150,
                    0.9541702441750861130032035,
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    LOOSE_ERROR_THRESHOLD);
-  EXPECT_ROW3_EQ(0, 0, 1, 0, to);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
   to = Transform();
-  to.SkewY(45);
+  to.SkewY(45.0);
   to.Blend(from, 0.5);
   EXPECT_ROW1_NEAR(1.1152212925809066312865525,
                    0.0676495144007326631996335,
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    LOOSE_ERROR_THRESHOLD);
   EXPECT_ROW2_NEAR(0.4619397844342648662419037,
                    0.9519009045724774464858342,
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    LOOSE_ERROR_THRESHOLD);
-  EXPECT_ROW3_EQ(0, 0, 1, 0, to);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
   to = Transform();
-  to.SkewY(45);
-  to.Blend(from, 1);
-  EXPECT_ROW1_NEAR(1, 0, 0, 0, to, LOOSE_ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(1, 1, 0, 0, to, LOOSE_ERROR_THRESHOLD);
-  EXPECT_ROW3_EQ(0, 0, 1, 0, to);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  to.SkewY(45.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_NEAR(1.0, 0.0, 0.0, 0.0, to, LOOSE_ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(1.0, 1.0, 0.0, 0.0, to, LOOSE_ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 }
 
-TEST(XFormTest, VerifyBlendForRotationAboutX)
-{
+TEST(XFormTest, VerifyBlendForRotationAboutX) {
   // Even though.Blending uses quaternions, axis-aligned rotations should.
   // Blend the same with quaternions or Euler angles. So we can test
   // rotation.Blending by comparing against manually specified matrices from
   // Euler angles.
 
   Transform from;
-  from.RotateAbout(Vector3dF(1, 0, 0), 0);
+  from.RotateAbout(Vector3dF(1.0, 0.0, 0.0), 0.0);
 
   Transform to;
 
-  to.RotateAbout(Vector3dF(1, 0, 0), 90);
-  to.Blend(from, 0);
+  to.RotateAbout(Vector3dF(1.0, 0.0, 0.0), 90.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   double expectedRotationAngle = 22.5 * M_PI / 180.0;
   to = Transform();
-  to.RotateAbout(Vector3dF(1, 0, 0), 90);
+  to.RotateAbout(Vector3dF(1.0, 0.0, 0.0), 90.0);
   to.Blend(from, 0.25);
-  EXPECT_ROW1_NEAR(1, 0, 0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(0,
+  EXPECT_ROW1_NEAR(1.0, 0.0, 0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0,
                    std::cos(expectedRotationAngle),
                    -std::sin(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(0,
+  EXPECT_ROW3_NEAR(0.0,
                    std::sin(expectedRotationAngle),
                    std::cos(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
-  expectedRotationAngle = 45 * M_PI / 180.0;
+  expectedRotationAngle = 45.0 * M_PI / 180.0;
   to = Transform();
-  to.RotateAbout(Vector3dF(1, 0, 0), 90);
+  to.RotateAbout(Vector3dF(1.0, 0.0, 0.0), 90.0);
   to.Blend(from, 0.5);
-  EXPECT_ROW1_NEAR(1, 0, 0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(0,
+  EXPECT_ROW1_NEAR(1.0, 0.0, 0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0,
                    std::cos(expectedRotationAngle),
                    -std::sin(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(0,
+  EXPECT_ROW3_NEAR(0.0,
                    std::sin(expectedRotationAngle),
                    std::cos(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
   to = Transform();
-  to.RotateAbout(Vector3dF(1, 0, 0), 90);
-  to.Blend(from, 1);
-  EXPECT_ROW1_NEAR(1, 0,  0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(0, 0, -1, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(0, 1,  0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  to.RotateAbout(Vector3dF(1.0, 0.0, 0.0), 90.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_NEAR(1.0, 0.0,  0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0, 0.0, -1.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(0.0, 1.0,  0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 }
 
-TEST(XFormTest, VerifyBlendForRotationAboutY)
-{
+TEST(XFormTest, VerifyBlendForRotationAboutY) {
   Transform from;
-  from.RotateAbout(Vector3dF(0, 1, 0), 0);
+  from.RotateAbout(Vector3dF(0.0, 1.0, 0.0), 0.0);
 
   Transform to;
 
-  to.RotateAbout(Vector3dF(0, 1, 0), 90);
-  to.Blend(from, 0);
+  to.RotateAbout(Vector3dF(0.0, 1.0, 0.0), 90.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   double expectedRotationAngle = 22.5 * M_PI / 180.0;
   to = Transform();
-  to.RotateAbout(Vector3dF(0, 1, 0), 90);
+  to.RotateAbout(Vector3dF(0.0, 1.0, 0.0), 90.0);
   to.Blend(from, 0.25);
   EXPECT_ROW1_NEAR(std::cos(expectedRotationAngle),
-                   0,
+                   0.0,
                    std::sin(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(0, 1, 0, 0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0, 1.0, 0.0, 0.0, to, ERROR_THRESHOLD);
   EXPECT_ROW3_NEAR(-std::sin(expectedRotationAngle),
-                   0,
+                   0.0,
                    std::cos(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
-  expectedRotationAngle = 45 * M_PI / 180.0;
+  expectedRotationAngle = 45.0 * M_PI / 180.0;
   to = Transform();
-  to.RotateAbout(Vector3dF(0, 1, 0), 90);
+  to.RotateAbout(Vector3dF(0.0, 1.0, 0.0), 90.0);
   to.Blend(from, 0.5);
   EXPECT_ROW1_NEAR(std::cos(expectedRotationAngle),
-                   0,
+                   0.0,
                    std::sin(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(0, 1, 0, 0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0, 1.0, 0.0, 0.0, to, ERROR_THRESHOLD);
   EXPECT_ROW3_NEAR(-std::sin(expectedRotationAngle),
-                   0,
+                   0.0,
                    std::cos(expectedRotationAngle),
-                   0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
   to = Transform();
-  to.RotateAbout(Vector3dF(0, 1, 0), 90);
-  to.Blend(from, 1);
-  EXPECT_ROW1_NEAR(0,  0, 1, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(0,  1, 0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(-1, 0, 0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  to.RotateAbout(Vector3dF(0.0, 1.0, 0.0), 90.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_NEAR(0.0,  0.0, 1.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0,  1.0, 0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(-1.0, 0.0, 0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 }
 
-TEST(XFormTest, VerifyBlendForRotationAboutZ)
-{
+TEST(XFormTest, VerifyBlendForRotationAboutZ) {
   Transform from;
-  from.RotateAbout(Vector3dF(0, 0, 1), 0);
+  from.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 0.0);
 
   Transform to;
 
-  to.RotateAbout(Vector3dF(0, 0, 1), 90);
-  to.Blend(from, 0);
+  to.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 90.0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   double expectedRotationAngle = 22.5 * M_PI / 180.0;
   to = Transform();
-  to.RotateAbout(Vector3dF(0, 0, 1), 90);
+  to.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 90.0);
   to.Blend(from, 0.25);
   EXPECT_ROW1_NEAR(std::cos(expectedRotationAngle),
                    -std::sin(expectedRotationAngle),
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
   EXPECT_ROW2_NEAR(std::sin(expectedRotationAngle),
                    std::cos(expectedRotationAngle),
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(0, 0, 1, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW3_NEAR(0.0, 0.0, 1.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
-  expectedRotationAngle = 45 * M_PI / 180.0;
+  expectedRotationAngle = 45.0 * M_PI / 180.0;
   to = Transform();
-  to.RotateAbout(Vector3dF(0, 0, 1), 90);
+  to.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 90.0);
   to.Blend(from, 0.5);
   EXPECT_ROW1_NEAR(std::cos(expectedRotationAngle),
                    -std::sin(expectedRotationAngle),
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
   EXPECT_ROW2_NEAR(std::sin(expectedRotationAngle),
                    std::cos(expectedRotationAngle),
-                   0,
-                   0,
+                   0.0,
+                   0.0,
                    to,
                    ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(0, 0, 1, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  EXPECT_ROW3_NEAR(0.0, 0.0, 1.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 
   to = Transform();
-  to.RotateAbout(Vector3dF(0, 0, 1), 90);
-  to.Blend(from, 1);
-  EXPECT_ROW1_NEAR(0, -1, 0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW2_NEAR(1,  0, 0, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW3_NEAR(0,  0, 1, 0, to, ERROR_THRESHOLD);
-  EXPECT_ROW4_EQ(0, 0, 0, 1, to);
+  to.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 90.0);
+  to.Blend(from, 1.0);
+  EXPECT_ROW1_NEAR(0.0, -1.0, 0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(1.0,  0.0, 0.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(0.0,  0.0, 1.0, 0.0, to, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, to);
 }
 
-TEST(XFormTest, VerifyBlendForCompositeTransform)
-{
+TEST(XFormTest, VerifyBlendForCompositeTransform) {
   // Verify that the.Blending was done with a decomposition in correct order
   // by blending a composite transform. Using matrix x vector notation
   // (Ax = b, where x is column vector), the ordering should be:
@@ -1082,14 +1126,14 @@
   Transform to;
 
   Transform expectedEndOfAnimation;
-  expectedEndOfAnimation.ApplyPerspectiveDepth(1);
-  expectedEndOfAnimation.Translate3d(10, 20, 30);
-  expectedEndOfAnimation.RotateAbout(Vector3dF(0, 0, 1), 25);
-  expectedEndOfAnimation.SkewY(45);
-  expectedEndOfAnimation.Scale3d(6, 7, 8);
+  expectedEndOfAnimation.ApplyPerspectiveDepth(1.0);
+  expectedEndOfAnimation.Translate3d(10.0, 20.0, 30.0);
+  expectedEndOfAnimation.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 25.0);
+  expectedEndOfAnimation.SkewY(45.0);
+  expectedEndOfAnimation.Scale3d(6.0, 7.0, 8.0);
 
   to = expectedEndOfAnimation;
-  to.Blend(from, 0);
+  to.Blend(from, 0.0);
   EXPECT_EQ(from, to);
 
   to = expectedEndOfAnimation;
@@ -1104,20 +1148,27 @@
   Transform normalizedExpectedEndOfAnimation = expectedEndOfAnimation;
   Transform normalizationMatrix;
   normalizationMatrix.matrix().set(
-      0, 0, SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3, 3)));
+      0.0,
+      0.0,
+      SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3.0, 3.0)));
   normalizationMatrix.matrix().set(
-      1, 1, SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3, 3)));
+      1.0,
+      1.0,
+      SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3.0, 3.0)));
   normalizationMatrix.matrix().set(
-      2, 2, SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3, 3)));
+      2.0,
+      2.0,
+      SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3.0, 3.0)));
   normalizationMatrix.matrix().set(
-      3, 3, SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3, 3)));
+      3.0,
+      3.0,
+      SkDoubleToMScalar(1 / expectedEndOfAnimation.matrix().get(3.0, 3.0)));
   normalizedExpectedEndOfAnimation.PreconcatTransform(normalizationMatrix);
 
   EXPECT_TRUE(MatricesAreNearlyEqual(normalizedExpectedEndOfAnimation, to));
 }
 
-TEST(XFormTest, DecomposedTransformCtor)
-{
+TEST(XFormTest, DecomposedTransformCtor) {
   DecomposedTransform decomp;
   for (int i = 0; i < 3; ++i) {
     EXPECT_EQ(0.0, decomp.translate[i]);
@@ -1182,64 +1233,991 @@
   EXPECT_FALSE(transform.IsIdentityOrIntegerTranslation());
 }
 
-TEST(XFormTest, verifyMatrixInversion)
-{
+TEST(XFormTest, verifyMatrixInversion) {
   {
     // Invert a translation
     gfx::Transform translation;
-    translation.Translate3d(2, 3, 4);
+    translation.Translate3d(2.0, 3.0, 4.0);
     EXPECT_TRUE(translation.IsInvertible());
 
     gfx::Transform inverse_translation;
     bool is_invertible = translation.GetInverse(&inverse_translation);
     EXPECT_TRUE(is_invertible);
-    EXPECT_ROW1_EQ(1, 0, 0, -2, inverse_translation);
-    EXPECT_ROW2_EQ(0, 1, 0, -3, inverse_translation);
-    EXPECT_ROW3_EQ(0, 0, 1, -4, inverse_translation);
-    EXPECT_ROW4_EQ(0, 0, 0,  1, inverse_translation);
+    EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, -2.0f, inverse_translation);
+    EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, -3.0f, inverse_translation);
+    EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, -4.0f, inverse_translation);
+    EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f,  1.0f, inverse_translation);
   }
 
   {
     // Invert a non-uniform scale
     gfx::Transform scale;
-    scale.Scale3d(4, 10, 100);
+    scale.Scale3d(4.0, 10.0, 100.0);
     EXPECT_TRUE(scale.IsInvertible());
 
     gfx::Transform inverse_scale;
     bool is_invertible = scale.GetInverse(&inverse_scale);
     EXPECT_TRUE(is_invertible);
-    EXPECT_ROW1_EQ(0.25,   0,    0, 0, inverse_scale);
-    EXPECT_ROW2_EQ(0,    .1f,    0, 0, inverse_scale);
-    EXPECT_ROW3_EQ(0,      0, .01f, 0, inverse_scale);
-    EXPECT_ROW4_EQ(0,      0,    0, 1, inverse_scale);
+    EXPECT_ROW1_EQ(0.25f, 0.0f, 0.0f, 0.0f, inverse_scale);
+    EXPECT_ROW2_EQ(0.0f,  0.1f, 0.0f, 0.0f, inverse_scale);
+    EXPECT_ROW3_EQ(0.0f,  0.0f, 0.01f, 0.0f, inverse_scale);
+    EXPECT_ROW4_EQ(0.0f,  0.0f, 0.0f, 1.0f, inverse_scale);
   }
 
   {
     // Try to invert a matrix that is not invertible.
     // The inverse() function should reset the output matrix to identity.
     gfx::Transform uninvertible;
-    uninvertible.matrix().setDouble(0, 0, 0);
-    uninvertible.matrix().setDouble(1, 1, 0);
-    uninvertible.matrix().setDouble(2, 2, 0);
-    uninvertible.matrix().setDouble(3, 3, 0);
+    uninvertible.matrix().setDouble(0, 0, 0.0);
+    uninvertible.matrix().setDouble(1, 1, 0.0);
+    uninvertible.matrix().setDouble(2, 2, 0.0);
+    uninvertible.matrix().setDouble(3, 3, 0.0);
     EXPECT_FALSE(uninvertible.IsInvertible());
 
     gfx::Transform inverse_of_uninvertible;
 
     // Add a scale just to more easily ensure that inverse_of_uninvertible is
     // reset to identity.
-    inverse_of_uninvertible.Scale3d(4, 10, 100);
+    inverse_of_uninvertible.Scale3d(4.0, 10.0, 100.0);
 
     bool is_invertible = uninvertible.GetInverse(&inverse_of_uninvertible);
     EXPECT_FALSE(is_invertible);
     EXPECT_TRUE(inverse_of_uninvertible.IsIdentity());
-    EXPECT_ROW1_EQ(1, 0, 0, 0, inverse_of_uninvertible);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, inverse_of_uninvertible);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, inverse_of_uninvertible);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, inverse_of_uninvertible);
+    EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, inverse_of_uninvertible);
+    EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, inverse_of_uninvertible);
+    EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, inverse_of_uninvertible);
+    EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, inverse_of_uninvertible);
   }
 }
 
+TEST(XFormTest, verifyBackfaceVisibilityBasicCases) {
+  Transform transform;
+
+  transform.MakeIdentity();
+  EXPECT_FALSE(transform.IsBackFaceVisible());
+
+  transform.MakeIdentity();
+  transform.RotateAboutYAxis(80.0);
+  EXPECT_FALSE(transform.IsBackFaceVisible());
+
+  transform.MakeIdentity();
+  transform.RotateAboutYAxis(100.0);
+  EXPECT_TRUE(transform.IsBackFaceVisible());
+
+  // Edge case, 90 degree rotation should return false.
+  transform.MakeIdentity();
+  transform.RotateAboutYAxis(90.0);
+  EXPECT_FALSE(transform.IsBackFaceVisible());
+}
+
+TEST(XFormTest, verifyBackfaceVisibilityForPerspective) {
+  Transform layer_space_to_projection_plane;
+
+  // This tests if IsBackFaceVisible works properly under perspective
+  // transforms.  Specifically, layers that may have their back face visible in
+  // orthographic projection, may not actually have back face visible under
+  // perspective projection.
+
+  // Case 1: Layer is rotated by slightly more than 90 degrees, at the center
+  //         of the prespective projection. In this case, the layer's back-side
+  //         is visible to the camera.
+  layer_space_to_projection_plane.MakeIdentity();
+  layer_space_to_projection_plane.ApplyPerspectiveDepth(1.0);
+  layer_space_to_projection_plane.Translate3d(0.0, 0.0, 0.0);
+  layer_space_to_projection_plane.RotateAboutYAxis(100.0);
+  EXPECT_TRUE(layer_space_to_projection_plane.IsBackFaceVisible());
+
+  // Case 2: Layer is rotated by slightly more than 90 degrees, but shifted off
+  //         to the side of the camera. Because of the wide field-of-view, the
+  //         layer's front side is still visible.
+  //
+  //                       |<-- front side of layer is visible to camera
+  //                    \  |            /
+  //                     \ |           /
+  //                      \|          /
+  //                       |         /
+  //                       |\       /<-- camera field of view
+  //                       | \     /
+  // back side of layer -->|  \   /
+  //                           \./ <-- camera origin
+  //
+  layer_space_to_projection_plane.MakeIdentity();
+  layer_space_to_projection_plane.ApplyPerspectiveDepth(1.0);
+  layer_space_to_projection_plane.Translate3d(-10.0, 0.0, 0.0);
+  layer_space_to_projection_plane.RotateAboutYAxis(100.0);
+  EXPECT_FALSE(layer_space_to_projection_plane.IsBackFaceVisible());
+
+  // Case 3: Additionally rotating the layer by 180 degrees should of course
+  //         show the opposite result of case 2.
+  layer_space_to_projection_plane.RotateAboutYAxis(180.0);
+  EXPECT_TRUE(layer_space_to_projection_plane.IsBackFaceVisible());
+}
+
+TEST(XFormTest, verifyDefaultConstructorCreatesIdentityMatrix) {
+  Transform A;
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+  EXPECT_TRUE(A.IsIdentity());
+}
+
+TEST(XFormTest, verifyCopyConstructor) {
+  Transform A;
+  InitializeTestMatrix(&A);
+
+  // Copy constructor should produce exact same elements as matrix A.
+  Transform B(A);
+  EXPECT_ROW1_EQ(10.0f, 14.0f, 18.0f, 22.0f, B);
+  EXPECT_ROW2_EQ(11.0f, 15.0f, 19.0f, 23.0f, B);
+  EXPECT_ROW3_EQ(12.0f, 16.0f, 20.0f, 24.0f, B);
+  EXPECT_ROW4_EQ(13.0f, 17.0f, 21.0f, 25.0f, B);
+}
+
+TEST(XFormTest, verifyConstructorFor16Elements) {
+  Transform transform(1.0, 2.0, 3.0, 4.0,
+                      5.0, 6.0, 7.0, 8.0,
+                      9.0, 10.0, 11.0, 12.0,
+                      13.0, 14.0, 15.0, 16.0);
+
+  EXPECT_ROW1_EQ(1.0f, 2.0f, 3.0f, 4.0f, transform);
+  EXPECT_ROW2_EQ(5.0f, 6.0f, 7.0f, 8.0f, transform);
+  EXPECT_ROW3_EQ(9.0f, 10.0f, 11.0f, 12.0f, transform);
+  EXPECT_ROW4_EQ(13.0f, 14.0f, 15.0f, 16.0f, transform);
+}
+
+TEST(XFormTest, verifyConstructorFor2dElements) {
+  Transform transform(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
+
+  EXPECT_ROW1_EQ(1.0f, 2.0f, 0.0f, 5.0f, transform);
+  EXPECT_ROW2_EQ(3.0f, 4.0f, 0.0f, 6.0f, transform);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, transform);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, transform);
+}
+
+
+TEST(XFormTest, verifyAssignmentOperator) {
+  Transform A;
+  InitializeTestMatrix(&A);
+  Transform B;
+  InitializeTestMatrix2(&B);
+  Transform C;
+  InitializeTestMatrix2(&C);
+  C = B = A;
+
+  // Both B and C should now have been re-assigned to the value of A.
+  EXPECT_ROW1_EQ(10.0f, 14.0f, 18.0f, 22.0f, B);
+  EXPECT_ROW2_EQ(11.0f, 15.0f, 19.0f, 23.0f, B);
+  EXPECT_ROW3_EQ(12.0f, 16.0f, 20.0f, 24.0f, B);
+  EXPECT_ROW4_EQ(13.0f, 17.0f, 21.0f, 25.0f, B);
+
+  EXPECT_ROW1_EQ(10.0f, 14.0f, 18.0f, 22.0f, C);
+  EXPECT_ROW2_EQ(11.0f, 15.0f, 19.0f, 23.0f, C);
+  EXPECT_ROW3_EQ(12.0f, 16.0f, 20.0f, 24.0f, C);
+  EXPECT_ROW4_EQ(13.0f, 17.0f, 21.0f, 25.0f, C);
+}
+
+TEST(XFormTest, verifyEqualsBooleanOperator) {
+  Transform A;
+  InitializeTestMatrix(&A);
+
+  Transform B;
+  InitializeTestMatrix(&B);
+  EXPECT_TRUE(A == B);
+
+  // Modifying multiple elements should cause equals operator to return false.
+  Transform C;
+  InitializeTestMatrix2(&C);
+  EXPECT_FALSE(A == C);
+
+  // Modifying any one individual element should cause equals operator to
+  // return false.
+  Transform D;
+  D = A;
+  D.matrix().setDouble(0, 0, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(1, 0, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(2, 0, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(3, 0, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(0, 1, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(1, 1, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(2, 1, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(3, 1, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(0, 2, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(1, 2, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(2, 2, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(3, 2, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(0, 3, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(1, 3, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(2, 3, 0.0);
+  EXPECT_FALSE(A == D);
+
+  D = A;
+  D.matrix().setDouble(3, 3, 0.0);
+  EXPECT_FALSE(A == D);
+}
+
+TEST(XFormTest, verifyMultiplyOperator) {
+  Transform A;
+  InitializeTestMatrix(&A);
+
+  Transform B;
+  InitializeTestMatrix2(&B);
+
+  Transform C = A * B;
+  EXPECT_ROW1_EQ(2036.0f, 2292.0f, 2548.0f, 2804.0f, C);
+  EXPECT_ROW2_EQ(2162.0f, 2434.0f, 2706.0f, 2978.0f, C);
+  EXPECT_ROW3_EQ(2288.0f, 2576.0f, 2864.0f, 3152.0f, C);
+  EXPECT_ROW4_EQ(2414.0f, 2718.0f, 3022.0f, 3326.0f, C);
+
+  // Just an additional sanity check; matrix multiplication is not commutative.
+  EXPECT_FALSE(A * B == B * A);
+}
+
+TEST(XFormTest, verifyMultiplyAndAssignOperator) {
+  Transform A;
+  InitializeTestMatrix(&A);
+
+  Transform B;
+  InitializeTestMatrix2(&B);
+
+  A *= B;
+  EXPECT_ROW1_EQ(2036.0f, 2292.0f, 2548.0f, 2804.0f, A);
+  EXPECT_ROW2_EQ(2162.0f, 2434.0f, 2706.0f, 2978.0f, A);
+  EXPECT_ROW3_EQ(2288.0f, 2576.0f, 2864.0f, 3152.0f, A);
+  EXPECT_ROW4_EQ(2414.0f, 2718.0f, 3022.0f, 3326.0f, A);
+
+  // Just an additional sanity check; matrix multiplication is not commutative.
+  Transform C = A;
+  C *= B;
+  Transform D = B;
+  D *= A;
+  EXPECT_FALSE(C == D);
+}
+
+TEST(XFormTest, verifyMatrixMultiplication) {
+  Transform A;
+  InitializeTestMatrix(&A);
+
+  Transform B;
+  InitializeTestMatrix2(&B);
+
+  A.PreconcatTransform(B);
+  EXPECT_ROW1_EQ(2036.0f, 2292.0f, 2548.0f, 2804.0f, A);
+  EXPECT_ROW2_EQ(2162.0f, 2434.0f, 2706.0f, 2978.0f, A);
+  EXPECT_ROW3_EQ(2288.0f, 2576.0f, 2864.0f, 3152.0f, A);
+  EXPECT_ROW4_EQ(2414.0f, 2718.0f, 3022.0f, 3326.0f, A);
+}
+
+TEST(XFormTest, verifyMakeIdentiy) {
+  Transform A;
+  InitializeTestMatrix(&A);
+  A.MakeIdentity();
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+  EXPECT_TRUE(A.IsIdentity());
+}
+
+TEST(XFormTest, verifyTranslate) {
+  Transform A;
+  A.Translate(2.0, 3.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 2.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 3.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that Translate() post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale(5.0, 5.0);
+  A.Translate(2.0, 3.0);
+  EXPECT_ROW1_EQ(5.0f, 0.0f, 0.0f, 10.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 5.0f, 0.0f, 15.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f,  A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f,  A);
+}
+
+TEST(XFormTest, verifyTranslate3d) {
+  Transform A;
+  A.Translate3d(2.0, 3.0, 4.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 2.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 3.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 4.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that Translate3d() post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.Translate3d(2.0, 3.0, 4.0);
+  EXPECT_ROW1_EQ(6.0f, 0.0f, 0.0f, 12.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 7.0f, 0.0f, 21.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 32.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f,  A);
+}
+
+TEST(XFormTest, verifyScale) {
+  Transform A;
+  A.Scale(6.0, 7.0);
+  EXPECT_ROW1_EQ(6.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 7.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that Scale() post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Translate3d(2.0, 3.0, 4.0);
+  A.Scale(6.0, 7.0);
+  EXPECT_ROW1_EQ(6.0f, 0.0f, 0.0f, 2.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 7.0f, 0.0f, 3.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 4.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyScale3d) {
+  Transform A;
+  A.Scale3d(6.0, 7.0, 8.0);
+  EXPECT_ROW1_EQ(6.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 7.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that scale3d() post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Translate3d(2.0, 3.0, 4.0);
+  A.Scale3d(6.0, 7.0, 8.0);
+  EXPECT_ROW1_EQ(6.0f, 0.0f, 0.0f, 2.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 7.0f, 0.0f, 3.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 4.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotate) {
+  Transform A;
+  A.Rotate(90.0);
+  EXPECT_ROW1_NEAR(0.0, -1.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(1.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that Rotate() post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.Rotate(90.0);
+  EXPECT_ROW1_NEAR(0.0, -6.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(7.0, 0.0,  0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotateAboutXAxis) {
+  Transform A;
+  double sin45 = 0.5 * sqrt(2.0);
+  double cos45 = sin45;
+
+  A.MakeIdentity();
+  A.RotateAboutXAxis(90.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_NEAR(0.0, 0.0, -1.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(0.0, 1.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  A.MakeIdentity();
+  A.RotateAboutXAxis(45.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_NEAR(0.0, cos45, -sin45, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(0.0, sin45, cos45, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that RotateAboutXAxis(angle) post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.RotateAboutXAxis(90.0);
+  EXPECT_ROW1_NEAR(6.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0, 0.0, -7.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(0.0, 8.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotateAboutYAxis) {
+  Transform A;
+  double sin45 = 0.5 * sqrt(2.0);
+  double cos45 = sin45;
+
+  // Note carefully, the expected pattern is inverted compared to rotating
+  // about x axis or z axis.
+  A.MakeIdentity();
+  A.RotateAboutYAxis(90.0);
+  EXPECT_ROW1_NEAR(0.0, 0.0, 1.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_NEAR(-1.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  A.MakeIdentity();
+  A.RotateAboutYAxis(45.0);
+  EXPECT_ROW1_NEAR(cos45, 0.0, sin45, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_NEAR(-sin45, 0.0, cos45, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that RotateAboutYAxis(angle) post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.RotateAboutYAxis(90.0);
+  EXPECT_ROW1_NEAR(0.0, 0.0, 6.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.0, 7.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(-8.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotateAboutZAxis) {
+  Transform A;
+  double sin45 = 0.5 * sqrt(2.0);
+  double cos45 = sin45;
+
+  A.MakeIdentity();
+  A.RotateAboutZAxis(90.0);
+  EXPECT_ROW1_NEAR(0.0, -1.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(1.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  A.MakeIdentity();
+  A.RotateAboutZAxis(45.0);
+  EXPECT_ROW1_NEAR(cos45, -sin45, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(sin45, cos45, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that RotateAboutZAxis(angle) post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.RotateAboutZAxis(90.0);
+  EXPECT_ROW1_NEAR(0.0, -6.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(7.0, 0.0,  0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotateAboutForAlignedAxes) {
+  Transform A;
+
+  // Check rotation about z-axis
+  A.MakeIdentity();
+  A.RotateAbout(Vector3dF(0.0, 0.0, 1.0), 90.0);
+  EXPECT_ROW1_NEAR(0.0, -1.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(1.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Check rotation about x-axis
+  A.MakeIdentity();
+  A.RotateAbout(Vector3dF(1.0, 0.0, 0.0), 90.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_NEAR(0.0, 0.0, -1.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(0.0, 1.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Check rotation about y-axis. Note carefully, the expected pattern is
+  // inverted compared to rotating about x axis or z axis.
+  A.MakeIdentity();
+  A.RotateAbout(Vector3dF(0.0, 1.0, 0.0), 90.0);
+  EXPECT_ROW1_NEAR(0.0, 0.0, 1.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_NEAR(-1.0, 0.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that rotate3d(axis, angle) post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.RotateAboutZAxis(90.0);
+  EXPECT_ROW1_NEAR(0.0, -6.0, 0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(7.0, 0.0,  0.0, 0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotateAboutForArbitraryAxis) {
+  // Check rotation about an arbitrary non-axis-aligned vector.
+  Transform A;
+  A.RotateAbout(Vector3dF(1.0, 1.0, 1.0), 90.0);
+  EXPECT_ROW1_NEAR(0.3333333333333334258519187,
+                   -0.2440169358562924717404030,
+                   0.9106836025229592124219380,
+                   0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW2_NEAR(0.9106836025229592124219380,
+                   0.3333333333333334258519187,
+                   -0.2440169358562924717404030,
+                   0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW3_NEAR(-0.2440169358562924717404030,
+                   0.9106836025229592124219380,
+                   0.3333333333333334258519187,
+                   0.0, A, ERROR_THRESHOLD);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyRotateAboutForDegenerateAxis) {
+  // Check rotation about a degenerate zero vector.
+  // It is expected to skip applying the rotation.
+  Transform A;
+
+  A.RotateAbout(Vector3dF(0.0, 0.0, 0.0), 45.0);
+  // Verify that A remains unchanged.
+  EXPECT_TRUE(A.IsIdentity());
+
+  InitializeTestMatrix(&A);
+  A.RotateAbout(Vector3dF(0.0, 0.0, 0.0), 35.0);
+
+  // Verify that A remains unchanged.
+  EXPECT_ROW1_EQ(10.0f, 14.0f, 18.0f, 22.0f, A);
+  EXPECT_ROW2_EQ(11.0f, 15.0f, 19.0f, 23.0f, A);
+  EXPECT_ROW3_EQ(12.0f, 16.0f, 20.0f, 24.0f, A);
+  EXPECT_ROW4_EQ(13.0f, 17.0f, 21.0f, 25.0f, A);
+}
+
+TEST(XFormTest, verifySkewX) {
+  Transform A;
+  A.SkewX(45.0);
+  EXPECT_ROW1_EQ(1.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that skewX() post-multiplies the existing matrix. Row 1, column 2,
+  // would incorrectly have value "7" if the matrix is pre-multiplied instead
+  // of post-multiplied.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.SkewX(45.0);
+  EXPECT_ROW1_EQ(6.0f, 6.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 7.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifySkewY) {
+  Transform A;
+  A.SkewY(45.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(1.0f, 1.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+
+  // Verify that skewY() post-multiplies the existing matrix. Row 2, column 1 ,
+  // would incorrectly have value "6" if the matrix is pre-multiplied instead
+  // of post-multiplied.
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.SkewY(45.0);
+  EXPECT_ROW1_EQ(6.0f, 0.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(7.0f, 7.0f, 0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, 8.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, 0.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyPerspectiveDepth) {
+  Transform A;
+  A.ApplyPerspectiveDepth(1.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f,  0.0f, 0.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f,  0.0f, 0.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f,  1.0f, 0.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, -1.0f, 1.0f, A);
+
+  // Verify that PerspectiveDepth() post-multiplies the existing matrix.
+  A.MakeIdentity();
+  A.Translate3d(2.0, 3.0, 4.0);
+  A.ApplyPerspectiveDepth(1.0);
+  EXPECT_ROW1_EQ(1.0f, 0.0f, -2.0f, 2.0f, A);
+  EXPECT_ROW2_EQ(0.0f, 1.0f, -3.0f, 3.0f, A);
+  EXPECT_ROW3_EQ(0.0f, 0.0f, -3.0f, 4.0f, A);
+  EXPECT_ROW4_EQ(0.0f, 0.0f, -1.0f, 1.0f, A);
+}
+
+TEST(XFormTest, verifyHasPerspective) {
+  Transform A;
+  A.ApplyPerspectiveDepth(1.0);
+  EXPECT_TRUE(A.HasPerspective());
+
+  A.MakeIdentity();
+  A.ApplyPerspectiveDepth(0.0);
+  EXPECT_FALSE(A.HasPerspective());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 0, -1.0);
+  EXPECT_TRUE(A.HasPerspective());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 1, -1.0);
+  EXPECT_TRUE(A.HasPerspective());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 2, -0.3);
+  EXPECT_TRUE(A.HasPerspective());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 3, 0.5);
+  EXPECT_TRUE(A.HasPerspective());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 3, 0.0);
+  EXPECT_TRUE(A.HasPerspective());
+}
+
+TEST(XFormTest, verifyIsInvertible) {
+  Transform A;
+
+  // Translations, rotations, scales, skews and arbitrary combinations of them
+  // are invertible.
+  A.MakeIdentity();
+  EXPECT_TRUE(A.IsInvertible());
+
+  A.MakeIdentity();
+  A.Translate3d(2.0, 3.0, 4.0);
+  EXPECT_TRUE(A.IsInvertible());
+
+  A.MakeIdentity();
+  A.Scale3d(6.0, 7.0, 8.0);
+  EXPECT_TRUE(A.IsInvertible());
+
+  A.MakeIdentity();
+  A.RotateAboutXAxis(10.0);
+  A.RotateAboutYAxis(20.0);
+  A.RotateAboutZAxis(30.0);
+  EXPECT_TRUE(A.IsInvertible());
+
+  A.MakeIdentity();
+  A.SkewX(45.0);
+  EXPECT_TRUE(A.IsInvertible());
+
+  // A perspective matrix (projection plane at z=0) is invertible. The
+  // intuitive explanation is that perspective is eqivalent to a skew of the
+  // w-axis; skews are invertible.
+  A.MakeIdentity();
+  A.ApplyPerspectiveDepth(1.0);
+  EXPECT_TRUE(A.IsInvertible());
+
+  // A "pure" perspective matrix derived by similar triangles, with m44() set
+  // to zero (i.e. camera positioned at the origin), is not invertible.
+  A.MakeIdentity();
+  A.ApplyPerspectiveDepth(1.0);
+  A.matrix().setDouble(3, 3, 0.0);
+  EXPECT_FALSE(A.IsInvertible());
+
+  // Adding more to a non-invertible matrix will not make it invertible in the
+  // general case.
+  A.MakeIdentity();
+  A.ApplyPerspectiveDepth(1.0);
+  A.matrix().setDouble(3, 3, 0.0);
+  A.Scale3d(6.0, 7.0, 8.0);
+  A.RotateAboutXAxis(10.0);
+  A.RotateAboutYAxis(20.0);
+  A.RotateAboutZAxis(30.0);
+  A.Translate3d(6.0, 7.0, 8.0);
+  EXPECT_FALSE(A.IsInvertible());
+
+  // A degenerate matrix of all zeros is not invertible.
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 0, 0.0);
+  A.matrix().setDouble(1, 1, 0.0);
+  A.matrix().setDouble(2, 2, 0.0);
+  A.matrix().setDouble(3, 3, 0.0);
+  EXPECT_FALSE(A.IsInvertible());
+}
+
+TEST(XFormTest, verifyIsIdentity) {
+  Transform A;
+
+  InitializeTestMatrix(&A);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  EXPECT_TRUE(A.IsIdentity());
+
+  // Modifying any one individual element should cause the matrix to no longer
+  // be identity.
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 3, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 3, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 3, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 3, 2.0);
+  EXPECT_FALSE(A.IsIdentity());
+}
+
+TEST(XFormTest, verifyIsIdentityOrTranslation) {
+  Transform A;
+
+  InitializeTestMatrix(&A);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  EXPECT_TRUE(A.IsIdentityOrTranslation());
+
+  // Modifying any non-translation components should cause
+  // IsIdentityOrTranslation() to return false. NOTE: (0, 3), (1, 3), and
+  // (2, 3) are the translation components, so modifying them should still
+  // return true.
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 0, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 1, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 2, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 3, 2.0);
+  EXPECT_TRUE(A.IsIdentityOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 3, 2.0);
+  EXPECT_TRUE(A.IsIdentityOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 3, 2.0);
+  EXPECT_TRUE(A.IsIdentityOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 3, 2.0);
+  EXPECT_FALSE(A.IsIdentityOrTranslation());
+}
+
+TEST(XFormTest, verifyIsScaleOrTranslation) {
+  Transform A;
+
+  InitializeTestMatrix(&A);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  // Modifying any non-scale or non-translation components should cause
+  // IsScaleOrTranslation() to return false. (0, 0), (1, 1), (2, 2), (0, 3),
+  // (1, 3), and (2, 3) are the scale and translation components, so
+  // modifying them should still return true.
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 0, 2.0);
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 0, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 0, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 0, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 1, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 1, 2.0);
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 1, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 1, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 2, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 2, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 2, 2.0);
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 2, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(0, 3, 2.0);
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(1, 3, 2.0);
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  // Note carefully - expecting true here.
+  A.MakeIdentity();
+  A.matrix().setDouble(2, 3, 2.0);
+  EXPECT_TRUE(A.IsScaleOrTranslation());
+
+  A.MakeIdentity();
+  A.matrix().setDouble(3, 3, 2.0);
+  EXPECT_FALSE(A.IsScaleOrTranslation());
+}
+
+TEST(XFormTest, verifyFlattenTo2d) {
+  Transform A;
+  InitializeTestMatrix(&A);
+
+  A.FlattenTo2d();
+  EXPECT_ROW1_EQ(10.0f, 14.0f, 0.0f, 22.0f, A);
+  EXPECT_ROW2_EQ(11.0f, 15.0f, 0.0f, 23.0f, A);
+  EXPECT_ROW3_EQ(0.0f,  0.0f,  1.0f, 0.0f,  A);
+  EXPECT_ROW4_EQ(13.0f, 17.0f, 0.0f, 25.0f, A);
+}
+
 }  // namespace
 
 }  // namespace gfx
Index: src/ui/gfx/rect_f.h
===================================================================
--- src/ui/gfx/rect_f.h	(revision 184497)
+++ src/ui/gfx/rect_f.h	(working copy)
@@ -49,10 +49,7 @@
 
   void Scale(float x_scale, float y_scale) {
     set_origin(ScalePoint(origin(), x_scale, y_scale));
-
-    SizeF new_size = gfx::ScaleSize(size(), x_scale, y_scale);
-    new_size.ClampToNonNegative();
-    set_size(new_size);
+    set_size(ScaleSize(size(), x_scale, y_scale));
   }
 
   // This method reports if the RectF can be safely converted to an integer
@@ -72,9 +69,16 @@
   return !(lhs == rhs);
 }
 
-UI_EXPORT RectF operator+(const RectF& lhs, const Vector2dF& rhs);
-UI_EXPORT RectF operator-(const RectF& lhs, const Vector2dF& rhs);
+inline RectF operator+(const RectF& lhs, const Vector2dF& rhs) {
+  return RectF(lhs.x() + rhs.x(), lhs.y() + rhs.y(),
+      lhs.width(), lhs.height());
+}
 
+inline RectF operator-(const RectF& lhs, const Vector2dF& rhs) {
+  return RectF(lhs.x() - rhs.x(), lhs.y() - rhs.y(),
+      lhs.width(), lhs.height());
+}
+
 inline RectF operator+(const Vector2dF& lhs, const RectF& rhs) {
   return rhs + lhs;
 }
@@ -82,8 +86,12 @@
 UI_EXPORT RectF IntersectRects(const RectF& a, const RectF& b);
 UI_EXPORT RectF UnionRects(const RectF& a, const RectF& b);
 UI_EXPORT RectF SubtractRects(const RectF& a, const RectF& b);
-UI_EXPORT RectF ScaleRect(const RectF& r, float x_scale, float y_scale);
 
+inline RectF ScaleRect(const RectF& r, float x_scale, float y_scale) {
+  return RectF(r.x() * x_scale, r.y() * y_scale,
+       r.width() * x_scale, r.height() * y_scale);
+}
+
 inline RectF ScaleRect(const RectF& r, float scale) {
   return ScaleRect(r, scale, scale);
 }
Index: src/ui/gfx/size_base.h
===================================================================
--- src/ui/gfx/size_base.h	(revision 184497)
+++ src/ui/gfx/size_base.h	(working copy)
@@ -28,8 +28,8 @@
     set_height(height_ + height);
   }
 
-  void set_width(Type width) { width_ = width; }
-  void set_height(Type height) { height_ = height; }
+  void set_width(Type width);
+  void set_height(Type height);
 
   void ClampToMax(const Class& max) {
     width_ = width_ <= max.width_ ? width_ : max.width_;
@@ -42,20 +42,11 @@
   }
 
   bool IsEmpty() const {
-    return (width_ <= 0) || (height_ <= 0);
+    return (width_ == 0) || (height_ == 0);
   }
 
-  void ClampToNonNegative() {
-    if (width_ < 0)
-      width_ = 0;
-    if (height_ < 0)
-      height_ = 0;
-  }
-
  protected:
-  SizeBase(Type width, Type height)
-      : width_(width),
-        height_(height) {}
+  SizeBase(Type width, Type height);
 
   // Destructor is intentionally made non virtual and protected.
   // Do not make this public.
Index: src/ui/gfx/size.cc
===================================================================
--- src/ui/gfx/size.cc	(revision 184497)
+++ src/ui/gfx/size.cc	(working copy)
@@ -8,18 +8,16 @@
 #include <windows.h>
 #endif
 
-#include "base/logging.h"
 #include "base/stringprintf.h"
-#include "ui/gfx/size_base.h"
+#include "ui/gfx/size_base_impl.h"
 
 namespace gfx {
 
 template class SizeBase<Size, int>;
 
 #if defined(OS_MACOSX)
-Size::Size(const CGSize& s) : SizeBase<Size, int>(0, 0) {
-  set_width(s.width);
-  set_height(s.height);
+Size::Size(const CGSize& s)
+    : SizeBase<Size, int>(s.width, s.height) {
 }
 
 Size& Size::operator=(const CGSize& s) {
Index: src/ui/gfx/size_f.cc
===================================================================
--- src/ui/gfx/size_f.cc	(revision 184497)
+++ src/ui/gfx/size_f.cc	(working copy)
@@ -4,8 +4,8 @@
 
 #include "ui/gfx/size_f.h"
 
-#include "base/logging.h"
 #include "base/stringprintf.h"
+#include "ui/gfx/size_base_impl.h"
 
 namespace gfx {
 
Index: src/ui/gfx/quad_f.cc
===================================================================
--- src/ui/gfx/quad_f.cc	(revision 184497)
+++ src/ui/gfx/quad_f.cc	(working copy)
@@ -34,13 +34,6 @@
 QuadF::~QuadF() {
 }
 
-void QuadF::operator=(const QuadF& quad) {
-  p1_ = quad.p1_;
-  p2_ = quad.p2_;
-  p3_ = quad.p3_;
-  p4_ = quad.p4_;
-}
-
 void QuadF::operator=(const RectF& rect) {
   p1_ = PointF(rect.x(), rect.y());
   p2_ = PointF(rect.right(), rect.y());
Index: src/ui/gfx/transform.cc
===================================================================
--- src/ui/gfx/transform.cc	(revision 184497)
+++ src/ui/gfx/transform.cc	(working copy)
@@ -31,6 +31,48 @@
 
 }  // namespace
 
+Transform::Transform(
+    double col1row1, double col2row1, double col3row1, double col4row1,
+    double col1row2, double col2row2, double col3row2, double col4row2,
+    double col1row3, double col2row3, double col3row3, double col4row3,
+    double col1row4, double col2row4, double col3row4, double col4row4)
+    : matrix_(SkMatrix44::kUninitialized_Constructor)
+{
+  matrix_.setDouble(0, 0, col1row1);
+  matrix_.setDouble(1, 0, col1row2);
+  matrix_.setDouble(2, 0, col1row3);
+  matrix_.setDouble(3, 0, col1row4);
+
+  matrix_.setDouble(0, 1, col2row1);
+  matrix_.setDouble(1, 1, col2row2);
+  matrix_.setDouble(2, 1, col2row3);
+  matrix_.setDouble(3, 1, col2row4);
+
+  matrix_.setDouble(0, 2, col3row1);
+  matrix_.setDouble(1, 2, col3row2);
+  matrix_.setDouble(2, 2, col3row3);
+  matrix_.setDouble(3, 2, col3row4);
+
+  matrix_.setDouble(0, 3, col4row1);
+  matrix_.setDouble(1, 3, col4row2);
+  matrix_.setDouble(2, 3, col4row3);
+  matrix_.setDouble(3, 3, col4row4);
+}
+
+Transform::Transform(
+    double col1row1, double col2row1,
+    double col1row2, double col2row2,
+    double x_translation, double y_translation)
+    : matrix_(SkMatrix44::kIdentity_Constructor)
+{
+  matrix_.setDouble(0, 0, col1row1);
+  matrix_.setDouble(1, 0, col1row2);
+  matrix_.setDouble(0, 1, col2row1);
+  matrix_.setDouble(1, 1, col2row2);
+  matrix_.setDouble(0, 3, x_translation);
+  matrix_.setDouble(1, 3, y_translation);
+}
+
 void Transform::RotateAboutXAxis(double degrees) {
   double radians = degrees * M_PI / 180;
   double cosTheta = std::cos(radians);
@@ -258,6 +300,16 @@
   matrix_.transpose();
 }
 
+void Transform::FlattenTo2d() {
+  matrix_.setDouble(2, 0, 0.0);
+  matrix_.setDouble(2, 1, 0.0);
+  matrix_.setDouble(0, 2, 0.0);
+  matrix_.setDouble(1, 2, 0.0);
+  matrix_.setDouble(2, 2, 1.0);
+  matrix_.setDouble(3, 2, 0.0);
+  matrix_.setDouble(2, 3, 0.0);
+}
+
 void Transform::TransformPoint(Point& point) const {
   TransformPointInternal(matrix_, point);
 }
Index: src/ui/compositor/compositor.cc
===================================================================
--- src/ui/compositor/compositor.cc	(revision 184497)
+++ src/ui/compositor/compositor.cc	(working copy)
@@ -83,8 +83,7 @@
     return NULL;
   }
 
-  virtual void SendFrameToParentCompositor(
-      const cc::CompositorFrame&) OVERRIDE {
+  virtual void SendFrameToParentCompositor(cc::CompositorFrame*) OVERRIDE {
   }
 
  private:
Index: src/ui/compositor/compositor.gyp
===================================================================
--- src/ui/compositor/compositor.gyp	(revision 184497)
+++ src/ui/compositor/compositor.gyp	(working copy)
@@ -35,6 +35,8 @@
         'debug_utils.h',
         'dip_util.cc',
         'dip_util.h',
+        'float_animation_curve_adapter.cc',
+        'float_animation_curve_adapter.h',
         'layer.cc',
         'layer.h',
         'layer_animation_delegate.h',
@@ -55,6 +57,8 @@
         # UI tests need TestWebGraphicsContext3D, so we always build it.
         'test_web_graphics_context_3d.cc',
         'test_web_graphics_context_3d.h',
+        'transform_animation_curve_adapter.cc',
+        'transform_animation_curve_adapter.h',
       ],
       'conditions': [
         ['OS == "win" and use_aura == 1', {
Index: src/ui/compositor/layer.cc
===================================================================
--- src/ui/compositor/layer.cc	(revision 184497)
+++ src/ui/compositor/layer.cc	(working copy)
@@ -791,12 +791,11 @@
 
     gfx::Size size(std::min(bounds().width(), texture_size.width()),
                    std::min(bounds().height(), texture_size.height()));
-    gfx::RectF rect(
-        0,
-        0,
+    gfx::PointF uv_top_left(0.f, 0.f);
+    gfx::PointF uv_bottom_right(
         static_cast<float>(size.width())/texture_size.width(),
         static_cast<float>(size.height())/texture_size.height());
-    texture_layer_->setUVRect(rect);
+    texture_layer_->setUV(uv_top_left, uv_bottom_right);
 
     cc_layer_->setBounds(ConvertSizeToPixel(this, size));
   }
Index: src/ui/gl/async_pixel_transfer_delegate_stub.cc
===================================================================
--- src/ui/gl/async_pixel_transfer_delegate_stub.cc	(revision 184497)
+++ src/ui/gl/async_pixel_transfer_delegate_stub.cc	(working copy)
@@ -62,7 +62,8 @@
   needs_late_bind_ = false;
 }
 
-AsyncPixelTransferDelegateStub::AsyncPixelTransferDelegateStub() {
+AsyncPixelTransferDelegateStub::AsyncPixelTransferDelegateStub()
+    : texture_upload_count_(0) {
 }
 
 AsyncPixelTransferDelegateStub::~AsyncPixelTransferDelegateStub() {
@@ -76,8 +77,9 @@
 }
 
 void AsyncPixelTransferDelegateStub::AsyncNotifyCompletion(
-    const base::Closure& task) {
-  task.Run();
+    const AsyncMemoryParams& mem_params,
+    const CompletionCallback& callback) {
+  callback.Run(mem_params);
 }
 
 void AsyncPixelTransferDelegateStub::AsyncTexImage2D(
@@ -122,6 +124,7 @@
   AsyncTransferStateStub* state =
       static_cast<AsyncTransferStateStub*>(transfer_state);
   DCHECK(!state->needs_late_bind_);
+  base::TimeTicks begin_time(base::TimeTicks::HighResNow());
   glTexSubImage2D(
       tex_params.target,
       tex_params.level,
@@ -132,6 +135,17 @@
       tex_params.format,
       tex_params.type,
       data);
+  texture_upload_count_++;
+  total_texture_upload_time_ += base::TimeTicks::HighResNow() - begin_time;
 }
+
+uint32 AsyncPixelTransferDelegateStub::GetTextureUploadCount() {
+  return texture_upload_count_;
+}
+
+base::TimeDelta AsyncPixelTransferDelegateStub::GetTotalTextureUploadTime() {
+  return total_texture_upload_time_;
+}
+
 }  // namespace gfx
 
Index: src/ui/gl/async_pixel_transfer_delegate_android.cc
===================================================================
--- src/ui/gl/async_pixel_transfer_delegate_android.cc	(revision 184497)
+++ src/ui/gl/async_pixel_transfer_delegate_android.cc	(working copy)
@@ -4,7 +4,7 @@
 
 #include "ui/gl/async_pixel_transfer_delegate_android.h"
 
-#include <sys/resource.h>
+#include <string>
 
 #include "base/bind.h"
 #include "base/debug/trace_event.h"
@@ -23,7 +23,11 @@
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_context.h"
 #include "ui/gl/gl_surface_egl.h"
+#include "ui/gl/safe_shared_memory_pool.h"
 
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
+
 using base::SharedMemory;
 using base::SharedMemoryHandle;
 
@@ -38,47 +42,50 @@
   GLenum glerror;
   bool success = true;
   while ((eglerror = eglGetError()) != EGL_SUCCESS) {
-     LOG(ERROR) << "Async transfer eglerror at "
+     LOG(ERROR) << "Async transfer EGL error at "
                 << file << ":" << line << " " << eglerror;
      success = false;
   }
   while ((glerror = glGetError()) != GL_NO_ERROR) {
-     LOG(ERROR) << "Async transfer openglerror at "
+     LOG(ERROR) << "Async transfer OpenGL error at "
                 << file << ":" << line << " " << glerror;
      success = false;
   }
   return success;
 }
-#define CHK() CheckErrors(__FILE__, __LINE__)
+#define CHECK_GL() CheckErrors(__FILE__, __LINE__)
 
-// We duplicate shared memory to avoid use-after-free issues. This could also
-// be solved by ref-counting something, or with a destruction callback. There
-// wasn't an obvious hook or ref-counted container, so for now we dup/mmap.
-SharedMemory* DuplicateSharedMemory(SharedMemory* shared_memory, uint32 size) {
-  // Duplicate the handle.
-  SharedMemoryHandle duped_shared_memory_handle;
-  if (!shared_memory->ShareToProcess(
-      base::GetCurrentProcessHandle(),
-      &duped_shared_memory_handle))
-    return NULL;
-  scoped_ptr<SharedMemory> duped_shared_memory(
-      new SharedMemory(duped_shared_memory_handle, false));
-  // Map the shared memory into this process. This validates the size.
-  if (!duped_shared_memory->Map(size))
-    return NULL;
-  return duped_shared_memory.release();
+// Regular glTexImage2D call.
+void DoTexImage2D(const AsyncTexImage2DParams& tex_params, void* data) {
+  glTexImage2D(
+      GL_TEXTURE_2D, tex_params.level, tex_params.internal_format,
+      tex_params.width, tex_params.height,
+      tex_params.border, tex_params.format, tex_params.type, data);
 }
 
+// Regular glTexSubImage2D call.
+void DoTexSubImage2D(const AsyncTexSubImage2DParams& tex_params, void* data) {
+  glTexSubImage2D(
+      GL_TEXTURE_2D, tex_params.level,
+      tex_params.xoffset, tex_params.yoffset,
+      tex_params.width, tex_params.height,
+      tex_params.format, tex_params.type, data);
+}
+
+// Full glTexSubImage2D call, from glTexImage2D params.
+void DoFullTexSubImage2D(const AsyncTexImage2DParams& tex_params, void* data) {
+  glTexSubImage2D(
+      GL_TEXTURE_2D, tex_params.level,
+      0, 0, tex_params.width, tex_params.height,
+      tex_params.format, tex_params.type, data);
+}
+
 // Gets the address of the data from shared memory.
-void* GetAddress(SharedMemory* shared_memory,
-                 uint32 shm_size,
-                 uint32 shm_data_offset,
-                 uint32 shm_data_size) {
+void* GetAddress(SharedMemory* shared_memory, uint32 shm_data_offset) {
   // Memory bounds have already been validated, so there
   // is just DCHECKS here.
-  DCHECK(shared_memory);
-  DCHECK(shared_memory->memory());
-  DCHECK_LE(shm_data_offset + shm_data_size, shm_size);
+  CHECK(shared_memory);
+  CHECK(shared_memory->memory());
   return static_cast<int8*>(shared_memory->memory()) + shm_data_offset;
 }
 
@@ -92,11 +99,6 @@
   }
 
   virtual void Init() OVERRIDE {
-    // Lower the thread priority for uploads.
-    // TODO(epenner): What's a good value? Without lowering this, uploads
-    // would often execute immediately and block the GPU thread.
-    setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), 5);
-
     GLShareGroup* share_group = NULL;
     bool software = false;
     surface_ = new gfx::PbufferGLSurfaceEGL(software, gfx::Size(1,1));
@@ -106,6 +108,10 @@
                                                gfx::PreferDiscreteGpu);
     bool is_current = context_->MakeCurrent(surface_);
     DCHECK(is_current);
+
+    // TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+    int nice_value = 10; // Idle priority.
+    setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), nice_value);
   }
 
   virtual void CleanUp() OVERRIDE {
@@ -114,29 +120,48 @@
     context_ = NULL;
   }
 
+  SafeSharedMemoryPool* safe_shared_memory_pool() {
+      return &safe_shared_memory_pool_;
+  }
+
  private:
   scoped_refptr<gfx::GLContext> context_;
   scoped_refptr<gfx::GLSurface> surface_;
 
+  SafeSharedMemoryPool safe_shared_memory_pool_;
+
   DISALLOW_COPY_AND_ASSIGN(TransferThread);
 };
 
 base::LazyInstance<TransferThread>
     g_transfer_thread = LAZY_INSTANCE_INITIALIZER;
 
+base::MessageLoopProxy* transfer_message_loop_proxy() {
+  return g_transfer_thread.Pointer()->message_loop_proxy();
+}
+
+SafeSharedMemoryPool* safe_shared_memory_pool() {
+  return g_transfer_thread.Pointer()->safe_shared_memory_pool();
+}
+
+
 } // namespace
 
 // Class which holds async pixel transfers state (EGLImage).
 // The EGLImage is accessed by either thread, but everything
 // else accessed only on the main thread.
-class TransferStateInternal
-    : public base::RefCountedThreadSafe<TransferStateInternal> {
+class TransferStateInternal : public base::RefCounted<TransferStateInternal> {
  public:
-  explicit TransferStateInternal(GLuint texture_id)
+  explicit TransferStateInternal(GLuint texture_id,
+                                 bool wait_for_uploads,
+                                 bool use_image_preserved)
       : texture_id_(texture_id),
+        thread_texture_id_(0),
         needs_late_bind_(false),
         transfer_in_progress_(false),
-        egl_image_(EGL_NO_IMAGE_KHR) {
+        egl_image_(EGL_NO_IMAGE_KHR),
+        wait_for_uploads_(wait_for_uploads),
+        use_image_preserved_(use_image_preserved) {
     static const AsyncTexImage2DParams zero_params = {0, 0, 0, 0, 0, 0, 0, 0};
     late_bind_define_params_ = zero_params;
   }
@@ -147,36 +172,98 @@
   }
 
   void BindTransfer(AsyncTexImage2DParams* bound_params) {
+    TRACE_EVENT2("gpu", "BindAsyncTransfer glEGLImageTargetTexture2DOES",
+                 "width", late_bind_define_params_.width,
+                 "height", late_bind_define_params_.height);
     DCHECK(bound_params);
-    DCHECK(needs_late_bind_);
+    DCHECK(texture_id_);
+    *bound_params = late_bind_define_params_;
+    if (!needs_late_bind_)
+      return;
+    DCHECK_NE(EGL_NO_IMAGE_KHR, egl_image_);
+
+    // We can only change the active texture and unit 0,
+    // as that is all that will be restored.
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, texture_id_);
     glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, egl_image_);
-    *bound_params = late_bind_define_params_;
     needs_late_bind_ = false;
+
+    DCHECK(CHECK_GL());
   }
 
-  // Completion callbacks.
-  void TexImage2DCompleted() {
-    needs_late_bind_ = true;
-    transfer_in_progress_ = false;
+  void CreateEglImage(GLuint texture_id) {
+    TRACE_EVENT0("gpu", "eglCreateImageKHR");
+    DCHECK(texture_id);
+    DCHECK_EQ(egl_image_, EGL_NO_IMAGE_KHR);
+
+    EGLDisplay egl_display = eglGetCurrentDisplay();
+    EGLContext egl_context = eglGetCurrentContext();
+    EGLenum egl_target = EGL_GL_TEXTURE_2D_KHR;
+    EGLClientBuffer egl_buffer =
+        reinterpret_cast<EGLClientBuffer>(texture_id);
+
+    EGLint image_preserved = use_image_preserved_ ? EGL_TRUE : EGL_FALSE;
+    EGLint egl_attrib_list[] = {
+        EGL_GL_TEXTURE_LEVEL_KHR, 0, // mip-level.
+        EGL_IMAGE_PRESERVED_KHR, image_preserved,
+        EGL_NONE
+    };
+    egl_image_ = eglCreateImageKHR(
+        egl_display,
+        egl_context,
+        egl_target,
+        egl_buffer,
+        egl_attrib_list);
+
+    DCHECK_NE(EGL_NO_IMAGE_KHR, egl_image_);
   }
-  void TexSubImage2DCompleted() {
-    transfer_in_progress_ = false;
+
+  void CreateEglImageOnUploadThread() {
+    CreateEglImage(thread_texture_id_);
   }
 
-protected:
-  friend class base::RefCountedThreadSafe<TransferStateInternal>;
+  void CreateEglImageOnMainThreadIfNeeded() {
+    if (egl_image_ == EGL_NO_IMAGE_KHR)
+      CreateEglImage(texture_id_);
+  }
+
+  void WaitForLastUpload() {
+    // This glFinish is just a safe-guard for if uploads have some
+    // GPU action that needs to occur. We could use fences and try
+    // to do this less often. However, on older drivers fences are
+    // not always reliable (eg. Mali-400 just blocks forever).
+    if (wait_for_uploads_) {
+      TRACE_EVENT0("gpu", "glFinish");
+      glFinish();
+    }
+  }
+
+ protected:
+  friend class base::RefCounted<TransferStateInternal>;
   friend class AsyncPixelTransferDelegateAndroid;
 
+  static void DeleteTexture(GLuint id) {
+    glDeleteTextures(1, &id);
+  }
+
   virtual ~TransferStateInternal() {
-    if (egl_image_) {
+    if (egl_image_ != EGL_NO_IMAGE_KHR) {
       EGLDisplay display = eglGetCurrentDisplay();
       eglDestroyImageKHR(display, egl_image_);
     }
+    if (thread_texture_id_) {
+      transfer_message_loop_proxy()->PostTask(FROM_HERE,
+          base::Bind(&DeleteTexture, thread_texture_id_));
+    }
   }
 
   // The 'real' texture.
   GLuint texture_id_;
 
+  // The EGLImage sibling on the upload thread.
+  GLuint thread_texture_id_;
+
   // Indicates there is a new EGLImage and the 'real'
   // texture needs to be bound to it as an EGLImage target.
   bool needs_late_bind_;
@@ -191,14 +278,25 @@
   // every upload, but I found that didn't work, so this stores
   // one for the lifetime of the texture.
   EGLImageKHR egl_image_;
+
+  // Time spent performing last transfer.
+  base::TimeDelta last_transfer_time_;
+
+  // Customize when we block on fences (these are work-arounds).
+  bool wait_for_uploads_;
+  bool use_image_preserved_;
 };
 
 // Android needs thread-safe ref-counting, so this just wraps
 // an internal thread-safe ref-counted state object.
 class AsyncTransferStateAndroid : public AsyncPixelTransferState {
  public:
-  explicit AsyncTransferStateAndroid(GLuint texture_id)
-      : internal_(new TransferStateInternal(texture_id)) {
+  explicit AsyncTransferStateAndroid(GLuint texture_id,
+                                     bool wait_for_uploads,
+                                     bool use_image_preserved)
+      : internal_(new TransferStateInternal(texture_id,
+                                            wait_for_uploads,
+                                            use_image_preserved)) {
   }
   virtual ~AsyncTransferStateAndroid() {}
   virtual bool TransferIsInProgress() {
@@ -212,14 +310,17 @@
 
 // Class which handles async pixel transfers on Android (using
 // EGLImageKHR and another upload thread)
-class AsyncPixelTransferDelegateAndroid : public AsyncPixelTransferDelegate {
+class AsyncPixelTransferDelegateAndroid
+    : public AsyncPixelTransferDelegate,
+      public base::SupportsWeakPtr<AsyncPixelTransferDelegateAndroid> {
  public:
-  AsyncPixelTransferDelegateAndroid() {}
-  virtual ~AsyncPixelTransferDelegateAndroid() {}
+  AsyncPixelTransferDelegateAndroid();
+  virtual ~AsyncPixelTransferDelegateAndroid();
 
   // implement AsyncPixelTransferDelegate:
   virtual void AsyncNotifyCompletion(
-      const base::Closure& task) OVERRIDE;
+      const AsyncMemoryParams& mem_params,
+      const CompletionCallback& callback) OVERRIDE;
   virtual void AsyncTexImage2D(
       AsyncPixelTransferState* state,
       const AsyncTexImage2DParams& tex_params,
@@ -228,24 +329,47 @@
       AsyncPixelTransferState* state,
       const AsyncTexSubImage2DParams& tex_params,
       const AsyncMemoryParams& mem_params) OVERRIDE;
+  virtual uint32 GetTextureUploadCount() OVERRIDE;
+  virtual base::TimeDelta GetTotalTextureUploadTime() OVERRIDE;
 
  private:
   // implement AsyncPixelTransferDelegate:
   virtual AsyncPixelTransferState*
       CreateRawPixelTransferState(GLuint texture_id) OVERRIDE;
 
-  base::MessageLoopProxy* transfer_message_loop_proxy() {
-    return g_transfer_thread.Pointer()->message_loop_proxy();
-  }
+  void AsyncTexImage2DCompleted(scoped_refptr<TransferStateInternal> state);
+  void AsyncTexSubImage2DCompleted(scoped_refptr<TransferStateInternal> state);
+
+  static void PerformNotifyCompletion(
+      AsyncMemoryParams mem_params,
+      ScopedSafeSharedMemory* safe_shared_memory,
+      const CompletionCallback& callback);
   static void PerformAsyncTexImage2D(
       TransferStateInternal* state,
       AsyncTexImage2DParams tex_params,
-      AsyncMemoryParams mem_params);
+      AsyncMemoryParams mem_params,
+      ScopedSafeSharedMemory* safe_shared_memory);
   static void PerformAsyncTexSubImage2D(
       TransferStateInternal* state,
       AsyncTexSubImage2DParams tex_params,
-      AsyncMemoryParams mem_params);
+      AsyncMemoryParams mem_params,
+      ScopedSafeSharedMemory* safe_shared_memory);
 
+  // Returns true if a work-around was used.
+  bool WorkAroundAsyncTexImage2D(
+      TransferStateInternal* state,
+      const AsyncTexImage2DParams& tex_params,
+      const AsyncMemoryParams& mem_params);
+  bool WorkAroundAsyncTexSubImage2D(
+      TransferStateInternal* state,
+      const AsyncTexSubImage2DParams& tex_params,
+      const AsyncMemoryParams& mem_params);
+
+  int texture_upload_count_;
+  base::TimeDelta total_texture_upload_time_;
+  bool is_imagination_;
+  bool is_qualcomm_;
+
   DISALLOW_COPY_AND_ASSIGN(AsyncPixelTransferDelegateAndroid);
 };
 
@@ -256,11 +380,7 @@
 scoped_ptr<AsyncPixelTransferDelegate>
     AsyncPixelTransferDelegate::Create(gfx::GLContext* context) {
   DCHECK(context);
-  // TODO(epenner): Enable it! Waiting for impl-side painting
-  // to be more stable before enabling this.
-  bool enable = false;
-  if (enable &&
-      context->HasExtension("EGL_KHR_fence_sync") &&
+  if (context->HasExtension("EGL_KHR_fence_sync") &&
       context->HasExtension("EGL_KHR_image") &&
       context->HasExtension("EGL_KHR_image_base") &&
       context->HasExtension("EGL_KHR_gl_texture_2D_image") &&
@@ -276,35 +396,66 @@
   }
 }
 
+AsyncPixelTransferDelegateAndroid::AsyncPixelTransferDelegateAndroid()
+    : texture_upload_count_(0) {
+  std::string vendor;
+  vendor = reinterpret_cast<const char*>(glGetString(GL_VENDOR));
+  is_imagination_ = vendor.find("Imagination") != std::string::npos;
+  is_qualcomm_ = vendor.find("Qualcomm") != std::string::npos;
+}
+
+AsyncPixelTransferDelegateAndroid::~AsyncPixelTransferDelegateAndroid() {
+}
+
 AsyncPixelTransferState*
     AsyncPixelTransferDelegateAndroid::
         CreateRawPixelTransferState(GLuint texture_id) {
+
+  // We can't wait on uploads on imagination (it can take 200ms+).
+  // In practice, they are complete when the CPU glTexSubImage2D completes.
+  bool wait_for_uploads = !is_imagination_;
+
+  // Qualcomm has a race when using image_preserved=FALSE,
+  // which can result in black textures even after the first upload.
+  // Since using FALSE is mainly for performance (to avoid layout changes),
+  // but Qualcomm itself doesn't seem to get any performance benefit,
+  // we just using image_preservedd=TRUE on Qualcomm as a work-around.
+  bool use_image_preserved = is_qualcomm_ || is_imagination_;
+
   return static_cast<AsyncPixelTransferState*>(
-      new AsyncTransferStateAndroid(texture_id));
+      new AsyncTransferStateAndroid(texture_id,
+                                    wait_for_uploads,
+                                    use_image_preserved));
 }
 
-namespace {
-// Dummy function to measure completion on
-// the upload thread.
-void NoOp() {}
-} // namespace
-
 void AsyncPixelTransferDelegateAndroid::AsyncNotifyCompletion(
-      const base::Closure& task) {
-  // Post a no-op task to the upload thread followed
-  // by a reply to the callback. The reply will then occur after
-  // all async transfers are complete.
-  transfer_message_loop_proxy()->PostTaskAndReply(FROM_HERE,
-      base::Bind(&NoOp), task);
+    const AsyncMemoryParams& mem_params,
+    const CompletionCallback& callback) {
+  DCHECK(mem_params.shared_memory);
+  DCHECK_LE(mem_params.shm_data_offset + mem_params.shm_data_size,
+            mem_params.shm_size);
+  // Post a PerformNotifyCompletion task to the upload thread. This task
+  // will run after all async transfers are complete.
+  transfer_message_loop_proxy()->PostTask(
+      FROM_HERE,
+      base::Bind(&AsyncPixelTransferDelegateAndroid::PerformNotifyCompletion,
+                 mem_params,
+                 base::Owned(
+                     new ScopedSafeSharedMemory(safe_shared_memory_pool(),
+                                                mem_params.shared_memory,
+                                                mem_params.shm_size)),
+                 callback));
 }
 
 void AsyncPixelTransferDelegateAndroid::AsyncTexImage2D(
     AsyncPixelTransferState* transfer_state,
     const AsyncTexImage2DParams& tex_params,
     const AsyncMemoryParams& mem_params) {
-  TransferStateInternal* state =
+  scoped_refptr<TransferStateInternal> state =
       static_cast<AsyncTransferStateAndroid*>(transfer_state)->internal_.get();
   DCHECK(mem_params.shared_memory);
+  DCHECK_LE(mem_params.shm_data_offset + mem_params.shm_data_size,
+            mem_params.shm_size);
   DCHECK(state);
   DCHECK(state->texture_id_);
   DCHECK(!state->needs_late_bind_);
@@ -313,25 +464,30 @@
   DCHECK_EQ(static_cast<GLenum>(GL_TEXTURE_2D), tex_params.target);
   DCHECK_EQ(tex_params.level, 0);
 
+  if (WorkAroundAsyncTexImage2D(state, tex_params, mem_params))
+    return;
+
   // Mark the transfer in progress and save define params for lazy binding.
   state->transfer_in_progress_ = true;
   state->late_bind_define_params_ = tex_params;
 
   // Duplicate the shared memory so there are no way we can get
   // a use-after-free of the raw pixels.
-  // TODO: Could we pass an own pointer of the new SharedMemory to the task?
-  AsyncMemoryParams duped_mem = mem_params;
-  duped_mem.shared_memory = DuplicateSharedMemory(mem_params.shared_memory,
-                                                  mem_params.shm_size);
   transfer_message_loop_proxy()->PostTaskAndReply(FROM_HERE,
       base::Bind(
           &AsyncPixelTransferDelegateAndroid::PerformAsyncTexImage2D,
-          base::Unretained(state), // This is referenced in reply below.
+          base::Unretained(state.get()),  // This is referenced in reply below.
           tex_params,
-          duped_mem),
+          mem_params,
+          base::Owned(new ScopedSafeSharedMemory(safe_shared_memory_pool(),
+                                                 mem_params.shared_memory,
+                                                 mem_params.shm_size))),
       base::Bind(
-          &TransferStateInternal::TexImage2DCompleted,
+          &AsyncPixelTransferDelegateAndroid::AsyncTexImage2DCompleted,
+          AsWeakPtr(),
           state));
+
+  DCHECK(CHECK_GL());
 }
 
 void AsyncPixelTransferDelegateAndroid::AsyncTexSubImage2D(
@@ -341,182 +497,281 @@
   TRACE_EVENT2("gpu", "AsyncTexSubImage2D",
                "width", tex_params.width,
                "height", tex_params.height);
-  TransferStateInternal* state =
+  scoped_refptr<TransferStateInternal> state =
       static_cast<AsyncTransferStateAndroid*>(transfer_state)->internal_.get();
   DCHECK(state->texture_id_);
   DCHECK(!state->transfer_in_progress_);
   DCHECK(mem_params.shared_memory);
+  DCHECK_LE(mem_params.shm_data_offset + mem_params.shm_data_size,
+            mem_params.shm_size);
   DCHECK_EQ(static_cast<GLenum>(GL_TEXTURE_2D), tex_params.target);
   DCHECK_EQ(tex_params.level, 0);
 
+  if (WorkAroundAsyncTexSubImage2D(state, tex_params, mem_params))
+    return;
+
   // Mark the transfer in progress.
   state->transfer_in_progress_ = true;
 
+  // If this wasn't async allocated, we don't have an EGLImage yet.
   // Create the EGLImage if it hasn't already been created.
-  if (!state->egl_image_) {
-    EGLDisplay egl_display = eglGetCurrentDisplay();
-    EGLContext egl_context = eglGetCurrentContext();
-    EGLenum egl_target = EGL_GL_TEXTURE_2D_KHR;
-    EGLClientBuffer egl_buffer =
-        reinterpret_cast<EGLClientBuffer>(state->texture_id_);
-    EGLint egl_attrib_list[] = {
-        EGL_GL_TEXTURE_LEVEL_KHR, tex_params.level, // mip-level to reference.
-        EGL_IMAGE_PRESERVED_KHR, EGL_TRUE, // preserve the data in the texture.
-        EGL_NONE
-    };
-    state->egl_image_ = eglCreateImageKHR(
-        egl_display,
-        egl_context,
-        egl_target,
-        egl_buffer,
-        egl_attrib_list);
-  }
+  state->CreateEglImageOnMainThreadIfNeeded();
 
   // Duplicate the shared memory so there are no way we can get
   // a use-after-free of the raw pixels.
-  // TODO: Could we pass an own pointer of the new SharedMemory to the task?
-  AsyncMemoryParams duped_mem = mem_params;
-  duped_mem.shared_memory = DuplicateSharedMemory(mem_params.shared_memory,
-                                                  mem_params.shm_size);
   transfer_message_loop_proxy()->PostTaskAndReply(FROM_HERE,
       base::Bind(
           &AsyncPixelTransferDelegateAndroid::PerformAsyncTexSubImage2D,
-          base::Unretained(state), // This is referenced in reply below.
+          base::Unretained(state.get()),  // This is referenced in reply below.
           tex_params,
-          duped_mem),
+          mem_params,
+          base::Owned(new ScopedSafeSharedMemory(safe_shared_memory_pool(),
+                                                 mem_params.shared_memory,
+                                                 mem_params.shm_size))),
       base::Bind(
-          &TransferStateInternal::TexSubImage2DCompleted,
+          &AsyncPixelTransferDelegateAndroid::AsyncTexSubImage2DCompleted,
+          AsWeakPtr(),
           state));
+
+  DCHECK(CHECK_GL());
 }
 
-namespace {
-void WaitForGlFence() {
-  // Uploads usually finish on the CPU, but just in case add a fence
-  // and guarantee the upload has completed. The flush bit is set to
-  // insure we don't wait forever.
+uint32 AsyncPixelTransferDelegateAndroid::GetTextureUploadCount() {
+  return texture_upload_count_;
+}
 
-  EGLDisplay display = eglGetCurrentDisplay();
-  EGLSyncKHR fence = eglCreateSyncKHR(display, EGL_SYNC_FENCE_KHR, NULL);
-  EGLint flags = EGL_SYNC_FLUSH_COMMANDS_BIT_KHR;
-  EGLTimeKHR time = EGL_FOREVER_KHR;
+base::TimeDelta AsyncPixelTransferDelegateAndroid::GetTotalTextureUploadTime() {
+  return total_texture_upload_time_;
+}
 
-  // This fence is basically like calling glFinish, which is fine if
-  // uploads occur on the CPU. If some upload work occurs on the GPU,
-  // we may want to delay blocking on the fence.
-  eglClientWaitSyncKHR(display, fence, flags, time);
-  eglDestroySyncKHR(display, fence);
+void AsyncPixelTransferDelegateAndroid::AsyncTexImage2DCompleted(
+    scoped_refptr<TransferStateInternal> state) {
+  state->needs_late_bind_ = true;
+  state->transfer_in_progress_ = false;
 }
+
+void AsyncPixelTransferDelegateAndroid::AsyncTexSubImage2DCompleted(
+    scoped_refptr<TransferStateInternal> state) {
+  state->transfer_in_progress_ = false;
+  texture_upload_count_++;
+  total_texture_upload_time_ += state->last_transfer_time_;
+}
+
+namespace {
+void SetGlParametersForEglImageTexture() {
+  // These params are needed for EGLImage creation to succeed on several
+  // Android devices. I couldn't find this requirement in the EGLImage
+  // extension spec, but several devices fail without it.
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+}
 } // namespace
 
+void AsyncPixelTransferDelegateAndroid::PerformNotifyCompletion(
+    AsyncMemoryParams mem_params,
+    ScopedSafeSharedMemory* safe_shared_memory,
+    const CompletionCallback& callback) {
+  TRACE_EVENT0("gpu", "PerformNotifyCompletion");
+  gfx::AsyncMemoryParams safe_mem_params = mem_params;
+  safe_mem_params.shared_memory = safe_shared_memory->shared_memory();
+  callback.Run(safe_mem_params);
+}
+
 void AsyncPixelTransferDelegateAndroid::PerformAsyncTexImage2D(
     TransferStateInternal* state,
     AsyncTexImage2DParams tex_params,
-    AsyncMemoryParams mem_params) {
-  // TODO(epenner): This is just to insure it is deleted. Could bind() do this?
-  scoped_ptr<SharedMemory> shared_memory =
-      make_scoped_ptr(mem_params.shared_memory);
-
-  void* data = GetAddress(mem_params.shared_memory,
-                          mem_params.shm_size,
-                          mem_params.shm_data_offset,
-                          mem_params.shm_data_size);
-
-  // In texImage2D, we do everything on the upload thread. This is
-  // because texImage2D can incur CPU allocation cost, and it also
-  // 'orphans' any previous EGLImage bound to the texture.
+    AsyncMemoryParams mem_params,
+    ScopedSafeSharedMemory* safe_shared_memory) {
+  TRACE_EVENT2("gpu", "PerformAsyncTexImage",
+               "width", tex_params.width,
+               "height", tex_params.height);
+  DCHECK(state);
+  DCHECK(!state->thread_texture_id_);
   DCHECK_EQ(0, tex_params.level);
   DCHECK_EQ(EGL_NO_IMAGE_KHR, state->egl_image_);
-  TRACE_EVENT2("gpu", "performAsyncTexImage2D",
-               "width", tex_params.width,
-               "height", tex_params.height);
 
-  // Create a texture from the image and upload to it.
-  GLuint temp_texture = 0;
-  glGenTextures(1, &temp_texture);
-  glActiveTexture(GL_TEXTURE0);
-  glBindTexture(GL_TEXTURE_2D, temp_texture);
+  void* data = GetAddress(safe_shared_memory->shared_memory(),
+                          mem_params.shm_data_offset);
   {
-    TRACE_EVENT0("gpu", "performAsyncTexSubImage2D glTexImage2D");
-    glTexImage2D(
-        GL_TEXTURE_2D,
-        tex_params.level,
-        tex_params.internal_format,
-        tex_params.width,
-        tex_params.height,
-        tex_params.border,
-        tex_params.format,
-        tex_params.type,
-        data);
+    TRACE_EVENT0("gpu", "glTexImage2D no data");
+    glGenTextures(1, &state->thread_texture_id_);
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, state->thread_texture_id_);
+
+    SetGlParametersForEglImageTexture();
+
+    // If we need to use image_preserved, we pass the data with
+    // the allocation. Otherwise we use a NULL allocation to
+    // try to avoid any costs associated with creating the EGLImage.
+    if (state->use_image_preserved_)
+       DoTexImage2D(tex_params, data);
+    else
+       DoTexImage2D(tex_params, NULL);
   }
 
-  // Create the EGLImage, as texSubImage always 'orphan's a previous EGLImage.
-  EGLDisplay egl_display = eglGetCurrentDisplay();
-  EGLContext egl_context = eglGetCurrentContext();
-  EGLenum egl_target = EGL_GL_TEXTURE_2D_KHR;
-  EGLClientBuffer egl_buffer = (EGLClientBuffer) temp_texture;
-  EGLint egl_attrib_list[] = {
-      EGL_GL_TEXTURE_LEVEL_KHR, tex_params.level, // mip-map level.
-      EGL_IMAGE_PRESERVED_KHR, EGL_TRUE,          // preserve the data.
-      EGL_NONE
-  };
-  state->egl_image_ = eglCreateImageKHR(
-      egl_display,
-      egl_context,
-      egl_target,
-      egl_buffer,
-      egl_attrib_list);
-  WaitForGlFence();
+  state->CreateEglImageOnUploadThread();
 
-  // We can delete this thread's texture as the real texture
-  // now contains the data.
-  glDeleteTextures(1, &temp_texture);
+  {
+    TRACE_EVENT0("gpu", "glTexSubImage2D with data");
+
+    // If we didn't use image_preserved, we haven't uploaded
+    // the data yet, so we do this with a full texSubImage.
+    if (!state->use_image_preserved_)
+      DoFullTexSubImage2D(tex_params, data);
+  }
+
+  state->WaitForLastUpload();
+  DCHECK(CHECK_GL());
 }
 
 void AsyncPixelTransferDelegateAndroid::PerformAsyncTexSubImage2D(
     TransferStateInternal* state,
     AsyncTexSubImage2DParams tex_params,
-    AsyncMemoryParams mem_params) {
-  // TODO(epenner): This is just to insure it is deleted. Could bind() do this?
-  scoped_ptr<SharedMemory> shared_memory =
-      make_scoped_ptr(mem_params.shared_memory);
+    AsyncMemoryParams mem_params,
+    ScopedSafeSharedMemory* safe_shared_memory) {
+  TRACE_EVENT2("gpu", "PerformAsyncTexSubImage2D",
+               "width", tex_params.width,
+               "height", tex_params.height);
 
-  void* data = GetAddress(mem_params.shared_memory,
-                          mem_params.shm_size,
-                          mem_params.shm_data_offset,
-                          mem_params.shm_data_size);
-
-  // For a texSubImage, the texture must already have been
-  // created on the main thread, along with EGLImageKHR.
+  DCHECK(state);
   DCHECK_NE(EGL_NO_IMAGE_KHR, state->egl_image_);
   DCHECK_EQ(0, tex_params.level);
-  TRACE_EVENT2("gpu", "performAsyncTexSubImage2D",
-               "width", tex_params.width,
-               "height", tex_params.height);
 
-  // Create a texture from the image and upload to it.
-  GLuint temp_texture = 0;
-  glGenTextures(1, &temp_texture);
-  glActiveTexture(GL_TEXTURE0);
-  glBindTexture(GL_TEXTURE_2D, temp_texture);
-  glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, state->egl_image_);
+  void* data = GetAddress(safe_shared_memory->shared_memory(),
+                          mem_params.shm_data_offset);
+
+  base::TimeTicks begin_time(base::TimeTicks::HighResNow());
+  if (!state->thread_texture_id_) {
+    TRACE_EVENT0("gpu", "glEGLImageTargetTexture2DOES");
+    glGenTextures(1, &state->thread_texture_id_);
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, state->thread_texture_id_);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, state->egl_image_);
+  } else {
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, state->thread_texture_id_);
+  }
   {
-    TRACE_EVENT0("gpu", "performAsyncTexSubImage2D glTexSubImage2D");
-    glTexSubImage2D(
-        GL_TEXTURE_2D,
-        tex_params.level,
-        tex_params.xoffset,
-        tex_params.yoffset,
-        tex_params.width,
-        tex_params.height,
-        tex_params.format,
-        tex_params.type,
-        data);
+    TRACE_EVENT0("gpu", "glTexSubImage2D");
+    DoTexSubImage2D(tex_params, data);
   }
-  WaitForGlFence();
+  state->WaitForLastUpload();
 
-  // We can delete this thread's texture as the real texture
-  // now contains the data.
-  glDeleteTextures(1, &temp_texture);
+  DCHECK(CHECK_GL());
+  state->last_transfer_time_ = base::TimeTicks::HighResNow() - begin_time;
 }
 
+namespace {
+bool IsPowerOfTwo (unsigned int x) {
+  return ((x != 0) && !(x & (x - 1)));
+}
+
+bool IsMultipleOfEight(unsigned int x) {
+  return (x & 7) == 0;
+}
+
+bool DimensionsSupportImgFastPath(int width, int height) {
+  // Multiple of eight, but not a power of two.
+  return IsMultipleOfEight(width) &&
+         IsMultipleOfEight(height) &&
+         !(IsPowerOfTwo(width) &&
+           IsPowerOfTwo(height));
+}
+} // namespace
+
+// It is very difficult to stream uploads on Imagination GPUs:
+// - glTexImage2D defers a swizzle/stall until draw-time
+// - glTexSubImage2D will sleep for 16ms on a good day, and 100ms
+//   or longer if OpenGL is in heavy use by another thread.
+// The one combination that avoids these problems requires:
+// a.) Allocations/Uploads must occur on different threads/contexts.
+// b.) Texture size must be non-power-of-two.
+// When using a+b, uploads will be incorrect/corrupt unless:
+// c.) Texture size must be a multiple-of-eight.
+//
+// To achieve a.) we allocate synchronously on the main thread followed
+// by uploading on the upload thread. When b/c are not true we fall back
+// on purely synchronous allocation/upload on the main thread.
+
+bool AsyncPixelTransferDelegateAndroid::WorkAroundAsyncTexImage2D(
+    TransferStateInternal* state,
+    const AsyncTexImage2DParams& tex_params,
+    const AsyncMemoryParams& mem_params) {
+  if (!is_imagination_)
+    return false;
+
+  // On imagination we allocate synchronously all the time, even
+  // if the dimensions support fast uploads. This is for part a.)
+  // above, so allocations occur on a different thread/context as uploads.
+  void* data = GetAddress(mem_params.shared_memory,
+                          mem_params.shm_data_offset);
+  SetGlParametersForEglImageTexture();
+
+  {
+    TRACE_EVENT0("gpu", "glTexImage2D with data");
+    DoTexImage2D(tex_params, data);
+  }
+
+  // The allocation has already occured, so mark it as finished
+  // and ready for binding.
+  state->needs_late_bind_ = false;
+  state->transfer_in_progress_ = false;
+  state->late_bind_define_params_ = tex_params;
+
+  // If the dimensions support fast async uploads, create the
+  // EGLImage for future uploads. The late bind should not
+  // be needed since the EGLImage was created from the main thread
+  // texture, but this is required to prevent an imagination driver crash.
+  if (DimensionsSupportImgFastPath(tex_params.width, tex_params.height)) {
+    state->CreateEglImageOnMainThreadIfNeeded();
+    state->needs_late_bind_ = true;
+  }
+
+  DCHECK(CHECK_GL());
+  return true;
+}
+
+bool AsyncPixelTransferDelegateAndroid::WorkAroundAsyncTexSubImage2D(
+    TransferStateInternal* state,
+    const AsyncTexSubImage2DParams& tex_params,
+    const AsyncMemoryParams& mem_params) {
+  if (!is_imagination_)
+    return false;
+
+  // If the dimensions support fast async uploads, we can use the
+  // normal async upload path for uploads.
+  if (DimensionsSupportImgFastPath(tex_params.width, tex_params.height))
+    return false;
+
+  // Fall back on a synchronous stub as we don't have a known fast path.
+  // Also, older ICS drivers crash when we do any glTexSubImage2D on the
+  // same thread. To work around this we do glTexImage2D instead. Since
+  // we didn't create an EGLImage for this texture (see above), this is
+  // okay, but it limits this API to full updates for now.
+  DCHECK(!state->egl_image_);
+  DCHECK_EQ(tex_params.xoffset, 0);
+  DCHECK_EQ(tex_params.yoffset, 0);
+  DCHECK_EQ(state->late_bind_define_params_.width, tex_params.width);
+  DCHECK_EQ(state->late_bind_define_params_.height, tex_params.height);
+  DCHECK_EQ(state->late_bind_define_params_.level, tex_params.level);
+  DCHECK_EQ(state->late_bind_define_params_.format, tex_params.format);
+  DCHECK_EQ(state->late_bind_define_params_.type, tex_params.type);
+
+  void* data = GetAddress(mem_params.shared_memory,
+                          mem_params.shm_data_offset);
+  base::TimeTicks begin_time(base::TimeTicks::HighResNow());
+  {
+    TRACE_EVENT0("gpu", "glTexSubImage2D");
+    // Note we use late_bind_define_params_ instead of tex_params.
+    // The DCHECKs above verify this is always the same.
+    DoTexImage2D(state->late_bind_define_params_, data);
+  }
+  texture_upload_count_++;
+  total_texture_upload_time_ += base::TimeTicks::HighResNow() - begin_time;
+
+  DCHECK(CHECK_GL());
+  return true;
+}
+
 }  // namespace gfx
Index: src/ui/gl/async_pixel_transfer_delegate_stub.h
===================================================================
--- src/ui/gl/async_pixel_transfer_delegate_stub.h	(revision 184497)
+++ src/ui/gl/async_pixel_transfer_delegate_stub.h	(working copy)
@@ -36,7 +36,9 @@
   virtual ~AsyncPixelTransferDelegateStub();
 
   // implement AsyncPixelTransferDelegate:
-  virtual void AsyncNotifyCompletion(const base::Closure& task) OVERRIDE;
+  virtual void AsyncNotifyCompletion(
+      const AsyncMemoryParams& mem_params,
+      const CompletionCallback& callback) OVERRIDE;
   virtual void AsyncTexImage2D(
       AsyncPixelTransferState* transfer_state,
       const AsyncTexImage2DParams& tex_params,
@@ -45,11 +47,16 @@
       AsyncPixelTransferState* transfer_state,
       const AsyncTexSubImage2DParams& tex_params,
       const AsyncMemoryParams& mem_params) OVERRIDE;
+  virtual uint32 GetTextureUploadCount() OVERRIDE;
+  virtual base::TimeDelta GetTotalTextureUploadTime() OVERRIDE;
  private:
   // implement AsyncPixelTransferDelegate:
   virtual AsyncPixelTransferState*
       CreateRawPixelTransferState(GLuint texture_id) OVERRIDE;
 
+  int texture_upload_count_;
+  base::TimeDelta total_texture_upload_time_;
+
   DISALLOW_COPY_AND_ASSIGN(AsyncPixelTransferDelegateStub);
 };
 
Index: src/ui/gl/gl.gyp
===================================================================
--- src/ui/gl/gl.gyp	(revision 184497)
+++ src/ui/gl/gl.gyp	(working copy)
@@ -97,6 +97,8 @@
         'gl_switches.h',
         'gpu_switching_manager.cc',
         'gpu_switching_manager.h',
+        'safe_shared_memory_pool.h',
+        'safe_shared_memory_pool.cc',
         'scoped_make_current.cc',
         'scoped_make_current.h',
         'gl_state_restorer.cc',
Index: src/ui/gl/gl_context_egl.cc
===================================================================
--- src/ui/gl/gl_context_egl.cc	(revision 184497)
+++ src/ui/gl/gl_context_egl.cc	(working copy)
@@ -185,4 +185,12 @@
   Destroy();
 }
 
+#if !defined(OS_ANDROID)
+bool GLContextEGL::GetTotalGpuMemory(size_t* bytes) {
+  DCHECK(bytes);
+  *bytes = 0;
+  return false;
+}
+#endif
+
 }  // namespace gfx
Index: src/ui/gl/gl_context_android.cc
===================================================================
--- src/ui/gl/gl_context_android.cc	(revision 184497)
+++ src/ui/gl/gl_context_android.cc	(working copy)
@@ -6,6 +6,7 @@
 
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
+#include "base/sys_info.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_context_egl.h"
 #include "ui/gl/gl_context_stub.h"
@@ -32,4 +33,40 @@
   return context;
 }
 
+bool GLContextEGL::GetTotalGpuMemory(size_t* bytes) {
+  DCHECK(bytes);
+  *bytes = 0;
+  // We can't query available GPU memory from the system on Android,
+  // but the dalvik heap size give us a good estimate of available
+  // GPU memory on a wide range of devices.
+  //
+  // The heap size tends to be about 1/4 of total ram on higher end
+  // devices, so we use 1/2 of that by default. For example both the
+  // Nexus 4/10 have 2GB of ram and 512MB Dalvik heap size. For lower
+  // end devices, 1/2 of the heap size can be too high, but this
+  // correlates well with having a small heap-growth-limit. So for
+  // devices with less ram, we factor in the growth limit.
+  //
+  // This is the result of the calculation below:
+  // Droid DNA 1080P  128MB
+  // Nexus S           56MB
+  // Galaxy Nexus     112MB
+  // Nexus 4/10       256MB
+  // Xoom              88MB
+  size_t dalvik_limit = 0;
+  if (!dalvik_limit) {
+    size_t heap_size   = static_cast<size_t>(base::SysInfo::DalvikHeapSizeMB());
+    size_t heap_growth = static_cast<size_t>(
+                             base::SysInfo::DalvikHeapGrowthLimitMB());
+    size_t limit = 0;
+    if (heap_size >= 350)
+        limit = heap_size / 2;
+    else
+        limit = (heap_size + (heap_growth * 2)) / 4;
+    dalvik_limit = limit * 1024 * 1024;
+  }
+  *bytes = dalvik_limit;
+  return true;
 }
+
+}
Index: src/ui/gl/async_pixel_transfer_delegate.h
===================================================================
--- src/ui/gl/async_pixel_transfer_delegate.h	(revision 184497)
+++ src/ui/gl/async_pixel_transfer_delegate.h	(working copy)
@@ -9,6 +9,7 @@
 #include "base/bind.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/memory/weak_ptr.h"
+#include "base/time.h"
 #include "build/build_config.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_export.h"
@@ -77,6 +78,8 @@
 
 class GL_EXPORT AsyncPixelTransferDelegate {
  public:
+  typedef base::Callback<void(const AsyncMemoryParams&)> CompletionCallback;
+
   static scoped_ptr<AsyncPixelTransferDelegate>
       Create(gfx::GLContext* context);
   virtual ~AsyncPixelTransferDelegate() {}
@@ -88,8 +91,10 @@
     return make_scoped_ptr(CreateRawPixelTransferState(texture_id));
   }
 
+  // There's no guarantee that callback will run on the caller thread.
   virtual void AsyncNotifyCompletion(
-      const base::Closure& notify_task) = 0;
+      const AsyncMemoryParams& mem_params,
+      const CompletionCallback& callback) = 0;
 
   virtual void AsyncTexImage2D(
       AsyncPixelTransferState* state,
@@ -101,6 +106,9 @@
       const AsyncTexSubImage2DParams& tex_params,
       const AsyncMemoryParams& mem_params) = 0;
 
+  virtual uint32 GetTextureUploadCount() = 0;
+  virtual base::TimeDelta GetTotalTextureUploadTime() = 0;
+
  protected:
   AsyncPixelTransferDelegate() {}
   // For testing, as returning scoped_ptr wouldn't work with MOCK_METHOD.
Index: src/ui/gl/gl_context_egl.h
===================================================================
--- src/ui/gl/gl_context_egl.h	(revision 184497)
+++ src/ui/gl/gl_context_egl.h	(working copy)
@@ -34,6 +34,7 @@
   virtual void SetSwapInterval(int interval) OVERRIDE;
   virtual std::string GetExtensions() OVERRIDE;
   virtual bool WasAllocatedUsingRobustnessExtension() OVERRIDE;
+  virtual bool GetTotalGpuMemory(size_t* bytes) OVERRIDE;
 
  protected:
   virtual ~GLContextEGL();
Index: src/ui/base/gestures/gesture_sequence.cc
===================================================================
--- src/ui/base/gestures/gesture_sequence.cc	(revision 184497)
+++ src/ui/base/gestures/gesture_sequence.cc	(working copy)
@@ -537,7 +537,9 @@
 void GestureSequence::RecreateBoundingBox() {
   // TODO(sad): Recreating the bounding box at every touch-event is not very
   // efficient. This should be made better.
-  if (point_count_ == 1) {
+  if (point_count_ == 0) {
+    bounding_box_.SetRect(0, 0, 0, 0);
+  } else if (point_count_ == 1) {
     bounding_box_ = GetPointByPointId(0)->enclosing_rectangle();
   } else {
     int left = INT_MAX / 20, top = INT_MAX / 20;
Index: src/ui/ui.gyp
===================================================================
--- src/ui/ui.gyp	(revision 184497)
+++ src/ui/ui.gyp	(working copy)
@@ -342,6 +342,8 @@
         'base/x/x11_util.cc',
         'base/x/x11_util.h',
         'base/x/x11_util_internal.h',
+        'gfx/android/device_display_info.cc',
+        'gfx/android/device_display_info.h',
         'gfx/android/gfx_jni_registrar.cc',
         'gfx/android/gfx_jni_registrar.h',
         'gfx/android/java_bitmap.cc',
@@ -496,6 +498,7 @@
         'gfx/size.cc',
         'gfx/size.h',
         'gfx/size_base.h',
+        'gfx/size_base_impl.h',
         'gfx/size_conversions.cc',
         'gfx/size_conversions.h',
         'gfx/size_f.cc',
@@ -873,6 +876,7 @@
            'type': 'none',
            'sources': [
              'android/java/src/org/chromium/ui/gfx/BitmapHelper.java',
+             'android/java/src/org/chromium/ui/gfx/DeviceDisplayInfo.java',
              'android/java/src/org/chromium/ui/gfx/NativeWindow.java',
              'android/java/src/org/chromium/ui/SelectFileDialog.java',
            ],
Index: src/media/tools/player_x11/x11_video_renderer.h
===================================================================
--- src/media/tools/player_x11/x11_video_renderer.h	(revision 184497)
+++ src/media/tools/player_x11/x11_video_renderer.h	(working copy)
@@ -24,11 +24,10 @@
 
   void Paint(media::VideoFrame* video_frame);
 
- protected:
+ private:
   friend class base::RefCountedThreadSafe<X11VideoRenderer>;
   ~X11VideoRenderer();
 
- private:
   // Initializes X11 rendering for the given dimensions.
   void Initialize(gfx::Size coded_size, gfx::Rect visible_rect);
 
Index: src/media/tools/player_x11/gl_video_renderer.h
===================================================================
--- src/media/tools/player_x11/gl_video_renderer.h	(revision 184497)
+++ src/media/tools/player_x11/gl_video_renderer.h	(working copy)
@@ -23,11 +23,10 @@
 
   void Paint(media::VideoFrame* video_frame);
 
- protected:
+ private:
   friend class base::RefCountedThreadSafe<GlVideoRenderer>;
   ~GlVideoRenderer();
 
- private:
   // Initializes GL rendering for the given dimensions.
   void Initialize(gfx::Size coded_size, gfx::Rect visible_rect);
 
Index: src/webkit/glue/webpreferences.cc
===================================================================
--- src/webkit/glue/webpreferences.cc	(revision 184497)
+++ src/webkit/glue/webpreferences.cc	(working copy)
@@ -130,6 +130,8 @@
       editing_behavior(EDITING_BEHAVIOR_MAC),
 #elif defined(OS_WIN)
       editing_behavior(EDITING_BEHAVIOR_WIN),
+#elif defined(OS_ANDROID)
+      editing_behavior(EDITING_BEHAVIOR_ANDROID),
 #elif defined(OS_POSIX)
       editing_behavior(EDITING_BEHAVIOR_UNIX),
 #else
@@ -495,5 +497,8 @@
     WebPreferences::EDITING_BEHAVIOR_WIN, WebSettings::EditingBehaviorWin);
 COMPILE_ASSERT_MATCHING_ENUMS(
     WebPreferences::EDITING_BEHAVIOR_UNIX, WebSettings::EditingBehaviorUnix);
+COMPILE_ASSERT_MATCHING_ENUMS(
+    WebPreferences::EDITING_BEHAVIOR_ANDROID,
+    WebSettings::EditingBehaviorAndroid);
 
 }  // namespace webkit_glue
Index: src/webkit/glue/webpreferences.h
===================================================================
--- src/webkit/glue/webpreferences.h	(revision 184497)
+++ src/webkit/glue/webpreferences.h	(working copy)
@@ -33,7 +33,8 @@
   enum EditingBehavior {
     EDITING_BEHAVIOR_MAC,
     EDITING_BEHAVIOR_WIN,
-    EDITING_BEHAVIOR_UNIX
+    EDITING_BEHAVIOR_UNIX,
+    EDITING_BEHAVIOR_ANDROID
   };
 
   // The ISO 15924 script code for undetermined script aka Common. It's the
Index: src/webkit/glue/fling_animator_impl_android.cc
===================================================================
--- src/webkit/glue/fling_animator_impl_android.cc	(revision 184497)
+++ src/webkit/glue/fling_animator_impl_android.cc	(working copy)
@@ -9,6 +9,7 @@
 #include "base/logging.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGestureCurveTarget.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebPoint.h"
+#include "ui/gfx/screen.h"
 #include "ui/gfx/vector2d.h"
 
 using base::android::AttachCurrentThread;
@@ -108,7 +109,9 @@
   gfx::Point current_position = GetCurrentPosition();
   gfx::Vector2d diff(current_position - last_position_);
   last_position_ = current_position;
-  WebKit::WebPoint scroll_amount(diff.x(), diff.y());
+  float dpi_scale = gfx::Screen::GetNativeScreen()->GetPrimaryDisplay()
+      .device_scale_factor();
+  WebKit::WebPoint scroll_amount(diff.x() / dpi_scale, diff.y() / dpi_scale);
   // scrollBy() could delete this curve if the animation is over, so don't touch
   // any member variables after making that call.
   target->scrollBy(scroll_amount);
Index: src/webkit/glue/glue_serialize.cc
===================================================================
--- src/webkit/glue/glue_serialize.cc	(revision 184497)
+++ src/webkit/glue/glue_serialize.cc	(working copy)
@@ -17,6 +17,7 @@
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebString.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebURL.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebVector.h"
+#include "ui/gfx/screen.h"
 #include "webkit/base/file_path_string_conversions.h"
 
 using WebKit::WebData;
@@ -456,11 +457,23 @@
   }
 
 #if defined(OS_ANDROID)
-  // Now-unused values that shipped in this version of Chrome for Android when
-  // it was on a private branch.
   if (obj->version == 11) {
+    // Now-unused values that shipped in this version of Chrome for Android when
+    // it was on a private branch.
     ReadReal(obj);
     ReadBoolean(obj);
+
+    // In this version, pageScaleFactor included deviceScaleFactor and scroll
+    // offsets were premultiplied by pageScaleFactor.
+    if (item.pageScaleFactor()) {
+      if (include_scroll_offset)
+        item.setScrollOffset(
+            WebPoint(item.scrollOffset().x / item.pageScaleFactor(),
+                     item.scrollOffset().y / item.pageScaleFactor()));
+      item.setPageScaleFactor(item.pageScaleFactor() /
+          gfx::Screen::GetNativeScreen()->GetPrimaryDisplay()
+              .device_scale_factor());
+    }
   }
 #endif
 
Index: src/webkit/glue/webkit_glue.gypi
===================================================================
--- src/webkit/glue/webkit_glue.gypi	(revision 184497)
+++ src/webkit/glue/webkit_glue.gypi	(working copy)
@@ -320,6 +320,8 @@
         'simple_webmimeregistry_impl.h',
         'touch_fling_platform_gesture_curve.cc',
         'touch_fling_platform_gesture_curve.h',
+        'web_discardable_memory_impl.cc',
+        'web_discardable_memory_impl.h',
         'webclipboard_impl.cc',
         'webclipboard_impl.h',
         'webcookie.cc',
Index: src/webkit/glue/webkitplatformsupport_impl.h
===================================================================
--- src/webkit/glue/webkitplatformsupport_impl.h	(revision 184497)
+++ src/webkit/glue/webkitplatformsupport_impl.h	(working copy)
@@ -132,6 +132,8 @@
   virtual WebKit::WebThread* createThread(const char* name);
   virtual WebKit::WebThread* currentThread();
   virtual WebKit::WebCompositorSupport* compositorSupport();
+  virtual WebKit::WebDiscardableMemory* allocateAndLockDiscardableMemory(
+      size_t bytes);
 
 
   // Embedder functions. The following are not implemented by the glue layer and
Index: src/webkit/glue/webkitplatformsupport_impl.cc
===================================================================
--- src/webkit/glue/webkitplatformsupport_impl.cc	(revision 184497)
+++ src/webkit/glue/webkitplatformsupport_impl.cc	(working copy)
@@ -15,6 +15,7 @@
 #include "base/allocator/allocator_extension.h"
 #include "base/bind.h"
 #include "base/debug/trace_event.h"
+#include "base/memory/discardable_memory.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/memory/singleton.h"
 #include "base/message_loop.h"
@@ -32,6 +33,7 @@
 #include "grit/webkit_chromium_resources.h"
 #include "grit/webkit_resources.h"
 #include "grit/webkit_strings.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebDiscardableMemory.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGestureCurve.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebFrameClient.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebInputEvent.h"
@@ -45,6 +47,7 @@
 #include "ui/base/layout.h"
 #include "webkit/base/file_path_string_conversions.h"
 #include "webkit/compositor_bindings/web_compositor_support_impl.h"
+#include "webkit/glue/web_discardable_memory_impl.h"
 #include "webkit/glue/touch_fling_platform_gesture_curve.h"
 #include "webkit/glue/websocketstreamhandle_impl.h"
 #include "webkit/glue/webthread_impl.h"
@@ -900,4 +903,15 @@
   return TouchFlingGestureCurve::CreateForTouchPad(velocity, cumulative_scroll);
 }
 
+WebKit::WebDiscardableMemory*
+    WebKitPlatformSupportImpl::allocateAndLockDiscardableMemory(size_t bytes) {
+  if (!base::DiscardableMemory::Supported())
+    return NULL;
+  scoped_ptr<WebDiscardableMemoryImpl> discardable(
+      new WebDiscardableMemoryImpl());
+  if (discardable->InitializeAndLock(bytes))
+    return discardable.release();
+  return NULL;
+}
+
 }  // namespace webkit_glue
Index: src/webkit/compositor_bindings/web_layer_tree_view_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_layer_tree_view_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_layer_tree_view_impl.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "web_layer_tree_view_impl.h"
 
 #include "base/command_line.h"
+#include "base/string_number_conversions.h"
 #include "cc/font_atlas.h"
 #include "cc/input_handler.h"
 #include "cc/layer.h"
@@ -41,6 +42,7 @@
     settings.acceleratePainting = webSettings.acceleratePainting;
     settings.renderVSyncEnabled = webSettings.renderVSyncEnabled;
     settings.perTilePaintingEnabled = webSettings.perTilePaintingEnabled;
+    settings.rightAlignedSchedulingEnabled = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kEnableRightAlignedScheduling);
     settings.acceleratedAnimationEnabled = webSettings.acceleratedAnimationEnabled;
     settings.pageScalePinchZoomEnabled = webSettings.pageScalePinchZoomEnabled;
     settings.refreshRate = webSettings.refreshRate;
@@ -50,6 +52,21 @@
     settings.initialDebugState.showPaintRects = webSettings.showPaintRects;
     settings.initialDebugState.showPlatformLayerTree = webSettings.showPlatformLayerTree;
     settings.initialDebugState.showDebugBorders = webSettings.showDebugBorders;
+    settings.implSidePainting = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kEnableImplSidePainting);
+
+    settings.calculateTopControlsPosition = CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableTopControlsPositionCalculation);
+    if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kTopControlsHeight)) {
+        std::string controls_height_str =
+            CommandLine::ForCurrentProcess()->GetSwitchValueASCII(switches::kTopControlsHeight);
+        int controls_height;
+        if (base::StringToInt(controls_height_str, &controls_height) && controls_height > 0)
+            settings.topControlsHeightPx = controls_height;
+    }
+    if (settings.calculateTopControlsPosition && (settings.topControlsHeightPx <= 0 || !settings.compositorFrameMessage)) {
+        DCHECK(false) << "Top controls repositioning enabled without valid height or compositorFrameMessage set.";
+        settings.calculateTopControlsPosition = false;
+    }
+
     m_layerTreeHost = LayerTreeHost::create(this, settings, implThread.Pass());
     if (!m_layerTreeHost.get())
         return false;
@@ -91,7 +108,7 @@
 
 WebFloatPoint WebLayerTreeViewImpl::adjustEventPointForPinchZoom(const WebFloatPoint& point) const
 {
-    return m_layerTreeHost->adjustEventPointForPinchZoom(point);
+    return point;
 }
 
 void WebLayerTreeViewImpl::setDeviceScaleFactor(const float deviceScaleFactor)
@@ -211,11 +228,6 @@
     return FontAtlas::create(bitmap, asciiToRectTable, fontHeight).Pass();
 }
 
-void WebLayerTreeViewImpl::loseCompositorContext(int numTimes)
-{
-    m_layerTreeHost->loseOutputSurface(numTimes);
-}
-
 void WebLayerTreeViewImpl::willBeginFrame()
 {
     m_client->willBeginFrame();
Index: src/webkit/compositor_bindings/web_layer_tree_view_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_layer_tree_view_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_layer_tree_view_impl.h	(working copy)
@@ -8,6 +8,7 @@
 #include "base/memory/scoped_ptr.h"
 #include "cc/layer_tree_host_client.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeView.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace cc {
 class FontAtlas;
@@ -22,10 +23,12 @@
 
 class WebLayerTreeViewImpl : public WebLayerTreeView, public cc::LayerTreeHostClient {
 public:
-    explicit WebLayerTreeViewImpl(WebLayerTreeViewClient*);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebLayerTreeViewImpl(
+        WebLayerTreeViewClient*);
     virtual ~WebLayerTreeViewImpl();
 
-    bool initialize(const Settings&, scoped_ptr<cc::Thread> implThread);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT bool initialize(
+        const Settings&, scoped_ptr<cc::Thread> implThread);
 
     // WebLayerTreeView implementation.
     virtual void setSurfaceReady() OVERRIDE;
@@ -34,7 +37,7 @@
     virtual void setViewportSize(const WebSize& layoutViewportSize, const WebSize& deviceViewportSize = WebSize()) OVERRIDE;
     virtual WebSize layoutViewportSize() const OVERRIDE;
     virtual WebSize deviceViewportSize() const OVERRIDE;
-    virtual WebFloatPoint adjustEventPointForPinchZoom(const WebFloatPoint& point) const OVERRIDE;
+    virtual WebFloatPoint adjustEventPointForPinchZoom(const WebFloatPoint& point) const; // FIXME: remove this after WebKit roll.
     virtual void setDeviceScaleFactor(float) OVERRIDE;
     virtual float deviceScaleFactor() const OVERRIDE;
     virtual void setBackgroundColor(WebColor) OVERRIDE;
@@ -54,7 +57,6 @@
     virtual void renderingStats(WebRenderingStats&) const OVERRIDE;
     virtual void setShowFPSCounter(bool show);
     virtual void setShowPaintRects(bool show);
-    virtual void loseCompositorContext(int numTimes) OVERRIDE;
 
     // cc::LayerTreeHostClient implementation.
     virtual void willBeginFrame() OVERRIDE;
Index: src/webkit/compositor_bindings/compositor_bindings_tests.gyp
===================================================================
--- src/webkit/compositor_bindings/compositor_bindings_tests.gyp	(revision 184497)
+++ src/webkit/compositor_bindings/compositor_bindings_tests.gyp	(working copy)
@@ -8,12 +8,11 @@
     'webkit_compositor_bindings_tests_sources': [
       'web_animation_unittest.cc',
       'web_float_animation_curve_unittest.cc',
+      'web_layer_impl_fixed_bounds_unittest.cc',
       'web_layer_unittest.cc',
       'web_layer_tree_view_unittest.cc',
       'web_transform_animation_curve_unittest.cc',
-      'web_transform_operations_unittest.cc',
       'web_transformation_matrix_unittest.cc',
-      'test/fake_web_scrollbar_theme_geometry.h',
       'test/web_layer_tree_view_test_common.h',
     ],
   },
@@ -35,12 +34,7 @@
         'test/run_all_unittests.cc',
       ],
       'include_dirs': [
-        '.',
-        'test',
-        '<(DEPTH)/cc',
-        '<(DEPTH)/cc/stubs',
-        '<(DEPTH)/cc/test',
-        '../../third_party/WebKit/Source/Platform/chromium'
+        '../..'
       ],
       'conditions': [
         ['OS == "android" and gtest_target_type == "shared_library"', {
Index: src/webkit/compositor_bindings/web_layer_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_layer_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_layer_unittest.cc	(working copy)
@@ -2,27 +2,27 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include <public/WebLayer.h>
-
 #include "cc/thread.h"
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
-#include "web_layer_impl.h"
-#include "web_layer_tree_view_impl.h"
-#include "web_layer_tree_view_test_common.h"
-#include <public/WebContentLayer.h>
-#include <public/WebContentLayerClient.h>
-#include <public/WebExternalTextureLayer.h>
-#include <public/WebFloatPoint.h>
-#include <public/WebFloatRect.h>
-#include <public/WebLayerScrollClient.h>
-#include <public/WebLayerTreeView.h>
-#include <public/WebLayerTreeViewClient.h>
-#include <public/WebRect.h>
-#include <public/WebSize.h>
-#include <public/WebSolidColorLayer.h>
+#include "testing/gmock/include/gmock/gmock.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebContentLayer.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebContentLayerClient.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebExternalTextureLayer.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFloatPoint.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFloatRect.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayer.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayerScrollClient.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeView.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeViewClient.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebRect.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSolidColorLayer.h"
+#include "webkit/compositor_bindings/test/web_layer_tree_view_test_common.h"
+#include "webkit/compositor_bindings/web_content_layer_impl.h"
+#include "webkit/compositor_bindings/web_external_texture_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_tree_view_impl.h"
+#include "webkit/compositor_bindings/web_solid_color_layer_impl.h"
 
-#include <gmock/gmock.h>
-
 using namespace WebKit;
 using testing::AnyNumber;
 using testing::AtLeast;
@@ -45,7 +45,7 @@
 
     virtual void SetUp()
     {
-        m_rootLayer.reset(WebLayer::create());
+        m_rootLayer.reset(new WebLayerImpl);
         EXPECT_CALL(m_client, scheduleComposite()).Times(AnyNumber());
         m_view.reset(new WebLayerTreeViewImpl(&m_client));
         EXPECT_TRUE(m_view->initialize(WebLayerTreeView::Settings(), scoped_ptr<cc::Thread>(NULL)));
@@ -74,7 +74,7 @@
 {
     // Base layer.
     EXPECT_CALL(m_client, scheduleComposite()).Times(AnyNumber());
-    scoped_ptr<WebLayer> layer(WebLayer::create());
+    scoped_ptr<WebLayer> layer(new WebLayerImpl);
     layer->setDrawsContent(true);
     m_rootLayer->addChild(layer.get());
     Mock::VerifyAndClearExpectations(&m_client);
@@ -103,7 +103,7 @@
     EXPECT_TRUE(layer->masksToBounds());
 
     EXPECT_CALL(m_client, scheduleComposite()).Times(AnyNumber());
-    scoped_ptr<WebLayer> otherLayer(WebLayer::create());
+    scoped_ptr<WebLayer> otherLayer(new WebLayerImpl);
     m_rootLayer->addChild(otherLayer.get());
     EXPECT_CALL(m_client, scheduleComposite()).Times(AtLeast(1));
     layer->setMaskLayer(otherLayer.get());
@@ -127,7 +127,7 @@
 
     // Texture layer.
     EXPECT_CALL(m_client, scheduleComposite()).Times(AtLeast(1));
-    scoped_ptr<WebExternalTextureLayer> textureLayer(WebExternalTextureLayer::create());
+    scoped_ptr<WebExternalTextureLayer> textureLayer(new WebExternalTextureLayerImpl(NULL));
     m_rootLayer->addChild(textureLayer->layer());
     Mock::VerifyAndClearExpectations(&m_client);
 
@@ -150,7 +150,7 @@
     EXPECT_CALL(contentClient, paintContents(_, _, _, _)).Times(AnyNumber());
                                              
     EXPECT_CALL(m_client, scheduleComposite()).Times(AnyNumber());
-    scoped_ptr<WebContentLayer> contentLayer(WebContentLayer::create(&contentClient));
+    scoped_ptr<WebContentLayer> contentLayer(new WebContentLayerImpl(&contentClient));
     m_rootLayer->addChild(contentLayer->layer());
     Mock::VerifyAndClearExpectations(&m_client);
 
@@ -161,7 +161,7 @@
 
     // Solid color layer.
     EXPECT_CALL(m_client, scheduleComposite()).Times(AtLeast(1));
-    scoped_ptr<WebSolidColorLayer> solidColorLayer(WebSolidColorLayer::create());
+    scoped_ptr<WebSolidColorLayer> solidColorLayer(new WebSolidColorLayerImpl);
     m_rootLayer->addChild(solidColorLayer->layer());
     Mock::VerifyAndClearExpectations(&m_client);
 
Index: src/webkit/compositor_bindings/web_compositor_support_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_compositor_support_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_compositor_support_impl.h	(working copy)
@@ -8,6 +8,7 @@
 #include "base/memory/ref_counted.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebLayer.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebCompositorSupport.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h"
 
 namespace base {
 class MessageLoopProxy;
@@ -37,7 +38,6 @@
   virtual WebKit::WebLayer* createLayer();
   virtual WebKit::WebContentLayer* createContentLayer(
       WebKit::WebContentLayerClient* client);
-  virtual WebKit::WebDelegatedRendererLayer* createDelegatedRendererLayer();
   virtual WebKit::WebExternalTextureLayer*
     createExternalTextureLayer(WebKit::WebExternalTextureLayerClient* client);
   virtual WebKit::WebIOSurfaceLayer*
@@ -59,6 +59,8 @@
     createFloatAnimationCurve();
   virtual WebKit::WebTransformAnimationCurve*
     createTransformAnimationCurve();
+  virtual WebKit::WebTransformOperations*
+    createTransformOperations();
 
  private:
   scoped_refptr<base::MessageLoopProxy> impl_thread_message_loop_proxy_;
Index: src/webkit/compositor_bindings/web_transform_animation_curve_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_transform_animation_curve_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_transform_animation_curve_unittest.cc	(working copy)
@@ -7,19 +7,24 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h"
-#include "web_transform_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_transform_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_transform_operations_impl.h"
 
 using namespace WebKit;
 
+#if WEB_TRANSFORM_OPERATIONS_IS_VIRTUAL
+using webkit::WebTransformOperationsImpl;
+#endif
+
 namespace {
 
 // Tests that a transform animation with one keyframe works as expected.
 TEST(WebTransformAnimationCurveTest, OneTransformKeyframe)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations;
-    operations.appendTranslate(2, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations(new WebTransformOperationsImpl());
+    operations->appendTranslate(2, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     EXPECT_FLOAT_EQ(2, curve->getValue(-1).m41());
     EXPECT_FLOAT_EQ(2, curve->getValue(0).m41());
@@ -32,12 +37,12 @@
 TEST(WebTransformAnimationCurveTest, TwoTransformKeyframe)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(2, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(2, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(4, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
     EXPECT_FLOAT_EQ(2, curve->getValue(-1).m41());
     EXPECT_FLOAT_EQ(2, curve->getValue(0).m41());
     EXPECT_FLOAT_EQ(3, curve->getValue(0.5).m41());
@@ -49,15 +54,15 @@
 TEST(WebTransformAnimationCurveTest, ThreeTransformKeyframe)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(2, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations3;
-    operations3.appendTranslate(8, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(2, operations3), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(2, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(4, 0, 0);
+    scoped_ptr<WebTransformOperations> operations3(new WebTransformOperationsImpl());
+    operations3->appendTranslate(8, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(2, operations3.release()), WebAnimationCurve::TimingFunctionTypeLinear);
     EXPECT_FLOAT_EQ(2, curve->getValue(-1).m41());
     EXPECT_FLOAT_EQ(2, curve->getValue(0).m41());
     EXPECT_FLOAT_EQ(3, curve->getValue(0.5).m41());
@@ -72,18 +77,18 @@
 {
     // A step function.
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations3;
-    operations3.appendTranslate(6, 0, 0);
-    WebKit::WebTransformOperations operations4;
-    operations4.appendTranslate(6, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(1, operations3), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(2, operations4), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(4, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(4, 0, 0);
+    scoped_ptr<WebTransformOperations> operations3(new WebTransformOperationsImpl());
+    operations3->appendTranslate(6, 0, 0);
+    scoped_ptr<WebTransformOperations> operations4(new WebTransformOperationsImpl());
+    operations4->appendTranslate(6, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(1, operations3.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(2, operations4.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     EXPECT_FLOAT_EQ(4, curve->getValue(-1).m41());
     EXPECT_FLOAT_EQ(4, curve->getValue(0).m41());
@@ -102,15 +107,15 @@
 TEST(WebTransformAnimationCurveTest, UnsortedKeyframes)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(2, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations3;
-    operations3.appendTranslate(8, 0, 0);
-    curve->add(WebTransformKeyframe(2, operations3), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(2, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(4, 0, 0);
+    scoped_ptr<WebTransformOperations> operations3(new WebTransformOperationsImpl());
+    operations3->appendTranslate(8, 0, 0);
+    curve->add(WebTransformKeyframe(2, operations3.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     EXPECT_FLOAT_EQ(2, curve->getValue(-1).m41());
     EXPECT_FLOAT_EQ(2, curve->getValue(0).m41());
@@ -125,12 +130,12 @@
 TEST(WebTransformAnimationCurveTest, CubicBezierTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), 0.25, 0, 0.75, 1);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), 0.25, 0, 0.75, 1);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
     EXPECT_FLOAT_EQ(0, curve->getValue(0).m41());
     EXPECT_LT(0, curve->getValue(0.25).m41());
     EXPECT_GT(0.25, curve->getValue(0.25).m41());
@@ -144,12 +149,12 @@
 TEST(WebTransformAnimationCurveTest, EaseTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeEase);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeEase);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     scoped_ptr<cc::TimingFunction> timingFunction(cc::EaseTimingFunction::create());
     for (int i = 0; i <= 4; ++i) {
@@ -162,12 +167,12 @@
 TEST(WebTransformAnimationCurveTest, LinearTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeLinear);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeLinear);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     for (int i = 0; i <= 4; ++i) {
         const double time = i * 0.25;
@@ -179,12 +184,12 @@
 TEST(WebTransformAnimationCurveTest, EaseInTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeEaseIn);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeEaseIn);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     scoped_ptr<cc::TimingFunction> timingFunction(cc::EaseInTimingFunction::create());
     for (int i = 0; i <= 4; ++i) {
@@ -197,12 +202,12 @@
 TEST(WebTransformAnimationCurveTest, EaseOutTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeEaseOut);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeEaseOut);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     scoped_ptr<cc::TimingFunction> timingFunction(cc::EaseOutTimingFunction::create());
     for (int i = 0; i <= 4; ++i) {
@@ -215,12 +220,12 @@
 TEST(WebTransformAnimationCurveTest, EaseInOutTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), WebAnimationCurve::TimingFunctionTypeEaseInOut);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), WebAnimationCurve::TimingFunctionTypeEaseInOut);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     scoped_ptr<cc::TimingFunction> timingFunction(cc::EaseInOutTimingFunction::create());
     for (int i = 0; i <= 4; ++i) {
@@ -237,12 +242,12 @@
     double y1 = 0.2;
     double x2 = 0.8;
     double y2 = 0.7;
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1), x1, y1, x2, y2);
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()), x1, y1, x2, y2);
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     scoped_ptr<cc::TimingFunction> timingFunction(cc::CubicBezierTimingFunction::create(x1, y1, x2, y2));
     for (int i = 0; i <= 4; ++i) {
@@ -255,12 +260,12 @@
 TEST(WebTransformAnimationCurveTest, DefaultTimingFunction)
 {
     scoped_ptr<WebTransformAnimationCurve> curve(new WebTransformAnimationCurveImpl);
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(0, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(1, 0, 0);
-    curve->add(WebTransformKeyframe(0, operations1));
-    curve->add(WebTransformKeyframe(1, operations2), WebAnimationCurve::TimingFunctionTypeLinear);
+    scoped_ptr<WebTransformOperations> operations1(new WebTransformOperationsImpl());
+    operations1->appendTranslate(0, 0, 0);
+    scoped_ptr<WebTransformOperations> operations2(new WebTransformOperationsImpl());
+    operations2->appendTranslate(1, 0, 0);
+    curve->add(WebTransformKeyframe(0, operations1.release()));
+    curve->add(WebTransformKeyframe(1, operations2.release()), WebAnimationCurve::TimingFunctionTypeLinear);
 
     scoped_ptr<cc::TimingFunction> timingFunction(cc::EaseTimingFunction::create());
     for (int i = 0; i <= 4; ++i) {
Index: src/webkit/compositor_bindings/web_transform_operations_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_transform_operations_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_transform_operations_unittest.cc	(working copy)
@@ -1,610 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/memory/scoped_vector.h"
-#include "cc/test/geometry_test_utils.h"
-#include "testing/gtest/include/gtest/gtest.h"
-#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h"
-#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
-
-using namespace WebKit;
-
-TEST(WebTransformOperationTest, transformTypesAreUnique)
-{
-    ScopedVector<WebTransformOperations> transforms;
-
-    WebTransformOperations* toAdd = new WebTransformOperations();
-    toAdd->appendTranslate(1, 0, 0);
-    transforms.push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendRotate(0, 0, 1, 2);
-    transforms.push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendScale(2, 2, 2);
-    transforms.push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendSkew(1, 0);
-    transforms.push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendPerspective(800);
-    transforms.push_back(toAdd);
-
-    for (size_t i = 0; i < transforms.size(); ++i) {
-        for (size_t j = 0; j < transforms.size(); ++j) {
-            bool matchesType = transforms[i]->matchesTypes(*transforms[j]);
-            EXPECT_TRUE((i == j && matchesType) || !matchesType);
-        }
-    }
-}
-
-TEST(WebTransformOperationTest, matchTypesSameLength)
-{
-    WebTransformOperations translates;
-    translates.appendTranslate(1, 0, 0);
-    translates.appendTranslate(1, 0, 0);
-    translates.appendTranslate(1, 0, 0);
-
-    WebTransformOperations skews;
-    skews.appendSkew(0, 2);
-    skews.appendSkew(0, 2);
-    skews.appendSkew(0, 2);
-
-    WebTransformOperations translates2;
-    translates2.appendTranslate(0, 2, 0);
-    translates2.appendTranslate(0, 2, 0);
-    translates2.appendTranslate(0, 2, 0);
-
-    WebTransformOperations translates3 = translates2;
-
-    EXPECT_FALSE(translates.matchesTypes(skews));
-    EXPECT_TRUE(translates.matchesTypes(translates2));
-    EXPECT_TRUE(translates.matchesTypes(translates3));
-}
-
-TEST(WebTransformOperationTest, matchTypesDifferentLength)
-{
-    WebTransformOperations translates;
-    translates.appendTranslate(1, 0, 0);
-    translates.appendTranslate(1, 0, 0);
-    translates.appendTranslate(1, 0, 0);
-
-    WebTransformOperations skews;
-    skews.appendSkew(2, 0);
-    skews.appendSkew(2, 0);
-
-    WebTransformOperations translates2;
-    translates2.appendTranslate(0, 2, 0);
-    translates2.appendTranslate(0, 2, 0);
-
-    EXPECT_FALSE(translates.matchesTypes(skews));
-    EXPECT_FALSE(translates.matchesTypes(translates2));
-}
-
-void getIdentityOperations(ScopedVector<WebTransformOperations>* operations)
-{
-    WebTransformOperations* toAdd = new WebTransformOperations();
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendTranslate(0, 0, 0);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendTranslate(0, 0, 0);
-    toAdd->appendTranslate(0, 0, 0);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendScale(1, 1, 1);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendScale(1, 1, 1);
-    toAdd->appendScale(1, 1, 1);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendSkew(0, 0);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendSkew(0, 0);
-    toAdd->appendSkew(0, 0);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendRotate(0, 0, 1, 0);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendRotate(0, 0, 1, 0);
-    toAdd->appendRotate(0, 0, 1, 0);
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendMatrix(WebTransformationMatrix());
-    operations->push_back(toAdd);
-
-    toAdd = new WebTransformOperations();
-    toAdd->appendMatrix(WebTransformationMatrix());
-    toAdd->appendMatrix(WebTransformationMatrix());
-    operations->push_back(toAdd);
-}
-
-TEST(WebTransformOperationTest, identityAlwaysMatches)
-{
-    ScopedVector<WebTransformOperations> operations;
-    getIdentityOperations(&operations);
-
-    for (size_t i = 0; i < operations.size(); ++i) {
-        for (size_t j = 0; j < operations.size(); ++j)
-            EXPECT_TRUE(operations[i]->matchesTypes(*operations[j]));
-    }
-}
-
-TEST(WebTransformOperationTest, applyTranslate)
-{
-    double x = 1;
-    double y = 2;
-    double z = 3;
-    WebTransformOperations operations;
-    operations.appendTranslate(x, y, z);
-    WebTransformationMatrix expected;
-    expected.translate3d(x, y, z);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.apply());
-}
-
-TEST(WebTransformOperationTest, applyRotate)
-{
-    double x = 1;
-    double y = 2;
-    double z = 3;
-    double degrees = 80;
-    WebTransformOperations operations;
-    operations.appendRotate(x, y, z, degrees);
-    WebTransformationMatrix expected;
-    expected.rotate3d(x, y, z, degrees);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.apply());
-}
-
-TEST(WebTransformOperationTest, applyScale)
-{
-    double x = 1;
-    double y = 2;
-    double z = 3;
-    WebTransformOperations operations;
-    operations.appendScale(x, y, z);
-    WebTransformationMatrix expected;
-    expected.scale3d(x, y, z);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.apply());
-}
-
-TEST(WebTransformOperationTest, applySkew)
-{
-    double x = 1;
-    double y = 2;
-    WebTransformOperations operations;
-    operations.appendSkew(x, y);
-    WebTransformationMatrix expected;
-    expected.skewX(x);
-    expected.skewY(y);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.apply());
-}
-
-TEST(WebTransformOperationTest, applyPerspective)
-{
-    double depth = 800;
-    WebTransformOperations operations;
-    operations.appendPerspective(depth);
-    WebTransformationMatrix expected;
-    expected.applyPerspective(depth);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.apply());
-}
-
-TEST(WebTransformOperationTest, applyMatrix)
-{
-    double dx = 1;
-    double dy = 2;
-    double dz = 3;
-    WebTransformationMatrix expectedMatrix;
-    expectedMatrix.translate3d(dx, dy, dz);
-    WebTransformOperations matrixTransform;
-    matrixTransform.appendMatrix(expectedMatrix);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expectedMatrix, matrixTransform.apply());
-}
-
-TEST(WebTransformOperationTest, applyOrder)
-{
-    double sx = 2;
-    double sy = 4;
-    double sz = 8;
-
-    double dx = 1;
-    double dy = 2;
-    double dz = 3;
-
-    WebTransformOperations operations;
-    operations.appendScale(sx, sy, sz);
-    operations.appendTranslate(dx, dy, dz);
-
-    WebTransformationMatrix expectedScaleMatrix;
-    expectedScaleMatrix.scale3d(sx, sy, sz);
-
-    WebTransformationMatrix expectedTranslateMatrix;
-    expectedTranslateMatrix.translate3d(dx, dy, dz);
-
-    WebTransformationMatrix expectedCombinedMatrix = expectedScaleMatrix;
-    expectedCombinedMatrix.multiply(expectedTranslateMatrix);
-
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expectedCombinedMatrix, operations.apply());
-}
-
-TEST(WebTransformOperationTest, blendOrder)
-{
-    double sx1 = 2;
-    double sy1 = 4;
-    double sz1 = 8;
-
-    double dx1 = 1;
-    double dy1 = 2;
-    double dz1 = 3;
-
-    double sx2 = 4;
-    double sy2 = 8;
-    double sz2 = 16;
-
-    double dx2 = 10;
-    double dy2 = 20;
-    double dz2 = 30;
-
-    WebTransformOperations operationsFrom;
-    operationsFrom.appendScale(sx1, sy1, sz1);
-    operationsFrom.appendTranslate(dx1, dy1, dz1);
-
-    WebTransformOperations operationsTo;
-    operationsTo.appendScale(sx2, sy2, sz2);
-    operationsTo.appendTranslate(dx2, dy2, dz2);
-
-    WebTransformationMatrix scaleFrom;
-    scaleFrom.scale3d(sx1, sy1, sz1);
-    WebTransformationMatrix translateFrom;
-    translateFrom.translate3d(dx1, dy1, dz1);
-
-    WebTransformationMatrix scaleTo;
-    scaleTo.scale3d(sx2, sy2, sz2);
-    WebTransformationMatrix translateTo;
-    translateTo.translate3d(dx2, dy2, dz2);
-
-    double progress = 0.25;
-
-    WebTransformationMatrix blendedScale = scaleTo;
-    blendedScale.blend(scaleFrom, progress);
-
-    WebTransformationMatrix blendedTranslate = translateTo;
-    blendedTranslate.blend(translateFrom, progress);
-
-    WebTransformationMatrix expected = blendedScale;
-    expected.multiply(blendedTranslate);
-
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operationsTo.blend(operationsFrom, progress));
-}
-
-static void checkProgress(double progress,
-                          const WebTransformationMatrix& fromMatrix,
-                          const WebTransformationMatrix& toMatrix,
-                          const WebTransformOperations& fromTransform,
-                          const WebTransformOperations& toTransform)
-{
-    WebTransformationMatrix expectedMatrix = toMatrix;
-    expectedMatrix.blend(fromMatrix, progress);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expectedMatrix, toTransform.blend(fromTransform, progress));
-}
-
-TEST(WebTransformOperationTest, blendProgress)
-{
-    double sx = 2;
-    double sy = 4;
-    double sz = 8;
-    WebTransformOperations operationsFrom;
-    operationsFrom.appendScale(sx, sy, sz);
-
-    WebTransformationMatrix matrixFrom;
-    matrixFrom.scale3d(sx, sy, sz);
-
-    sx = 4;
-    sy = 8;
-    sz = 16;
-    WebTransformOperations operationsTo;
-    operationsTo.appendScale(sx, sy, sz);
-
-    WebTransformationMatrix matrixTo;
-    matrixTo.scale3d(sx, sy, sz);
-
-    checkProgress(-1, matrixFrom, matrixTo, operationsFrom, operationsTo);
-    checkProgress(0, matrixFrom, matrixTo, operationsFrom, operationsTo);
-    checkProgress(0.25, matrixFrom, matrixTo, operationsFrom, operationsTo);
-    checkProgress(0.5, matrixFrom, matrixTo, operationsFrom, operationsTo);
-    checkProgress(1, matrixFrom, matrixTo, operationsFrom, operationsTo);
-    checkProgress(2, matrixFrom, matrixTo, operationsFrom, operationsTo);
-}
-
-TEST(WebTransformOperationTest, blendWhenTypesDoNotMatch)
-{
-    double sx1 = 2;
-    double sy1 = 4;
-    double sz1 = 8;
-
-    double dx1 = 1;
-    double dy1 = 2;
-    double dz1 = 3;
-
-    double sx2 = 4;
-    double sy2 = 8;
-    double sz2 = 16;
-
-    double dx2 = 10;
-    double dy2 = 20;
-    double dz2 = 30;
-
-    WebTransformOperations operationsFrom;
-    operationsFrom.appendScale(sx1, sy1, sz1);
-    operationsFrom.appendTranslate(dx1, dy1, dz1);
-
-    WebTransformOperations operationsTo;
-    operationsTo.appendTranslate(dx2, dy2, dz2);
-    operationsTo.appendScale(sx2, sy2, sz2);
-
-    WebTransformationMatrix from;
-    from.scale3d(sx1, sy1, sz1);
-    from.translate3d(dx1, dy1, dz1);
-
-    WebTransformationMatrix to;
-    to.translate3d(dx2, dy2, dz2);
-    to.scale3d(sx2, sy2, sz2);
-
-    double progress = 0.25;
-
-    WebTransformationMatrix expected = to;
-    expected.blend(from, progress);
-
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operationsTo.blend(operationsFrom, progress));
-}
-
-TEST(WebTransformOperationTest, largeRotationsWithSameAxis)
-{
-    WebTransformOperations operationsFrom;
-    operationsFrom.appendRotate(0, 0, 1, 0);
-
-    WebTransformOperations operationsTo;
-    operationsTo.appendRotate(0, 0, 2, 360);
-
-    double progress = 0.5;
-
-    WebTransformationMatrix expected;
-    expected.rotate3d(0, 0, 1, 180);
-
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operationsTo.blend(operationsFrom, progress));
-}
-
-TEST(WebTransformOperationTest, largeRotationsWithSameAxisInDifferentDirection)
-{
-    WebTransformOperations operationsFrom;
-    operationsFrom.appendRotate(0, 0, 1, 180);
-
-    WebTransformOperations operationsTo;
-    operationsTo.appendRotate(0, 0, -1, 180);
-
-    double progress = 0.5;
-
-    WebTransformationMatrix expected;
-
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operationsTo.blend(operationsFrom, progress));
-}
-
-TEST(WebTransformOperationTest, largeRotationsWithDifferentAxes)
-{
-    WebTransformOperations operationsFrom;
-    operationsFrom.appendRotate(0, 0, 1, 180);
-
-    WebTransformOperations operationsTo;
-    operationsTo.appendRotate(0, 1, 0, 180);
-
-    double progress = 0.5;
-    WebTransformationMatrix matrixFrom;
-    matrixFrom.rotate3d(0, 0, 1, 180);
-
-    WebTransformationMatrix matrixTo;
-    matrixTo.rotate3d(0, 1, 0, 180);
-
-    WebTransformationMatrix expected = matrixTo;
-    expected.blend(matrixFrom, progress);
-
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operationsTo.blend(operationsFrom, progress));
-}
-
-TEST(WebTransformOperationTest, blendRotationFromIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendRotate(0, 0, 1, 360);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.rotate3d(0, 0, 1, 180);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.blend(*identityOperations[i], progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendTranslationFromIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendTranslate(2, 2, 2);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.translate3d(1, 1, 1);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.blend(*identityOperations[i], progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendScaleFromIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendScale(3, 3, 3);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.scale3d(2, 2, 2);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.blend(*identityOperations[i], progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendSkewFromIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendSkew(2, 2);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.skewX(1);
-        expected.skewY(1);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.blend(*identityOperations[i], progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendPerspectiveFromIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendPerspective(1000);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.applyPerspective(500 + 0.5 * std::numeric_limits<double>::max());
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.blend(*identityOperations[i], progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendRotationToIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendRotate(0, 0, 1, 360);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.rotate3d(0, 0, 1, 180);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, identityOperations[i]->blend(operations, progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendTranslationToIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendTranslate(2, 2, 2);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.translate3d(1, 1, 1);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, identityOperations[i]->blend(operations, progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendScaleToIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendScale(3, 3, 3);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.scale3d(2, 2, 2);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, identityOperations[i]->blend(operations, progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendSkewToIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendSkew(2, 2);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.skewX(1);
-        expected.skewY(1);
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, identityOperations[i]->blend(operations, progress));
-    }
-}
-
-TEST(WebTransformOperationTest, blendPerspectiveToIdentity)
-{
-    ScopedVector<WebTransformOperations> identityOperations;
-    getIdentityOperations(&identityOperations);
-
-    for (size_t i = 0; i < identityOperations.size(); ++i) {
-        WebTransformOperations operations;
-        operations.appendPerspective(1000);
-
-        double progress = 0.5;
-
-        WebTransformationMatrix expected;
-        expected.applyPerspective(500 + 0.5 * std::numeric_limits<double>::max());
-
-        EXPECT_TRANSFORMATION_MATRIX_EQ(expected, identityOperations[i]->blend(operations, progress));
-    }
-}
Index: src/webkit/compositor_bindings/web_external_texture_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_external_texture_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_external_texture_layer_impl.h	(working copy)
@@ -8,6 +8,7 @@
 #include "base/memory/scoped_ptr.h"
 #include "cc/texture_layer_client.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebExternalTextureLayer.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace WebKit {
 
@@ -16,7 +17,8 @@
 class WebExternalTextureLayerImpl : public WebExternalTextureLayer,
                                     public cc::TextureLayerClient {
 public:
-    explicit WebExternalTextureLayerImpl(WebExternalTextureLayerClient*);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebExternalTextureLayerImpl(
+        WebExternalTextureLayerClient*);
     virtual ~WebExternalTextureLayerImpl();
 
     // WebExternalTextureLayer implementation.
Index: src/webkit/compositor_bindings/web_delegated_renderer_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_delegated_renderer_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_delegated_renderer_layer_impl.cc	(working copy)
@@ -1,27 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "web_delegated_renderer_layer_impl.h"
-
-#include "cc/delegated_renderer_layer.h"
-
-using namespace cc;
-
-namespace WebKit {
-
-WebDelegatedRendererLayerImpl::WebDelegatedRendererLayerImpl()
-    : m_layer(new WebLayerImpl(DelegatedRendererLayer::create()))
-{
-}
-
-WebDelegatedRendererLayerImpl::~WebDelegatedRendererLayerImpl()
-{
-}
-
-WebLayer* WebDelegatedRendererLayerImpl::layer()
-{
-    return m_layer.get();
-}
-
-} // namespace WebKit
Index: src/webkit/compositor_bindings/web_compositor_support_output_surface.cc
===================================================================
--- src/webkit/compositor_bindings/web_compositor_support_output_surface.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_compositor_support_output_surface.cc	(working copy)
@@ -41,7 +41,7 @@
 }
 
 void WebCompositorSupportOutputSurface::SendFrameToParentCompositor(
-    const cc::CompositorFrame&) {
+    cc::CompositorFrame*) {
   // No support for delegated renderers in DumpRenderTree.
   NOTREACHED();
 }
Index: src/webkit/compositor_bindings/web_video_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_video_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_video_layer_impl.cc	(working copy)
@@ -7,23 +7,17 @@
 #include "base/bind.h"
 #include "cc/video_layer.h"
 #include "webkit/compositor_bindings/web_layer_impl.h"
+#include "webkit/compositor_bindings/web_to_ccvideo_frame_provider.h"
 #include "webkit/media/webvideoframe_impl.h"
 
 namespace WebKit {
 
-WebVideoLayer* WebVideoLayer::create(WebVideoFrameProvider* provider)
+WebVideoLayerImpl::WebVideoLayerImpl(WebVideoFrameProvider* web_provider)
+    : m_providerAdapter(webkit::WebToCCVideoFrameProvider::Create(web_provider))
+    , m_layer(new WebLayerImpl(cc::VideoLayer::create(m_providerAdapter.get())))
 {
-    return new WebVideoLayerImpl(provider);
 }
 
-WebVideoLayerImpl::WebVideoLayerImpl(WebVideoFrameProvider* provider)
-    : m_layer(new WebLayerImpl(
-        cc::VideoLayer::create(
-            provider,
-            base::Bind(webkit_media::WebVideoFrameImpl::toVideoFrame))))
-{
-}
-
 WebVideoLayerImpl::~WebVideoLayerImpl()
 {
 }
Index: src/webkit/compositor_bindings/web_compositor_support_output_surface.h
===================================================================
--- src/webkit/compositor_bindings/web_compositor_support_output_surface.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_compositor_support_output_surface.h	(working copy)
@@ -8,6 +8,7 @@
 #include "base/memory/scoped_ptr.h"
 #include "cc/output_surface.h"
 #include "webkit/compositor_bindings/web_compositor_support_software_output_device.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace webkit {
 
@@ -35,12 +36,12 @@
   virtual WebKit::WebGraphicsContext3D* Context3D() const OVERRIDE;
   virtual cc::SoftwareOutputDevice* SoftwareDevice() const OVERRIDE;
 
-  virtual void SendFrameToParentCompositor(const cc::CompositorFrame&) OVERRIDE;
+  virtual void SendFrameToParentCompositor(cc::CompositorFrame*) OVERRIDE;
 
 private:
-  explicit WebCompositorSupportOutputSurface(
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebCompositorSupportOutputSurface(
       scoped_ptr<WebKit::WebGraphicsContext3D> context3d);
-  explicit WebCompositorSupportOutputSurface(
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebCompositorSupportOutputSurface(
       scoped_ptr<cc::SoftwareOutputDevice> software_device);
 
   struct cc::OutputSurface::Capabilities capabilities_;
Index: src/webkit/compositor_bindings/web_layer_tree_view_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_layer_tree_view_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_layer_tree_view_unittest.cc	(working copy)
@@ -7,7 +7,6 @@
 #include "base/threading/thread.h"
 #include "cc/proxy.h"
 #include "cc/thread_impl.h"
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebLayer.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeViewClient.h"
Index: src/webkit/compositor_bindings/web_nine_patch_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_nine_patch_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_nine_patch_layer_impl.cc	(working copy)
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_nine_patch_layer_impl.h"
+#include "webkit/compositor_bindings/web_nine_patch_layer_impl.h"
 
 #include "cc/nine_patch_layer.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/rect.h"
-#include "web_layer_impl.h"
-#include "SkBitmap.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
 
 using cc::NinePatchLayer;
 
Index: src/webkit/compositor_bindings/web_solid_color_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_solid_color_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_solid_color_layer_impl.h	(working copy)
@@ -7,13 +7,14 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebSolidColorLayer.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace WebKit {
 class WebLayerImpl;
 
 class WebSolidColorLayerImpl : public WebSolidColorLayer {
 public:
-    WebSolidColorLayerImpl();
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebSolidColorLayerImpl();
     virtual ~WebSolidColorLayerImpl();
 
     // WebSolidColorLayer implementation.
Index: src/webkit/compositor_bindings/web_content_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_content_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_content_layer_impl.cc	(working copy)
@@ -2,9 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_content_layer_impl.h"
+#include "webkit/compositor_bindings/web_content_layer_impl.h"
 
-#include "SkMatrix44.h"
 #include "base/command_line.h"
 #include "cc/content_layer.h"
 #include "cc/picture_layer.h"
@@ -14,6 +13,7 @@
 #include "third_party/WebKit/Source/Platform/chromium/public/WebFloatRect.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebRect.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
+#include "third_party/skia/include/utils/SkMatrix44.h"
 
 using namespace cc;
 
@@ -24,11 +24,6 @@
     return CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kEnableImplSidePainting);
 }
 
-WebContentLayer* WebContentLayer::create(WebContentLayerClient* client)
-{
-    return new WebContentLayerImpl(client);
-}
-
 WebContentLayerImpl::WebContentLayerImpl(WebContentLayerClient* client)
     : m_client(client)
 {
Index: src/webkit/compositor_bindings/web_float_animation_curve_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_float_animation_curve_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_float_animation_curve_impl.cc	(working copy)
@@ -2,20 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_float_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_float_animation_curve_impl.h"
 
 #include "cc/animation_curve.h"
 #include "cc/keyframed_animation_curve.h"
 #include "cc/timing_function.h"
-#include "web_animation_curve_common.h"
+#include "webkit/compositor_bindings/web_animation_curve_common.h"
 
 namespace WebKit {
 
-WebFloatAnimationCurve* WebFloatAnimationCurve::create()
-{
-    return new WebFloatAnimationCurveImpl();
-}
-
 WebFloatAnimationCurveImpl::WebFloatAnimationCurveImpl()
     : m_curve(cc::KeyframedFloatAnimationCurve::create())
 {
Index: src/webkit/compositor_bindings/web_transformation_matrix_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_transformation_matrix_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_transformation_matrix_unittest.cc	(working copy)
@@ -5,7 +5,6 @@
 #define _USE_MATH_DEFINES
 #include <math.h>
 
-#include "cc/test/geometry_test_utils.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
 
@@ -33,6 +32,24 @@
     EXPECT_FLOAT_EQ((c), (matrix).m34());       \
     EXPECT_FLOAT_EQ((d), (matrix).m44());
 
+#define EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(expected, actual)        \
+    EXPECT_FLOAT_EQ((expected).m11(), (actual).m11());               \
+    EXPECT_FLOAT_EQ((expected).m12(), (actual).m12());               \
+    EXPECT_FLOAT_EQ((expected).m13(), (actual).m13());               \
+    EXPECT_FLOAT_EQ((expected).m14(), (actual).m14());               \
+    EXPECT_FLOAT_EQ((expected).m21(), (actual).m21());               \
+    EXPECT_FLOAT_EQ((expected).m22(), (actual).m22());               \
+    EXPECT_FLOAT_EQ((expected).m23(), (actual).m23());               \
+    EXPECT_FLOAT_EQ((expected).m24(), (actual).m24());               \
+    EXPECT_FLOAT_EQ((expected).m31(), (actual).m31());               \
+    EXPECT_FLOAT_EQ((expected).m32(), (actual).m32());               \
+    EXPECT_FLOAT_EQ((expected).m33(), (actual).m33());               \
+    EXPECT_FLOAT_EQ((expected).m34(), (actual).m34());               \
+    EXPECT_FLOAT_EQ((expected).m41(), (actual).m41());               \
+    EXPECT_FLOAT_EQ((expected).m42(), (actual).m42());               \
+    EXPECT_FLOAT_EQ((expected).m43(), (actual).m43());               \
+    EXPECT_FLOAT_EQ((expected).m44(), (actual).m44());
+
 // Checking float values for equality close to zero is not robust using EXPECT_FLOAT_EQ
 // (see gtest documentation). So, to verify rotation matrices, we must use a looser
 // absolute error threshold in some places.
@@ -994,7 +1011,7 @@
     to.makeIdentity();
     to.translate3d(200, 100, 300);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     to.makeIdentity();
     to.translate3d(200, 100, 300);
@@ -1031,7 +1048,7 @@
     to.makeIdentity();
     to.scale3d(200, 100, 300);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     to.makeIdentity();
     to.scale3d(200, 100, 300);
@@ -1068,7 +1085,7 @@
     to.makeIdentity();
     to.skewX(45);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     to.makeIdentity();
     to.skewX(45);
@@ -1117,7 +1134,7 @@
     to.makeIdentity();
     to.skewY(45);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     to.makeIdentity();
     to.skewY(45);
@@ -1159,7 +1176,7 @@
     to.makeIdentity();
     to.rotate3d(1, 0, 0, 90);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     double expectedRotationAngle = 22.5 * M_PI / 180.0;
     to.makeIdentity();
@@ -1198,7 +1215,7 @@
     to.makeIdentity();
     to.rotate3d(0, 1, 0, 90);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     double expectedRotationAngle = 22.5 * M_PI / 180.0;
     to.makeIdentity();
@@ -1237,7 +1254,7 @@
     to.makeIdentity();
     to.rotate3d(0, 0, 1, 90);
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     double expectedRotationAngle = 22.5 * M_PI / 180.0;
     to.makeIdentity();
@@ -1290,7 +1307,7 @@
     
     to = expectedEndOfAnimation;
     to.blend(from, 0);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(from, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(from, to);
 
     to = expectedEndOfAnimation;
     to.blend(from, 1);
@@ -1306,7 +1323,7 @@
     normalizationMatrix.setM44(1 / expectedEndOfAnimation.m44());
     normalizedExpectedEndOfAnimation.multiply(normalizationMatrix);
 
-    EXPECT_TRANSFORMATION_MATRIX_EQ(normalizedExpectedEndOfAnimation, to);
+    EXPECT_WEB_TRANSFORMATION_MATRIX_EQ(normalizedExpectedEndOfAnimation, to);
 }
 
 } // namespace
Index: src/webkit/compositor_bindings/web_animation_curve_common.cc
===================================================================
--- src/webkit/compositor_bindings/web_animation_curve_common.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_animation_curve_common.cc	(working copy)
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_animation_curve_common.h"
+#include "webkit/compositor_bindings/web_animation_curve_common.h"
 
 #include "cc/timing_function.h"
 
Index: src/webkit/compositor_bindings/web_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_layer_impl.h	(working copy)
@@ -7,6 +7,7 @@
 
 #include "base/memory/ref_counted.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebLayer.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace cc {
 class Layer;
@@ -19,8 +20,8 @@
 
 class WebLayerImpl : public WebLayer {
 public:
-    WebLayerImpl();
-    explicit WebLayerImpl(scoped_refptr<cc::Layer>);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebLayerImpl();
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebLayerImpl(scoped_refptr<cc::Layer>);
     virtual ~WebLayerImpl();
 
     // WebLayer implementation.
Index: src/webkit/compositor_bindings/web_scrollbar_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_scrollbar_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_scrollbar_layer_impl.cc	(working copy)
@@ -2,23 +2,25 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_scrollbar_layer_impl.h"
+#include "webkit/compositor_bindings/web_scrollbar_layer_impl.h"
 
 #include "cc/scrollbar_layer.h"
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
+#include "webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.h"
 
 using cc::ScrollbarLayer;
+using cc::ScrollbarThemePainter;
 
 namespace WebKit {
 
-WebScrollbarLayer* WebScrollbarLayer::create(WebScrollbar* scrollbar, WebScrollbarThemePainter painter, WebScrollbarThemeGeometry* geometry)
-{
-    return new WebScrollbarLayerImpl(scrollbar, painter, geometry);
-}
-
-
 WebScrollbarLayerImpl::WebScrollbarLayerImpl(WebScrollbar* scrollbar, WebScrollbarThemePainter painter, WebScrollbarThemeGeometry* geometry)
-    : m_layer(new WebLayerImpl(ScrollbarLayer::create(make_scoped_ptr(scrollbar), painter, make_scoped_ptr(geometry), 0)))
+    : m_layer(new WebLayerImpl(ScrollbarLayer::create(
+        make_scoped_ptr(scrollbar),
+        WebToCCScrollbarThemePainterAdapter::Create(
+            make_scoped_ptr(new WebScrollbarThemePainter(painter)))
+            .PassAs<ScrollbarThemePainter>(),
+        make_scoped_ptr(geometry),
+        0)))
 {
 }
 
Index: src/webkit/compositor_bindings/web_animation_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_animation_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_animation_impl.cc	(working copy)
@@ -2,26 +2,21 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_animation_impl.h"
+#include "webkit/compositor_bindings/web_animation_impl.h"
 
-#include "cc/active_animation.h"
+#include "cc/animation.h"
 #include "cc/animation_curve.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebAnimationCurve.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebAnimation.h"
-#include "web_animation_id_provider.h"
-#include "web_float_animation_curve_impl.h"
-#include "web_transform_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_animation_id_provider.h"
+#include "webkit/compositor_bindings/web_float_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_transform_animation_curve_impl.h"
 
-using cc::ActiveAnimation;
+using cc::Animation;
 using webkit::WebAnimationIdProvider;
 
 namespace WebKit {
 
-WebAnimation* WebAnimation::create(const WebAnimationCurve& curve, TargetProperty targetProperty, int animationId)
-{
-    return new WebAnimationImpl(curve, targetProperty, animationId, 0);
-}
-
 WebAnimationImpl::WebAnimationImpl(const WebAnimationCurve& webCurve, TargetProperty targetProperty, int animationId, int groupId)
 {
     if (!animationId)
@@ -43,7 +38,7 @@
         break;
     }
     }
-    m_animation = ActiveAnimation::create(curve.Pass(), animationId, groupId, static_cast<cc::ActiveAnimation::TargetProperty>(targetProperty));
+    m_animation = Animation::create(curve.Pass(), animationId, groupId, static_cast<cc::Animation::TargetProperty>(targetProperty));
 }
 
 WebAnimationImpl::~WebAnimationImpl()
@@ -100,9 +95,9 @@
     m_animation->setAlternatesDirection(alternates);
 }
 
-scoped_ptr<cc::ActiveAnimation> WebAnimationImpl::cloneToAnimation()
+scoped_ptr<cc::Animation> WebAnimationImpl::cloneToAnimation()
 {
-    scoped_ptr<cc::ActiveAnimation> toReturn(m_animation->clone(cc::ActiveAnimation::NonControllingInstance));
+    scoped_ptr<cc::Animation> toReturn(m_animation->clone(cc::Animation::NonControllingInstance));
     toReturn->setNeedsSynchronizedStartTime(true);
     return toReturn.Pass();
 }
Index: src/webkit/compositor_bindings/web_image_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_image_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_image_layer_impl.h	(working copy)
@@ -7,17 +7,18 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebImageLayer.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace WebKit {
 class WebLayerImpl;
 
 class WebImageLayerImpl : public WebImageLayer {
 public:
-    WebImageLayerImpl();
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebImageLayerImpl();
     virtual ~WebImageLayerImpl();
 
     // WebImageLayer implementation.
-    WebLayer* layer() OVERRIDE;
+    virtual WebLayer* layer() OVERRIDE;
     virtual void setBitmap(SkBitmap) OVERRIDE;
 
 private:
Index: src/webkit/compositor_bindings/web_transform_animation_curve_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_transform_animation_curve_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_transform_animation_curve_impl.h	(working copy)
@@ -7,6 +7,7 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebTransformAnimationCurve.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace cc {
 class AnimationCurve;
@@ -17,7 +18,7 @@
 
 class WebTransformAnimationCurveImpl : public WebTransformAnimationCurve {
 public:
-    WebTransformAnimationCurveImpl();
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebTransformAnimationCurveImpl();
     virtual ~WebTransformAnimationCurveImpl();
 
     // WebAnimationCurve implementation.
Index: src/webkit/compositor_bindings/web_scrollbar_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_scrollbar_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_scrollbar_layer_impl.h	(working copy)
@@ -7,13 +7,15 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbarLayer.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace WebKit {
 class WebLayerImpl;
 
 class WebScrollbarLayerImpl : public WebScrollbarLayer {
 public:
-    WebScrollbarLayerImpl(WebScrollbar*, WebScrollbarThemePainter, WebScrollbarThemeGeometry*);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebScrollbarLayerImpl(
+        WebScrollbar*, WebScrollbarThemePainter, WebScrollbarThemeGeometry*);
     virtual ~WebScrollbarLayerImpl();
 
     // WebScrollbarLayer implementation.
Index: src/webkit/compositor_bindings/web_animation_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_animation_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_animation_impl.h	(working copy)
@@ -7,16 +7,18 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebAnimation.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace cc {
-class ActiveAnimation;
+class Animation;
 }
 
 namespace WebKit {
 
 class WebAnimationImpl : public WebAnimation {
 public:
-    WebAnimationImpl(const WebAnimationCurve&, TargetProperty, int animationId, int groupId = 0);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebAnimationImpl(
+        const WebAnimationCurve&, TargetProperty, int animationId, int groupId = 0);
     virtual ~WebAnimationImpl();
 
     // WebAnimation implementation
@@ -31,10 +33,10 @@
     virtual bool alternatesDirection() const OVERRIDE;
     virtual void setAlternatesDirection(bool) OVERRIDE;
 
-    scoped_ptr<cc::ActiveAnimation> cloneToAnimation();
+    scoped_ptr<cc::Animation> cloneToAnimation();
 
 private:
-    scoped_ptr<cc::ActiveAnimation> m_animation;
+    scoped_ptr<cc::Animation> m_animation;
 };
 
 }
Index: src/webkit/compositor_bindings/web_to_ccinput_handler_adapter.cc
===================================================================
--- src/webkit/compositor_bindings/web_to_ccinput_handler_adapter.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_to_ccinput_handler_adapter.cc	(working copy)
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_to_ccinput_handler_adapter.h"
+#include "webkit/compositor_bindings/web_to_ccinput_handler_adapter.h"
 
 #include "third_party/WebKit/Source/Platform/chromium/public/WebInputHandlerClient.h"
 
Index: src/webkit/compositor_bindings/web_compositor_support_software_output_device.h
===================================================================
--- src/webkit/compositor_bindings/web_compositor_support_software_output_device.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_compositor_support_software_output_device.h	(working copy)
@@ -10,13 +10,14 @@
 #include "skia/ext/refptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebImage.h"
 #include "third_party/skia/include/core/SkDevice.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace webkit {
 
 class WebCompositorSupportSoftwareOutputDevice
     : public cc::SoftwareOutputDevice {
  public:
-  WebCompositorSupportSoftwareOutputDevice();
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebCompositorSupportSoftwareOutputDevice();
   virtual ~WebCompositorSupportSoftwareOutputDevice();
 
   virtual WebKit::WebImage* Lock(bool forWrite) OVERRIDE;
Index: src/webkit/compositor_bindings/web_float_animation_curve_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_float_animation_curve_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_float_animation_curve_unittest.cc	(working copy)
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_float_animation_curve_impl.h"
 #include "base/memory/scoped_ptr.h"
 #include "cc/timing_function.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "webkit/compositor_bindings/web_float_animation_curve_impl.h"
 
 using namespace WebKit;
 
Index: src/webkit/compositor_bindings/web_compositor_support_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_compositor_support_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_compositor_support_impl.cc	(working copy)
@@ -7,11 +7,11 @@
 #include "base/memory/scoped_ptr.h"
 #include "base/message_loop_proxy.h"
 #include "cc/thread_impl.h"
+#include "cc/transform_operations.h"
 #include "webkit/compositor_bindings/web_animation_impl.h"
 #include "webkit/compositor_bindings/web_compositor_support_output_surface.h"
 #include "webkit/compositor_bindings/web_compositor_support_software_output_device.h"
 #include "webkit/compositor_bindings/web_content_layer_impl.h"
-#include "webkit/compositor_bindings/web_delegated_renderer_layer_impl.h"
 #include "webkit/compositor_bindings/web_external_texture_layer_impl.h"
 #include "webkit/compositor_bindings/web_float_animation_curve_impl.h"
 #include "webkit/compositor_bindings/web_image_layer_impl.h"
@@ -21,6 +21,7 @@
 #include "webkit/compositor_bindings/web_scrollbar_layer_impl.h"
 #include "webkit/compositor_bindings/web_solid_color_layer_impl.h"
 #include "webkit/compositor_bindings/web_transform_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_transform_operations_impl.h"
 #include "webkit/compositor_bindings/web_video_layer_impl.h"
 #include "webkit/glue/webthread_impl.h"
 #include "webkit/support/webkit_support.h"
@@ -29,7 +30,6 @@
 using WebKit::WebAnimationCurve;
 using WebKit::WebContentLayer;
 using WebKit::WebContentLayerClient;
-using WebKit::WebDelegatedRendererLayer;
 using WebKit::WebExternalTextureLayer;
 using WebKit::WebExternalTextureLayerClient;
 using WebKit::WebFloatAnimationCurve;
@@ -45,6 +45,7 @@
 using WebKit::WebScrollbarThemePainter;
 using WebKit::WebSolidColorLayer;
 using WebKit::WebTransformAnimationCurve;
+using WebKit::WebTransformOperations;
 using WebKit::WebVideoFrameProvider;
 using WebKit::WebVideoLayer;
 
@@ -120,11 +121,6 @@
   return new WebKit::WebContentLayerImpl(client);
 }
 
-WebDelegatedRendererLayer*
-    WebCompositorSupportImpl::createDelegatedRendererLayer() {
-  return new WebKit::WebDelegatedRendererLayerImpl();
-}
-
 WebExternalTextureLayer* WebCompositorSupportImpl::createExternalTextureLayer(
     WebExternalTextureLayerClient* client) {
   return new WebKit::WebExternalTextureLayerImpl(client);
@@ -171,4 +167,8 @@
   return new WebKit::WebTransformAnimationCurveImpl();
 }
 
+WebTransformOperations* WebCompositorSupportImpl::createTransformOperations() {
+  return new WebTransformOperationsImpl();
+}
+
 }  // namespace webkit
Index: src/webkit/compositor_bindings/web_animation_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_animation_unittest.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_animation_unittest.cc	(working copy)
@@ -4,8 +4,8 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include "web_animation_impl.h"
-#include "web_float_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_animation_impl.h"
+#include "webkit/compositor_bindings/web_float_animation_curve_impl.h"
 
 using namespace WebKit;
 
Index: src/webkit/compositor_bindings/web_external_texture_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_external_texture_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_external_texture_layer_impl.cc	(working copy)
@@ -2,24 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_external_texture_layer_impl.h"
+#include "webkit/compositor_bindings/web_external_texture_layer_impl.h"
 
 #include "cc/resource_update_queue.h"
 #include "cc/texture_layer.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebExternalTextureLayerClient.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebFloatRect.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
 
 using namespace cc;
 
 namespace WebKit {
 
-WebExternalTextureLayer* WebExternalTextureLayer::create(WebExternalTextureLayerClient* client)
-{
-    return new WebExternalTextureLayerImpl(client);
-}
-
 WebExternalTextureLayerImpl::WebExternalTextureLayerImpl(WebExternalTextureLayerClient* client)
     : m_client(client)
 {
@@ -54,7 +49,7 @@
 
 void WebExternalTextureLayerImpl::setUVRect(const WebFloatRect& rect)
 {
-    static_cast<TextureLayer*>(m_layer->layer())->setUVRect(rect);
+    static_cast<TextureLayer*>(m_layer->layer())->setUV(gfx::PointF(rect.x, rect.y), gfx::PointF(rect.x + rect.width, rect.y + rect.height));
 }
 
 void WebExternalTextureLayerImpl::setOpaque(bool opaque)
Index: src/webkit/compositor_bindings/web_delegated_renderer_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_delegated_renderer_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_delegated_renderer_layer_impl.h	(working copy)
@@ -1,30 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef WebDelegatedRendererLayerImpl_h
-#define WebDelegatedRendererLayerImpl_h
-
-#include "web_layer_impl.h"
-#include "base/memory/scoped_ptr.h"
-#include "third_party/WebKit/Source/Platform/chromium/public/WebDelegatedRendererLayer.h"
-
-namespace WebKit {
-
-class WebDelegatedRendererLayerImpl : public WebDelegatedRendererLayer {
-public:
-    WebDelegatedRendererLayerImpl();
-
-    // WebDelegatedRendererLayer implementation.
-    virtual WebLayer* layer() OVERRIDE;
-
-protected:
-    virtual ~WebDelegatedRendererLayerImpl();
-
-private:
-    scoped_ptr<WebLayerImpl> m_layer;
-};
-
-} // namespace WebKit
-
-#endif // WebDelegatedLayerImpl_h
Index: src/webkit/compositor_bindings/web_video_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_video_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_video_layer_impl.h	(working copy)
@@ -7,13 +7,19 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebVideoLayer.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
+namespace webkit {
+class WebToCCVideoFrameProvider;
+}
+
 namespace WebKit {
 class WebLayerImpl;
 
 class WebVideoLayerImpl : public WebVideoLayer {
 public:
-    explicit WebVideoLayerImpl(WebVideoFrameProvider*);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebVideoLayerImpl(
+        WebVideoFrameProvider*);
     virtual ~WebVideoLayerImpl();
 
     // WebVideoLayer implementation.
@@ -21,6 +27,7 @@
     virtual bool active() const OVERRIDE;
 
 private:
+    scoped_ptr<webkit::WebToCCVideoFrameProvider> m_providerAdapter;
     scoped_ptr<WebLayerImpl> m_layer;
 };
 
Index: src/webkit/compositor_bindings/web_solid_color_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_solid_color_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_solid_color_layer_impl.cc	(working copy)
@@ -2,20 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_solid_color_layer_impl.h"
+#include "webkit/compositor_bindings/web_solid_color_layer_impl.h"
 
 #include "cc/solid_color_layer.h"
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
 
 using cc::SolidColorLayer;
 
 namespace WebKit {
 
-WebSolidColorLayer* WebSolidColorLayer::create()
-{
-    return new WebSolidColorLayerImpl();
-}
-
 WebSolidColorLayerImpl::WebSolidColorLayerImpl()
     : m_layer(new WebLayerImpl(SolidColorLayer::create()))
 {
Index: src/webkit/compositor_bindings/web_nine_patch_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_nine_patch_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_nine_patch_layer_impl.h	(working copy)
@@ -5,9 +5,9 @@
 #ifndef WebNinePatchLayerImpl_h
 #define WebNinePatchLayerImpl_h
 
-#include "web_layer_impl.h"
 #include "base/memory/scoped_ptr.h"
-#include "SkBitmap.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
 
 namespace WebKit {
 
Index: src/webkit/compositor_bindings/compositor_bindings.gyp
===================================================================
--- src/webkit/compositor_bindings/compositor_bindings.gyp	(revision 184497)
+++ src/webkit/compositor_bindings/compositor_bindings.gyp	(working copy)
@@ -17,8 +17,6 @@
       'web_compositor_support_software_output_device.h',
       'web_content_layer_impl.cc',
       'web_content_layer_impl.h',
-      'web_delegated_renderer_layer_impl.cc',
-      'web_delegated_renderer_layer_impl.h',
       'web_external_texture_layer_impl.cc',
       'web_external_texture_layer_impl.h',
       'web_float_animation_curve_impl.cc',
@@ -29,21 +27,38 @@
       'web_image_layer_impl.h',
       'web_layer_impl.cc',
       'web_layer_impl.h',
+      'web_layer_impl_fixed_bounds.cc',
+      'web_layer_impl_fixed_bounds.h',
       'web_nine_patch_layer_impl.cc',
       'web_nine_patch_layer_impl.h',
       'web_to_ccinput_handler_adapter.cc',
       'web_to_ccinput_handler_adapter.h',
+      'web_to_ccscrollbar_theme_painter_adapter.cc',
+      'web_to_ccscrollbar_theme_painter_adapter.h',
+      'web_to_ccvideo_frame_provider.cc',
+      'web_to_ccvideo_frame_provider.h',
       'web_layer_tree_view_impl.cc',
       'web_layer_tree_view_impl.h',
       'web_scrollbar_layer_impl.cc',
       'web_scrollbar_layer_impl.h',
       'web_solid_color_layer_impl.cc',
       'web_solid_color_layer_impl.h',
+      'web_transform_operations_impl.cc',
+      'web_transform_operations_impl.h',
+      'web_transformation_matrix_util.cc',
+      'web_transformation_matrix_util.h',
       'web_video_layer_impl.cc',
       'web_video_layer_impl.h',
       'web_transform_animation_curve_impl.cc',
       'web_transform_animation_curve_impl.h',
     ],
+    'conditions': [
+      ['inside_chromium_build==0', {
+        'webkit_src_dir': '../../../../..',
+      },{
+        'webkit_src_dir': '../../third_party/WebKit',
+      }],
+    ],
   },
   'targets': [
     {
@@ -51,43 +66,35 @@
       'type': 'static_library',
       'dependencies': [
         '../../skia/skia.gyp:skia',
+        '../../cc/cc.gyp:cc',
         'webkit_compositor_bindings',
       ],
       'sources': [
         'web_compositor_support_impl.cc',
         'web_compositor_support_impl.h',
       ],
-      'includes': [
-        '../../cc/cc.gypi',
-      ],
       'include_dirs': [
         '../..',
-        '../../cc',
         '<(SHARED_INTERMEDIATE_DIR)/webkit',
-        '<(webkit_src_dir)/Source/Platform/chromium',
-        '<@(cc_stubs_dirs)',
       ],
     },
     {
       'target_name': 'webkit_compositor_bindings',
-      'type': 'static_library',
-      'includes': [
-        '../../cc/cc.gypi',
-      ],
+      'type': '<(component)',
       'dependencies': [
         '../../base/base.gyp:base',
         '../../cc/cc.gyp:cc',
+        '../../media/media.gyp:media',
         '../../skia/skia.gyp:skia',
         '../../ui/ui.gyp:ui',
+        '<(webkit_src_dir)/Source/WebKit/chromium/WebKit.gyp:webkit',
       ],
-      'include_dirs': [
-        '../../cc',
-        '<@(cc_stubs_dirs)',
-        '<(webkit_src_dir)/Source/Platform/chromium',
-      ],
       'sources': [
         '<@(webkit_compositor_bindings_sources)',
       ],
+      'defines': [
+        'WEBKIT_COMPOSITOR_BINDINGS_IMPLEMENTATION=1'
+      ]
     },
   ],
 }
Index: src/webkit/compositor_bindings/web_content_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_content_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_content_layer_impl.h	(working copy)
@@ -8,7 +8,8 @@
 #include "base/memory/scoped_ptr.h"
 #include "cc/content_layer_client.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebContentLayer.h"
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace cc {
 class IntRect;
@@ -21,7 +22,8 @@
 class WebContentLayerImpl : public WebContentLayer,
                             public cc::ContentLayerClient {
 public:
-    explicit WebContentLayerImpl(WebContentLayerClient*);
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebContentLayerImpl(
+        WebContentLayerClient*);
 
     // WebContentLayer implementation.
     virtual WebLayer* layer() OVERRIDE;
Index: src/webkit/compositor_bindings/web_float_animation_curve_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_float_animation_curve_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_float_animation_curve_impl.h	(working copy)
@@ -7,6 +7,7 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebFloatAnimationCurve.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace cc {
 class AnimationCurve;
@@ -17,7 +18,7 @@
 
 class WebFloatAnimationCurveImpl : public WebFloatAnimationCurve {
 public:
-    WebFloatAnimationCurveImpl();
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebFloatAnimationCurveImpl();
     virtual ~WebFloatAnimationCurveImpl();
 
     // WebAnimationCurve implementation.
Index: src/webkit/compositor_bindings/web_io_surface_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_io_surface_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_io_surface_layer_impl.cc	(working copy)
@@ -2,20 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_io_surface_layer_impl.h"
+#include "webkit/compositor_bindings/web_io_surface_layer_impl.h"
 
 #include "cc/io_surface_layer.h"
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
 
 using cc::IOSurfaceLayer;
 
 namespace WebKit {
 
-WebIOSurfaceLayer* WebIOSurfaceLayer::create()
-{
-    return new WebIOSurfaceLayerImpl();
-}
-
 WebIOSurfaceLayerImpl::WebIOSurfaceLayerImpl()
     : m_layer(new WebLayerImpl(IOSurfaceLayer::create()))
 {
Index: src/webkit/compositor_bindings/web_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_layer_impl.cc	(working copy)
@@ -2,32 +2,26 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
 
-#include "SkMatrix44.h"
-#ifdef LOG
-#undef LOG
-#endif
 #include "base/string_util.h"
-#include "cc/active_animation.h"
+#include "cc/animation.h"
 #include "cc/layer.h"
 #include "cc/region.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebFloatPoint.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebFloatRect.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
-#include "web_animation_impl.h"
+#include "third_party/skia/include/utils/SkMatrix44.h"
+#include "webkit/compositor_bindings/web_animation_impl.h"
+#include "webkit/compositor_bindings/web_transformation_matrix_util.h"
 
-using cc::ActiveAnimation;
+using cc::Animation;
 using cc::Layer;
+using webkit::WebTransformationMatrixUtil;
 
 namespace WebKit {
 
-WebLayer* WebLayer::create()
-{
-    return new WebLayerImpl();
-}
-
 WebLayerImpl::WebLayerImpl()
     : m_layer(Layer::create())
 {
@@ -174,7 +168,7 @@
 
 void WebLayerImpl::setSublayerTransform(const WebTransformationMatrix& matrix)
 {
-    m_layer->setSublayerTransform(matrix.toTransform());
+    m_layer->setSublayerTransform(WebTransformationMatrixUtil::ToTransform(matrix));
 }
 
 SkMatrix44 WebLayerImpl::sublayerTransform() const
@@ -191,7 +185,7 @@
 
 void WebLayerImpl::setTransform(const WebTransformationMatrix& matrix)
 {
-    m_layer->setTransform(matrix.toTransform());
+    m_layer->setTransform(WebTransformationMatrixUtil::ToTransform(matrix));
 }
 
 SkMatrix44 WebLayerImpl::transform() const
@@ -267,7 +261,7 @@
 
 void WebLayerImpl::removeAnimation(int animationId, WebAnimation::TargetProperty targetProperty)
 {
-    m_layer->layerAnimationController()->removeAnimation(animationId, static_cast<ActiveAnimation::TargetProperty>(targetProperty));
+    m_layer->layerAnimationController()->removeAnimation(animationId, static_cast<Animation::TargetProperty>(targetProperty));
 }
 
 void WebLayerImpl::pauseAnimation(int animationId, double timeOffset)
Index: src/webkit/compositor_bindings/test/web_layer_tree_view_test_common.h
===================================================================
--- src/webkit/compositor_bindings/test/web_layer_tree_view_test_common.h	(revision 184497)
+++ src/webkit/compositor_bindings/test/web_layer_tree_view_test_common.h	(working copy)
@@ -5,10 +5,9 @@
 #ifndef WebLayerTreeViewTestCommon_h
 #define WebLayerTreeViewTestCommon_h
 
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
 #include "cc/test/fake_output_surface.h"
-#include <gmock/gmock.h>
-#include <public/WebLayerTreeViewClient.h>
+#include "testing/gmock/include/gmock/gmock.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeViewClient.h"
 
 namespace WebKit {
 
@@ -23,7 +22,7 @@
 
     virtual cc::OutputSurface* createOutputSurface() OVERRIDE
     {
-      return cc::FakeOutputSurface::Create3d(cc::CompositorFakeWebGraphicsContext3D::create(WebGraphicsContext3D::Attributes()).PassAs<WebKit::WebGraphicsContext3D>()).release();
+      return cc::createFakeOutputSurface().release();
     }
     virtual void didRecreateOutputSurface(bool) OVERRIDE { }
 
Index: src/webkit/compositor_bindings/test/fake_web_scrollbar_theme_geometry.h
===================================================================
--- src/webkit/compositor_bindings/test/fake_web_scrollbar_theme_geometry.h	(revision 184497)
+++ src/webkit/compositor_bindings/test/fake_web_scrollbar_theme_geometry.h	(working copy)
@@ -1,48 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef FakeWebScrollbarThemeGeometry_h
-#define FakeWebScrollbarThemeGeometry_h
-
-#include <public/WebScrollbarThemeGeometry.h>
-#include <wtf/PassOwnPtr.h>
-
-namespace WebKit {
-
-class FakeWebScrollbarThemeGeometry : public WebKit::WebScrollbarThemeGeometry {
-public:
-    static PassOwnPtr<WebKit::WebScrollbarThemeGeometry> create() { return adoptPtr(new WebKit::FakeWebScrollbarThemeGeometry()); }
-
-    virtual WebKit::WebScrollbarThemeGeometry* clone() const OVERRIDE
-    {
-        return new FakeWebScrollbarThemeGeometry();
-    }
-
-    virtual int thumbPosition(WebScrollbar*) OVERRIDE { return 0; }
-    virtual int thumbLength(WebScrollbar*) OVERRIDE { return 0; }
-    virtual int trackPosition(WebScrollbar*) OVERRIDE { return 0; }
-    virtual int trackLength(WebScrollbar*) OVERRIDE { return 0; }
-    virtual bool hasButtons(WebScrollbar*) OVERRIDE { return false; }
-    virtual bool hasThumb(WebScrollbar*) OVERRIDE { return false; }
-    virtual WebRect trackRect(WebScrollbar*) OVERRIDE { return WebRect(); }
-    virtual WebRect thumbRect(WebScrollbar*) OVERRIDE { return WebRect(); }
-    virtual int minimumThumbLength(WebScrollbar*) OVERRIDE { return 0; }
-    virtual int scrollbarThickness(WebScrollbar*) OVERRIDE { return 0; }
-    virtual WebRect backButtonStartRect(WebScrollbar*) OVERRIDE { return WebRect(); }
-    virtual WebRect backButtonEndRect(WebScrollbar*) OVERRIDE { return WebRect(); }
-    virtual WebRect forwardButtonStartRect(WebScrollbar*) OVERRIDE { return WebRect(); }
-    virtual WebRect forwardButtonEndRect(WebScrollbar*) OVERRIDE { return WebRect(); }
-    virtual WebRect constrainTrackRectToTrackPieces(WebScrollbar*, const WebRect&) OVERRIDE { return WebRect(); }
-
-    virtual void splitTrack(WebScrollbar*, const WebRect& track, WebRect& startTrack, WebRect& thumb, WebRect& endTrack) OVERRIDE
-    {
-        startTrack = WebRect();
-        thumb = WebRect();
-        endTrack = WebRect();
-    }
-};
-
-} // namespace WebKit
-
-#endif // FakeWebScrollbarThemeGeometry_h
Index: src/webkit/compositor_bindings/web_io_surface_layer_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_io_surface_layer_impl.h	(revision 184497)
+++ src/webkit/compositor_bindings/web_io_surface_layer_impl.h	(working copy)
@@ -5,14 +5,15 @@
 #ifndef WebIOSurfaceLayerImpl_h
 #define WebIOSurfaceLayerImpl_h
 
+#include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebIOSurfaceLayer.h"
-#include "base/memory/scoped_ptr.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
 
 namespace WebKit {
 
 class WebIOSurfaceLayerImpl : public WebIOSurfaceLayer {
 public:
-    WebIOSurfaceLayerImpl();
+    WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebIOSurfaceLayerImpl();
     virtual ~WebIOSurfaceLayerImpl();
 
     // WebIOSurfaceLayer implementation.
Index: src/webkit/compositor_bindings/web_transform_animation_curve_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_transform_animation_curve_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_transform_animation_curve_impl.cc	(working copy)
@@ -2,19 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_transform_animation_curve_impl.h"
+#include "webkit/compositor_bindings/web_transform_animation_curve_impl.h"
 
 #include "cc/keyframed_animation_curve.h"
 #include "cc/timing_function.h"
-#include "web_animation_curve_common.h"
+#include "cc/transform_operations.h"
+#include "webkit/compositor_bindings/web_animation_curve_common.h"
+#include "webkit/compositor_bindings/web_transform_operations_impl.h"
+#include "webkit/compositor_bindings/web_transformation_matrix_util.h"
 
 namespace WebKit {
 
-WebTransformAnimationCurve* WebTransformAnimationCurve::create()
-{
-    return new WebTransformAnimationCurveImpl();
-}
-
 WebTransformAnimationCurveImpl::WebTransformAnimationCurveImpl()
     : m_curve(cc::KeyframedTransformAnimationCurve::create())
 {
@@ -36,17 +34,21 @@
 
 void WebTransformAnimationCurveImpl::add(const WebTransformKeyframe& keyframe, TimingFunctionType type)
 {
-    m_curve->addKeyframe(cc::TransformKeyframe::create(keyframe.time, keyframe.value, createTimingFunction(type)));
+    const cc::TransformOperations& transformOperations =
+        static_cast<const webkit::WebTransformOperationsImpl&>(keyframe.value()).AsTransformOperations();
+    m_curve->addKeyframe(cc::TransformKeyframe::create(keyframe.time(), transformOperations, createTimingFunction(type)));
 }
 
 void WebTransformAnimationCurveImpl::add(const WebTransformKeyframe& keyframe, double x1, double y1, double x2, double y2)
 {
-    m_curve->addKeyframe(cc::TransformKeyframe::create(keyframe.time, keyframe.value, cc::CubicBezierTimingFunction::create(x1, y1, x2, y2).PassAs<cc::TimingFunction>()));
+    const cc::TransformOperations& transformOperations =
+        static_cast<const webkit::WebTransformOperationsImpl&>(keyframe.value()).AsTransformOperations();
+    m_curve->addKeyframe(cc::TransformKeyframe::create(keyframe.time(), transformOperations, cc::CubicBezierTimingFunction::create(x1, y1, x2, y2).PassAs<cc::TimingFunction>()));
 }
 
 WebTransformationMatrix WebTransformAnimationCurveImpl::getValue(double time) const
 {
-    return m_curve->getValue(time);
+    return webkit::WebTransformationMatrixUtil::ToWebTransformationMatrix(m_curve->getValue(time));
 }
 
 scoped_ptr<cc::AnimationCurve> WebTransformAnimationCurveImpl::cloneToAnimationCurve() const
Index: src/webkit/compositor_bindings/web_image_layer_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_image_layer_impl.cc	(revision 184497)
+++ src/webkit/compositor_bindings/web_image_layer_impl.cc	(working copy)
@@ -2,13 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "web_image_layer_impl.h"
+#include "webkit/compositor_bindings/web_image_layer_impl.h"
 
 #include "base/command_line.h"
 #include "cc/image_layer.h"
 #include "cc/picture_image_layer.h"
 #include "cc/switches.h"
-#include "web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
+#include "webkit/compositor_bindings/web_layer_impl_fixed_bounds.h"
 
 static bool usingPictureLayer()
 {
@@ -17,15 +18,10 @@
 
 namespace WebKit {
 
-WebImageLayer* WebImageLayer::create()
-{
-    return new WebImageLayerImpl();
-}
-
 WebImageLayerImpl::WebImageLayerImpl()
 {
     if (usingPictureLayer())
-        m_layer.reset(new WebLayerImpl(cc::PictureImageLayer::create()));
+        m_layer.reset(new WebLayerImplFixedBounds(cc::PictureImageLayer::create()));
     else
         m_layer.reset(new WebLayerImpl(cc::ImageLayer::create()));
 }
@@ -41,9 +37,10 @@
 
 void WebImageLayerImpl::setBitmap(SkBitmap bitmap)
 {
-    if (usingPictureLayer())
+    if (usingPictureLayer()) {
         static_cast<cc::PictureImageLayer*>(m_layer->layer())->setBitmap(bitmap);
-    else
+        static_cast<WebLayerImplFixedBounds*>(m_layer.get())->SetFixedBounds(gfx::Size(bitmap.width(), bitmap.height()));
+    } else
         static_cast<cc::ImageLayer*>(m_layer->layer())->setBitmap(bitmap);
 }
 
Index: src/webkit/compositor_bindings/copyfiles.py
===================================================================
--- src/webkit/compositor_bindings/copyfiles.py	(revision 184497)
+++ src/webkit/compositor_bindings/copyfiles.py	(working copy)
@@ -1,78 +0,0 @@
-# Copyright (c) 2012 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-import shutil
-import os
-import re
-
-prefixes = ["../../third_party/WebKit/Source/WebCore/platform/chromium/support",
-            "../../third_party/WebKit/Source/WebKit/chromium/src",
-            "../../third_party/WebKit/Source/WebKit/chromium/tests",
-            "../../third_party/WebKit/Source/WebCore/platform"]
-
-def Copy(name):
-  src = name
-  dst = name
-  fullsrc = ""
-  if name.startswith("test/"):
-    src = src[5:]
-  for prefix in prefixes:
-    candidate = "%s/%s" % (prefix, src)
-    if os.path.exists(candidate):
-      fullsrc = candidate
-      break
-  assert fullsrc != ""
-  shutil.copyfile(fullsrc, dst)
-  print "copying from %s to %s" % (fullsrc, dst)
-  return dst
-
-def Readfile(gypfile):
-  cc_gyp = open(gypfile, "r")
-  obj = eval(cc_gyp.read())
-  cc_gyp.close()
-  return obj
-
-def FixCopyrightHeaderText(text, year):
-  header_template = """// Copyright %s The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-"""
-
-  while text[0].find(" */") == -1:
-    text = text[1:]
-  text = text[1:]
-
-  return (header_template % year) + "".join(text)
-
-def FixCopyrightHeader(filepath):
-  with open(filepath, "r") as f:
-    text = f.readlines()
-
-  pattern = ".*Copyright \(C\) (20[01][0-9])"
-  m = re.match(pattern, text[0])
-  if m == None:
-    m = re.match(pattern, text[1])
-  assert m
-  year = m.group(1)
-
-  fixed_text = FixCopyrightHeaderText(text, year)
-  with open(filepath, "w") as f:
-    f.write(fixed_text)
-
-def Main():
-  files = Readfile("compositor_bindings.gyp")['variables']['webkit_compositor_bindings_sources']
-  for f in files:
-    dst = Copy(f)
-    FixCopyrightHeader(dst)
-
-  variables = Readfile("compositor_bindings_tests.gyp")['variables']
-  files = variables['webkit_compositor_bindings_tests_sources']
-  for f in files:
-    dst = Copy(f)
-    FixCopyrightHeader(dst)
-
-if __name__ == '__main__':
-  import sys
-  os.chdir(os.path.dirname(__file__))
-  sys.exit(Main())
Index: src/webkit/media/webvideoframe_impl.cc
===================================================================
--- src/webkit/media/webvideoframe_impl.cc	(revision 184497)
+++ src/webkit/media/webvideoframe_impl.cc	(working copy)
@@ -2,89 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "media/base/video_frame.h"
 #include "webkit/media/webvideoframe_impl.h"
 
-#include "base/logging.h"
-#include "media/base/video_frame.h"
-#include "third_party/WebKit/Source/WebKit/chromium/public/WebVideoFrame.h"
-
-using WebKit::WebVideoFrame;
-
 namespace webkit_media {
 
 WebVideoFrameImpl::WebVideoFrameImpl(
     scoped_refptr<media::VideoFrame> video_frame)
-    : video_frame_(video_frame) {
+    : video_frame(video_frame) {
 }
 
 WebVideoFrameImpl::~WebVideoFrameImpl() {}
 
-#define COMPILE_ASSERT_MATCHING_ENUM(webkit_name, chromium_name) \
-    COMPILE_ASSERT(int(WebKit::WebVideoFrame::webkit_name) == \
-                   int(media::VideoFrame::chromium_name), \
-                   mismatching_enums)
-COMPILE_ASSERT_MATCHING_ENUM(FormatInvalid, INVALID);
-COMPILE_ASSERT_MATCHING_ENUM(FormatRGB32, RGB32);
-COMPILE_ASSERT_MATCHING_ENUM(FormatYV12, YV12);
-COMPILE_ASSERT_MATCHING_ENUM(FormatYV16, YV16);
-COMPILE_ASSERT_MATCHING_ENUM(FormatEmpty, EMPTY);
-COMPILE_ASSERT_MATCHING_ENUM(FormatI420, I420);
-COMPILE_ASSERT_MATCHING_ENUM(FormatNativeTexture, NATIVE_TEXTURE);
-
-WebVideoFrame::Format WebVideoFrameImpl::format() const {
-  if (video_frame_.get())
-    return static_cast<WebVideoFrame::Format>(video_frame_->format());
-  return WebVideoFrame::FormatInvalid;
-}
-
-unsigned WebVideoFrameImpl::planes() const {
-  if (!video_frame_.get())
-    return 0;
-  switch (video_frame_->format()) {
-    case media::VideoFrame::RGB32:
-      return 1;
-    case media::VideoFrame::YV12:
-    case media::VideoFrame::YV16:
-      return 3;
-    case media::VideoFrame::INVALID:
-    case media::VideoFrame::EMPTY:
-    case media::VideoFrame::I420:
-      break;
-    case media::VideoFrame::NATIVE_TEXTURE:
-      return 0;
-  }
-  NOTREACHED();
-  return 0;
-}
-
-const void* WebVideoFrameImpl::data(unsigned plane) const {
-  if (!video_frame_.get() || format() == FormatNativeTexture)
-    return NULL;
-  return static_cast<const void*>(video_frame_->data(plane));
-}
-
-unsigned WebVideoFrameImpl::textureId() const {
-  if (!video_frame_.get() || format() != FormatNativeTexture)
-    return 0;
-  return video_frame_->texture_id();
-}
-
-unsigned WebVideoFrameImpl::textureTarget() const {
-  if (!video_frame_.get() || format() != FormatNativeTexture)
-    return 0;
-  return video_frame_->texture_target();
-}
-
-WebKit::WebRect WebVideoFrameImpl::visibleRect() const {
-  if (!video_frame_.get())
-    return WebKit::WebRect(0, 0, 0, 0);
-  return WebKit::WebRect(video_frame_->visible_rect());
-}
-
-WebKit::WebSize WebVideoFrameImpl::textureSize() const {
-  if (!video_frame_.get() || format() != FormatNativeTexture)
-    return WebKit::WebSize(0, 0);
-  return WebKit::WebSize(video_frame_->coded_size());
-}
-
 }  // namespace webkit_media
Index: src/webkit/media/webmediaplayer_ms.h
===================================================================
--- src/webkit/media/webmediaplayer_ms.h	(revision 184497)
+++ src/webkit/media/webmediaplayer_ms.h	(working copy)
@@ -17,6 +17,7 @@
 namespace WebKit {
 class WebFrame;
 class WebMediaPlayerClient;
+class WebVideoFrame;
 }
 
 namespace media {
Index: src/webkit/media/android/webmediaplayer_manager_android.cc
===================================================================
--- src/webkit/media/android/webmediaplayer_manager_android.cc	(revision 184497)
+++ src/webkit/media/android/webmediaplayer_manager_android.cc	(working copy)
@@ -14,6 +14,12 @@
 }
 
 WebMediaPlayerManagerAndroid::~WebMediaPlayerManagerAndroid() {
+  std::map<int32, WebMediaPlayerAndroid*>::iterator player_it;
+  for (player_it = media_players_.begin();
+      player_it != media_players_.end(); ++player_it) {
+    WebMediaPlayerAndroid* player = player_it->second;
+    player->Detach();
+  }
 }
 
 int WebMediaPlayerManagerAndroid::RegisterMediaPlayer(
Index: src/webkit/media/android/webmediaplayer_android.cc
===================================================================
--- src/webkit/media/android/webmediaplayer_android.cc	(revision 184497)
+++ src/webkit/media/android/webmediaplayer_android.cc	(working copy)
@@ -7,6 +7,7 @@
 #include "base/file_path.h"
 #include "base/logging.h"
 #include "media/base/android/media_player_bridge.h"
+#include "media/base/video_frame.h"
 #include "net/base/mime_util.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebMediaPlayerClient.h"
 #include "webkit/media/android/stream_texture_factory_android.h"
@@ -359,6 +360,13 @@
 }
 
 void WebMediaPlayerAndroid::WillDestroyCurrentMessageLoop() {
+  if (manager_)
+    manager_->UnregisterMediaPlayer(player_id_);
+  Detach();
+  main_loop_ = NULL;
+}
+
+void WebMediaPlayerAndroid::Detach() {
   Destroy();
 
   if (stream_id_) {
@@ -368,11 +376,7 @@
 
   video_frame_.reset();
 
-  if (manager_)
-    manager_->UnregisterMediaPlayer(player_id_);
-
   manager_ = NULL;
-  main_loop_ = NULL;
 }
 
 void WebMediaPlayerAndroid::ReallocateVideoFrame() {
Index: src/webkit/media/android/webmediaplayer_android.h
===================================================================
--- src/webkit/media/android/webmediaplayer_android.h	(revision 184497)
+++ src/webkit/media/android/webmediaplayer_android.h	(working copy)
@@ -121,6 +121,9 @@
   // Method inherited from DestructionObserver.
   virtual void WillDestroyCurrentMessageLoop() OVERRIDE;
 
+  // Detach the player from its manager.
+  void Detach();
+
  protected:
   // Construct a WebMediaPlayerAndroid object with reference to the
   // client, manager and stream texture factory.
Index: src/webkit/media/android/webmediaplayer_impl_android.cc
===================================================================
--- src/webkit/media/android/webmediaplayer_impl_android.cc	(revision 184497)
+++ src/webkit/media/android/webmediaplayer_impl_android.cc	(working copy)
@@ -34,7 +34,8 @@
 }
 
 WebMediaPlayerImplAndroid::~WebMediaPlayerImplAndroid() {
-  Destroy();
+  if (proxy_)
+    proxy_->DestroyPlayer(player_id());
 }
 
 void WebMediaPlayerImplAndroid::enterFullscreen() {
@@ -125,7 +126,6 @@
 }
 
 void WebMediaPlayerImplAndroid::Destroy() {
-  proxy_->DestroyPlayer(player_id());
   proxy_ = NULL;
 }
 
Index: src/webkit/media/android/webmediaplayer_impl_android.h
===================================================================
--- src/webkit/media/android/webmediaplayer_impl_android.h	(revision 184497)
+++ src/webkit/media/android/webmediaplayer_impl_android.h	(working copy)
@@ -12,7 +12,6 @@
 #include "base/basictypes.h"
 #include "base/memory/scoped_ptr.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebMediaPlayer.h"
-#include "third_party/WebKit/Source/WebKit/chromium/public/WebVideoFrame.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebSize.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebURL.h"
 #include "webkit/media/android/webmediaplayer_android.h"
Index: src/webkit/media/android/webmediaplayer_in_process_android.h
===================================================================
--- src/webkit/media/android/webmediaplayer_in_process_android.h	(revision 184497)
+++ src/webkit/media/android/webmediaplayer_in_process_android.h	(working copy)
@@ -13,7 +13,6 @@
 #include "base/memory/scoped_ptr.h"
 #include "media/base/android/cookie_getter.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebMediaPlayer.h"
-#include "third_party/WebKit/Source/WebKit/chromium/public/WebVideoFrame.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebSize.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebURL.h"
 #include "webkit/media/android/webmediaplayer_android.h"
Index: src/webkit/media/webvideoframe_impl.h
===================================================================
--- src/webkit/media/webvideoframe_impl.h	(revision 184497)
+++ src/webkit/media/webvideoframe_impl.h	(working copy)
@@ -6,45 +6,26 @@
 #define WEBKIT_MEDIA_WEBVIDEOFRAME_IMPL_H_
 
 #include "base/compiler_specific.h"
-#include "media/base/video_frame.h"
-#include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebRect.h"
-#include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebSize.h"
+#include "base/memory/ref_counted.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebVideoFrame.h"
 
+namespace media {
+class VideoFrame;
+}
+
 namespace webkit_media {
 
 class WebVideoFrameImpl : public WebKit::WebVideoFrame {
  public:
-  // This converts a WebKit::WebVideoFrame to a media::VideoFrame.
-  static media::VideoFrame* toVideoFrame(
-      WebKit::WebVideoFrame* web_video_frame);
-
   WebVideoFrameImpl(scoped_refptr<media::VideoFrame> video_frame);
   virtual ~WebVideoFrameImpl();
-  virtual WebVideoFrame::Format format() const;
-  virtual unsigned planes() const;
-  virtual const void* data(unsigned plane) const;
-  virtual unsigned textureId() const;
-  virtual unsigned textureTarget() const;
-  virtual WebKit::WebRect visibleRect() const;
-  virtual WebKit::WebSize textureSize() const;
 
+  scoped_refptr<media::VideoFrame> video_frame;
+
  private:
-  scoped_refptr<media::VideoFrame> video_frame_;
   DISALLOW_COPY_AND_ASSIGN(WebVideoFrameImpl);
 };
 
-// TODO(skaslev) This is temporarily inline pending the removal of
-// WebKit::WebVideoFrame and WebVideoFrameImpl which are currently unused.
-inline media::VideoFrame* WebVideoFrameImpl::toVideoFrame(
-    WebKit::WebVideoFrame* web_video_frame) {
-  WebVideoFrameImpl* wrapped_frame =
-      static_cast<WebVideoFrameImpl*>(web_video_frame);
-  if (wrapped_frame)
-    return wrapped_frame->video_frame_.get();
-  return NULL;
-}
-
 }  // namespace webkit_media
 
 #endif  // WEBKIT_MEDIA_WEBVIDEOFRAME_IMPL_H_
Index: src/webkit/media/webmediaplayer_impl.cc
===================================================================
--- src/webkit/media/webmediaplayer_impl.cc	(revision 184497)
+++ src/webkit/media/webmediaplayer_impl.cc	(working copy)
@@ -25,7 +25,6 @@
 #include "media/filters/chunk_demuxer.h"
 #include "media/filters/video_renderer_base.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebRuntimeFeatures.h"
-#include "third_party/WebKit/Source/WebKit/chromium/public/WebVideoFrame.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebView.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebRect.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/platform/WebSize.h"
@@ -645,9 +644,8 @@
     UMA_HISTOGRAM_BOOLEAN("Media.AcceleratedCompositingActive", true);
   }
   if (web_video_frame) {
-    scoped_refptr<media::VideoFrame> video_frame(
-        WebVideoFrameImpl::toVideoFrame(web_video_frame));
-    proxy_->PutCurrentFrame(video_frame);
+    WebVideoFrameImpl* impl = static_cast<WebVideoFrameImpl*>(web_video_frame);
+    proxy_->PutCurrentFrame(impl->video_frame);
     delete web_video_frame;
   } else {
     proxy_->PutCurrentFrame(NULL);
Index: src/webkit/plugins/webview_plugin.cc
===================================================================
--- src/webkit/plugins/webview_plugin.cc	(revision 184497)
+++ src/webkit/plugins/webview_plugin.cc	(working copy)
@@ -127,13 +127,6 @@
 
   paint_rect.Offset(-rect_.x(), -rect_.y());
 
-  float content_scale = 1.0f / GetPageScaleFactor();
-  paint_rect.SetRect(
-      ceil(content_scale * paint_rect.x()),
-      ceil(content_scale * paint_rect.y()),
-      ceil(content_scale * paint_rect.width()),
-      ceil(content_scale * paint_rect.height()));
-
   canvas->translate(SkIntToScalar(rect_.x()), SkIntToScalar(rect_.y()));
   canvas->save();
 
@@ -149,10 +142,7 @@
     const WebVector<WebRect>& cut_out_rects, bool is_visible) {
   if (static_cast<gfx::Rect>(frame_rect) != rect_) {
     rect_ = frame_rect;
-
-    float content_scale = 1.0f / GetPageScaleFactor();
-    web_view_->resize(WebSize(content_scale * frame_rect.width,
-                              content_scale * frame_rect.height));
+    web_view_->resize(WebSize(frame_rect.width, frame_rect.height));
   }
 }
 
@@ -250,13 +240,4 @@
   WebFrameClient::didReceiveResponse(frame, identifier, response);
 }
 
-float WebViewPlugin::GetPageScaleFactor() {
-  if (container_) {
-    WebFrame* frame = container_->element().document().frame();
-    WebView* top_view = frame->top()->view();
-    return top_view->pageScaleFactor();
-  }
-  return 1.0f;
-}
-
 }  // namespace webkit
Index: src/webkit/plugins/webview_plugin.h
===================================================================
--- src/webkit/plugins/webview_plugin.h	(revision 184497)
+++ src/webkit/plugins/webview_plugin.h	(working copy)
@@ -143,9 +143,6 @@
   friend class base::DeleteHelper<WebViewPlugin>;
   virtual ~WebViewPlugin();
 
-  // Get the scale factor for the current page.
-  float GetPageScaleFactor();
-
   Delegate* delegate_;
   // Destroys itself.
   WebKit::WebCursorInfo current_cursor_;
Index: src/gpu/command_buffer/common/command_buffer.h
===================================================================
--- src/gpu/command_buffer/common/command_buffer.h	(revision 184497)
+++ src/gpu/command_buffer/common/command_buffer.h	(working copy)
@@ -83,6 +83,13 @@
   // Returns the last state without synchronizing with the service.
   virtual State GetLastState() = 0;
 
+  // Returns the last token without synchronizing with the service. Note that
+  // while you could just call GetLastState().token, GetLastState needs to be
+  // fast as it is called for every command where GetLastToken is only called
+  // by code that needs to know the last token so it can be slower but more up
+  // to date than GetLastState.
+  virtual int32 GetLastToken() = 0;
+
   // The writer calls this to update its put offset. This ensures the reader
   // sees the latest added commands, and will eventually process them. On the
   // service side, commands are processed up to the given put_offset before
Index: src/gpu/command_buffer/common/gles2_cmd_utils.h
===================================================================
--- src/gpu/command_buffer/common/gles2_cmd_utils.h	(revision 184497)
+++ src/gpu/command_buffer/common/gles2_cmd_utils.h	(working copy)
@@ -109,16 +109,16 @@
 
   // Computes the size of an image row including alignment padding
   static bool ComputeImagePaddedRowSize(
-    int width, int format, int type, int unpack_alignment,
-    uint32* padded_row_size);
+      int width, int format, int type, int unpack_alignment,
+      uint32* padded_row_size);
 
   // Computes the size of image data for TexImage2D and TexSubImage2D.
   // Optionally the unpadded and padded row sizes can be returned. If height < 2
   // then the padded_row_size will be the same as the unpadded_row_size since
   // padding is not necessary.
   static bool ComputeImageDataSizes(
-    int width, int height, int format, int type, int unpack_alignment,
-    uint32* size, uint32* unpadded_row_size, uint32* padded_row_size);
+      int width, int height, int format, int type, int unpack_alignment,
+      uint32* size, uint32* unpadded_row_size, uint32* padded_row_size);
 
   static size_t RenderbufferBytesPerPixel(int format);
 
Index: src/gpu/command_buffer/common/command_buffer_mock.h
===================================================================
--- src/gpu/command_buffer/common/command_buffer_mock.h	(revision 184497)
+++ src/gpu/command_buffer/common/command_buffer_mock.h	(working copy)
@@ -24,6 +24,7 @@
   MOCK_METHOD0(Initialize, bool());
   MOCK_METHOD0(GetState, State());
   MOCK_METHOD0(GetLastState, State());
+  MOCK_METHOD0(GetLastToken, int32());
   MOCK_METHOD1(Flush, void(int32 put_offset));
   MOCK_METHOD2(FlushSync, State(int32 put_offset, int32 last_known_get));
   MOCK_METHOD1(SetGetBuffer, void(int32 transfer_buffer_id));
Index: src/gpu/command_buffer/client/client_test_helper.h
===================================================================
--- src/gpu/command_buffer/client/client_test_helper.h	(revision 184497)
+++ src/gpu/command_buffer/client/client_test_helper.h	(working copy)
@@ -29,6 +29,7 @@
   virtual bool Initialize() OVERRIDE;
   virtual State GetState() OVERRIDE;
   virtual State GetLastState() OVERRIDE;
+  virtual int32 GetLastToken() OVERRIDE;
   virtual State FlushSync(int32 put_offset, int32 last_known_get) OVERRIDE;
   virtual void SetGetBuffer(int transfer_buffer_id) OVERRIDE;
   virtual void SetGetOffset(int32 get_offset) OVERRIDE;
Index: src/gpu/command_buffer/client/cmd_buffer_helper.h
===================================================================
--- src/gpu/command_buffer/client/cmd_buffer_helper.h	(revision 184497)
+++ src/gpu/command_buffer/client/cmd_buffer_helper.h	(working copy)
@@ -124,7 +124,7 @@
   }
 
   int32 last_token_read() const {
-    return command_buffer_->GetLastState().token;
+    return command_buffer_->GetLastToken();
   }
 
   int32 get_offset() const {
Index: src/gpu/command_buffer/client/client_test_helper.cc
===================================================================
--- src/gpu/command_buffer/client/client_test_helper.cc	(revision 184497)
+++ src/gpu/command_buffer/client/client_test_helper.cc	(working copy)
@@ -30,6 +30,10 @@
   return state_;
 }
 
+int32 MockCommandBufferBase::GetLastToken() {
+  return state_.token;
+}
+
 void MockCommandBufferBase::SetGetOffset(int32 get_offset) {
   state_.get_offset = get_offset;
 }
Index: src/gpu/command_buffer/client/fenced_allocator.cc
===================================================================
--- src/gpu/command_buffer/client/fenced_allocator.cc	(revision 184497)
+++ src/gpu/command_buffer/client/fenced_allocator.cc	(working copy)
@@ -85,6 +85,7 @@
 
 // Gets the max of the size of the blocks marked as free.
 unsigned int FencedAllocator::GetLargestFreeSize() {
+  FreeUnused();
   unsigned int max_size = 0;
   for (unsigned int i = 0; i < blocks_.size(); ++i) {
     Block &block = blocks_[i];
Index: src/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc
===================================================================
--- src/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc	(revision 184497)
+++ src/gpu/command_buffer/service/gles2_cmd_decoder_unittest.cc	(working copy)
@@ -15,6 +15,7 @@
 #include "gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h"
 #include "gpu/command_buffer/service/image_manager.h"
 #include "gpu/command_buffer/service/mailbox_manager.h"
+#include "gpu/command_buffer/service/mocks.h"
 #include "gpu/command_buffer/service/program_manager.h"
 #include "gpu/command_buffer/service/stream_texture_manager_mock.h"
 #include "gpu/command_buffer/service/stream_texture_mock.h"
@@ -8112,6 +8113,260 @@
   info->SetAsyncTransferState(scoped_ptr<gfx::AsyncPixelTransferState>());
 }
 
+namespace {
+
+class SizeOnlyMemoryTracker : public MemoryTracker {
+ public:
+  SizeOnlyMemoryTracker() {
+    // These are the default textures. 1 for TEXTURE_2D and 6 faces for
+    // TEXTURE_CUBE_MAP.
+    const size_t kInitialUnmanagedPoolSize = 7 * 4;
+    const size_t kInitialManagedPoolSize = 0;
+    pool_infos_[MemoryTracker::kUnmanaged].initial_size =
+        kInitialUnmanagedPoolSize;
+    pool_infos_[MemoryTracker::kManaged].initial_size =
+        kInitialManagedPoolSize;
+  }
+
+  // Ensure a certain amount of GPU memory is free. Returns true on success.
+  MOCK_METHOD1(EnsureGPUMemoryAvailable, bool(size_t size_needed));
+
+  virtual void TrackMemoryAllocatedChange(
+      size_t old_size, size_t new_size, Pool pool) {
+    PoolInfo& info = pool_infos_[pool];
+    info.size += new_size - old_size;
+  }
+
+  size_t GetPoolSize(Pool pool) {
+    const PoolInfo& info = pool_infos_[pool];
+    return info.size - info.initial_size;
+  }
+
+ private:
+  virtual ~SizeOnlyMemoryTracker() {
+  }
+  struct PoolInfo {
+    PoolInfo()
+        : initial_size(0),
+          size(0) {
+    }
+    size_t initial_size;
+    size_t size;
+  };
+  std::map<Pool, PoolInfo> pool_infos_;
+};
+
+}  // anonymous namespace.
+
+TEST_F(GLES2DecoderManualInitTest, MemoryTrackerInitialSize) {
+  scoped_refptr<SizeOnlyMemoryTracker> memory_tracker =
+      new SizeOnlyMemoryTracker();
+  set_memory_tracker(memory_tracker.get());
+  InitDecoder(
+      "",      // extensions
+      false,   // has alpha
+      false,   // has depth
+      false,   // has stencil
+      false,   // request alpha
+      false,   // request depth
+      false,   // request stencil
+      true);   // bind generates resource
+  // Expect that initial size - size is 0.
+  EXPECT_EQ(0u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+  EXPECT_EQ(0u, memory_tracker->GetPoolSize(MemoryTracker::kManaged));
+}
+
+TEST_F(GLES2DecoderManualInitTest, MemoryTrackerTexImage2D) {
+  scoped_refptr<SizeOnlyMemoryTracker> memory_tracker =
+      new SizeOnlyMemoryTracker();
+  set_memory_tracker(memory_tracker.get());
+  InitDecoder(
+      "",      // extensions
+      false,   // has alpha
+      false,   // has depth
+      false,   // has stencil
+      false,   // request alpha
+      false,   // request depth
+      false,   // request stencil
+      true);   // bind generates resource
+  DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(true))
+      .RetiresOnSaturation();
+  DoTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 8, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+               kSharedMemoryId, kSharedMemoryOffset);
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(64))
+      .WillOnce(Return(true))
+      .RetiresOnSaturation();
+  DoTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+               kSharedMemoryId, kSharedMemoryOffset);
+  EXPECT_EQ(64u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+  EXPECT_EQ(GL_NO_ERROR, GetGLError());
+  // Check we get out of memory and no call to glTexImage2D if Ensure fails.
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(64))
+      .WillOnce(Return(false))
+      .RetiresOnSaturation();
+  TexImage2D cmd;
+  cmd.Init(GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE,
+           kSharedMemoryId, kSharedMemoryOffset);
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(GL_OUT_OF_MEMORY, GetGLError());
+  EXPECT_EQ(64u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+}
+
+TEST_F(GLES2DecoderManualInitTest, MemoryTrackerTexStorage2DEXT) {
+  scoped_refptr<SizeOnlyMemoryTracker> memory_tracker =
+      new SizeOnlyMemoryTracker();
+  set_memory_tracker(memory_tracker.get());
+  InitDecoder(
+      "",      // extensions
+      false,   // has alpha
+      false,   // has depth
+      false,   // has stencil
+      false,   // request alpha
+      false,   // request depth
+      false,   // request stencil
+      true);   // bind generates resource
+  DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
+  // Check we get out of memory and no call to glTexStorage2DEXT
+  // if Ensure fails.
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(false))
+      .RetiresOnSaturation();
+  TexStorage2DEXT cmd;
+  cmd.Init(GL_TEXTURE_2D, 1, GL_RGBA8, 8, 4);
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(0u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+  EXPECT_EQ(GL_OUT_OF_MEMORY, GetGLError());
+}
+
+TEST_F(GLES2DecoderManualInitTest, MemoryTrackerCopyTexImage2D) {
+  GLenum target = GL_TEXTURE_2D;
+  GLint level = 0;
+  GLenum internal_format = GL_RGBA;
+  GLsizei width = 4;
+  GLsizei height = 8;
+  GLint border = 0;
+  scoped_refptr<SizeOnlyMemoryTracker> memory_tracker =
+      new SizeOnlyMemoryTracker();
+  set_memory_tracker(memory_tracker.get());
+  InitDecoder(
+      "",      // extensions
+      true,    // has alpha
+      false,   // has depth
+      false,   // has stencil
+      true,    // request alpha
+      false,   // request depth
+      false,   // request stencil
+      true);   // bind generates resource
+  DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(true))
+      .RetiresOnSaturation();
+  EXPECT_CALL(*gl_, GetError())
+      .WillOnce(Return(GL_NO_ERROR))
+      .WillOnce(Return(GL_NO_ERROR))
+      .RetiresOnSaturation();
+  EXPECT_CALL(*gl_, CopyTexImage2D(
+      target, level, internal_format, 0, 0, width, height, border))
+      .Times(1)
+      .RetiresOnSaturation();
+  CopyTexImage2D cmd;
+  cmd.Init(target, level, internal_format, 0, 0, width, height, border);
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+  EXPECT_EQ(GL_NO_ERROR, GetGLError());
+  // Check we get out of memory and no call to glCopyTexImage2D if Ensure fails.
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(false))
+      .RetiresOnSaturation();
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(GL_OUT_OF_MEMORY, GetGLError());
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+}
+
+TEST_F(GLES2DecoderManualInitTest, MemoryTrackerRenderbufferStorage) {
+  scoped_refptr<SizeOnlyMemoryTracker> memory_tracker =
+      new SizeOnlyMemoryTracker();
+  set_memory_tracker(memory_tracker.get());
+  InitDecoder(
+      "",      // extensions
+      false,   // has alpha
+      false,   // has depth
+      false,   // has stencil
+      false,   // request alpha
+      false,   // request depth
+      false,   // request stencil
+      true);   // bind generates resource
+  DoBindRenderbuffer(GL_RENDERBUFFER, client_renderbuffer_id_,
+                    kServiceRenderbufferId);
+  EXPECT_CALL(*gl_, GetError())
+      .WillOnce(Return(GL_NO_ERROR))
+      .WillOnce(Return(GL_NO_ERROR))
+      .RetiresOnSaturation();
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(true))
+      .RetiresOnSaturation();
+  EXPECT_CALL(*gl_, RenderbufferStorageEXT(
+      GL_RENDERBUFFER, GL_RGBA, 8, 4))
+      .Times(1)
+      .RetiresOnSaturation();
+  RenderbufferStorage cmd;
+  cmd.Init(GL_RENDERBUFFER, GL_RGBA4, 8, 4);
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(GL_NO_ERROR, GetGLError());
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+  // Check we get out of memory and no call to glRenderbufferStorage if Ensure
+  // fails.
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(false))
+      .RetiresOnSaturation();
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(GL_OUT_OF_MEMORY, GetGLError());
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kUnmanaged));
+}
+
+TEST_F(GLES2DecoderManualInitTest, MemoryTrackerBufferData) {
+  scoped_refptr<SizeOnlyMemoryTracker> memory_tracker =
+      new SizeOnlyMemoryTracker();
+  set_memory_tracker(memory_tracker.get());
+  InitDecoder(
+      "",      // extensions
+      false,   // has alpha
+      false,   // has depth
+      false,   // has stencil
+      false,   // request alpha
+      false,   // request depth
+      false,   // request stencil
+      true);   // bind generates resource
+  DoBindBuffer(GL_ARRAY_BUFFER, client_buffer_id_,
+               kServiceBufferId);
+  EXPECT_CALL(*gl_, GetError())
+      .WillOnce(Return(GL_NO_ERROR))
+      .WillOnce(Return(GL_NO_ERROR))
+      .RetiresOnSaturation();
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(true))
+      .RetiresOnSaturation();
+  EXPECT_CALL(*gl_, BufferData(GL_ARRAY_BUFFER, 128, _, GL_STREAM_DRAW))
+      .Times(1)
+      .RetiresOnSaturation();
+  BufferData cmd;
+  cmd.Init(GL_ARRAY_BUFFER, 128, 0, 0, GL_STREAM_DRAW);
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(GL_NO_ERROR, GetGLError());
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kManaged));
+  // Check we get out of memory and no call to glBufferData if Ensure
+  // fails.
+  EXPECT_CALL(*memory_tracker, EnsureGPUMemoryAvailable(128))
+      .WillOnce(Return(false))
+      .RetiresOnSaturation();
+  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
+  EXPECT_EQ(GL_OUT_OF_MEMORY, GetGLError());
+  EXPECT_EQ(128u, memory_tracker->GetPoolSize(MemoryTracker::kManaged));
+}
+
 // TODO(gman): Complete this test.
 // TEST_F(GLES2DecoderTest, CompressedTexImage2DGLError) {
 // }
Index: src/gpu/command_buffer/service/memory_program_cache.h
===================================================================
--- src/gpu/command_buffer/service/memory_program_cache.h	(revision 184497)
+++ src/gpu/command_buffer/service/memory_program_cache.h	(working copy)
@@ -62,12 +62,11 @@
     const ShaderTranslator::VariableMap attrib_map_1;
     const ShaderTranslator::VariableMap uniform_map_1;
 
-   protected:
+   private:
     friend class base::RefCounted<ProgramCacheValue>;
 
     ~ProgramCacheValue();
 
-   private:
     DISALLOW_COPY_AND_ASSIGN(ProgramCacheValue);
   };
 
Index: src/gpu/command_buffer/service/gles2_cmd_decoder.cc
===================================================================
--- src/gpu/command_buffer/service/gles2_cmd_decoder.cc	(revision 184497)
+++ src/gpu/command_buffer/service/gles2_cmd_decoder.cc	(working copy)
@@ -665,6 +665,18 @@
     return vertex_array_manager_.get();
   }
 
+  MemoryTracker* memory_tracker() {
+    return group_->memory_tracker();
+  }
+
+  bool EnsureGPUMemoryAvailable(size_t estimated_size) {
+    MemoryTracker* tracker = memory_tracker();
+    if (tracker) {
+      return tracker->EnsureGPUMemoryAvailable(estimated_size);
+    }
+    return true;
+  }
+
   bool IsOffscreenBufferMultisampled() const {
     return offscreen_target_samples_ > 1;
   }
@@ -1832,8 +1844,7 @@
 
 Texture::Texture(GLES2DecoderImpl* decoder)
     : decoder_(decoder),
-      memory_tracker_(decoder->GetContextGroup()->memory_tracker(),
-                      MemoryTracker::kUnmanaged),
+      memory_tracker_(decoder->memory_tracker(), MemoryTracker::kUnmanaged),
       bytes_allocated_(0),
       id_(0) {
 }
@@ -1868,8 +1879,7 @@
   memory_tracker_.TrackMemAlloc(bytes_allocated_);
 }
 
-bool Texture::AllocateStorage(const gfx::Size& size, GLenum format,
-                              bool zero) {
+bool Texture::AllocateStorage(const gfx::Size& size, GLenum format, bool zero) {
   DCHECK_NE(id_, 0u);
   ScopedGLErrorSuppressor suppressor(decoder_);
   ScopedTexture2DBinder binder(decoder_, id_);
@@ -1878,6 +1888,10 @@
       size.width(), size.height(), format, GL_UNSIGNED_BYTE, 8, &image_size,
       NULL, NULL);
 
+  if (!memory_tracker_.EnsureGPUMemoryAvailable(image_size)) {
+    return false;
+  }
+
   scoped_array<char> zero_data;
   if (zero) {
     zero_data.reset(new char[image_size]);
@@ -1934,8 +1948,7 @@
 
 RenderBuffer::RenderBuffer(GLES2DecoderImpl* decoder)
     : decoder_(decoder),
-      memory_tracker_(decoder->GetContextGroup()->memory_tracker(),
-                      MemoryTracker::kUnmanaged),
+      memory_tracker_(decoder->memory_tracker(), MemoryTracker::kUnmanaged),
       bytes_allocated_(0),
       id_(0) {
 }
@@ -1957,6 +1970,17 @@
                                    GLsizei samples) {
   ScopedGLErrorSuppressor suppressor(decoder_);
   ScopedRenderBufferBinder binder(decoder_, id_);
+
+  uint32 estimated_size = 0;
+  if (!RenderbufferManager::ComputeEstimatedRenderbufferSize(
+      size.width(), size.height(), samples, format, &estimated_size)) {
+    return false;
+  }
+
+  if (!memory_tracker_.EnsureGPUMemoryAvailable(estimated_size)) {
+    return false;
+  }
+
   if (samples <= 1) {
     glRenderbufferStorageEXT(GL_RENDERBUFFER,
                              format,
@@ -1980,9 +2004,7 @@
   bool success = glGetError() == GL_NO_ERROR;
   if (success) {
     memory_tracker_.TrackMemFree(bytes_allocated_);
-    bytes_allocated_ =
-        size.width() * size.height() * samples *
-        GLES2Util::RenderbufferBytesPerPixel(format);
+    bytes_allocated_ = estimated_size;
     memory_tracker_.TrackMemAlloc(bytes_allocated_);
   }
   return success;
@@ -2713,6 +2735,9 @@
     return false;
   }
 
+  if (engine() && query_manager_.get())
+    query_manager_->ProcessPendingTransferQueries();
+
   // TODO(epenner): Is there a better place to do this? Transfers
   // can complete any time we yield the main thread. So we *must*
   // process transfers after any such yield, before resuming.
@@ -2731,6 +2756,9 @@
     framebuffer_manager()->IncFramebufferStateChangeCount();
   }
 
+  if (workarounds().flush_on_context_switch)
+    glFlush();
+
   return true;
 }
 
@@ -2984,11 +3012,13 @@
 }
 
 uint32 GLES2DecoderImpl::GetTextureUploadCount() {
-  return texture_upload_count_;
+  return texture_upload_count_ +
+      async_pixel_transfer_delegate_->GetTextureUploadCount();
 }
 
 base::TimeDelta GLES2DecoderImpl::GetTotalTextureUploadTime() {
-  return total_texture_upload_time_;
+  return total_texture_upload_time_ +
+      async_pixel_transfer_delegate_->GetTotalTextureUploadTime();
 }
 
 base::TimeDelta GLES2DecoderImpl::GetTotalProcessingCommandsTime() {
@@ -4805,39 +4835,39 @@
       GetRenderbufferInfoForTarget(GL_RENDERBUFFER);
   if (!renderbuffer) {
     SetGLError(GL_INVALID_OPERATION,
-               "glGetRenderbufferStorageMultisample", "no renderbuffer bound");
+               "glRenderbufferStorageMultisampleEXT", "no renderbuffer bound");
     return;
   }
 
   if (samples > renderbuffer_manager()->max_samples()) {
     SetGLError(GL_INVALID_VALUE,
-               "glGetRenderbufferStorageMultisample", "samples too large");
+               "glRenderbufferStorageMultisampleEXT", "samples too large");
     return;
   }
 
   if (width > renderbuffer_manager()->max_renderbuffer_size() ||
       height > renderbuffer_manager()->max_renderbuffer_size()) {
     SetGLError(GL_INVALID_VALUE,
-               "glGetRenderbufferStorageMultisample", "size too large");
+               "glRenderbufferStorageMultisample", "dimensions too large");
     return;
   }
 
-  GLenum impl_format = internalformat;
-  if (gfx::GetGLImplementation() != gfx::kGLImplementationEGLGLES2) {
-    switch (impl_format) {
-      case GL_DEPTH_COMPONENT16:
-        impl_format = GL_DEPTH_COMPONENT;
-        break;
-      case GL_RGBA4:
-      case GL_RGB5_A1:
-        impl_format = GL_RGBA;
-        break;
-      case GL_RGB565:
-        impl_format = GL_RGB;
-        break;
-    }
+  uint32 estimated_size = 0;
+  if (!RenderbufferManager::ComputeEstimatedRenderbufferSize(
+      width, height, samples, internalformat, &estimated_size)) {
+    SetGLError(GL_OUT_OF_MEMORY,
+               "glRenderbufferStorageMultsampleEXT", "dimensions too large");
+    return;
   }
 
+  if (!EnsureGPUMemoryAvailable(estimated_size)) {
+    SetGLError(GL_OUT_OF_MEMORY,
+               "glRenderbufferStorageMultsampleEXT", "out of memory");
+    return;
+  }
+
+  GLenum impl_format = RenderbufferManager::
+      InternalRenderbufferFormatToImplFormat(internalformat);
   CopyRealGLErrorsToWrapper();
   if (IsAngle()) {
     glRenderbufferStorageMultisampleANGLE(
@@ -4862,42 +4892,42 @@
       GetRenderbufferInfoForTarget(GL_RENDERBUFFER);
   if (!renderbuffer) {
     SetGLError(GL_INVALID_OPERATION,
-               "glGetRenderbufferStorage", "no renderbuffer bound");
+               "glRenderbufferStorage", "no renderbuffer bound");
     return;
   }
 
   if (width > renderbuffer_manager()->max_renderbuffer_size() ||
       height > renderbuffer_manager()->max_renderbuffer_size()) {
     SetGLError(GL_INVALID_VALUE,
-               "glGetRenderbufferStorage", "size too large");
+               "glRenderbufferStorage", "dimensions too large");
     return;
   }
 
-  GLenum impl_format = internalformat;
-  if (gfx::GetGLImplementation() != gfx::kGLImplementationEGLGLES2) {
-    switch (impl_format) {
-      case GL_DEPTH_COMPONENT16:
-        impl_format = GL_DEPTH_COMPONENT;
-        break;
-      case GL_RGBA4:
-      case GL_RGB5_A1:
-        impl_format = GL_RGBA;
-        break;
-      case GL_RGB565:
-        impl_format = GL_RGB;
-        break;
-    }
+  uint32 estimated_size = 0;
+  if (!RenderbufferManager::ComputeEstimatedRenderbufferSize(
+      width, height, 1, internalformat, &estimated_size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glRenderbufferStorage",
+               "dimensions too large");
+    return;
   }
 
+  if (!EnsureGPUMemoryAvailable(estimated_size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glRenderbufferStorage", "out of memory");
+    return;
+  }
+
   CopyRealGLErrorsToWrapper();
-  glRenderbufferStorageEXT(target, impl_format, width, height);
+  glRenderbufferStorageEXT(
+      target, RenderbufferManager::
+          InternalRenderbufferFormatToImplFormat(internalformat),
+      width, height);
   GLenum error = PeekGLError();
   if (error == GL_NO_ERROR) {
     // TODO(gman): If tetxures tracked which framebuffers they were attached to
     // we could just mark those framebuffers as not complete.
     framebuffer_manager()->IncFramebufferStateChangeCount();
     renderbuffer_manager()->SetInfo(
-        renderbuffer, 0, internalformat, width, height);
+        renderbuffer, 1, internalformat, width, height);
   }
 }
 
@@ -7114,6 +7144,12 @@
     SetGLError(GL_INVALID_VALUE, "glBufferData", "unknown buffer");
     return;
   }
+
+  if (!EnsureGPUMemoryAvailable(size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glBufferData", "out of memory");
+    return;
+  }
+
   // Clear the buffer to 0 if no initial data was passed in.
   scoped_array<int8> zero;
   if (!data) {
@@ -7465,6 +7501,11 @@
     return error::kNoError;
   }
 
+  if (!EnsureGPUMemoryAvailable(image_size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glCompressedTexImage2D", "out of memory");
+    return error::kNoError;
+  }
+
   if (info->IsAttachedToFramebuffer()) {
     clear_state_dirty_ = true;
     // TODO(gman): If textures tracked which framebuffers they were attached to
@@ -7699,6 +7740,12 @@
       width, height, border, format, type, pixels, pixels_size)) {
     return;
   }
+
+  if (!EnsureGPUMemoryAvailable(pixels_size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glTexImage2D", "out of memory");
+    return;
+  }
+
   TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);
   GLsizei tex_width = 0;
   GLsizei tex_height = 0;
@@ -7925,10 +7972,23 @@
   if ((channels_needed & (GLES2Util::kDepth | GLES2Util::kStencil)) != 0) {
     SetGLError(
         GL_INVALID_OPERATION,
-        "glCopyImage2D", "can not be used with depth or stencil textures");
+        "glCopyTexImage2D", "can not be used with depth or stencil textures");
     return;
   }
 
+  uint32 estimated_size = 0;
+  if (!GLES2Util::ComputeImageDataSizes(
+      width, height, internal_format, GL_UNSIGNED_BYTE, state_.unpack_alignment,
+      &estimated_size, NULL, NULL)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glCopyTexImage2D", "dimensions too large");
+    return;
+  }
+
+  if (!EnsureGPUMemoryAvailable(estimated_size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glCopyTexImage2D", "out of memory");
+    return;
+  }
+
   if (!CheckBoundFramebuffersValid("glCopyTexImage2D")) {
     return;
   }
@@ -9090,6 +9150,8 @@
     return error::kOutOfBounds;
   }
 
+  query_manager_->ProcessPendingTransferQueries();
+
   state_.current_query = NULL;
   return error::kNoError;
 }
@@ -9601,13 +9663,38 @@
                "glTexStorage2DEXT", "texture is immutable");
     return;
   }
+
+  GLenum format = ExtractFormatFromStorageFormat(internal_format);
+  GLenum type = ExtractTypeFromStorageFormat(internal_format);
+
+  {
+    GLsizei level_width = width;
+    GLsizei level_height = height;
+    uint32 estimated_size = 0;
+    for (int ii = 0; ii < levels; ++ii) {
+      uint32 level_size = 0;
+      if (!GLES2Util::ComputeImageDataSizes(
+          level_width, level_height, format, type, state_.unpack_alignment,
+          &estimated_size, NULL, NULL) ||
+          !SafeAddUint32(estimated_size, level_size, &estimated_size)) {
+        SetGLError(GL_OUT_OF_MEMORY,
+                   "glTexStorage2DEXT", "dimensions too large");
+        return;
+      }
+      level_width = std::max(1, level_width >> 1);
+      level_height = std::max(1, level_height >> 1);
+    }
+    if (!EnsureGPUMemoryAvailable(estimated_size)) {
+      SetGLError(GL_OUT_OF_MEMORY, "glTexStorage2DEXT", "out of memory");
+      return;
+    }
+  }
+
   CopyRealGLErrorsToWrapper();
   glTexStorage2DEXT(target, levels, GetTexInternalFormat(internal_format),
                     width, height);
   GLenum error = PeekGLError();
   if (error == GL_NO_ERROR) {
-    GLenum format = ExtractFormatFromStorageFormat(internal_format);
-    GLenum type = ExtractTypeFromStorageFormat(internal_format);
     GLsizei level_width = width;
     GLsizei level_height = height;
     for (int ii = 0; ii < levels; ++ii) {
@@ -9909,6 +9996,11 @@
     return error::kNoError;
   }
 
+  if (!EnsureGPUMemoryAvailable(pixels_size)) {
+    SetGLError(GL_OUT_OF_MEMORY, "glAsyncTexImage2DCHROMIUM", "out of memory");
+    return error::kNoError;
+  }
+
   // We know the memory/size is safe, so get the real shared memory since
   // it might need to be duped to prevent use-after-free of the memory.
   Buffer buffer = GetSharedMemoryBuffer(c.pixels_shm_id);
Index: src/gpu/command_buffer/service/command_buffer_service.cc
===================================================================
--- src/gpu/command_buffer/service/command_buffer_service.cc	(revision 184497)
+++ src/gpu/command_buffer/service/command_buffer_service.cc	(working copy)
@@ -54,6 +54,10 @@
   return GetState();
 }
 
+int32 CommandBufferService::GetLastToken() {
+  return GetState().token;
+}
+
 void CommandBufferService::UpdateState() {
   if (shared_state_) {
     CommandBufferService::State state = GetState();
@@ -144,6 +148,7 @@
 
 void CommandBufferService::SetToken(int32 token) {
   token_ = token;
+  UpdateState();
 }
 
 void CommandBufferService::SetParseError(error::Error error) {
Index: src/gpu/command_buffer/service/memory_tracking.h
===================================================================
--- src/gpu/command_buffer/service/memory_tracking.h	(revision 184497)
+++ src/gpu/command_buffer/service/memory_tracking.h	(working copy)
@@ -25,6 +25,9 @@
                                            size_t new_size,
                                            Pool pool) = 0;
 
+   // Ensure a certain amount of GPU memory is free. Returns true on success.
+   virtual bool EnsureGPUMemoryAvailable(size_t size_needed) = 0;
+
  protected:
   friend class base::RefCounted<MemoryTracker>;
   MemoryTracker() {}
@@ -76,6 +79,14 @@
     return mem_represented_at_last_update_;
   }
 
+  // Ensure a certain amount of GPU memory is free. Returns true on success.
+  bool EnsureGPUMemoryAvailable(size_t size_needed) {
+    if (memory_tracker_) {
+      return memory_tracker_->EnsureGPUMemoryAvailable(size_needed);
+    }
+    return true;
+  }
+
  private:
   MemoryTracker* memory_tracker_;
   MemoryTracker::Pool pool_;
Index: src/gpu/command_buffer/service/buffer_manager_unittest.cc
===================================================================
--- src/gpu/command_buffer/service/buffer_manager_unittest.cc	(revision 184497)
+++ src/gpu/command_buffer/service/buffer_manager_unittest.cc	(working copy)
@@ -3,27 +3,26 @@
 // found in the LICENSE file.
 
 #include "gpu/command_buffer/service/buffer_manager.h"
+#include "gpu/command_buffer/service/mocks.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gl/gl_mock.h"
 
+using ::testing::StrictMock;
+
 namespace gpu {
 namespace gles2 {
 
-class BufferManagerTest : public testing::Test {
- public:
-  BufferManagerTest() : manager_(NULL) {
-  }
-  ~BufferManagerTest() {
-    manager_.Destroy(false);
-  }
-
+class BufferManagerTestBase : public testing::Test {
  protected:
-  virtual void SetUp() {
+  void SetUpBase(MemoryTracker* memory_tracker) {
     gl_.reset(new ::testing::StrictMock< ::gfx::MockGLInterface>());
     ::gfx::GLInterface::SetGLInterface(gl_.get());
+    manager_.reset(new BufferManager(memory_tracker));
   }
 
   virtual void TearDown() {
+    manager_->Destroy(false);
+    manager_.reset();
     ::gfx::GLInterface::SetGLInterface(NULL);
     gl_.reset();
   }
@@ -34,18 +33,41 @@
 
   // Use StrictMock to make 100% sure we know how GL will be called.
   scoped_ptr< ::testing::StrictMock< ::gfx::MockGLInterface> > gl_;
-  BufferManager manager_;
+  scoped_ptr<BufferManager> manager_;
 };
 
+class BufferManagerTest : public BufferManagerTestBase {
+ protected:
+  virtual void SetUp() {
+    SetUpBase(NULL);
+  }
+};
+
+class BufferManagerMemoryTrackerTest : public BufferManagerTestBase {
+ protected:
+  virtual void SetUp() {
+    mock_memory_tracker_ = new StrictMock<MockMemoryTracker>();
+    SetUpBase(mock_memory_tracker_.get());
+  }
+
+  scoped_refptr<MockMemoryTracker> mock_memory_tracker_;
+};
+
+#define EXPECT_MEMORY_ALLOCATION_CHANGE(old_size, new_size, pool) \
+    EXPECT_CALL(*mock_memory_tracker_, \
+                TrackMemoryAllocatedChange(old_size, new_size, pool)) \
+        .Times(1) \
+        .RetiresOnSaturation() \
+
 TEST_F(BufferManagerTest, Basic) {
   const GLuint kClientBuffer1Id = 1;
   const GLuint kServiceBuffer1Id = 11;
   const GLsizeiptr kBuffer1Size = 123;
   const GLuint kClientBuffer2Id = 2;
   // Check we can create buffer.
-  manager_.CreateBufferInfo(kClientBuffer1Id, kServiceBuffer1Id);
+  manager_->CreateBufferInfo(kClientBuffer1Id, kServiceBuffer1Id);
   // Check buffer got created.
-  BufferManager::BufferInfo* info1 = manager_.GetBufferInfo(kClientBuffer1Id);
+  BufferManager::BufferInfo* info1 = manager_->GetBufferInfo(kClientBuffer1Id);
   ASSERT_TRUE(info1 != NULL);
   EXPECT_EQ(0u, GetTarget(info1));
   EXPECT_EQ(0, info1->size());
@@ -53,42 +75,64 @@
   EXPECT_FALSE(info1->IsDeleted());
   EXPECT_EQ(kServiceBuffer1Id, info1->service_id());
   GLuint client_id = 0;
-  EXPECT_TRUE(manager_.GetClientId(info1->service_id(), &client_id));
+  EXPECT_TRUE(manager_->GetClientId(info1->service_id(), &client_id));
   EXPECT_EQ(kClientBuffer1Id, client_id);
-  manager_.SetTarget(info1, GL_ELEMENT_ARRAY_BUFFER);
+  manager_->SetTarget(info1, GL_ELEMENT_ARRAY_BUFFER);
   EXPECT_EQ(static_cast<GLenum>(GL_ELEMENT_ARRAY_BUFFER), GetTarget(info1));
   // Check we and set its size.
-  manager_.SetInfo(info1, kBuffer1Size, GL_DYNAMIC_DRAW);
+  manager_->SetInfo(info1, kBuffer1Size, GL_DYNAMIC_DRAW);
   EXPECT_EQ(kBuffer1Size, info1->size());
   EXPECT_EQ(static_cast<GLenum>(GL_DYNAMIC_DRAW), info1->usage());
   // Check we get nothing for a non-existent buffer.
-  EXPECT_TRUE(manager_.GetBufferInfo(kClientBuffer2Id) == NULL);
+  EXPECT_TRUE(manager_->GetBufferInfo(kClientBuffer2Id) == NULL);
   // Check trying to a remove non-existent buffers does not crash.
-  manager_.RemoveBufferInfo(kClientBuffer2Id);
+  manager_->RemoveBufferInfo(kClientBuffer2Id);
   // Check that it gets deleted when the last reference is released.
   EXPECT_CALL(*gl_, DeleteBuffersARB(1, ::testing::Pointee(kServiceBuffer1Id)))
       .Times(1)
       .RetiresOnSaturation();
   // Check we can't get the buffer after we remove it.
-  manager_.RemoveBufferInfo(kClientBuffer1Id);
-  EXPECT_TRUE(manager_.GetBufferInfo(kClientBuffer1Id) == NULL);
+  manager_->RemoveBufferInfo(kClientBuffer1Id);
+  EXPECT_TRUE(manager_->GetBufferInfo(kClientBuffer1Id) == NULL);
 }
 
+TEST_F(BufferManagerMemoryTrackerTest, Basic) {
+  const GLuint kClientBuffer1Id = 1;
+  const GLuint kServiceBuffer1Id = 11;
+  const GLsizeiptr kBuffer1Size1 = 123;
+  const GLsizeiptr kBuffer1Size2 = 456;
+  // Check we can create buffer.
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 0, MemoryTracker::kManaged);
+  manager_->CreateBufferInfo(kClientBuffer1Id, kServiceBuffer1Id);
+  // Check buffer got created.
+  BufferManager::BufferInfo* info1 = manager_->GetBufferInfo(kClientBuffer1Id);
+  ASSERT_TRUE(info1 != NULL);
+  manager_->SetTarget(info1, GL_ELEMENT_ARRAY_BUFFER);
+  // Check we and set its size.
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, kBuffer1Size1, MemoryTracker::kManaged);
+  manager_->SetInfo(info1, kBuffer1Size1, GL_DYNAMIC_DRAW);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(kBuffer1Size1, 0, MemoryTracker::kManaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, kBuffer1Size2, MemoryTracker::kManaged);
+  manager_->SetInfo(info1, kBuffer1Size2, GL_DYNAMIC_DRAW);
+  // On delete it will get freed.
+  EXPECT_MEMORY_ALLOCATION_CHANGE(kBuffer1Size2, 0, MemoryTracker::kManaged);
+}
+
 TEST_F(BufferManagerTest, Destroy) {
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
   // Check we can create buffer.
-  manager_.CreateBufferInfo(kClient1Id, kService1Id);
+  manager_->CreateBufferInfo(kClient1Id, kService1Id);
   // Check buffer got created.
   BufferManager::BufferInfo* info1 =
-      manager_.GetBufferInfo(kClient1Id);
+      manager_->GetBufferInfo(kClient1Id);
   ASSERT_TRUE(info1 != NULL);
   EXPECT_CALL(*gl_, DeleteBuffersARB(1, ::testing::Pointee(kService1Id)))
       .Times(1)
       .RetiresOnSaturation();
-  manager_.Destroy(true);
+  manager_->Destroy(true);
   // Check the resources were released.
-  info1 = manager_.GetBufferInfo(kClient1Id);
+  info1 = manager_->GetBufferInfo(kClient1Id);
   ASSERT_TRUE(info1 == NULL);
 }
 
@@ -96,18 +140,18 @@
   const GLuint kClientBufferId = 1;
   const GLuint kServiceBufferId = 11;
   const uint8 data[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
-  manager_.CreateBufferInfo(kClientBufferId, kServiceBufferId);
-  BufferManager::BufferInfo* info = manager_.GetBufferInfo(kClientBufferId);
+  manager_->CreateBufferInfo(kClientBufferId, kServiceBufferId);
+  BufferManager::BufferInfo* info = manager_->GetBufferInfo(kClientBufferId);
   ASSERT_TRUE(info != NULL);
-  manager_.SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
-  manager_.SetInfo(info, sizeof(data), GL_STATIC_DRAW);
+  manager_->SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
+  manager_->SetInfo(info, sizeof(data), GL_STATIC_DRAW);
   EXPECT_TRUE(info->SetRange(0, sizeof(data), data));
   EXPECT_TRUE(info->SetRange(sizeof(data), 0, data));
   EXPECT_FALSE(info->SetRange(sizeof(data), 1, data));
   EXPECT_FALSE(info->SetRange(0, sizeof(data) + 1, data));
   EXPECT_FALSE(info->SetRange(-1, sizeof(data), data));
   EXPECT_FALSE(info->SetRange(0, -1, data));
-  manager_.SetInfo(info, 1, GL_STATIC_DRAW);
+  manager_->SetInfo(info, 1, GL_STATIC_DRAW);
   const int size = 0x20000;
   scoped_array<uint8> temp(new uint8[size]);
   EXPECT_FALSE(info->SetRange(0 - size, size, temp.get()));
@@ -118,11 +162,11 @@
   const GLuint kClientBufferId = 1;
   const GLuint kServiceBufferId = 11;
   const uint8 data[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
-  manager_.CreateBufferInfo(kClientBufferId, kServiceBufferId);
-  BufferManager::BufferInfo* info = manager_.GetBufferInfo(kClientBufferId);
+  manager_->CreateBufferInfo(kClientBufferId, kServiceBufferId);
+  BufferManager::BufferInfo* info = manager_->GetBufferInfo(kClientBufferId);
   ASSERT_TRUE(info != NULL);
-  manager_.SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
-  manager_.SetInfo(info, sizeof(data), GL_STATIC_DRAW);
+  manager_->SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
+  manager_->SetInfo(info, sizeof(data), GL_STATIC_DRAW);
   const char* buf = static_cast<const char*>(info->GetRange(0, sizeof(data)));
   ASSERT_TRUE(buf != NULL);
   const char* buf1 =
@@ -133,7 +177,7 @@
   EXPECT_TRUE(info->GetRange(-1, sizeof(data)) == NULL);
   EXPECT_TRUE(info->GetRange(-0, -1) == NULL);
   const int size = 0x20000;
-  manager_.SetInfo(info, size / 2, GL_STATIC_DRAW);
+  manager_->SetInfo(info, size / 2, GL_STATIC_DRAW);
   EXPECT_TRUE(info->GetRange(0 - size, size) == NULL);
   EXPECT_TRUE(info->GetRange(1, size / 2) == NULL);
 }
@@ -143,11 +187,11 @@
   const GLuint kServiceBufferId = 11;
   const uint8 data[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
   const uint8 new_data[] = {100, 120, 110};
-  manager_.CreateBufferInfo(kClientBufferId, kServiceBufferId);
-  BufferManager::BufferInfo* info = manager_.GetBufferInfo(kClientBufferId);
+  manager_->CreateBufferInfo(kClientBufferId, kServiceBufferId);
+  BufferManager::BufferInfo* info = manager_->GetBufferInfo(kClientBufferId);
   ASSERT_TRUE(info != NULL);
-  manager_.SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
-  manager_.SetInfo(info, sizeof(data), GL_STATIC_DRAW);
+  manager_->SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
+  manager_->SetInfo(info, sizeof(data), GL_STATIC_DRAW);
   EXPECT_TRUE(info->SetRange(0, sizeof(data), data));
   GLuint max_value;
   // Check entire range succeeds.
@@ -173,11 +217,11 @@
   const GLuint kServiceBufferId = 11;
   const uint16 data[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
   const uint16 new_data[] = {100, 120, 110};
-  manager_.CreateBufferInfo(kClientBufferId, kServiceBufferId);
-  BufferManager::BufferInfo* info = manager_.GetBufferInfo(kClientBufferId);
+  manager_->CreateBufferInfo(kClientBufferId, kServiceBufferId);
+  BufferManager::BufferInfo* info = manager_->GetBufferInfo(kClientBufferId);
   ASSERT_TRUE(info != NULL);
-  manager_.SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
-  manager_.SetInfo(info, sizeof(data), GL_STATIC_DRAW);
+  manager_->SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
+  manager_->SetInfo(info, sizeof(data), GL_STATIC_DRAW);
   EXPECT_TRUE(info->SetRange(0, sizeof(data), data));
   GLuint max_value;
   // Check entire range succeeds.
@@ -205,11 +249,11 @@
   const GLuint kServiceBufferId = 11;
   const uint32 data[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
   const uint32 new_data[] = {100, 120, 110};
-  manager_.CreateBufferInfo(kClientBufferId, kServiceBufferId);
-  BufferManager::BufferInfo* info = manager_.GetBufferInfo(kClientBufferId);
+  manager_->CreateBufferInfo(kClientBufferId, kServiceBufferId);
+  BufferManager::BufferInfo* info = manager_->GetBufferInfo(kClientBufferId);
   ASSERT_TRUE(info != NULL);
-  manager_.SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
-  manager_.SetInfo(info, sizeof(data), GL_STATIC_DRAW);
+  manager_->SetTarget(info, GL_ELEMENT_ARRAY_BUFFER);
+  manager_->SetInfo(info, sizeof(data), GL_STATIC_DRAW);
   EXPECT_TRUE(info->SetRange(0, sizeof(data), data));
   GLuint max_value;
   // Check entire range succeeds.
@@ -238,14 +282,15 @@
   const GLuint kClientBufferId = 1;
   const GLuint kServiceBufferId = 11;
   const uint32 data[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
-  manager_.CreateBufferInfo(kClientBufferId, kServiceBufferId);
-  BufferManager::BufferInfo::Ref info = manager_.GetBufferInfo(kClientBufferId);
+  manager_->CreateBufferInfo(kClientBufferId, kServiceBufferId);
+  BufferManager::BufferInfo::Ref info =
+      manager_->GetBufferInfo(kClientBufferId);
   ASSERT_TRUE(info != NULL);
-  manager_.SetTarget(info, GL_ARRAY_BUFFER);
+  manager_->SetTarget(info, GL_ARRAY_BUFFER);
   // Remove buffer
-  manager_.RemoveBufferInfo(kClientBufferId);
+  manager_->RemoveBufferInfo(kClientBufferId);
   // Use it after removing
-  manager_.SetInfo(info, sizeof(data), GL_STATIC_DRAW);
+  manager_->SetInfo(info, sizeof(data), GL_STATIC_DRAW);
   // Check that it gets deleted when the last reference is released.
   EXPECT_CALL(*gl_, DeleteBuffersARB(1, ::testing::Pointee(kServiceBufferId)))
       .Times(1)
Index: src/gpu/command_buffer/service/gpu_switches.cc
===================================================================
--- src/gpu/command_buffer/service/gpu_switches.cc	(revision 184497)
+++ src/gpu/command_buffer/service/gpu_switches.cc	(working copy)
@@ -45,6 +45,11 @@
 // affected systems.
 const char kForceGLFinishWorkaround[]       = "force-glfinish-workaround";
 
+// Disable the nonuniform GPU memory memory and instead use the scheme that
+// distributes memory uniformly to all visible renderers.
+const char kDisableNonuniformGpuMemPolicy[] =
+    "disable-nonuniform-gpu-mem-policy";
+
 // Sets the total amount of memory that may be allocated for GPU resources
 const char kForceGpuMemAvailableMb[]        = "force-gpu-mem-available-mb";
 
@@ -64,6 +69,7 @@
   kDisableGpuProgramCache,
   kEnforceGLMinimums,
   kForceGLFinishWorkaround,
+  kDisableNonuniformGpuMemPolicy,
   kForceGpuMemAvailableMb,
   kGpuProgramCacheSizeKb,
   kTraceGL,
Index: src/gpu/command_buffer/service/renderbuffer_manager.h
===================================================================
--- src/gpu/command_buffer/service/renderbuffer_manager.h	(revision 184497)
+++ src/gpu/command_buffer/service/renderbuffer_manager.h	(working copy)
@@ -170,6 +170,10 @@
     return memory_tracker_->GetMemRepresented();
   }
 
+  static bool ComputeEstimatedRenderbufferSize(
+      int width, int height, int samples, int internal_format, uint32* size);
+  static GLenum InternalRenderbufferFormatToImplFormat(GLenum impl_format);
+
  private:
   void StartTracking(RenderbufferInfo* renderbuffer);
   void StopTracking(RenderbufferInfo* renderbuffer);
Index: src/gpu/command_buffer/service/mocks.cc
===================================================================
--- src/gpu/command_buffer/service/mocks.cc	(revision 184497)
+++ src/gpu/command_buffer/service/mocks.cc	(working copy)
@@ -36,5 +36,10 @@
 MockProgramCache::MockProgramCache() {}
 MockProgramCache::~MockProgramCache() {}
 
+MockMemoryTracker::MockMemoryTracker() {}
+MockMemoryTracker::~MockMemoryTracker() {}
+
 }  // namespace gles2
 }  // namespace gpu
+
+
Index: src/gpu/command_buffer/service/texture_manager.cc
===================================================================
--- src/gpu/command_buffer/service/texture_manager.cc	(revision 184497)
+++ src/gpu/command_buffer/service/texture_manager.cc	(working copy)
@@ -481,8 +481,10 @@
         return GL_INVALID_ENUM;
       }
       manager_->GetMemTracker(pool_)->TrackMemFree(estimated_size());
+      manager_->GetMemTracker(pool_)->UpdateMemRepresented();
       pool_ = param;
       manager_->GetMemTracker(pool_)->TrackMemAlloc(estimated_size());
+      manager_->GetMemTracker(pool_)->UpdateMemRepresented();
       break;
     case GL_TEXTURE_WRAP_S:
       if (!feature_info->validators()->texture_wrap_mode.IsValid(param)) {
Index: src/gpu/command_buffer/service/query_manager.h
===================================================================
--- src/gpu/command_buffer/service/query_manager.h	(revision 184497)
+++ src/gpu/command_buffer/service/query_manager.h	(working copy)
@@ -89,11 +89,21 @@
       submit_count_ = submit_count;
     }
 
+    void UnmarkAsPending() {
+      DCHECK(pending_);
+      pending_ = false;
+    }
+
     // Returns false if shared memory for sync is invalid.
     bool AddToPendingQueue(uint32 submit_count) {
       return manager_->AddPendingQuery(this, submit_count);
     }
 
+    // Returns false if shared memory for sync is invalid.
+    bool AddToPendingTransferQueue(uint32 submit_count) {
+      return manager_->AddPendingTransferQuery(this, submit_count);
+    }
+
     void BeginQueryHelper(GLenum target, GLuint id) {
       manager_->BeginQueryHelper(target, id);
     }
@@ -102,15 +112,15 @@
       manager_->EndQueryHelper(target);
     }
 
+    uint32 submit_count() const {
+      return submit_count_;
+    }
+
    private:
     friend class QueryManager;
     friend class QueryManagerTest;
     friend class base::RefCounted<Query>;
 
-    uint32 submit_count() const {
-      return submit_count_;
-    }
-
     // The manager that owns this Query.
     QueryManager* manager_;
 
@@ -162,6 +172,13 @@
   // True if there are pending queries.
   bool HavePendingQueries();
 
+  // Processes pending transfer queries. Returns false if any queries are
+  // pointing to invalid shared memory.
+  bool ProcessPendingTransferQueries();
+
+  // True if there are pending transfer queries.
+  bool HavePendingTransferQueries();
+
   GLES2Decoder* decoder() const {
     return decoder_;
   }
@@ -179,6 +196,10 @@
   // Returns false if any query is pointing to invalid shared memory.
   bool AddPendingQuery(Query* query, uint32 submit_count);
 
+  // Adds to queue of transfer queries waiting for completion.
+  // Returns false if any query is pointing to invalid shared memory.
+  bool AddPendingTransferQuery(Query* query, uint32 submit_count);
+
   // Removes a query from the queue of pending queries.
   // Returns false if any query is pointing to invalid shared memory.
   bool RemovePendingQuery(Query* query);
@@ -205,6 +226,9 @@
   typedef std::deque<Query::Ref> QueryQueue;
   QueryQueue pending_queries_;
 
+  // Async pixel transfer queries waiting for completion.
+  QueryQueue pending_transfer_queries_;
+
   DISALLOW_COPY_AND_ASSIGN(QueryManager);
 };
 
Index: src/gpu/command_buffer/service/renderbuffer_manager_unittest.cc
===================================================================
--- src/gpu/command_buffer/service/renderbuffer_manager_unittest.cc	(revision 184497)
+++ src/gpu/command_buffer/service/renderbuffer_manager_unittest.cc	(working copy)
@@ -5,91 +5,116 @@
 #include "gpu/command_buffer/service/renderbuffer_manager.h"
 
 #include <set>
+#include "gpu/command_buffer/common/gles2_cmd_utils.h"
+#include "gpu/command_buffer/service/mocks.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gl/gl_mock.h"
 
+using ::testing::StrictMock;
+
 namespace gpu {
 namespace gles2 {
 
-class RenderbufferManagerTest : public testing::Test {
+class RenderbufferManagerTestBase : public testing::Test {
  public:
   static const GLint kMaxSize = 128;
   static const GLint kMaxSamples = 4;
 
-  RenderbufferManagerTest()
-      : manager_(NULL, kMaxSize, kMaxSamples) {
-  }
-  ~RenderbufferManagerTest() {
-    manager_.Destroy(false);
-  }
-
  protected:
-  virtual void SetUp() {
+  void SetUpBase(MemoryTracker* memory_tracker) {
     gl_.reset(new ::testing::StrictMock<gfx::MockGLInterface>());
     ::gfx::GLInterface::SetGLInterface(gl_.get());
+    manager_.reset(new RenderbufferManager(
+        memory_tracker, kMaxSize, kMaxSamples));
   }
 
   virtual void TearDown() {
+    manager_->Destroy(true);
+    manager_.reset();
     ::gfx::GLInterface::SetGLInterface(NULL);
     gl_.reset();
   }
 
   // Use StrictMock to make 100% sure we know how GL will be called.
   scoped_ptr< ::testing::StrictMock< ::gfx::MockGLInterface> > gl_;
-  RenderbufferManager manager_;
+  scoped_ptr<RenderbufferManager> manager_;
 };
 
+class RenderbufferManagerTest : public RenderbufferManagerTestBase {
+ protected:
+  virtual void SetUp() {
+    SetUpBase(NULL);
+  }
+};
+
+class RenderbufferManagerMemoryTrackerTest
+    : public RenderbufferManagerTestBase {
+ protected:
+  virtual void SetUp() {
+    mock_memory_tracker_ = new StrictMock<MockMemoryTracker>();
+    SetUpBase(mock_memory_tracker_.get());
+  }
+
+  scoped_refptr<MockMemoryTracker> mock_memory_tracker_;
+};
+
+#define EXPECT_MEMORY_ALLOCATION_CHANGE(old_size, new_size, pool) \
+    EXPECT_CALL(*mock_memory_tracker_, \
+                TrackMemoryAllocatedChange(old_size, new_size, pool)) \
+        .Times(1) \
+        .RetiresOnSaturation() \
+
 // GCC requires these declarations, but MSVC requires they not be present
 #ifndef COMPILER_MSVC
-const GLint RenderbufferManagerTest::kMaxSize;
-const GLint RenderbufferManagerTest::kMaxSamples;
+const GLint RenderbufferManagerTestBase::kMaxSize;
+const GLint RenderbufferManagerTestBase::kMaxSamples;
 #endif
 
 TEST_F(RenderbufferManagerTest, Basic) {
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
   const GLuint kClient2Id = 2;
-  EXPECT_EQ(kMaxSize, manager_.max_renderbuffer_size());
-  EXPECT_EQ(kMaxSamples, manager_.max_samples());
-  EXPECT_FALSE(manager_.HaveUnclearedRenderbuffers());
+  EXPECT_EQ(kMaxSize, manager_->max_renderbuffer_size());
+  EXPECT_EQ(kMaxSamples, manager_->max_samples());
+  EXPECT_FALSE(manager_->HaveUnclearedRenderbuffers());
   // Check we can create renderbuffer.
-  manager_.CreateRenderbufferInfo(kClient1Id, kService1Id);
+  manager_->CreateRenderbufferInfo(kClient1Id, kService1Id);
   // Check renderbuffer got created.
   RenderbufferManager::RenderbufferInfo* info1 =
-      manager_.GetRenderbufferInfo(kClient1Id);
+      manager_->GetRenderbufferInfo(kClient1Id);
   ASSERT_TRUE(info1 != NULL);
-  EXPECT_FALSE(manager_.HaveUnclearedRenderbuffers());
+  EXPECT_FALSE(manager_->HaveUnclearedRenderbuffers());
   GLuint client_id = 0;
-  EXPECT_TRUE(manager_.GetClientId(info1->service_id(), &client_id));
+  EXPECT_TRUE(manager_->GetClientId(info1->service_id(), &client_id));
   EXPECT_EQ(kClient1Id, client_id);
   // Check we get nothing for a non-existent renderbuffer.
-  EXPECT_TRUE(manager_.GetRenderbufferInfo(kClient2Id) == NULL);
+  EXPECT_TRUE(manager_->GetRenderbufferInfo(kClient2Id) == NULL);
   // Check trying to a remove non-existent renderbuffers does not crash.
-  manager_.RemoveRenderbufferInfo(kClient2Id);
+  manager_->RemoveRenderbufferInfo(kClient2Id);
   // Check that the renderbuffer is deleted when the last ref is released.
   EXPECT_CALL(*gl_, DeleteRenderbuffersEXT(1, ::testing::Pointee(kService1Id)))
       .Times(1)
       .RetiresOnSaturation();
   // Check we can't get the renderbuffer after we remove it.
-  manager_.RemoveRenderbufferInfo(kClient1Id);
-  EXPECT_TRUE(manager_.GetRenderbufferInfo(kClient1Id) == NULL);
-  EXPECT_FALSE(manager_.HaveUnclearedRenderbuffers());
+  manager_->RemoveRenderbufferInfo(kClient1Id);
+  EXPECT_TRUE(manager_->GetRenderbufferInfo(kClient1Id) == NULL);
+  EXPECT_FALSE(manager_->HaveUnclearedRenderbuffers());
 }
 
 TEST_F(RenderbufferManagerTest, Destroy) {
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
   // Check we can create renderbuffer.
-  manager_.CreateRenderbufferInfo(kClient1Id, kService1Id);
+  manager_->CreateRenderbufferInfo(kClient1Id, kService1Id);
   // Check renderbuffer got created.
   RenderbufferManager::RenderbufferInfo* info1 =
-      manager_.GetRenderbufferInfo(kClient1Id);
+      manager_->GetRenderbufferInfo(kClient1Id);
   ASSERT_TRUE(info1 != NULL);
   EXPECT_CALL(*gl_, DeleteRenderbuffersEXT(1, ::testing::Pointee(kService1Id)))
       .Times(1)
       .RetiresOnSaturation();
-  manager_.Destroy(true);
-  info1 = manager_.GetRenderbufferInfo(kClient1Id);
+  manager_->Destroy(true);
+  info1 = manager_->GetRenderbufferInfo(kClient1Id);
   ASSERT_TRUE(info1 == NULL);
 }
 
@@ -97,10 +122,10 @@
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
   // Check we can create renderbuffer.
-  manager_.CreateRenderbufferInfo(kClient1Id, kService1Id);
+  manager_->CreateRenderbufferInfo(kClient1Id, kService1Id);
   // Check renderbuffer got created.
   RenderbufferManager::RenderbufferInfo* info1 =
-      manager_.GetRenderbufferInfo(kClient1Id);
+      manager_->GetRenderbufferInfo(kClient1Id);
   ASSERT_TRUE(info1 != NULL);
   EXPECT_EQ(kService1Id, info1->service_id());
   EXPECT_EQ(0, info1->samples());
@@ -115,50 +140,85 @@
   const GLenum kFormat = GL_RGBA4;
   const GLsizei kWidth = 128;
   const GLsizei kHeight = 64;
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
   EXPECT_EQ(kSamples, info1->samples());
   EXPECT_EQ(kFormat, info1->internal_format());
   EXPECT_EQ(kWidth, info1->width());
   EXPECT_EQ(kHeight, info1->height());
   EXPECT_FALSE(info1->cleared());
   EXPECT_FALSE(info1->IsDeleted());
-  EXPECT_TRUE(manager_.HaveUnclearedRenderbuffers());
-  EXPECT_EQ(kWidth * kHeight * 4u * 2u, info1->EstimatedSize());
+  EXPECT_TRUE(manager_->HaveUnclearedRenderbuffers());
+  EXPECT_EQ(kWidth * kHeight * 4u * 4u, info1->EstimatedSize());
 
-  manager_.SetCleared(info1, true);
+  manager_->SetCleared(info1, true);
   EXPECT_TRUE(info1->cleared());
-  EXPECT_FALSE(manager_.HaveUnclearedRenderbuffers());
+  EXPECT_FALSE(manager_->HaveUnclearedRenderbuffers());
 
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
-  EXPECT_TRUE(manager_.HaveUnclearedRenderbuffers());
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
+  EXPECT_TRUE(manager_->HaveUnclearedRenderbuffers());
 
   // Check that the renderbuffer is deleted when the last ref is released.
   EXPECT_CALL(*gl_, DeleteRenderbuffersEXT(1, ::testing::Pointee(kService1Id)))
       .Times(1)
       .RetiresOnSaturation();
-  manager_.RemoveRenderbufferInfo(kClient1Id);
-  EXPECT_FALSE(manager_.HaveUnclearedRenderbuffers());
+  manager_->RemoveRenderbufferInfo(kClient1Id);
+  EXPECT_FALSE(manager_->HaveUnclearedRenderbuffers());
 }
 
+TEST_F(RenderbufferManagerMemoryTrackerTest, Basic) {
+  const GLuint kClient1Id = 1;
+  const GLuint kService1Id = 11;
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 0, MemoryTracker::kUnmanaged);
+  manager_->CreateRenderbufferInfo(kClient1Id, kService1Id);
+  RenderbufferManager::RenderbufferInfo* info1 =
+      manager_->GetRenderbufferInfo(kClient1Id);
+  ASSERT_TRUE(info1 != NULL);
+
+  const GLsizei kSamples = 4;
+  const GLenum kFormat = GL_RGBA4;
+  const GLsizei kWidth = 128;
+  const GLsizei kHeight1 = 64;
+  const GLsizei kHeight2 = 32;
+  uint32 expected_size_1 = 0;
+  uint32 expected_size_2 = 0;
+  RenderbufferManager::ComputeEstimatedRenderbufferSize(
+      kWidth, kHeight1, kSamples, kFormat, &expected_size_1);
+  RenderbufferManager::ComputeEstimatedRenderbufferSize(
+      kWidth, kHeight2, kSamples, kFormat, &expected_size_2);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(
+      0, expected_size_1, MemoryTracker::kUnmanaged);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight1);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(
+      expected_size_1, 0, MemoryTracker::kUnmanaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(
+      0, expected_size_2, MemoryTracker::kUnmanaged);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight2);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(
+      expected_size_2, 0, MemoryTracker::kUnmanaged);
+  EXPECT_CALL(*gl_, DeleteRenderbuffersEXT(1, ::testing::Pointee(kService1Id)))
+      .Times(1)
+      .RetiresOnSaturation();
+}
+
 TEST_F(RenderbufferManagerTest, UseDeletedRenderbufferInfo) {
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
-  manager_.CreateRenderbufferInfo(kClient1Id, kService1Id);
+  manager_->CreateRenderbufferInfo(kClient1Id, kService1Id);
   RenderbufferManager::RenderbufferInfo::Ref info1(
-      manager_.GetRenderbufferInfo(kClient1Id));
+      manager_->GetRenderbufferInfo(kClient1Id));
   ASSERT_TRUE(info1 != NULL);
   // Remove it.
-  manager_.RemoveRenderbufferInfo(kClient1Id);
+  manager_->RemoveRenderbufferInfo(kClient1Id);
   // Use after removing.
   const GLsizei kSamples = 4;
   const GLenum kFormat = GL_RGBA4;
   const GLsizei kWidth = 128;
   const GLsizei kHeight = 64;
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
   // See that it still affects manager.
-  EXPECT_TRUE(manager_.HaveUnclearedRenderbuffers());
-  manager_.SetCleared(info1, true);
-  EXPECT_FALSE(manager_.HaveUnclearedRenderbuffers());
+  EXPECT_TRUE(manager_->HaveUnclearedRenderbuffers());
+  manager_->SetCleared(info1, true);
+  EXPECT_FALSE(manager_->HaveUnclearedRenderbuffers());
   // Check that the renderbuffer is deleted when the last ref is released.
   EXPECT_CALL(*gl_, DeleteRenderbuffersEXT(1, ::testing::Pointee(kService1Id)))
       .Times(1)
@@ -179,15 +239,15 @@
 TEST_F(RenderbufferManagerTest, AddToSignature) {
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
-  manager_.CreateRenderbufferInfo(kClient1Id, kService1Id);
+  manager_->CreateRenderbufferInfo(kClient1Id, kService1Id);
   RenderbufferManager::RenderbufferInfo::Ref info1(
-      manager_.GetRenderbufferInfo(kClient1Id));
+      manager_->GetRenderbufferInfo(kClient1Id));
   ASSERT_TRUE(info1 != NULL);
   const GLsizei kSamples = 4;
   const GLenum kFormat = GL_RGBA4;
   const GLsizei kWidth = 128;
   const GLsizei kHeight = 64;
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
   std::string signature1;
   std::string signature2;
   info1->AddToSignature(&signature1);
@@ -196,33 +256,37 @@
   EXPECT_FALSE(InSet(&string_set, signature1));
 
   // change things and see that the signatures change.
-  manager_.SetInfo(info1, kSamples +  1, kFormat, kWidth, kHeight);
+  manager_->SetInfo(info1, kSamples +  1, kFormat, kWidth, kHeight);
   info1->AddToSignature(&signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetInfo(info1, kSamples, kFormat + 1, kWidth, kHeight);
+  manager_->SetInfo(info1, kSamples, kFormat + 1, kWidth, kHeight);
   signature2.clear();
   info1->AddToSignature(&signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth + 1, kHeight);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth + 1, kHeight);
   signature2.clear();
   info1->AddToSignature(&signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth, kHeight + 1);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight + 1);
   signature2.clear();
   info1->AddToSignature(&signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
   // put it back to the same and it should be the same.
-  manager_.SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
+  manager_->SetInfo(info1, kSamples, kFormat, kWidth, kHeight);
   signature2.clear();
   info1->AddToSignature(&signature2);
   EXPECT_EQ(signature1, signature2);
 
   // Check the set was acutally getting different signatures.
   EXPECT_EQ(5u, string_set.size());
+
+  EXPECT_CALL(*gl_, DeleteRenderbuffersEXT(1, ::testing::Pointee(kService1Id)))
+      .Times(1)
+      .RetiresOnSaturation();
 }
 
 }  // namespace gles2
Index: src/gpu/command_buffer/service/gpu_switches.h
===================================================================
--- src/gpu/command_buffer/service/gpu_switches.h	(revision 184497)
+++ src/gpu/command_buffer/service/gpu_switches.h	(working copy)
@@ -22,6 +22,7 @@
 GPU_EXPORT extern const char kDisableGpuProgramCache[];
 GPU_EXPORT extern const char kEnforceGLMinimums[];
 GPU_EXPORT extern const char kForceGLFinishWorkaround[];
+GPU_EXPORT extern const char kDisableNonuniformGpuMemPolicy[];
 GPU_EXPORT extern const char kForceGpuMemAvailableMb[];
 GPU_EXPORT extern const char kGpuProgramCacheSizeKb[];
 GPU_EXPORT extern const char kTraceGL[];
Index: src/gpu/command_buffer/service/transfer_buffer_manager.cc
===================================================================
--- src/gpu/command_buffer/service/transfer_buffer_manager.cc	(revision 184497)
+++ src/gpu/command_buffer/service/transfer_buffer_manager.cc	(working copy)
@@ -124,7 +124,7 @@
   DCHECK(shared_memory_bytes_allocated_ >= registered_objects_[handle].size);
   shared_memory_bytes_allocated_ -= registered_objects_[handle].size;
   TRACE_COUNTER_ID1(
-      "CommandBuffer", "SharedMemory", this, shared_memory_bytes_allocated_);
+      "gpu", "GpuTransferBufferMemory", this, shared_memory_bytes_allocated_);
 
   delete registered_objects_[handle].shared_memory;
   registered_objects_[handle] = Buffer();
Index: src/gpu/command_buffer/service/mocks.h
===================================================================
--- src/gpu/command_buffer/service/mocks.h	(revision 184497)
+++ src/gpu/command_buffer/service/mocks.h	(working copy)
@@ -15,6 +15,7 @@
 #include "base/logging.h"
 #include "gpu/command_buffer/service/cmd_parser.h"
 #include "gpu/command_buffer/service/cmd_buffer_engine.h"
+#include "gpu/command_buffer/service/memory_tracking.h"
 #include "gpu/command_buffer/service/program_cache.h"
 #include "gpu/command_buffer/service/shader_translator.h"
 #include "testing/gmock/include/gmock/gmock.h"
@@ -110,6 +111,20 @@
   MOCK_METHOD0(ClearBackend, void());
 };
 
+class MockMemoryTracker : public MemoryTracker {
+ public:
+  MockMemoryTracker();
+
+  MOCK_METHOD3(TrackMemoryAllocatedChange, void(
+      size_t old_size, size_t new_size, Pool pool));
+  MOCK_METHOD1(EnsureGPUMemoryAvailable, bool(size_t size_needed));
+
+ private:
+  friend class ::testing::StrictMock<MockMemoryTracker>;
+  friend class base::RefCounted< ::testing::StrictMock<MockMemoryTracker> >;
+  virtual ~MockMemoryTracker();
+};
+
 }  // namespace gles2
 }  // namespace gpu
 
Index: src/gpu/command_buffer/service/async_pixel_transfer_delegate_mock.h
===================================================================
--- src/gpu/command_buffer/service/async_pixel_transfer_delegate_mock.h	(revision 184497)
+++ src/gpu/command_buffer/service/async_pixel_transfer_delegate_mock.h	(working copy)
@@ -32,8 +32,9 @@
   // Implement AsyncPixelTransferDelegate.
   MOCK_METHOD1(CreateRawPixelTransferState,
       gfx::AsyncPixelTransferState*(GLuint service_id));
-  MOCK_METHOD1(AsyncNotifyCompletion,
-      void(const base::Closure& task));
+  MOCK_METHOD2(AsyncNotifyCompletion,
+      void(const AsyncMemoryParams& mem_params,
+           const CompletionCallback& callback));
   MOCK_METHOD3(AsyncTexImage2D,
       void(gfx::AsyncPixelTransferState*,
           const AsyncTexImage2DParams& tex_params,
@@ -42,6 +43,8 @@
       void(gfx::AsyncPixelTransferState*,
           const AsyncTexSubImage2DParams& tex_params,
           const AsyncMemoryParams& mem_params));
+  MOCK_METHOD0(GetTextureUploadCount, uint32());
+  MOCK_METHOD0(GetTotalTextureUploadTime, base::TimeDelta());
 
  private:
   DISALLOW_COPY_AND_ASSIGN(MockAsyncPixelTransferDelegate);
Index: src/gpu/command_buffer/service/command_buffer_service.h
===================================================================
--- src/gpu/command_buffer/service/command_buffer_service.h	(revision 184497)
+++ src/gpu/command_buffer/service/command_buffer_service.h	(working copy)
@@ -27,6 +27,7 @@
   virtual bool Initialize() OVERRIDE;
   virtual State GetState() OVERRIDE;
   virtual State GetLastState() OVERRIDE;
+  virtual int32 GetLastToken() OVERRIDE;
   virtual void Flush(int32 put_offset) OVERRIDE;
   virtual State FlushSync(int32 put_offset, int32 last_known_get) OVERRIDE;
   virtual void SetGetBuffer(int32 transfer_buffer_id) OVERRIDE;
Index: src/gpu/command_buffer/service/renderbuffer_manager.cc
===================================================================
--- src/gpu/command_buffer/service/renderbuffer_manager.cc	(revision 184497)
+++ src/gpu/command_buffer/service/renderbuffer_manager.cc	(working copy)
@@ -9,6 +9,7 @@
 #include "gpu/command_buffer/common/gles2_cmd_utils.h"
 #include "gpu/command_buffer/service/gles2_cmd_decoder.h"
 #include "gpu/command_buffer/service/memory_tracking.h"
+#include "ui/gl/gl_implementation.h"
 
 namespace gpu {
 namespace gles2 {
@@ -37,8 +38,10 @@
 }
 
 size_t RenderbufferManager::RenderbufferInfo::EstimatedSize() {
-  return width_ * height_ * samples_ *
-         GLES2Util::RenderbufferBytesPerPixel(internal_format_);
+  uint32 size = 0;
+  RenderbufferManager::ComputeEstimatedRenderbufferSize(
+      width_, height_, samples_, internal_format_, &size);
+  return size;
 }
 
 void RenderbufferManager::RenderbufferInfo::AddToSignature(
@@ -147,6 +150,42 @@
   return false;
 }
 
+bool RenderbufferManager::ComputeEstimatedRenderbufferSize(
+    int width, int height, int samples, int internal_format, uint32* size) {
+  DCHECK(size);
+
+  uint32 temp = 0;
+  if (!SafeMultiplyUint32(width, height, &temp)) {
+    return false;
+  }
+  if (!SafeMultiplyUint32(temp, samples, &temp)) {
+    return false;
+  }
+  GLenum impl_format = InternalRenderbufferFormatToImplFormat(internal_format);
+  if (!SafeMultiplyUint32(
+      temp, GLES2Util::RenderbufferBytesPerPixel(impl_format), &temp)) {
+    return false;
+  }
+  *size = temp;
+  return true;
+}
+
+GLenum RenderbufferManager::InternalRenderbufferFormatToImplFormat(
+    GLenum impl_format) {
+  if (gfx::GetGLImplementation() != gfx::kGLImplementationEGLGLES2) {
+    switch (impl_format) {
+      case GL_DEPTH_COMPONENT16:
+        return GL_DEPTH_COMPONENT;
+      case GL_RGBA4:
+      case GL_RGB5_A1:
+        return GL_RGBA;
+      case GL_RGB565:
+        return GL_RGB;
+    }
+  }
+  return impl_format;
+}
+
 }  // namespace gles2
 }  // namespace gpu
 
Index: src/gpu/command_buffer/service/feature_info.h
===================================================================
--- src/gpu/command_buffer/service/feature_info.h	(revision 184497)
+++ src/gpu/command_buffer/service/feature_info.h	(working copy)
@@ -55,6 +55,8 @@
     bool set_texture_filter_before_generating_mipmap;
     bool use_current_program_after_successful_link;
     bool restore_scissor_on_fbo_change;
+    bool flush_on_context_switch;
+    bool delete_instead_of_resize_fbo;
 
     // Note: 0 here means use driver limit.
     GLint max_texture_size;
Index: src/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc
===================================================================
--- src/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc	(revision 184497)
+++ src/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.cc	(working copy)
@@ -40,6 +40,7 @@
 GLES2DecoderTestBase::GLES2DecoderTestBase()
     : surface_(NULL),
       context_(NULL),
+      memory_tracker_(NULL),
       client_buffer_id_(100),
       client_framebuffer_id_(101),
       client_program_id_(102),
@@ -90,7 +91,7 @@
   ::gfx::GLInterface::SetGLInterface(gl_.get());
   group_ = ContextGroup::Ref(new ContextGroup(NULL,
                                               NULL,
-                                              NULL,
+                                              memory_tracker_,
                                               bind_generates_resource));
 
   InSequence sequence;
Index: src/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h
===================================================================
--- src/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h	(revision 184497)
+++ src/gpu/command_buffer/service/gles2_cmd_decoder_unittest_base.h	(working copy)
@@ -27,6 +27,8 @@
 namespace gpu {
 namespace gles2 {
 
+class MemoryTracker;
+
 class GLES2DecoderTestBase : public testing::Test {
  public:
   GLES2DecoderTestBase();
@@ -140,6 +142,10 @@
 
   void SetBucketAsCString(uint32 bucket_id, const char* str);
 
+  void set_memory_tracker(MemoryTracker* memory_tracker) {
+    memory_tracker_ = memory_tracker;
+  }
+
   void InitDecoder(
       const char* extensions,
       bool has_alpha,
@@ -468,6 +474,7 @@
   scoped_refptr<gfx::GLContextStub> context_;
   scoped_ptr<GLES2Decoder> mock_decoder_;
   scoped_ptr<GLES2Decoder> decoder_;
+  MemoryTracker* memory_tracker_;
 
   GLuint client_buffer_id_;
   GLuint client_framebuffer_id_;
Index: src/gpu/command_buffer/service/texture_manager_unittest.cc
===================================================================
--- src/gpu/command_buffer/service/texture_manager_unittest.cc	(revision 184497)
+++ src/gpu/command_buffer/service/texture_manager_unittest.cc	(working copy)
@@ -7,12 +7,15 @@
 #include "base/memory/scoped_ptr.h"
 #include "gpu/command_buffer/service/feature_info.h"
 #include "gpu/command_buffer/service/gles2_cmd_decoder_mock.h"
+#include "gpu/command_buffer/service/memory_tracking.h"
+#include "gpu/command_buffer/service/mocks.h"
 #include "gpu/command_buffer/service/test_helper.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gl/gl_mock.h"
 
 using ::testing::Pointee;
 using ::testing::Return;
+using ::testing::StrictMock;
 using ::testing::_;
 
 namespace gpu {
@@ -28,25 +31,27 @@
   static const GLint kMaxExternalLevels = 1;
 
   TextureManagerTest()
-      : feature_info_(new FeatureInfo()),
-        manager_(
-          NULL, feature_info_.get(), kMaxTextureSize, kMaxCubeMapTextureSize) {
+      : feature_info_(new FeatureInfo()) {
   }
 
   ~TextureManagerTest() {
-    manager_.Destroy(false);
   }
 
  protected:
-  virtual void SetUp() {
+  void SetUp() {
     gl_.reset(new ::testing::StrictMock< ::gfx::MockGLInterface>());
     ::gfx::GLInterface::SetGLInterface(gl_.get());
 
+    manager_.reset(new TextureManager(
+        NULL, feature_info_.get(),
+        kMaxTextureSize, kMaxCubeMapTextureSize));
     TestHelper::SetupTextureManagerInitExpectations(gl_.get(), "");
-    manager_.Initialize();
+    manager_->Initialize();
   }
 
   virtual void TearDown() {
+    manager_->Destroy(false);
+    manager_.reset();
     ::gfx::GLInterface::SetGLInterface(NULL);
     gl_.reset();
   }
@@ -54,7 +59,7 @@
   // Use StrictMock to make 100% sure we know how GL will be called.
   scoped_ptr< ::testing::StrictMock< ::gfx::MockGLInterface> > gl_;
   FeatureInfo::Ref feature_info_;
-  TextureManager manager_;
+  scoped_ptr<TextureManager> manager_;
 };
 
 // GCC requires these declarations, but MSVC requires they not be present
@@ -71,68 +76,68 @@
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
   const GLuint kClient2Id = 2;
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   // Check we can create texture.
-  manager_.CreateTextureInfo(kClient1Id, kService1Id);
+  manager_->CreateTextureInfo(kClient1Id, kService1Id);
   // Check texture got created.
-  TextureManager::TextureInfo* info1 = manager_.GetTextureInfo(kClient1Id);
+  TextureManager::TextureInfo* info1 = manager_->GetTextureInfo(kClient1Id);
   ASSERT_TRUE(info1 != NULL);
   EXPECT_EQ(kService1Id, info1->service_id());
   GLuint client_id = 0;
-  EXPECT_TRUE(manager_.GetClientId(info1->service_id(), &client_id));
+  EXPECT_TRUE(manager_->GetClientId(info1->service_id(), &client_id));
   EXPECT_EQ(kClient1Id, client_id);
   // Check we get nothing for a non-existent texture.
-  EXPECT_TRUE(manager_.GetTextureInfo(kClient2Id) == NULL);
+  EXPECT_TRUE(manager_->GetTextureInfo(kClient2Id) == NULL);
   // Check trying to a remove non-existent textures does not crash.
-  manager_.RemoveTextureInfo(kClient2Id);
+  manager_->RemoveTextureInfo(kClient2Id);
   // Check that it gets deleted when the last reference is released.
   EXPECT_CALL(*gl_, DeleteTextures(1, ::testing::Pointee(kService1Id)))
       .Times(1)
       .RetiresOnSaturation();
   // Check we can't get the texture after we remove it.
-  manager_.RemoveTextureInfo(kClient1Id);
-  EXPECT_TRUE(manager_.GetTextureInfo(kClient1Id) == NULL);
+  manager_->RemoveTextureInfo(kClient1Id);
+  EXPECT_TRUE(manager_->GetTextureInfo(kClient1Id) == NULL);
 }
 
 TEST_F(TextureManagerTest, SetParameter) {
   const GLuint kClient1Id = 1;
   const GLuint kService1Id = 11;
   // Check we can create texture.
-  manager_.CreateTextureInfo(kClient1Id, kService1Id);
+  manager_->CreateTextureInfo(kClient1Id, kService1Id);
   // Check texture got created.
-  TextureManager::TextureInfo* info = manager_.GetTextureInfo(kClient1Id);
+  TextureManager::TextureInfo* info = manager_->GetTextureInfo(kClient1Id);
   ASSERT_TRUE(info != NULL);
-  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
       info, GL_TEXTURE_MIN_FILTER, GL_NEAREST));
   EXPECT_EQ(static_cast<GLenum>(GL_NEAREST), info->min_filter());
-  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
       info, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
   EXPECT_EQ(static_cast<GLenum>(GL_NEAREST), info->mag_filter());
-  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
       info, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
   EXPECT_EQ(static_cast<GLenum>(GL_CLAMP_TO_EDGE), info->wrap_s());
-  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
       info, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
   EXPECT_EQ(static_cast<GLenum>(GL_CLAMP_TO_EDGE), info->wrap_t());
-  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
       info, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1));
-  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
       info, GL_TEXTURE_MAX_ANISOTROPY_EXT, 2));
-  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_->SetParameter(
       info, GL_TEXTURE_MIN_FILTER, GL_CLAMP_TO_EDGE));
   EXPECT_EQ(static_cast<GLenum>(GL_NEAREST), info->min_filter());
-  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_->SetParameter(
       info, GL_TEXTURE_MAG_FILTER, GL_CLAMP_TO_EDGE));
   EXPECT_EQ(static_cast<GLenum>(GL_NEAREST), info->min_filter());
-  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_->SetParameter(
       info, GL_TEXTURE_WRAP_S, GL_NEAREST));
   EXPECT_EQ(static_cast<GLenum>(GL_CLAMP_TO_EDGE), info->wrap_s());
-  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_ENUM), manager_->SetParameter(
       info, GL_TEXTURE_WRAP_T, GL_NEAREST));
   EXPECT_EQ(static_cast<GLenum>(GL_CLAMP_TO_EDGE), info->wrap_t());
-  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_VALUE), manager_.SetParameter(
+  EXPECT_EQ(static_cast<GLenum>(GL_INVALID_VALUE), manager_->SetParameter(
       info, GL_TEXTURE_MAX_ANISOTROPY_EXT, 0));
 }
 
@@ -203,106 +208,106 @@
 
 TEST_F(TextureManagerTest, MaxValues) {
   // Check we get the right values for the max sizes.
-  EXPECT_EQ(kMax2dLevels, manager_.MaxLevelsForTarget(GL_TEXTURE_2D));
+  EXPECT_EQ(kMax2dLevels, manager_->MaxLevelsForTarget(GL_TEXTURE_2D));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_X));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_X));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_X));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_X));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Y));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Y));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Z));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Z));
   EXPECT_EQ(kMaxCubeMapLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z));
   EXPECT_EQ(kMaxExternalLevels,
-            manager_.MaxLevelsForTarget(GL_TEXTURE_EXTERNAL_OES));
-  EXPECT_EQ(kMaxTextureSize, manager_.MaxSizeForTarget(GL_TEXTURE_2D));
+            manager_->MaxLevelsForTarget(GL_TEXTURE_EXTERNAL_OES));
+  EXPECT_EQ(kMaxTextureSize, manager_->MaxSizeForTarget(GL_TEXTURE_2D));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_X));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_X));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_X));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_X));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Y));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Y));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Z));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_POSITIVE_Z));
   EXPECT_EQ(kMaxCubeMapTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z));
+            manager_->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z));
   EXPECT_EQ(kMaxExternalTextureSize,
-            manager_.MaxSizeForTarget(GL_TEXTURE_EXTERNAL_OES));
+            manager_->MaxSizeForTarget(GL_TEXTURE_EXTERNAL_OES));
 }
 
 TEST_F(TextureManagerTest, ValidForTarget) {
   // check 2d
-  EXPECT_TRUE(manager_.ValidForTarget(
+  EXPECT_TRUE(manager_->ValidForTarget(
       GL_TEXTURE_2D, 0, kMaxTextureSize, kMaxTextureSize, 1));
-  EXPECT_TRUE(manager_.ValidForTarget(
+  EXPECT_TRUE(manager_->ValidForTarget(
       GL_TEXTURE_2D, kMax2dLevels - 1, 1, 1, 1));
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_2D, kMax2dLevels - 1, 1, 2, 1));
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_2D, kMax2dLevels - 1, 2, 1, 1));
   // check level out of range.
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_2D, kMax2dLevels, kMaxTextureSize, 1, 1));
   // check has depth.
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_2D, kMax2dLevels, kMaxTextureSize, 1, 2));
   // Check NPOT width on level 0
-  EXPECT_TRUE(manager_.ValidForTarget(GL_TEXTURE_2D, 0, 5, 2, 1));
+  EXPECT_TRUE(manager_->ValidForTarget(GL_TEXTURE_2D, 0, 5, 2, 1));
   // Check NPOT height on level 0
-  EXPECT_TRUE(manager_.ValidForTarget(GL_TEXTURE_2D, 0, 2, 5, 1));
+  EXPECT_TRUE(manager_->ValidForTarget(GL_TEXTURE_2D, 0, 2, 5, 1));
   // Check NPOT width on level 1
-  EXPECT_FALSE(manager_.ValidForTarget(GL_TEXTURE_2D, 1, 5, 2, 1));
+  EXPECT_FALSE(manager_->ValidForTarget(GL_TEXTURE_2D, 1, 5, 2, 1));
   // Check NPOT height on level 1
-  EXPECT_FALSE(manager_.ValidForTarget(GL_TEXTURE_2D, 1, 2, 5, 1));
+  EXPECT_FALSE(manager_->ValidForTarget(GL_TEXTURE_2D, 1, 2, 5, 1));
 
   // check cube
-  EXPECT_TRUE(manager_.ValidForTarget(
+  EXPECT_TRUE(manager_->ValidForTarget(
       GL_TEXTURE_CUBE_MAP, 0,
       kMaxCubeMapTextureSize, kMaxCubeMapTextureSize, 1));
-  EXPECT_TRUE(manager_.ValidForTarget(
+  EXPECT_TRUE(manager_->ValidForTarget(
       GL_TEXTURE_CUBE_MAP, kMaxCubeMapLevels - 1, 1, 1, 1));
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_CUBE_MAP, kMaxCubeMapLevels - 1, 2, 2, 1));
   // check level out of range.
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_CUBE_MAP, kMaxCubeMapLevels,
       kMaxCubeMapTextureSize, 1, 1));
   // check not square.
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_CUBE_MAP, kMaxCubeMapLevels,
       kMaxCubeMapTextureSize, 1, 1));
   // check has depth.
-  EXPECT_FALSE(manager_.ValidForTarget(
+  EXPECT_FALSE(manager_->ValidForTarget(
       GL_TEXTURE_CUBE_MAP, kMaxCubeMapLevels,
       kMaxCubeMapTextureSize, 1, 2));
 
   for (GLint level = 0; level < kMax2dLevels; ++level) {
-    EXPECT_TRUE(manager_.ValidForTarget(
+    EXPECT_TRUE(manager_->ValidForTarget(
         GL_TEXTURE_2D, level, kMaxTextureSize >> level, 1, 1));
-    EXPECT_TRUE(manager_.ValidForTarget(
+    EXPECT_TRUE(manager_->ValidForTarget(
         GL_TEXTURE_2D, level, 1, kMaxTextureSize >> level, 1));
-    EXPECT_FALSE(manager_.ValidForTarget(
+    EXPECT_FALSE(manager_->ValidForTarget(
         GL_TEXTURE_2D, level, (kMaxTextureSize >> level) + 1, 1, 1));
-    EXPECT_FALSE(manager_.ValidForTarget(
+    EXPECT_FALSE(manager_->ValidForTarget(
         GL_TEXTURE_2D, level, 1, (kMaxTextureSize >> level) + 1, 1));
   }
 
   for (GLint level = 0; level < kMaxCubeMapLevels; ++level) {
-    EXPECT_TRUE(manager_.ValidForTarget(
+    EXPECT_TRUE(manager_->ValidForTarget(
         GL_TEXTURE_CUBE_MAP, level,
         kMaxCubeMapTextureSize >> level,
         kMaxCubeMapTextureSize >> level,
         1));
-    EXPECT_FALSE(manager_.ValidForTarget(
+    EXPECT_FALSE(manager_->ValidForTarget(
         GL_TEXTURE_CUBE_MAP, level,
         (kMaxCubeMapTextureSize >> level) * 2,
         (kMaxCubeMapTextureSize >> level) * 2,
@@ -328,7 +333,7 @@
   manager.Destroy(false);
 }
 
-class TextureInfoTest : public testing::Test {
+class TextureInfoTestBase : public testing::Test {
  public:
   static const GLint kMaxTextureSize = 16;
   static const GLint kMaxCubeMapTextureSize = 8;
@@ -337,22 +342,22 @@
   static const GLuint kClient1Id = 1;
   static const GLuint kService1Id = 11;
 
-  TextureInfoTest()
-      : feature_info_(new FeatureInfo()),
-        manager_(
-          NULL, feature_info_.get(), kMaxTextureSize, kMaxCubeMapTextureSize) {
+  TextureInfoTestBase()
+      : feature_info_(new FeatureInfo()) {
   }
-  ~TextureInfoTest() {
+  ~TextureInfoTestBase() {
     info_ = NULL;
-    manager_.Destroy(false);
   }
 
  protected:
-  virtual void SetUp() {
+  void SetUpBase(MemoryTracker* memory_tracker) {
     gl_.reset(new ::testing::StrictMock< ::gfx::MockGLInterface>());
     ::gfx::GLInterface::SetGLInterface(gl_.get());
-    manager_.CreateTextureInfo(kClient1Id, kService1Id);
-    info_ = manager_.GetTextureInfo(kClient1Id);
+    manager_.reset(new TextureManager(
+        memory_tracker, feature_info_.get(),
+        kMaxTextureSize, kMaxCubeMapTextureSize));
+    manager_->CreateTextureInfo(kClient1Id, kService1Id);
+    info_ = manager_->GetTextureInfo(kClient1Id);
     ASSERT_TRUE(info_.get() != NULL);
   }
 
@@ -361,7 +366,7 @@
       GLuint client_id = 0;
       // If it's not in the manager then setting info_ to NULL will
       // delete the texture.
-      if (!manager_.GetClientId(info_->service_id(), &client_id)) {
+      if (!manager_->GetClientId(info_->service_id(), &client_id)) {
         // Check that it gets deleted when the last reference is released.
         EXPECT_CALL(*gl_,
             DeleteTextures(1, ::testing::Pointee(info_->service_id())))
@@ -370,6 +375,8 @@
       }
       info_ = NULL;
     }
+    manager_->Destroy(false);
+    manager_.reset();
     ::gfx::GLInterface::SetGLInterface(NULL);
     gl_.reset();
   }
@@ -377,138 +384,200 @@
   // Use StrictMock to make 100% sure we know how GL will be called.
   scoped_ptr< ::testing::StrictMock< ::gfx::MockGLInterface> > gl_;
   FeatureInfo::Ref feature_info_;
-  TextureManager manager_;
+  scoped_ptr<TextureManager> manager_;
   TextureManager::TextureInfo::Ref info_;
 };
 
+class TextureInfoTest : public TextureInfoTestBase {
+ protected:
+  virtual void SetUp() {
+    SetUpBase(NULL);
+  }
+};
+
+class TextureInfoMemoryTrackerTest : public TextureInfoTestBase {
+ protected:
+  virtual void SetUp() {
+    mock_memory_tracker_ = new StrictMock<MockMemoryTracker>();
+    SetUpBase(mock_memory_tracker_.get());
+  }
+
+  scoped_refptr<MockMemoryTracker> mock_memory_tracker_;
+};
+
+#define EXPECT_MEMORY_ALLOCATION_CHANGE(old_size, new_size, pool) \
+    EXPECT_CALL(*mock_memory_tracker_, \
+                TrackMemoryAllocatedChange(old_size, new_size, pool)) \
+        .Times(1) \
+        .RetiresOnSaturation() \
+
 TEST_F(TextureInfoTest, Basic) {
   EXPECT_EQ(0u, info_->target());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_FALSE(info_->cube_complete());
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
   EXPECT_FALSE(info_->npot());
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  EXPECT_FALSE(manager_.CanRender(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
   EXPECT_TRUE(info_->SafeToRenderFrom());
   EXPECT_FALSE(info_->IsImmutable());
   EXPECT_EQ(static_cast<GLenum>(GL_NEAREST_MIPMAP_LINEAR), info_->min_filter());
   EXPECT_EQ(static_cast<GLenum>(GL_LINEAR), info_->mag_filter());
   EXPECT_EQ(static_cast<GLenum>(GL_REPEAT), info_->wrap_s());
   EXPECT_EQ(static_cast<GLenum>(GL_REPEAT), info_->wrap_t());
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
   EXPECT_EQ(0u, info_->estimated_size());
 }
 
 TEST_F(TextureInfoTest, EstimatedSize) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 8, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_EQ(8u * 4u * 4u, info_->estimated_size());
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 2, GL_RGBA, 8, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_EQ(8u * 4u * 4u * 2u, info_->estimated_size());
 }
 
+TEST_F(TextureInfoMemoryTrackerTest, EstimatedSize) {
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 128, MemoryTracker::kUnmanaged);
+  manager_->SetLevelInfo(info_,
+      GL_TEXTURE_2D, 0, GL_RGBA, 8, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(128, 256, MemoryTracker::kUnmanaged);
+  manager_->SetLevelInfo(info_,
+      GL_TEXTURE_2D, 2, GL_RGBA, 8, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
+  // Add expectation for texture deletion.
+  EXPECT_MEMORY_ALLOCATION_CHANGE(256, 0, MemoryTracker::kUnmanaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 0, MemoryTracker::kUnmanaged);
+}
+
+TEST_F(TextureInfoMemoryTrackerTest, SetParameterPool) {
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 128, MemoryTracker::kUnmanaged);
+  manager_->SetLevelInfo(info_,
+      GL_TEXTURE_2D, 0, GL_RGBA, 8, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(128, 0, MemoryTracker::kUnmanaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 128, MemoryTracker::kManaged);
+  EXPECT_EQ(static_cast<GLenum>(GL_NO_ERROR), manager_->SetParameter(
+      info_, GL_TEXTURE_POOL_CHROMIUM, GL_TEXTURE_POOL_MANAGED_CHROMIUM));
+  // Add expectation for texture deletion.
+  EXPECT_MEMORY_ALLOCATION_CHANGE(128, 0, MemoryTracker::kManaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 0, MemoryTracker::kUnmanaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 0, MemoryTracker::kManaged);
+}
+
 TEST_F(TextureInfoTest, POT2D) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
   EXPECT_EQ(static_cast<GLenum>(GL_TEXTURE_2D), info_->target());
   // Check Setting level 0 to POT
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
-  EXPECT_FALSE(manager_.CanRender(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
   // Set filters to something that will work with a single mip.
-  manager_.SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  manager_->SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   // Set them back.
-  manager_.SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
+  manager_->SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
 
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
   // Make mips.
-  EXPECT_TRUE(manager_.MarkMipmapsGenerated(info_));
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
   EXPECT_TRUE(info_->texture_complete());
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   // Change a mip.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
   // Set a level past the number of mips that would get generated.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 3, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
   // Make mips.
-  EXPECT_TRUE(manager_.MarkMipmapsGenerated(info_));
-  EXPECT_TRUE(manager_.CanRender(info_));
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
+  EXPECT_TRUE(manager_->CanRender(info_));
   EXPECT_TRUE(info_->texture_complete());
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
 }
 
+TEST_F(TextureInfoMemoryTrackerTest, MarkMipmapsGenerated) {
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 64, MemoryTracker::kUnmanaged);
+  manager_->SetLevelInfo(info_,
+      GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(64, 84, MemoryTracker::kUnmanaged);
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
+  EXPECT_MEMORY_ALLOCATION_CHANGE(84, 0, MemoryTracker::kUnmanaged);
+  EXPECT_MEMORY_ALLOCATION_CHANGE(0, 0, MemoryTracker::kUnmanaged);
+}
+
 TEST_F(TextureInfoTest, UnusedMips) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
   EXPECT_EQ(static_cast<GLenum>(GL_TEXTURE_2D), info_->target());
   // Set level zero to large size.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
-  EXPECT_TRUE(manager_.MarkMipmapsGenerated(info_));
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
   EXPECT_FALSE(info_->npot());
   EXPECT_TRUE(info_->texture_complete());
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   // Set level zero to large smaller (levels unused mips)
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
-  EXPECT_TRUE(manager_.MarkMipmapsGenerated(info_));
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
   EXPECT_FALSE(info_->npot());
   EXPECT_TRUE(info_->texture_complete());
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   // Set an unused level to some size
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 4, GL_RGBA, 16, 16, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_TRUE(info_->texture_complete());
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
 }
 
 TEST_F(TextureInfoTest, NPOT2D) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
   EXPECT_EQ(static_cast<GLenum>(GL_TEXTURE_2D), info_->target());
   // Check Setting level 0 to NPOT
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 5, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_TRUE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetParameter(info_, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetParameter(info_, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetParameter(info_, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetParameter(info_, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   // Change it to POT.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
 }
 
 TEST_F(TextureInfoTest, NPOT2DNPOTOK) {
@@ -540,93 +609,93 @@
 }
 
 TEST_F(TextureInfoTest, POTCubeMap) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_CUBE_MAP);
+  manager_->SetInfoTarget(info_, GL_TEXTURE_CUBE_MAP);
   EXPECT_EQ(static_cast<GLenum>(GL_TEXTURE_CUBE_MAP), info_->target());
   // Check Setting level 0 each face to POT
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_POSITIVE_X,
       0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_FALSE(info_->cube_complete());
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetLevelInfo(info_,
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
       0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_FALSE(info_->cube_complete());
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetLevelInfo(info_,
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
       0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_FALSE(info_->cube_complete());
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetLevelInfo(info_,
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
       0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_FALSE(info_->cube_complete());
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetLevelInfo(info_,
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
       0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_FALSE(info_->cube_complete());
-  EXPECT_FALSE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
-  manager_.SetLevelInfo(info_,
+  EXPECT_FALSE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
       0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_TRUE(info_->cube_complete());
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
-  EXPECT_FALSE(manager_.CanRender(info_));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
+  EXPECT_FALSE(manager_->CanRender(info_));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
 
   // Make mips.
-  EXPECT_TRUE(manager_.MarkMipmapsGenerated(info_));
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
   EXPECT_TRUE(info_->texture_complete());
   EXPECT_TRUE(info_->cube_complete());
-  EXPECT_TRUE(manager_.CanRender(info_));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanRender(info_));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
 
   // Change a mip.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
       1, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_FALSE(info_->npot());
   EXPECT_FALSE(info_->texture_complete());
   EXPECT_TRUE(info_->cube_complete());
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
   // Set a level past the number of mips that would get generated.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
       3, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
-  EXPECT_TRUE(manager_.CanGenerateMipmaps(info_));
+  EXPECT_TRUE(manager_->CanGenerateMipmaps(info_));
   // Make mips.
-  EXPECT_TRUE(manager_.MarkMipmapsGenerated(info_));
+  EXPECT_TRUE(manager_->MarkMipmapsGenerated(info_));
   EXPECT_TRUE(info_->texture_complete());
   EXPECT_TRUE(info_->cube_complete());
 }
 
 TEST_F(TextureInfoTest, GetLevelSize) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 5, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   GLsizei width = -1;
   GLsizei height = -1;
@@ -636,15 +705,15 @@
   EXPECT_TRUE(info_->GetLevelSize(GL_TEXTURE_2D, 1, &width, &height));
   EXPECT_EQ(4, width);
   EXPECT_EQ(5, height);
-  manager_.RemoveTextureInfo(kClient1Id);
+  manager_->RemoveTextureInfo(kClient1Id);
   EXPECT_TRUE(info_->GetLevelSize(GL_TEXTURE_2D, 1, &width, &height));
   EXPECT_EQ(4, width);
   EXPECT_EQ(5, height);
 }
 
 TEST_F(TextureInfoTest, GetLevelType) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 5, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   GLenum type = -1;
   GLenum format = -1;
@@ -654,15 +723,15 @@
   EXPECT_TRUE(info_->GetLevelType(GL_TEXTURE_2D, 1, &type, &format));
   EXPECT_EQ(static_cast<GLenum>(GL_UNSIGNED_BYTE), type);
   EXPECT_EQ(static_cast<GLenum>(GL_RGBA), format);
-  manager_.RemoveTextureInfo(kClient1Id);
+  manager_->RemoveTextureInfo(kClient1Id);
   EXPECT_TRUE(info_->GetLevelType(GL_TEXTURE_2D, 1, &type, &format));
   EXPECT_EQ(static_cast<GLenum>(GL_UNSIGNED_BYTE), type);
   EXPECT_EQ(static_cast<GLenum>(GL_RGBA), format);
 }
 
 TEST_F(TextureInfoTest, ValidForTexture) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 5, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   // Check bad face.
   EXPECT_FALSE(info_->ValidForTexture(
@@ -701,7 +770,7 @@
   // Check valid particial size.
   EXPECT_TRUE(info_->ValidForTexture(
       GL_TEXTURE_2D, 1, 1, 1, 2, 3, GL_RGBA, GL_UNSIGNED_BYTE));
-  manager_.RemoveTextureInfo(kClient1Id);
+  manager_->RemoveTextureInfo(kClient1Id);
   EXPECT_TRUE(info_->ValidForTexture(
       GL_TEXTURE_2D, 1, 0, 0, 4, 5, GL_RGBA, GL_UNSIGNED_BYTE));
 }
@@ -825,160 +894,160 @@
   static const GLuint kService2Id = 12;
   static const GLuint kClient3Id = 3;
   static const GLuint kService3Id = 13;
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info_->num_uncleared_mips());
-  manager_.SetLevelCleared(info_, GL_TEXTURE_2D, 0, true);
+  manager_->SetLevelCleared(info_, GL_TEXTURE_2D, 0, true);
   EXPECT_TRUE(info_->SafeToRenderFrom());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info_->num_uncleared_mips());
-  manager_.SetLevelCleared(info_, GL_TEXTURE_2D, 1, true);
+  manager_->SetLevelCleared(info_, GL_TEXTURE_2D, 1, true);
   EXPECT_TRUE(info_->SafeToRenderFrom());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(2, info_->num_uncleared_mips());
-  manager_.SetLevelCleared(info_, GL_TEXTURE_2D, 0, true);
+  manager_->SetLevelCleared(info_, GL_TEXTURE_2D, 0, true);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info_->num_uncleared_mips());
-  manager_.SetLevelCleared(info_, GL_TEXTURE_2D, 1, true);
+  manager_->SetLevelCleared(info_, GL_TEXTURE_2D, 1, true);
   EXPECT_TRUE(info_->SafeToRenderFrom());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info_->num_uncleared_mips());
-  manager_.MarkMipmapsGenerated(info_);
+  manager_->MarkMipmapsGenerated(info_);
   EXPECT_TRUE(info_->SafeToRenderFrom());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
 
-  manager_.CreateTextureInfo(kClient2Id, kService2Id);
-  TextureManager::TextureInfo::Ref info2 = manager_.GetTextureInfo(kClient2Id);
+  manager_->CreateTextureInfo(kClient2Id, kService2Id);
+  TextureManager::TextureInfo::Ref info2 = manager_->GetTextureInfo(kClient2Id);
   ASSERT_TRUE(info2.get() != NULL);
-  manager_.SetInfoTarget(info2, GL_TEXTURE_2D);
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  manager_->SetInfoTarget(info2, GL_TEXTURE_2D);
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info2->num_uncleared_mips());
-  manager_.SetLevelInfo(info2,
+  manager_->SetLevelInfo(info2,
       GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info2->num_uncleared_mips());
-  manager_.SetLevelInfo(info2,
+  manager_->SetLevelInfo(info2,
       GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info2->num_uncleared_mips());
 
-  manager_.CreateTextureInfo(kClient3Id, kService3Id);
-  TextureManager::TextureInfo::Ref info3 = manager_.GetTextureInfo(kClient3Id);
+  manager_->CreateTextureInfo(kClient3Id, kService3Id);
+  TextureManager::TextureInfo::Ref info3 = manager_->GetTextureInfo(kClient3Id);
   ASSERT_TRUE(info3.get() != NULL);
-  manager_.SetInfoTarget(info3, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info3,
+  manager_->SetInfoTarget(info3, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info3,
       GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info3->num_uncleared_mips());
-  manager_.SetLevelCleared(info2, GL_TEXTURE_2D, 0, true);
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  manager_->SetLevelCleared(info2, GL_TEXTURE_2D, 0, true);
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info2->num_uncleared_mips());
-  manager_.SetLevelCleared(info3, GL_TEXTURE_2D, 0, true);
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  manager_->SetLevelCleared(info3, GL_TEXTURE_2D, 0, true);
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info3->num_uncleared_mips());
 
-  manager_.SetLevelInfo(info2,
+  manager_->SetLevelInfo(info2,
       GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  manager_.SetLevelInfo(info3,
+  manager_->SetLevelInfo(info3,
       GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info2->num_uncleared_mips());
   EXPECT_EQ(1, info3->num_uncleared_mips());
-  manager_.RemoveTextureInfo(kClient3Id);
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
-  manager_.RemoveTextureInfo(kClient2Id);
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  manager_->RemoveTextureInfo(kClient3Id);
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
+  manager_->RemoveTextureInfo(kClient2Id);
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_CALL(*gl_, DeleteTextures(1, ::testing::Pointee(kService2Id)))
       .Times(1)
       .RetiresOnSaturation();
   info2 = NULL;
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_CALL(*gl_, DeleteTextures(1, ::testing::Pointee(kService3Id)))
       .Times(1)
       .RetiresOnSaturation();
   info3 = NULL;
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
 }
 
 TEST_F(TextureInfoTest, ClearTexture) {
   scoped_ptr<MockGLES2Decoder> decoder(new gles2::MockGLES2Decoder());
   EXPECT_CALL(*decoder, ClearLevel(_, _, _, _, _, _, _, _, _))
       .WillRepeatedly(Return(true));
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(2, info_->num_uncleared_mips());
-  manager_.ClearRenderableLevels(decoder.get(), info_);
+  manager_->ClearRenderableLevels(decoder.get(), info_);
   EXPECT_TRUE(info_->SafeToRenderFrom());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(2, info_->num_uncleared_mips());
-  manager_.ClearTextureLevel(decoder.get(), info_, GL_TEXTURE_2D, 0);
+  manager_->ClearTextureLevel(decoder.get(), info_, GL_TEXTURE_2D, 0);
   EXPECT_FALSE(info_->SafeToRenderFrom());
-  EXPECT_TRUE(manager_.HaveUnsafeTextures());
-  EXPECT_TRUE(manager_.HaveUnclearedMips());
+  EXPECT_TRUE(manager_->HaveUnsafeTextures());
+  EXPECT_TRUE(manager_->HaveUnclearedMips());
   EXPECT_EQ(1, info_->num_uncleared_mips());
-  manager_.ClearTextureLevel(decoder.get(), info_, GL_TEXTURE_2D, 1);
+  manager_->ClearTextureLevel(decoder.get(), info_, GL_TEXTURE_2D, 1);
   EXPECT_TRUE(info_->SafeToRenderFrom());
-  EXPECT_FALSE(manager_.HaveUnsafeTextures());
-  EXPECT_FALSE(manager_.HaveUnclearedMips());
+  EXPECT_FALSE(manager_->HaveUnsafeTextures());
+  EXPECT_FALSE(manager_->HaveUnclearedMips());
   EXPECT_EQ(0, info_->num_uncleared_mips());
 }
 
@@ -986,25 +1055,25 @@
   static const GLuint kClient2Id = 2;
   static const GLuint kService2Id = 12;
   // Make the default texture renderable
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   // Make a new texture
-  manager_.CreateTextureInfo(kClient2Id, kService2Id);
-  TextureManager::TextureInfo::Ref info(manager_.GetTextureInfo(kClient2Id));
-  manager_.SetInfoTarget(info, GL_TEXTURE_2D);
-  EXPECT_FALSE(manager_.CanRender(info));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
+  manager_->CreateTextureInfo(kClient2Id, kService2Id);
+  TextureManager::TextureInfo::Ref info(manager_->GetTextureInfo(kClient2Id));
+  manager_->SetInfoTarget(info, GL_TEXTURE_2D);
+  EXPECT_FALSE(manager_->CanRender(info));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
   // Remove it.
-  manager_.RemoveTextureInfo(kClient2Id);
-  EXPECT_FALSE(manager_.CanRender(info));
-  EXPECT_TRUE(manager_.HaveUnrenderableTextures());
+  manager_->RemoveTextureInfo(kClient2Id);
+  EXPECT_FALSE(manager_->CanRender(info));
+  EXPECT_TRUE(manager_->HaveUnrenderableTextures());
   // Check that we can still manipulate it and it effects the manager.
-  manager_.SetLevelInfo(info,
+  manager_->SetLevelInfo(info,
       GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
-  EXPECT_TRUE(manager_.CanRender(info));
-  EXPECT_FALSE(manager_.HaveUnrenderableTextures());
+  EXPECT_TRUE(manager_->CanRender(info));
+  EXPECT_FALSE(manager_->HaveUnrenderableTextures());
   EXPECT_CALL(*gl_, DeleteTextures(1, ::testing::Pointee(kService2Id)))
       .Times(1)
       .RetiresOnSaturation();
@@ -1012,21 +1081,21 @@
 }
 
 TEST_F(TextureInfoTest, GetLevelImage) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_TRUE(info_->GetLevelImage(GL_TEXTURE_2D, 1) == NULL);
   // Set image.
-  manager_.SetLevelImage(info_,
+  manager_->SetLevelImage(info_,
       GL_TEXTURE_2D, 1, gfx::GLImage::CreateGLImage(0));
   EXPECT_FALSE(info_->GetLevelImage(GL_TEXTURE_2D, 1) == NULL);
   // Remove it.
-  manager_.SetLevelImage(info_, GL_TEXTURE_2D, 1, NULL);
+  manager_->SetLevelImage(info_, GL_TEXTURE_2D, 1, NULL);
   EXPECT_TRUE(info_->GetLevelImage(GL_TEXTURE_2D, 1) == NULL);
-  manager_.SetLevelImage(info_,
+  manager_->SetLevelImage(info_,
       GL_TEXTURE_2D, 1, gfx::GLImage::CreateGLImage(0));
   // Image should be reset when SetLevelInfo is called.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   EXPECT_TRUE(info_->GetLevelImage(GL_TEXTURE_2D, 1) == NULL);
 }
@@ -1042,110 +1111,112 @@
 }  // anonymous namespace
 
 TEST_F(TextureInfoTest, AddToSignature) {
-  manager_.SetInfoTarget(info_, GL_TEXTURE_2D);
-  manager_.SetLevelInfo(info_,
+  manager_->SetInfoTarget(info_, GL_TEXTURE_2D);
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   std::string signature1;
   std::string signature2;
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature1);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature1);
 
   std::set<std::string> string_set;
   EXPECT_FALSE(InSet(&string_set, signature1));
 
   // check changing 1 thing makes a different signature.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 4, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
   // check putting it back makes the same signature.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, true);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_EQ(signature1, signature2);
 
   // Check setting cleared status does not change signature.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_EQ(signature1, signature2);
 
   // Check changing other settings changes signature.
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 4, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_FLOAT,
       false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
   // put it back
-  manager_.SetLevelInfo(info_,
+  manager_->SetLevelInfo(info_,
       GL_TEXTURE_2D, 1, GL_RGBA, 2, 2, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE,
       false);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_EQ(signature1, signature2);
 
   // check changing parameters changes signature.
-  manager_.SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  manager_->SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetParameter(info_, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
-  manager_.SetParameter(info_, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  manager_->SetParameter(
+      info_, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR);
+  manager_->SetParameter(info_, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetParameter(info_, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-  manager_.SetParameter(info_, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  manager_->SetParameter(info_, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  manager_->SetParameter(info_, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
-  manager_.SetParameter(info_, GL_TEXTURE_WRAP_S, GL_REPEAT);
-  manager_.SetParameter(info_, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  manager_->SetParameter(info_, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  manager_->SetParameter(info_, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_FALSE(InSet(&string_set, signature2));
 
   // Check putting it back genenerates the same signature
-  manager_.SetParameter(info_, GL_TEXTURE_WRAP_T, GL_REPEAT);
+  manager_->SetParameter(info_, GL_TEXTURE_WRAP_T, GL_REPEAT);
   signature2.clear();
-  manager_.AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
+  manager_->AddToSignature(info_, GL_TEXTURE_2D, 1, &signature2);
   EXPECT_EQ(signature1, signature2);
 
   // Check the set was acutally getting different signatures.
   EXPECT_EQ(11u, string_set.size());
 }
 
+
 }  // namespace gles2
 }  // namespace gpu
 
Index: src/gpu/command_buffer/service/query_manager.cc
===================================================================
--- src/gpu/command_buffer/service/query_manager.cc	(revision 184497)
+++ src/gpu/command_buffer/service/query_manager.cc	(working copy)
@@ -3,13 +3,15 @@
 // found in the LICENSE file.
 
 #include "gpu/command_buffer/service/query_manager.h"
+
 #include "base/atomicops.h"
 #include "base/bind.h"
 #include "base/logging.h"
+#include "base/shared_memory.h"
 #include "base/time.h"
 #include "gpu/command_buffer/common/gles2_cmd_format.h"
+#include "gpu/command_buffer/service/feature_info.h"
 #include "gpu/command_buffer/service/gles2_cmd_decoder.h"
-#include "gpu/command_buffer/service/feature_info.h"
 #include "ui/gl/async_pixel_transfer_delegate.h"
 
 namespace gpu {
@@ -176,10 +178,22 @@
   virtual bool Process() OVERRIDE;
   virtual void Destroy(bool have_context) OVERRIDE;
 
-  void MarkAsCompletedCallback() { MarkAsCompleted(1); }
-
  protected:
   virtual ~AsyncPixelTransfersCompletedQuery();
+
+  static void MarkAsCompletedThreadSafe(
+      uint32 submit_count, const gfx::AsyncMemoryParams& mem_params) {
+    DCHECK(mem_params.shared_memory);
+    DCHECK(mem_params.shared_memory->memory());
+    void *data = static_cast<int8*>(mem_params.shared_memory->memory()) +
+        mem_params.shm_data_offset;
+    QuerySync* sync = static_cast<QuerySync*>(data);
+
+    // Need a MemoryBarrier here to ensure that upload completed before
+    // submit_count was written to sync->process_count.
+    base::subtle::MemoryBarrier();
+    sync->process_count = submit_count;
+  }
 };
 
 AsyncPixelTransfersCompletedQuery::AsyncPixelTransfersCompletedQuery(
@@ -192,28 +206,41 @@
 }
 
 bool AsyncPixelTransfersCompletedQuery::End(uint32 submit_count) {
-  MarkAsPending(submit_count);
+  gfx::AsyncMemoryParams mem_params;
+  // Get the real shared memory since it might need to be duped to prevent
+  // use-after-free of the memory.
+  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());
+  if (!buffer.shared_memory)
+    return false;
+  mem_params.shared_memory = buffer.shared_memory;
+  mem_params.shm_size = buffer.size;
+  mem_params.shm_data_offset = shm_offset();
+  mem_params.shm_data_size = sizeof(QuerySync);
 
-  // This will call MarkAsCompleted(1) as a reply to a task on
-  // the async upload thread, such that it occurs after all previous
-  // async transfers have completed.
+  // Ask AsyncPixelTransferDelegate to run completion callback after all
+  // previous async transfers are done. No guarantee that callback is run
+  // on the current thread.
   manager()->decoder()->GetAsyncPixelTransferDelegate()->AsyncNotifyCompletion(
-      base::Bind(
-          &AsyncPixelTransfersCompletedQuery::MarkAsCompletedCallback,
-          AsWeakPtr()));
+      mem_params,
+      base::Bind(AsyncPixelTransfersCompletedQuery::MarkAsCompletedThreadSafe,
+                 submit_count));
 
-  // TODO(epenner): The async task occurs outside the normal
-  // flow, via a callback on this thread. Is there anything
-  // missing or wrong with that?
-
-  // TODO(epenner): Could we possibly trigger the completion on
-  // the upload thread by writing to the query shared memory
-  // directly?
-  return true;
+  return AddToPendingTransferQueue(submit_count);
 }
 
 bool AsyncPixelTransfersCompletedQuery::Process() {
-  NOTREACHED();
+  QuerySync* sync = manager()->decoder()->GetSharedMemoryAs<QuerySync*>(
+      shm_id(), shm_offset(), sizeof(*sync));
+  if (!sync)
+    return false;
+
+  // Check if completion callback has been run. sync->process_count atomicity
+  // is guaranteed as this is already used to notify client of a completed
+  // query.
+  if (sync->process_count != submit_count())
+    return true;
+
+  UnmarkAsPending();
   return true;
 }
 
@@ -295,6 +322,7 @@
 
 void QueryManager::Destroy(bool have_context) {
   pending_queries_.clear();
+  pending_transfer_queries_.clear();
   while (!queries_.empty()) {
     Query* query = queries_.begin()->second;
     query->Destroy(have_context);
@@ -435,7 +463,7 @@
       return false;
     }
     if (query->pending()) {
-      return true;
+      break;
     }
     pending_queries_.pop_front();
   }
@@ -447,6 +475,25 @@
   return !pending_queries_.empty();
 }
 
+bool QueryManager::ProcessPendingTransferQueries() {
+  while (!pending_transfer_queries_.empty()) {
+    Query* query = pending_transfer_queries_.front().get();
+    if (!query->Process()) {
+      return false;
+    }
+    if (query->pending()) {
+      break;
+    }
+    pending_transfer_queries_.pop_front();
+  }
+
+  return true;
+}
+
+bool QueryManager::HavePendingTransferQueries() {
+  return !pending_transfer_queries_.empty();
+}
+
 bool QueryManager::AddPendingQuery(Query* query, uint32 submit_count) {
   DCHECK(query);
   DCHECK(!query->IsDeleted());
@@ -458,6 +505,17 @@
   return true;
 }
 
+bool QueryManager::AddPendingTransferQuery(Query* query, uint32 submit_count) {
+  DCHECK(query);
+  DCHECK(!query->IsDeleted());
+  if (!RemovePendingQuery(query)) {
+    return false;
+  }
+  query->MarkAsPending(submit_count);
+  pending_transfer_queries_.push_back(query);
+  return true;
+}
+
 bool QueryManager::RemovePendingQuery(Query* query) {
   DCHECK(query);
   if (query->pending()) {
@@ -471,6 +529,13 @@
         break;
       }
     }
+    for (QueryQueue::iterator it = pending_transfer_queries_.begin();
+         it != pending_transfer_queries_.end(); ++it) {
+      if (it->get() == query) {
+        pending_transfer_queries_.erase(it);
+        break;
+      }
+    }
     if (!query->MarkAsCompleted(0)) {
       return false;
     }
Index: src/gpu/command_buffer/service/buffer_manager.h
===================================================================
--- src/gpu/command_buffer/service/buffer_manager.h	(revision 184497)
+++ src/gpu/command_buffer/service/buffer_manager.h	(working copy)
@@ -69,7 +69,7 @@
 
    private:
     friend class BufferManager;
-    friend class BufferManagerTest;
+    friend class BufferManagerTestBase;
     friend class base::RefCounted<BufferInfo>;
 
     // Represents a range in a buffer.
Index: src/gpu/command_buffer/service/feature_info.cc
===================================================================
--- src/gpu/command_buffer/service/feature_info.cc	(revision 184497)
+++ src/gpu/command_buffer/service/feature_info.cc	(working copy)
@@ -93,6 +93,8 @@
       set_texture_filter_before_generating_mipmap(false),
       use_current_program_after_successful_link(false),
       restore_scissor_on_fbo_change(false),
+      flush_on_context_switch(false),
+      delete_instead_of_resize_fbo(false),
       max_texture_size(0),
       max_cube_map_texture_size(0) {
 }
@@ -212,6 +214,7 @@
   bool is_amd = false;
   bool is_mesa = false;
   bool is_qualcomm = false;
+  bool is_imagination = false;
   for (size_t ii = 0; ii < arraysize(string_ids); ++ii) {
     const char* str = reinterpret_cast<const char*>(
           glGetString(string_ids[ii]));
@@ -223,6 +226,7 @@
       is_amd |= string_set.Contains("amd") || string_set.Contains("ati");
       is_mesa |= string_set.Contains("mesa");
       is_qualcomm |= string_set.Contains("qualcomm");
+      is_imagination |= string_set.Contains("imagination");
     }
   }
 
@@ -255,6 +259,12 @@
   AddExtensionString("GL_CHROMIUM_texture_mailbox");
   AddExtensionString("GL_EXT_debug_marker");
 
+  // Add extension to indicate fast-path texture uploads. This is
+  // for IMG, where everything except async + non-power-of-two +
+  // multiple-of-eight textures are brutally slow.
+  if (is_imagination)
+    AddExtensionString("GL_CHROMIUM_fast_NPOT_MO8_textures");
+
   if (!disallowed_features_.gpu_memory_manager)
     AddExtensionString("GL_CHROMIUM_gpu_memory_manager");
 
@@ -674,6 +684,9 @@
 
     if (is_qualcomm) {
       workarounds_.restore_scissor_on_fbo_change = true;
+      workarounds_.flush_on_context_switch = true;
+      // This is only needed on the ICS driver.
+      workarounds_.delete_instead_of_resize_fbo = true;
     }
 
 #if defined(OS_MACOSX)
Index: src/gpu/command_buffer/service/common_decoder.cc
===================================================================
--- src/gpu/command_buffer/service/common_decoder.cc	(revision 184497)
+++ src/gpu/command_buffer/service/common_decoder.cc	(working copy)
@@ -63,6 +63,7 @@
 void* CommonDecoder::GetAddressAndCheckSize(unsigned int shm_id,
                                             unsigned int offset,
                                             unsigned int size) {
+  CHECK(engine_);
   Buffer buffer = engine_->GetSharedMemoryBuffer(shm_id);
   if (!buffer.ptr)
     return NULL;
Index: src/gpu/command_buffer/service/common_decoder.h
===================================================================
--- src/gpu/command_buffer/service/common_decoder.h	(revision 184497)
+++ src/gpu/command_buffer/service/common_decoder.h	(working copy)
@@ -102,6 +102,7 @@
   void set_engine(CommandBufferEngine* engine) {
     engine_ = engine;
   }
+  CommandBufferEngine* engine() const { return engine_; }
 
   // Creates a bucket. If the bucket already exists returns that bucket.
   Bucket* CreateBucket(uint32 bucket_id);
Index: src/ppapi/proxy/ppapi_command_buffer_proxy.h
===================================================================
--- src/ppapi/proxy/ppapi_command_buffer_proxy.h	(revision 184497)
+++ src/ppapi/proxy/ppapi_command_buffer_proxy.h	(working copy)
@@ -40,6 +40,7 @@
   virtual bool Initialize();
   virtual State GetState();
   virtual State GetLastState();
+  virtual int32 GetLastToken();
   virtual void Flush(int32 put_offset);
   virtual State FlushSync(int32 put_offset, int32 last_known_get);
   virtual void SetGetBuffer(int32 transfer_buffer_id);
Index: src/ppapi/proxy/ppapi_command_buffer_proxy.cc
===================================================================
--- src/ppapi/proxy/ppapi_command_buffer_proxy.cc	(revision 184497)
+++ src/ppapi/proxy/ppapi_command_buffer_proxy.cc	(working copy)
@@ -84,6 +84,12 @@
   return last_state_;
 }
 
+int32 PpapiCommandBufferProxy::GetLastToken() {
+  // Note: The locking command buffer wrapper does not take a global lock before
+  // calling this function.
+  return last_state_.token;
+}
+
 void PpapiCommandBufferProxy::Flush(int32 put_offset) {
   if (last_state_.error != gpu::error::kNoError)
     return;
Index: src/ppapi/proxy/ppb_graphics_3d_proxy.cc
===================================================================
--- src/ppapi/proxy/ppb_graphics_3d_proxy.cc	(revision 184497)
+++ src/ppapi/proxy/ppb_graphics_3d_proxy.cc	(working copy)
@@ -130,6 +130,9 @@
     // MaybeLock lock(need_to_lock_);
     return gpu_command_buffer_->GetLastState();
   }
+  virtual int32 GetLastToken() OVERRIDE {
+    return GetLastState().token;
+  }
   virtual void Flush(int32 put_offset) OVERRIDE {
     MaybeLock lock(need_to_lock_);
     gpu_command_buffer_->Flush(put_offset);
Index: src/content/public/common/gpu_memory_stats.cc
===================================================================
--- src/content/public/common/gpu_memory_stats.cc	(revision 184497)
+++ src/content/public/common/gpu_memory_stats.cc	(working copy)
@@ -6,7 +6,9 @@
 
 namespace content {
 
-GPUVideoMemoryUsageStats::GPUVideoMemoryUsageStats() {
+GPUVideoMemoryUsageStats::GPUVideoMemoryUsageStats()
+    : bytes_allocated(0),
+      bytes_allocated_historical_max(0) {
 }
 
 GPUVideoMemoryUsageStats::~GPUVideoMemoryUsageStats() {
Index: src/content/public/common/gpu_memory_stats.h
===================================================================
--- src/content/public/common/gpu_memory_stats.h	(revision 184497)
+++ src/content/public/common/gpu_memory_stats.h	(working copy)
@@ -36,6 +36,12 @@
 
   // A map of processes to their GPU resource consumption
   ProcessMap process_map;
+
+  // The total amount of GPU memory allocated at the time of the request.
+  size_t bytes_allocated;
+
+  // The maximum amount of GPU memory ever allocated at once.
+  size_t bytes_allocated_historical_max;
 };
 
 }  // namespace content
Index: src/content/public/android/java/src/org/chromium/content/browser/ContentViewClient.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/ContentViewClient.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/ContentViewClient.java	(working copy)
@@ -35,6 +35,13 @@
     }
 
     /**
+     * Called whenever the background color of the page changes as notified by WebKit.
+     * @param color The new ARGB color of the page background.
+     */
+    public void onBackgroundColorChanged(int color) {
+    }
+
+    /**
       * Lets client listen on the scaling changes on delayed, throttled
       * and best-effort basis. Used for WebView.onScaleChanged.
       */
Index: src/content/public/android/java/src/org/chromium/content/browser/SelectionHandleController.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/SelectionHandleController.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/SelectionHandleController.java	(working copy)
@@ -4,6 +4,7 @@
 
 package org.chromium.content.browser;
 
+import android.graphics.PointF;
 import android.view.View;
 
 /**
@@ -11,9 +12,11 @@
  */
 abstract class SelectionHandleController implements CursorController {
 
-    // The following constants match the ones in base/i18n/rtl.h.
-    private static final int TEXT_DIRECTION_RTL = 1;
-    private static final int TEXT_DIRECTION_LTR = 2;
+    // The following constants match the ones in
+    // third_party/WebKit/Source/WebKit/chromium/public/WebTextDirection.h
+    private static final int TEXT_DIRECTION_DEFAULT = 0;
+    private static final int TEXT_DIRECTION_LTR = 1;
+    private static final int TEXT_DIRECTION_RTL = 2;
 
     /** The cursor controller images, lazily created when shown. */
     private HandleView mStartHandle, mEndHandle;
@@ -67,7 +70,7 @@
      * should be the start handle or end handle) to coordinates x,y.
      * Note that this will not actually result in the handle moving to (x,y):
      * selectBetweenCoordinates(x1,y1,x2,y2) will trigger the selection and set the
-     * actual coordinates later via showHandlesAt.
+     * actual coordinates later via set[Start|End]HandlePosition.
      */
     @Override
     public void updatePosition(HandleView handle, int x, int y) {
@@ -84,11 +87,7 @@
     /**
      * The concrete implementation must trigger a selection between the given
      * coordinates and (possibly asynchronously) set the actual handle positions
-     * after the selection is made via showHandlesAt(x1,y1,x2,y2).
-     * @param x1
-     * @param y1
-     * @param x2
-     * @param y2
+     * after the selection is made via set[Start|End]HandlePosition.
      */
     protected abstract void selectBetweenCoordinates(int x1, int y1, int x2, int y2);
 
@@ -119,43 +118,52 @@
 
     /**
      * Moves the start handle so that it points at the given coordinates.
-     * @param x
-     * @param y
      */
     void setStartHandlePosition(int x, int y) {
         mStartHandle.positionAt(x, y);
     }
 
+    void setStartHandlePosition(PointF point) {
+        setStartHandlePosition((int)point.x, (int)point.y);
+    }
+
     /**
      * Moves the end handle so that it points at the given coordinates.
-     * @param x
-     * @param y
      */
     void setEndHandlePosition(int x, int y) {
         mEndHandle.positionAt(x, y);
     }
 
+    void setEndHandlePosition(PointF point) {
+        setEndHandlePosition((int)point.x, (int)point.y);
+    }
+
     /**
-     * Moves the start handle by x pixels horizontally and y pixels vertically.
-     * @param x
-     * @param y
+     * If the handles are not visible, sets their visibility to View.VISIBLE and begins fading them
+     * in.
      */
-    void moveStartHandleBy(int x, int y) {
-        mStartHandle.moveTo(mStartHandle.getPositionX() + x, mStartHandle.getPositionY() + y);
+    void beginHandleFadeIn() {
+        mStartHandle.beginFadeIn();
+        mEndHandle.beginFadeIn();
     }
 
     /**
-     * Moves the end handle by x pixels horizontally and y pixels vertically.
-     * @param x
-     * @param y
+     * Sets the start and end handles to the given visibility.
      */
-    void moveEndHandleBy(int x, int y) {
-        mEndHandle.moveTo(mEndHandle.getPositionX() + x, mEndHandle.getPositionY() + y);
+    void setHandleVisibility(int visibility) {
+        mStartHandle.setVisibility(visibility);
+        mEndHandle.setVisibility(visibility);
     }
 
-    void onSelectionChanged(int x1, int y1, int dir1, int x2, int y2, int dir2) {
+    /**
+     * Shows the handles if allowed.
+     *
+     * @param startDir Direction (left/right) of start handle.
+     * @param endDir Direction (left/right) of end handle.
+     */
+    void onSelectionChanged(int startDir, int endDir) {
         if (mAllowAutomaticShowing) {
-            showHandlesAt(x1, y1, dir1, x2, y2, dir2);
+            showHandles(startDir, endDir);
         }
     }
 
@@ -164,26 +172,22 @@
      * Note: this method does not trigger a selection, see
      * selectBetweenCoordinates()
      *
-     * @param x1
-     * @param y1
-     * @param x2
-     * @param y2
+     * @param startDir Direction (left/right) of start handle.
+     * @param endDir Direction (left/right) of end handle.
      */
-    void showHandlesAt(int x1, int y1, int dir1, int x2, int y2, int dir2) {
-        createHandlesIfNeeded(dir1, dir2);
-        setStartHandlePosition(x1, y1);
-        setEndHandlePosition(x2, y2);
+    void showHandles(int startDir, int endDir) {
+        createHandlesIfNeeded(startDir, endDir);
         showHandlesIfNeeded();
     }
 
-    private void createHandlesIfNeeded(int start_dir, int end_dir) {
+    private void createHandlesIfNeeded(int startDir, int endDir) {
         if (mStartHandle == null) {
             mStartHandle = new HandleView(this,
-                start_dir == TEXT_DIRECTION_LTR ? HandleView.LEFT : HandleView.RIGHT, mParent);
+                startDir == TEXT_DIRECTION_RTL ? HandleView.RIGHT : HandleView.LEFT, mParent);
         }
         if (mEndHandle == null) {
             mEndHandle = new HandleView(this,
-                end_dir == TEXT_DIRECTION_LTR ? HandleView.RIGHT : HandleView.LEFT, mParent);
+                endDir == TEXT_DIRECTION_RTL ? HandleView.LEFT : HandleView.RIGHT, mParent);
         }
     }
 
@@ -192,6 +196,7 @@
             mIsShowing = true;
             mStartHandle.show();
             mEndHandle.show();
+            setHandleVisibility(HandleView.VISIBLE);
         }
     }
 }
Index: src/content/public/android/java/src/org/chromium/content/browser/ImeAdapter.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/ImeAdapter.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/ImeAdapter.java	(working copy)
@@ -315,10 +315,9 @@
 
     private boolean checkCompositionQueueAndCallNative(String text, int newCursorPosition,
             boolean isCommit) {
-        if (mNativeImeAdapterAndroid == 0) {
-            return false;
-        }
+        if (mNativeImeAdapterAndroid == 0) return false;
 
+
         // Committing an empty string finishes the current composition.
         boolean isFinish = text.isEmpty();
         if (!isFinish) {
@@ -368,9 +367,8 @@
     }
 
     private boolean translateAndSendNativeEvents(KeyEvent event) {
-        if (mNativeImeAdapterAndroid == 0) {
-            return false;
-        }
+        if (mNativeImeAdapterAndroid == 0) return false;
+
         int action = event.getAction();
         if (action != KeyEvent.ACTION_DOWN &&
             action != KeyEvent.ACTION_UP) {
@@ -438,7 +436,7 @@
         return true;
     }
 
-    private boolean setEditableSelectionOffsets(int start, int end) {
+    protected boolean setEditableSelectionOffsets(int start, int end) {
         if (mNativeImeAdapterAndroid == 0) {
             return false;
         }
@@ -446,6 +444,11 @@
         return true;
     }
 
+    private void batchStateChanged(boolean isBegin) {
+        if (mNativeImeAdapterAndroid == 0) return;
+        nativeImeBatchStateChanged(mNativeImeAdapterAndroid, isBegin);
+    }
+
     private boolean setComposingRegion(int start, int end) {
         if (mNativeImeAdapterAndroid == 0) {
             return false;
@@ -502,6 +505,8 @@
         private ImeAdapter mImeAdapter;
         private Editable mEditable;
         private boolean mSingleLine;
+        private int mNumNestedBatchEdits = 0;
+        private boolean mIgnoreTextInputStateUpdates = false;
 
         // Factory function.
         static public AdapterInputConnection getInstance(View view, ImeAdapter imeAdapter,
@@ -545,34 +550,32 @@
 
             boolean textUnchanged = prevText.equals(text);
 
-            if (textUnchanged
-                    && prevSelectionStart == selectionStart && prevSelectionEnd == selectionEnd
+            if (!textUnchanged) {
+                mEditable.replace(0, mEditable.length(), text);
+            }
+
+            if (prevSelectionStart == selectionStart && prevSelectionEnd == selectionEnd
                     && prevCompositionStart == compositionStart
                     && prevCompositionEnd == compositionEnd) {
                 // Nothing has changed; don't need to do anything
                 return;
             }
 
-            if (!textUnchanged) {
-                mEditable.replace(0, mEditable.length(), text);
-            }
             Selection.setSelection(mEditable, selectionStart, selectionEnd);
             super.setComposingRegion(compositionStart, compositionEnd);
 
-            if (textUnchanged || prevText.equals("")) {
-                // updateSelection should be called when a manual selection change occurs.
-                // Should not be called if text is being entered else issues can occur
-                // e.g. backspace to undo autocorrection will not work with the default OSK.
-                getInputMethodManager().updateSelection(mInternalView,
-                        selectionStart, selectionEnd, compositionStart, compositionEnd);
-            }
+            if (mIgnoreTextInputStateUpdates) return;
+            updateSelection(selectionStart, selectionEnd, compositionStart, compositionEnd);
+        }
 
-            // When WebKit changes the editable field, both the start and the end positions for
-            // the composition will be set to -1. In this case we have to call restart input
-            // for the IME to update its state.
-            if (textUnchanged && compositionStart == -1 && compositionEnd == -1) {
-                restartInput();
-            }
+        protected void updateSelection(
+                int selectionStart, int selectionEnd,
+                int compositionStart, int compositionEnd) {
+            // updateSelection should
+            // be called every time the selection or composition changes if it happens not
+            // within a batch edit, or at the end of each top level batch edit.
+            getInputMethodManager().updateSelection(mInternalView,
+                    selectionStart, selectionEnd, compositionStart, compositionEnd);
         }
 
         @Override
@@ -600,22 +603,17 @@
 
         @Override
         public boolean performEditorAction(int actionCode) {
-            switch (actionCode) {
-                case EditorInfo.IME_ACTION_NEXT:
-                    restartInput();
-                    // Send TAB key event
-                    long timeStampMs = System.currentTimeMillis();
-                    mImeAdapter.sendSyntheticKeyEvent(
-                            sEventTypeRawKeyDown, timeStampMs, KeyEvent.KEYCODE_TAB, 0);
-                    return true;
-                case EditorInfo.IME_ACTION_GO:
-                case EditorInfo.IME_ACTION_SEARCH:
-                    mImeAdapter.dismissInput(true);
-                    break;
+            if (actionCode == EditorInfo.IME_ACTION_NEXT) {
+                restartInput();
+                // Send TAB key event
+                long timeStampMs = System.currentTimeMillis();
+                mImeAdapter.sendSyntheticKeyEvent(
+                        sEventTypeRawKeyDown, timeStampMs, KeyEvent.KEYCODE_TAB, 0);
+            } else {
+                mImeAdapter.sendKeyEventWithKeyCode(KeyEvent.KEYCODE_ENTER,
+                        KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE
+                        | KeyEvent.FLAG_EDITOR_ACTION);
             }
-            mImeAdapter.sendKeyEventWithKeyCode(KeyEvent.KEYCODE_ENTER,
-                    KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE
-                    | KeyEvent.FLAG_EDITOR_ACTION);
             return true;
         }
 
@@ -651,6 +649,23 @@
         }
 
         @Override
+        public boolean beginBatchEdit() {
+            if (mNumNestedBatchEdits == 0) mImeAdapter.batchStateChanged(true);
+
+            mNumNestedBatchEdits++;
+            return false;
+        }
+
+        @Override
+        public boolean endBatchEdit() {
+            if (mNumNestedBatchEdits == 0) return false;
+
+            --mNumNestedBatchEdits;
+            if (mNumNestedBatchEdits == 0) mImeAdapter.batchStateChanged(false);
+            return false;
+        }
+
+        @Override
         public boolean deleteSurroundingText(int leftLength, int rightLength) {
             if (!super.deleteSurroundingText(leftLength, rightLength)) {
                 return false;
@@ -714,6 +729,8 @@
          */
         void restartInput() {
             getInputMethodManager().restartInput(mInternalView);
+            mIgnoreTextInputStateUpdates = false;
+            mNumNestedBatchEdits = 0;
         }
 
         @Override
@@ -728,6 +745,20 @@
             return getInputMethodManager().isActive();
         }
 
+        void setIgnoreTextInputStateUpdates(boolean shouldIgnore) {
+            mIgnoreTextInputStateUpdates = shouldIgnore;
+            if (shouldIgnore || mEditable == null) return;
+
+            updateSelection(Selection.getSelectionStart(mEditable),
+                    Selection.getSelectionEnd(mEditable),
+                    getComposingSpanStart(mEditable),
+                    getComposingSpanEnd(mEditable));
+        }
+
+        protected boolean isIgnoringTextInputStateUpdates() {
+            return mIgnoreTextInputStateUpdates;
+        }
+
         private InputMethodManager getInputMethodManager() {
             return (InputMethodManager) mInternalView.getContext()
                     .getSystemService(Context.INPUT_METHOD_SERVICE);
@@ -783,6 +814,8 @@
                         | InputType.TYPE_NUMBER_VARIATION_NORMAL;
                 outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
             }
+            outAttrs.initialSelStart = 0;
+            outAttrs.initialSelEnd = 0;
         }
     }
 
@@ -812,6 +845,8 @@
     private native void nativeDeleteSurroundingText(int nativeImeAdapterAndroid,
             int before, int after);
 
+    private native void nativeImeBatchStateChanged(int nativeImeAdapterAndroid, boolean isBegin);
+
     private native void nativeUnselect(int nativeImeAdapterAndroid);
     private native void nativeSelectAll(int nativeImeAdapterAndroid);
     private native void nativeCut(int nativeImeAdapterAndroid);
Index: src/content/public/android/java/src/org/chromium/content/browser/ContentViewCore.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/ContentViewCore.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/ContentViewCore.java	(working copy)
@@ -80,9 +80,8 @@
     // produce little visible difference.
     private static final float ZOOM_CONTROLS_EPSILON = 0.007f;
 
-    // To avoid checkerboard, we clamp the fling velocity based on the maximum number of tiles
-    // should be allowed to upload per 100ms.
-    private final int mMaxNumUploadTiles;
+    // Length of the delay (in ms) before fading in handles after the last page movement.
+    private static final int TEXT_HANDLE_FADE_IN_DELAY = 300;
 
     // Personality of the ContentView.
     private final int mPersonality;
@@ -191,17 +190,54 @@
 
     private SelectionHandleController mSelectionHandleController;
     private InsertionHandleController mInsertionHandleController;
-    // These offsets in document space with page scale normalized to 1.0.
-    private final PointF mStartHandleNormalizedPoint = new PointF();
-    private final PointF mEndHandleNormalizedPoint = new PointF();
-    private final PointF mInsertionHandleNormalizedPoint = new PointF();
 
+    private Runnable mDeferredHandleFadeInRunnable;
+
+    /**
+     * Handles conversion of a point from window (physical pixel) to document (absolute CSS) space
+     * and vice versa.
+     */
+    private class NormalizedPoint {
+        final PointF document = new PointF();
+        final PointF window = new PointF();
+        final PointF screen = new PointF();
+
+        void updateDocumentFromWindow() {
+            float x = window.x / mNativePageScaleFactor + mNativeScrollX;
+            float y = window.y / mNativePageScaleFactor + mNativeScrollY;
+            document.set(x, y);
+            updateScreenFromWindow();
+        }
+        void updateWindowFromDocument() {
+            float x = (document.x - mNativeScrollX) * mNativePageScaleFactor;
+            float y = (document.y - mNativeScrollY) * mNativePageScaleFactor;
+            window.set(x, y);
+            updateScreenFromWindow();
+        }
+        void updateScreenFromWindow() {
+            float dpi = getContext().getResources().getDisplayMetrics().density;
+            screen.set(window.x * dpi, window.y * dpi);
+        }
+        void setWindow(float x, float y) {
+            window.set(x, y);
+            updateDocumentFromWindow();
+        }
+        void setDocument(float x, float y) {
+            document.set(x, y);
+            updateWindowFromDocument();
+        }
+    }
+    private final NormalizedPoint mStartHandlePoint = new NormalizedPoint();
+    private final NormalizedPoint mEndHandlePoint = new NormalizedPoint();
+    private final NormalizedPoint mInsertionHandlePoint = new NormalizedPoint();
+
     // Tracks whether a selection is currently active.  When applied to selected text, indicates
     // whether the last selected text is still highlighted.
     private boolean mHasSelection;
     private String mLastSelectedText;
     private boolean mSelectionEditable;
     private ActionMode mActionMode;
+    private boolean mUnselectAllOnActionModeDismiss;
 
     // Delegate that will handle GET downloads, and be notified of completion of POST downloads.
     private ContentViewDownloadDelegate mDownloadDelegate;
@@ -276,30 +312,6 @@
 
         mPersonality = personality;
         HeapStatsLogger.init(mContext.getApplicationContext());
-
-        // We should set this constant based on the GPU performance. As it doesn't exist in the
-        // framework yet, we use the memory class as an indicator. Here are some good values that
-        // we determined via manual experimentation:
-        //
-        // Device            Screen size        Memory class   Tiles per 100ms
-        // ================= ================== ============== =====================
-        // Nexus S            480 x  800         128            9 (3 rows portrait)
-        // Galaxy Nexus       720 x 1280         256           12 (3 rows portrait)
-        // Nexus 7           1280 x  800         384           18 (3 rows landscape)
-        // Nexus 10          2560 x 1600         512           44 (4 rows landscape)
-        //
-        // Here is a spreadsheet with the data, plus a curve fit:
-        // https://docs.google.com/a/chromium.org/spreadsheet/pub?key=0AlNYk7HM2CgQdG1vUWRVWkU3ODRTc1B2SVF3ZTJBUkE&output=html
-        // That gives us tiles-per-100ms of 8, 13, 22, 37 for the devices listed above.
-        // Not too bad, and it should behave reasonably sensibly for unknown devices.
-        // If you want to tweak these constants, please update the spreadsheet appropriately.
-        //
-        // The curve is y = b * m^x, with coefficients as follows:
-        double b = 4.70009671080384;
-        double m = 1.00404437546897;
-        int memoryClass = ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE))
-                .getLargeMemoryClass();
-        mMaxNumUploadTiles = (int) Math.round(b * Math.pow(m, memoryClass));
     }
 
     /**
@@ -699,6 +711,11 @@
         }
     }
 
+    @CalledByNative
+    private void onBackgroundColorChanged(int color) {
+        getContentViewClient().onBackgroundColorChanged(color);
+    }
+
     /**
      * Load url without fixing up the url string. Consumers of ContentView are responsible for
      * ensuring the URL passed in is properly formatted (i.e. the scheme has been added if left
@@ -1002,6 +1019,7 @@
     @Override
     public boolean sendGesture(int type, long timeMs, int x, int y, Bundle b) {
         if (mNativeContentViewCore == 0) return false;
+        updateTextHandlesForGesture(type);
         switch (type) {
             case ContentViewGestureHandler.GESTURE_SHOW_PRESSED_STATE:
                 nativeShowPressState(mNativeContentViewCore, timeMs, x, y);
@@ -1036,8 +1054,8 @@
                 return true;
             case ContentViewGestureHandler.GESTURE_FLING_START:
                 nativeFlingStart(mNativeContentViewCore, timeMs, x, y,
-                        clampFlingVelocityX(b.getInt(ContentViewGestureHandler.VELOCITY_X, 0)),
-                        clampFlingVelocityY(b.getInt(ContentViewGestureHandler.VELOCITY_Y, 0)));
+                        b.getInt(ContentViewGestureHandler.VELOCITY_X, 0),
+                        b.getInt(ContentViewGestureHandler.VELOCITY_Y, 0));
                 return true;
             case ContentViewGestureHandler.GESTURE_FLING_CANCEL:
                 nativeFlingCancel(mNativeContentViewCore, timeMs);
@@ -1571,32 +1589,6 @@
         }
     }
 
-    /*
-     * To avoid checkerboard, we clamp the fling velocity based on the maximum number of tiles
-     * allowed to be uploaded per 100ms. Calculation is limited to one direction. We assume the
-     * tile size is 256x256. The precise distance / velocity should be calculated based on the
-     * logic in Scroller.java. As it is almost linear for the first 100ms, we use a simple math.
-     */
-    private int clampFlingVelocityX(int velocity) {
-        int cols = mMaxNumUploadTiles / (int) (Math.ceil((float) getHeight() / 256) + 1);
-        int maxVelocity = cols > 0 ? cols * 2560 : 1000;
-        if (Math.abs(velocity) > maxVelocity) {
-            return velocity > 0 ? maxVelocity : -maxVelocity;
-        } else {
-            return velocity;
-        }
-    }
-
-    private int clampFlingVelocityY(int velocity) {
-        int rows = mMaxNumUploadTiles / (int) (Math.ceil((float) getWidth() / 256) + 1);
-        int maxVelocity = rows > 0 ? rows * 2560 : 1000;
-        if (Math.abs(velocity) > maxVelocity) {
-            return velocity > 0 ? maxVelocity : -maxVelocity;
-        } else {
-            return velocity;
-        }
-    }
-
     /**
      * Get the screen orientation from the OS and push it to WebKit.
      *
@@ -1658,15 +1650,8 @@
                 }
 
                 @Override
-                public void showHandlesAt(int x1, int y1, int dir1, int x2, int y2, int dir2) {
-                    super.showHandlesAt(x1, y1, dir1, x2, y2, dir2);
-                    mStartHandleNormalizedPoint.set(
-                            (x1 + mNativeScrollX) / mNativePageScaleFactor,
-                            (y1 + mNativeScrollY) / mNativePageScaleFactor);
-                    mEndHandleNormalizedPoint.set(
-                            (x2 + mNativeScrollX) / mNativePageScaleFactor,
-                            (y2 + mNativeScrollY) / mNativePageScaleFactor);
-
+                public void showHandles(int startDir, int endDir) {
+                    super.showHandles(startDir, endDir);
                     showSelectActionBar();
                 }
 
@@ -1702,11 +1687,8 @@
                 }
 
                 @Override
-                public void showHandleAt(int x, int y) {
-                    super.showHandleAt(x, y);
-                    mInsertionHandleNormalizedPoint.set(
-                            (x + mNativeScrollX) / mNativePageScaleFactor,
-                            (y + mNativeScrollY) / mNativePageScaleFactor);
+                public void showHandle() {
+                    super.showHandle();
                 }
             };
 
@@ -1721,20 +1703,16 @@
     }
 
     private void updateHandleScreenPositions() {
-        if (mSelectionHandleController != null && mSelectionHandleController.isShowing()) {
-            float startX = mStartHandleNormalizedPoint.x * mNativePageScaleFactor - mNativeScrollX;
-            float startY = mStartHandleNormalizedPoint.y * mNativePageScaleFactor - mNativeScrollY;
-            mSelectionHandleController.setStartHandlePosition((int) startX, (int) startY);
-
-            float endX = mEndHandleNormalizedPoint.x * mNativePageScaleFactor - mNativeScrollX;
-            float endY = mEndHandleNormalizedPoint.y * mNativePageScaleFactor - mNativeScrollY;
-            mSelectionHandleController.setEndHandlePosition((int) endX, (int) endY);
+        mStartHandlePoint.updateWindowFromDocument();
+        mEndHandlePoint.updateWindowFromDocument();
+        mInsertionHandlePoint.updateWindowFromDocument();
+        if (isSelectionHandleShowing()) {
+            mSelectionHandleController.setStartHandlePosition(mStartHandlePoint.screen);
+            mSelectionHandleController.setEndHandlePosition(mEndHandlePoint.screen);
         }
 
-        if (mInsertionHandleController != null && mInsertionHandleController.isShowing()) {
-            float x = mInsertionHandleNormalizedPoint.x * mNativePageScaleFactor - mNativeScrollX;
-            float y = mInsertionHandleNormalizedPoint.y * mNativePageScaleFactor - mNativeScrollY;
-            mInsertionHandleController.setHandlePosition((int) x, (int) y);
+        if (isInsertionHandleShowing()) {
+            mInsertionHandleController.setHandlePosition(mInsertionHandlePoint.screen);
         }
     }
 
@@ -1789,13 +1767,14 @@
             @Override
             public void onDestroyActionMode() {
                 mActionMode = null;
-                mImeAdapter.unselect();
+                if (mUnselectAllOnActionModeDismiss) mImeAdapter.unselect();
                 getContentViewClient().onContextualActionBarHidden();
             }
         };
         mActionMode = mContainerView.startActionMode(
                 getContentViewClient().getSelectActionModeCallback(getContext(), actionHandler,
                         nativeIsIncognito(mNativeContentViewCore)));
+        mUnselectAllOnActionModeDismiss = true;
         if (mActionMode == null) {
             // There is no ActionMode, so remove the selection.
             mImeAdapter.unselect();
@@ -1845,6 +1824,67 @@
         mContentHeight = Math.max(height, getHeight());
     }
 
+    private boolean isSelectionHandleShowing() {
+        return mSelectionHandleController != null && mSelectionHandleController.isShowing();
+    }
+
+    private boolean isInsertionHandleShowing() {
+        return mInsertionHandleController != null && mInsertionHandleController.isShowing();
+    }
+
+    private void updateTextHandlesForGesture(int type) {
+        switch(type) {
+            case ContentViewGestureHandler.GESTURE_DOUBLE_TAP:
+            case ContentViewGestureHandler.GESTURE_SCROLL_START:
+            case ContentViewGestureHandler.GESTURE_FLING_START:
+            case ContentViewGestureHandler.GESTURE_PINCH_BEGIN:
+                temporarilyHideTextHandles();
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    // Makes the insertion/selection handles invisible. They will fade back in shortly after the
+    // last call to scheduleTextHandleFadeIn (or temporarilyHideTextHandles).
+    private void temporarilyHideTextHandles() {
+        if (isSelectionHandleShowing()) {
+            mSelectionHandleController.setHandleVisibility(HandleView.INVISIBLE);
+        }
+        if (isInsertionHandleShowing()) {
+            mInsertionHandleController.setHandleVisibility(HandleView.INVISIBLE);
+        }
+        scheduleTextHandleFadeIn();
+    }
+
+    // Cancels any pending fade in and schedules a new one.
+    private void scheduleTextHandleFadeIn() {
+        if (!isInsertionHandleShowing() && !isSelectionHandleShowing()) return;
+
+        if (mDeferredHandleFadeInRunnable == null) {
+            mDeferredHandleFadeInRunnable = new Runnable() {
+                public void run() {
+                    if (mContentViewGestureHandler.isNativeScrolling() ||
+                            mContentViewGestureHandler.isNativePinching()) {
+                        // Delay fade in until no longer scrolling or pinching.
+                        scheduleTextHandleFadeIn();
+                    } else {
+                        if (isSelectionHandleShowing()) {
+                            mSelectionHandleController.beginHandleFadeIn();
+                        }
+                        if (isInsertionHandleShowing()) {
+                            mInsertionHandleController.beginHandleFadeIn();
+                        }
+                    }
+                }
+            };
+        }
+
+        mContainerView.removeCallbacks(mDeferredHandleFadeInRunnable);
+        mContainerView.postDelayed(mDeferredHandleFadeInRunnable, TEXT_HANDLE_FADE_IN_DELAY);
+    }
+
     @SuppressWarnings("unused")
     @CalledByNative
     private void updateScrollOffsetAndPageScaleFactor(int x, int y, float scale) {
@@ -1865,9 +1905,9 @@
         mNativePageScaleFactor = scale;
 
         mPopupZoomer.hide(true);
-        updateHandleScreenPositions();
+        mZoomManager.updateZoomControls();
 
-        mZoomManager.updateZoomControls();
+        temporarilyHideTextHandles();
     }
 
     @SuppressWarnings("unused")
@@ -1917,6 +1957,13 @@
 
     @SuppressWarnings("unused")
     @CalledByNative
+    private void processImeBatchStateAck(boolean isBegin) {
+        if (mInputConnection == null) return;
+        mInputConnection.setIgnoreTextInputStateUpdates(isBegin);
+    }
+
+    @SuppressWarnings("unused")
+    @CalledByNative
     private void setTitle(String title) {
         getContentViewClient().onUpdateTitle(title);
     }
@@ -1957,38 +2004,51 @@
 
     @SuppressWarnings("unused")
     @CalledByNative
-    private void onSelectionBoundsChanged(Rect startRect, int dir1, Rect endRect, int dir2) {
-        int x1 = startRect.left;
-        int y1 = startRect.bottom;
-        int x2 = endRect.left;
-        int y2 = endRect.bottom;
-        if (x1 != x2 || y1 != y2) {
+    private void onSelectionBoundsChanged(Rect anchorRect, int anchorDir, Rect focusRect,
+            int focusDir, boolean isAnchorFirst) {
+        int x1 = anchorRect.left;
+        int y1 = anchorRect.bottom;
+        int x2 = focusRect.left;
+        int y2 = focusRect.bottom;
+
+        if (x1 != x2 || y1 != y2 ||
+                (mSelectionHandleController != null && mSelectionHandleController.isDragging())) {
             if (mInsertionHandleController != null) {
                 mInsertionHandleController.hide();
             }
-            getSelectionHandleController().onSelectionChanged(x1, y1, dir1, x2, y2, dir2);
+            if (isAnchorFirst) {
+                mStartHandlePoint.setWindow(x1, y1);
+                mEndHandlePoint.setWindow(x2, y2);
+            } else {
+                mStartHandlePoint.setWindow(x2, y2);
+                mEndHandlePoint.setWindow(x1, y1);
+            }
+
+            getSelectionHandleController().onSelectionChanged(anchorDir, focusDir);
+            updateHandleScreenPositions();
             mHasSelection = true;
         } else {
+            mUnselectAllOnActionModeDismiss = false;
             hideSelectActionBar();
-            if (x1 != 0 && y1 != 0
-                    && (mSelectionHandleController == null
-                            || !mSelectionHandleController.isDragging())
-                    && mSelectionEditable) {
+            if (x1 != 0 && y1 != 0 && mSelectionEditable) {
                 // Selection is a caret, and a text field is focused.
                 if (mSelectionHandleController != null) {
                     mSelectionHandleController.hide();
                 }
-                getInsertionHandleController().onCursorPositionChanged(x1, y1);
+                mInsertionHandlePoint.setWindow(x1, y1);
+
+                getInsertionHandleController().onCursorPositionChanged();
+                updateHandleScreenPositions();
                 InputMethodManager manager = (InputMethodManager)
                         getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                 if (manager.isWatchingCursor(mContainerView)) {
-                    manager.updateCursor(mContainerView, startRect.left, startRect.top,
-                            startRect.right, startRect.bottom);
+                    PointF point = mInsertionHandlePoint.screen;
+                    manager.updateCursor(mContainerView, (int)point.x, (int)point.y, (int)point.x,
+                            (int)point.y);
                 }
             } else {
                 // Deselection
-                if (mSelectionHandleController != null
-                        && !mSelectionHandleController.isDragging()) {
+                if (mSelectionHandleController != null) {
                     mSelectionHandleController.hideAndDisallowAutomaticShowing();
                 }
                 if (mInsertionHandleController != null) {
@@ -2008,8 +2068,10 @@
     @SuppressWarnings("unused")
     @CalledByNative
     private void showPastePopup(int x, int y) {
-        getInsertionHandleController()
-                .showHandleWithPastePopupAt(x - mNativeScrollX, y - mNativeScrollY);
+        mInsertionHandlePoint.setWindow(x, y);
+        getInsertionHandleController().showHandle();
+        updateHandleScreenPositions();
+        getInsertionHandleController().showHandleWithPastePopup();
     }
 
     @SuppressWarnings("unused")
Index: src/content/public/android/java/src/org/chromium/content/browser/InsertionHandleController.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/InsertionHandleController.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/InsertionHandleController.java	(working copy)
@@ -8,6 +8,7 @@
 import android.content.Context;
 import android.content.res.TypedArray;
 import android.graphics.drawable.Drawable;
+import android.graphics.PointF;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -52,13 +53,10 @@
     }
 
     /**
-     * Sets the position and shows the handle.
-     * @param x1
-     * @param y1
+     * Shows the handle.
      */
-    void showHandleAt(int x, int y) {
+    void showHandle() {
         createHandleIfNeeded();
-        setHandlePosition(x, y);
         showHandleIfNeeded();
     }
 
@@ -68,15 +66,15 @@
         }
     }
 
-    void showHandleWithPastePopupAt(int x, int y) {
-        showHandleAt(x, y);
+    void showHandleWithPastePopup() {
+        showHandle();
         showPastePopup();
     }
 
     /** Shows the handle at the given coordinates, as long as automatic showing is allowed */
-    void onCursorPositionChanged(int x, int y) {
+    void onCursorPositionChanged() {
         if (mAllowAutomaticShowing) {
-            showHandleAt(x, y);
+            showHandle();
         }
     }
 
@@ -89,6 +87,32 @@
         mHandle.positionAt(x, y);
     }
 
+    void setHandlePosition(PointF point) {
+        setHandlePosition((int)point.x, (int)point.y);
+    }
+
+    /**
+     * If the handle is not visible, sets its visibility to View.VISIBLE and begins fading it in.
+     */
+    void beginHandleFadeIn() {
+        mHandle.beginFadeIn();
+    }
+
+    /**
+     * Sets the handle to the given visibility.
+     */
+    void setHandleVisibility(int visibility) {
+        mHandle.setVisibility(visibility);
+    }
+
+    int getHandleX() {
+        return mHandle.getAdjustedPositionX();
+    }
+
+    int getHandleY() {
+        return mHandle.getAdjustedPositionY();
+    }
+
     public HandleView getHandleViewForTest() {
         return mHandle;
     }
@@ -124,7 +148,7 @@
     /**
      * The concrete implementation must cause the cursor position to move to the given
      * coordinates and (possibly asynchronously) set the insertion handle position
-     * after the cursor position change is made via showHandleAt(x,y).
+     * after the cursor position change is made via setHandlePosition.
      * @param x
      * @param y
      */
@@ -152,6 +176,7 @@
         if (!mIsShowing) {
             mIsShowing = true;
             mHandle.show();
+            setHandleVisibility(HandleView.VISIBLE);
         }
     }
 
Index: src/content/public/android/java/src/org/chromium/content/browser/AndroidBrowserProcess.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/AndroidBrowserProcess.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/AndroidBrowserProcess.java	(working copy)
@@ -7,10 +7,7 @@
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.res.Resources;
-import android.graphics.Point;
 import android.util.Log;
-import android.view.WindowManager;
-import android.view.Display;
 
 import org.chromium.base.JNINamespace;
 import org.chromium.content.app.ContentMain;
@@ -127,26 +124,6 @@
             }
         }
 
-        // For very high resolution displays (eg. Nexus 10), set the default tile size
-        // to be 512. This should be removed in favour of a generic hueristic that works
-        // across all platforms and devices, once that exists: http://crbug.com/159524
-        // This switches to 512 for screens containing 40 or more 256x256 tiles, such
-        // that 1080p devices do not use 512x512 tiles (eg. 1920x1280 requires 37.5 tiles)
-        WindowManager windowManager = (WindowManager)
-                appContext.getSystemService(Context.WINDOW_SERVICE);
-        Display display = windowManager.getDefaultDisplay();
-        Point displaySize = new Point();
-        display.getSize(displaySize);
-        int numTiles = (displaySize.x * displaySize.y) / (256 * 256);
-        if (numTiles >= 40
-                && !CommandLine.getInstance().hasSwitch(CommandLine.DEFAULT_TILE_WIDTH)
-                && !CommandLine.getInstance().hasSwitch(CommandLine.DEFAULT_TILE_HEIGHT)) {
-            CommandLine.getInstance().appendSwitchWithValue(
-                    CommandLine.DEFAULT_TILE_WIDTH, "512");
-            CommandLine.getInstance().appendSwitchWithValue(
-                    CommandLine.DEFAULT_TILE_HEIGHT, "512");
-        }
-
         int maxRenderers = normalizeMaxRendererProcesses(appContext, maxRendererProcesses);
         Log.i(TAG, "Initializing chromium process, renderers=" + maxRenderers +
                 " hostIsChrome=" + hostIsChrome);
Index: src/content/public/android/java/src/org/chromium/content/browser/HandleView.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/HandleView.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/HandleView.java	(working copy)
@@ -28,6 +28,8 @@
  * View that displays a selection or insertion handle for text editing.
  */
 class HandleView extends View {
+    private static final float FADE_DURATION = 200.f;
+
     private Drawable mDrawable;
     private final PopupWindow mContainer;
     private int mPositionX;
@@ -47,6 +49,8 @@
     private long mTouchTimer;
     private boolean mIsInsertionHandle = false;
     private Runnable mLongPressCallback;
+    private float mAlpha;
+    private long mFadeStartTime;
 
     private View mParent;
     private InsertionHandleController.PastePopupMenu mPastePopupWindow;
@@ -97,6 +101,8 @@
         // Convert line offset dips to pixels.
         mLineOffsetY = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                 LINE_OFFSET_Y_DIP, context.getResources().getDisplayMetrics());
+
+        mAlpha = 1.f;
     }
 
     void setOrientation(int pos) {
@@ -257,6 +263,7 @@
 
     @Override
     protected void onDraw(Canvas c) {
+        updateAlpha();
         mDrawable.setBounds(0, 0, getRight() - getLeft(), getBottom() - getTop());
         mDrawable.draw(c);
     }
@@ -357,6 +364,23 @@
         return mDrawable;
     }
 
+    private void updateAlpha() {
+        if (mAlpha == 1.f) return;
+        mAlpha = Math.min(1.f, (System.currentTimeMillis() - mFadeStartTime) / FADE_DURATION);
+        mDrawable.setAlpha((int) (255 * mAlpha));
+        invalidate();
+    }
+
+    /**
+     * If the handle is not visible, sets its visibility to View.VISIBLE and begins fading it in.
+     */
+    void beginFadeIn() {
+        if (getVisibility() == VISIBLE) return;
+        mAlpha = 0.f;
+        mFadeStartTime = System.currentTimeMillis();
+        setVisibility(VISIBLE);
+    }
+
     void showPastePopupWindow() {
         InsertionHandleController ihc = (InsertionHandleController) mController;
         if (mIsInsertionHandle && ihc.canPaste()) {
Index: src/content/public/android/java/src/org/chromium/content/browser/ContentViewGestureHandler.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/browser/ContentViewGestureHandler.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/browser/ContentViewGestureHandler.java	(working copy)
@@ -550,6 +550,22 @@
     }
 
     /**
+     * @return Whether native is tracking a scroll (i.e. between sending GESTURE_SCROLL_START and
+     *         GESTURE_SCROLL_END, or during a fling before sending GESTURE_FLING_CANCEL).
+     */
+    boolean isNativeScrolling() {
+        return mNativeScrolling;
+    }
+
+    /**
+     * @return Whether native is tracking a pinch (i.e. between sending GESTURE_PINCH_BEGIN and
+     *         GESTURE_PINCH_END).
+     */
+    boolean isNativePinching() {
+        return mPinchInProgress;
+    }
+
+    /**
      * Starts a pinch gesture.
      * @param timeMs The time in ms for the event initiating this gesture.
      * @param x The x coordinate for the event initiating this gesture.
@@ -724,7 +740,7 @@
         TouchPoint[] pts = new TouchPoint[event.getPointerCount()];
         int type = TouchPoint.createTouchPoints(event, pts);
         boolean forwarded = false;
-        if (type != TouchPoint.CONVERSION_ERROR) {
+        if (type != TouchPoint.CONVERSION_ERROR && !mNativeScrolling && !mPinchInProgress) {
             forwarded = mMotionEventDelegate.sendTouchEvent(event.getEventTime(), type, pts);
             mTouchCancelEventSent = false;
         } else if (!mTouchCancelEventSent) {
Index: src/content/public/android/java/src/org/chromium/content/common/CommandLine.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/common/CommandLine.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/common/CommandLine.java	(working copy)
@@ -54,14 +54,10 @@
     // Sets the ISO country code that will be used for phone number detection.
     public static final String NETWORK_COUNTRY_ISO = "network-country-iso";
 
-    // Sets the default tile width/height. We use this for very high-res
-    // displays until Chrome can detect and do this correctly for all platforms.
-    public static final String DEFAULT_TILE_WIDTH = "default-tile-width";
-    public static final String DEFAULT_TILE_HEIGHT = "default-tile-height";
+    // Whether to enable the auto-hiding top controls.
+    public static final String ENABLE_TOP_CONTROLS_POSITION_CALCULATION
+            = "enable-top-controls-position-calculation";
 
-    // Whether fullscreen should be disabled.
-    public static final String DISABLE_FULLSCREEN = "disable-fullscreen";
-
     // The height of the movable top controls.
     public static final String TOP_CONTROLS_HEIGHT = "top-controls-height";
 
Index: src/content/public/android/java/src/org/chromium/content/common/DeviceInfo.java
===================================================================
--- src/content/public/android/java/src/org/chromium/content/common/DeviceInfo.java	(revision 184497)
+++ src/content/public/android/java/src/org/chromium/content/common/DeviceInfo.java	(working copy)
@@ -109,7 +109,7 @@
   }
 
   @CalledByNative
-  private static DeviceInfo create(Context context) {
+  public static DeviceInfo create(Context context) {
       return new DeviceInfo(context);
   }
 }
Index: src/content/public/android/javatests/src/org/chromium/content/browser/SelectPopupTest.java
===================================================================
--- src/content/public/android/javatests/src/org/chromium/content/browser/SelectPopupTest.java	(revision 184497)
+++ src/content/public/android/javatests/src/org/chromium/content/browser/SelectPopupTest.java	(working copy)
@@ -6,6 +6,7 @@
 
 import android.test.suitebuilder.annotation.LargeTest;
 
+import org.chromium.base.test.util.DisabledTest;
 import org.chromium.base.test.util.Feature;
 import org.chromium.content.browser.test.util.Criteria;
 import org.chromium.content.browser.test.util.CriteriaHelper;
@@ -52,9 +53,11 @@
     /**
      * Tests that showing a select popup and having the page reload while the popup is showing does
      * not assert.
+     * @LargeTest
+     * @Feature({"Browser"})
+     * BUG 172967
      */
-    @LargeTest
-    @Feature({"Browser"})
+    @DisabledTest
     public void testReloadWhilePopupShowing() throws InterruptedException, Exception, Throwable {
         // Load the test page.
         launchContentShellWithUrl(SELECT_URL);
Index: src/content/public/android/javatests/src/org/chromium/content/browser/GestureDetectorResetTest.java
===================================================================
--- src/content/public/android/javatests/src/org/chromium/content/browser/GestureDetectorResetTest.java	(revision 184497)
+++ src/content/public/android/javatests/src/org/chromium/content/browser/GestureDetectorResetTest.java	(working copy)
@@ -8,6 +8,7 @@
 
 import junit.framework.Assert;
 
+import org.chromium.base.test.util.DisabledTest;
 import org.chromium.base.test.util.Feature;
 import org.chromium.content.browser.test.util.Criteria;
 import org.chromium.content.browser.test.util.CriteriaHelper;
@@ -83,9 +84,12 @@
     /**
      * Tests that showing a select popup and having the page reload while the popup is showing does
      * not assert.
+     *
+     * @LargeTest
+     * @Feature({"Browser"})
+     * BUG 172967
      */
-    @LargeTest
-    @Feature({"Browser"})
+    @DisabledTest
     public void testSeparateClicksAreRegisteredOnReload()
             throws InterruptedException, Exception, Throwable {
         // Load the test page.
Index: src/content/browser/android/content_view_core_impl.cc
===================================================================
--- src/content/browser/android/content_view_core_impl.cc	(revision 184497)
+++ src/content/browser/android/content_view_core_impl.cc	(working copy)
@@ -8,6 +8,7 @@
 #include "base/android/jni_array.h"
 #include "base/android/jni_string.h"
 #include "base/android/scoped_java_ref.h"
+#include "base/command_line.h"
 #include "base/json/json_writer.h"
 #include "base/logging.h"
 #include "base/utf_string_conversions.h"
@@ -36,6 +37,7 @@
 #include "content/public/browser/notification_types.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/common/content_client.h"
+#include "content/public/common/content_switches.h"
 #include "content/public/common/page_transition_types.h"
 #include "jni/ContentViewCore_jni.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebBindings.h"
@@ -44,6 +46,8 @@
 #include "ui/gfx/android/java_bitmap.h"
 #include "ui/gfx/android/window_android.h"
 #include "ui/gfx/screen.h"
+#include "ui/gfx/size_conversions.h"
+#include "ui/gfx/size_f.h"
 #include "webkit/glue/webmenuitem.h"
 #include "webkit/user_agent/user_agent_util.h"
 
@@ -118,6 +122,18 @@
 struct ContentViewCoreImpl::JavaObject {
   ScopedJavaGlobalRef<jclass> rect_clazz;
   jmethodID rect_constructor;
+  ScopedJavaLocalRef<jobject> CreateJavaRect(
+      JNIEnv* env,
+      const gfx::Rect& rect,
+      float scale) {
+    return ScopedJavaLocalRef<jobject>(
+        env, env->NewObject(rect_clazz.obj(),
+                            rect_constructor,
+                            static_cast<int>(rect.x() * scale),
+                            static_cast<int>(rect.y() * scale),
+                            static_cast<int>(rect.right() * scale),
+                            static_cast<int>(rect.bottom() * scale)));
+  }
 };
 
 // static
@@ -167,7 +183,8 @@
 
   InitJNI(env, obj);
 
-  if (!gfx::Screen::GetNativeScreen()->IsDIPEnabled()) {
+  if (CommandLine::ForCurrentProcess()->HasSwitch(
+      switches::kEnableCssTransformPinch)) {
     dpi_scale_ = 1;
   } else {
     scoped_ptr<content::DeviceInfo> device_info(new content::DeviceInfo());
@@ -402,8 +419,9 @@
   ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
   if (obj.is_null())
     return;
-  Java_ContentViewCore_updateScrollOffsetAndPageScaleFactor(env, obj.obj(), x,
-                                                            y, scale);
+  Java_ContentViewCore_updateScrollOffsetAndPageScaleFactor(
+      env, obj.obj(), static_cast<int>(x * DpiScale()),
+      static_cast<int>(y * DpiScale()), scale);
 }
 
 void ContentViewCoreImpl::UpdatePageScaleLimits(float minimum_scale,
@@ -437,6 +455,14 @@
   Java_ContentViewCore_setTitle(env, obj.obj(), jtitle.obj());
 }
 
+void ContentViewCoreImpl::OnBackgroundColorChanged(SkColor color) {
+  JNIEnv* env = AttachCurrentThread();
+  ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
+  if (obj.is_null())
+    return;
+  Java_ContentViewCore_onBackgroundColorChanged(env, obj.obj(), color);
+}
+
 void ContentViewCoreImpl::ShowSelectPopupMenu(
     const std::vector<WebMenuItem>& items, int selected_item, bool multiple) {
   JNIEnv* env = AttachCurrentThread();
@@ -521,31 +547,21 @@
 }
 
 void ContentViewCoreImpl::OnSelectionBoundsChanged(
-    const gfx::Rect& start_rect, base::i18n::TextDirection start_dir,
-    const gfx::Rect& end_rect, base::i18n::TextDirection end_dir) {
+    const ViewHostMsg_SelectionBounds_Params& params) {
   JNIEnv* env = AttachCurrentThread();
   ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
   if (obj.is_null())
     return;
-  ScopedJavaLocalRef<jobject> start_rect_object(env,
-      env->NewObject(java_object_->rect_clazz.obj(),
-                     java_object_->rect_constructor,
-                     start_rect.x(),
-                     start_rect.y(),
-                     start_rect.right(),
-                     start_rect.bottom()));
-  ScopedJavaLocalRef<jobject> end_rect_object(env,
-      env->NewObject(java_object_->rect_clazz.obj(),
-                     java_object_->rect_constructor,
-                     end_rect.x(),
-                     end_rect.y(),
-                     end_rect.right(),
-                     end_rect.bottom()));
+  ScopedJavaLocalRef<jobject> anchor_rect(
+      java_object_->CreateJavaRect(env, params.anchor_rect, 1.f));
+  ScopedJavaLocalRef<jobject> focus_rect(
+      java_object_->CreateJavaRect(env, params.focus_rect, 1.f));
   Java_ContentViewCore_onSelectionBoundsChanged(env, obj.obj(),
-                                                start_rect_object.obj(),
-                                                start_dir,
-                                                end_rect_object.obj(),
-                                                end_dir);
+                                                anchor_rect.obj(),
+                                                params.anchor_dir,
+                                                focus_rect.obj(),
+                                                params.focus_dir,
+                                                params.is_anchor_first);
 }
 
 void ContentViewCoreImpl::ShowPastePopup(int x, int y) {
@@ -553,7 +569,8 @@
   ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
   if (obj.is_null())
     return;
-  Java_ContentViewCore_showPastePopup(env, obj.obj(), static_cast<jint>(x),
+  Java_ContentViewCore_showPastePopup(env, obj.obj(),
+                                      static_cast<jint>(x),
                                       static_cast<jint>(y));
 }
 
@@ -618,15 +635,19 @@
       env, obj.obj(), scroll_down, mouse_event_x, mouse_event_y);
 }
 
-gfx::Rect ContentViewCoreImpl::GetBounds() const {
+gfx::Size ContentViewCoreImpl::GetPhysicalSize() const {
   JNIEnv* env = AttachCurrentThread();
   ScopedJavaLocalRef<jobject> j_obj = java_ref_.get(env);
   if (j_obj.is_null())
-    return gfx::Rect();
-  return gfx::Rect(Java_ContentViewCore_getWidth(env, j_obj.obj()),
+    return gfx::Size();
+  return gfx::Size(Java_ContentViewCore_getWidth(env, j_obj.obj()),
                    Java_ContentViewCore_getHeight(env, j_obj.obj()));
 }
 
+gfx::Size ContentViewCoreImpl::GetDIPSize() const {
+  return gfx::ToCeiledSize(gfx::ScaleSize(GetPhysicalSize(), 1 / DpiScale()));
+}
+
 void ContentViewCoreImpl::AttachLayer(scoped_refptr<cc::Layer> layer) {
   root_layer_->addChild(layer);
 }
@@ -790,7 +811,7 @@
   if (rwhv) {
     using WebKit::WebTouchEvent;
     WebKit::WebTouchEvent event;
-    TouchPoint::BuildWebTouchEvent(env, type, time_ms, pts, event);
+    TouchPoint::BuildWebTouchEvent(env, type, time_ms, DpiScale(), pts, event);
     UpdateVSyncFlagOnInputEvent(&event);
     rwhv->SendTouchEvent(event);
     return true;
@@ -859,6 +880,7 @@
   event.x = x / DpiScale();
   event.y = y / DpiScale();
   event.timeStampSeconds = time_ms / 1000.0;
+  event.sourceDevice = WebGestureEvent::Touchscreen;
   UpdateVSyncFlagOnInputEvent(&event);
   return event;
 }
@@ -904,8 +926,10 @@
                                      jint x, jint y, jint vx, jint vy) {
   WebGestureEvent event = MakeGestureEvent(
       WebInputEvent::GestureFlingStart, time_ms, x, y);
-  event.data.flingStart.velocityX = vx / DpiScale();
-  event.data.flingStart.velocityY = vy / DpiScale();
+  event.data.flingStart.velocityX = vx;
+  event.data.flingStart.velocityY = vy;
+  // FIXME(mohsen || rjkroege): Remove following line after removing uses of
+  // flingStart.sourceDevice in WebKit, but before removing the field itself.
   event.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
 
   if (GetRenderWidgetHostViewAndroid())
@@ -1009,15 +1033,17 @@
                                                    jint x1, jint y1,
                                                    jint x2, jint y2) {
   if (GetRenderWidgetHostViewAndroid()) {
-    GetRenderWidgetHostViewAndroid()->SelectRange(gfx::Point(x1, y1),
-                                                  gfx::Point(x2, y2));
+    GetRenderWidgetHostViewAndroid()->SelectRange(
+        gfx::Point(x1 / DpiScale(), y1 / DpiScale()),
+        gfx::Point(x2 / DpiScale(), y2 / DpiScale()));
   }
 }
 
 void ContentViewCoreImpl::MoveCaret(JNIEnv* env, jobject obj,
                                     jint x, jint y) {
   if (GetRenderWidgetHostViewAndroid()) {
-    GetRenderWidgetHostViewAndroid()->MoveCaret(gfx::Point(x, y));
+    GetRenderWidgetHostViewAndroid()->MoveCaret(
+        gfx::Point(x / DpiScale(), y / DpiScale()));
   }
 }
 
@@ -1261,6 +1287,14 @@
                                         show_ime_if_needed);
 }
 
+void ContentViewCoreImpl::ProcessImeBatchStateAck(bool is_begin) {
+  JNIEnv* env = AttachCurrentThread();
+  ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
+  if (obj.is_null())
+    return;
+  Java_ContentViewCore_processImeBatchStateAck(env, obj.obj(), is_begin);
+}
+
 void ContentViewCoreImpl::ClearSslPreferences(JNIEnv* env, jobject obj) {
   SSLHostState* state = SSLHostState::GetFor(
       web_contents_->GetController().GetBrowserContext());
Index: src/content/browser/android/content_view_core_impl.h
===================================================================
--- src/content/browser/android/content_view_core_impl.h	(revision 184497)
+++ src/content/browser/android/content_view_core_impl.h	(working copy)
@@ -222,15 +222,16 @@
                         int selection_start, int selection_end,
                         int composition_start, int composition_end,
                         bool show_ime_if_needed);
+  void ProcessImeBatchStateAck(bool is_begin);
   void SetTitle(const string16& title);
+  void OnBackgroundColorChanged(SkColor color);
 
   bool HasFocus();
   void ConfirmTouchEvent(InputEventAckState ack_result);
   void HasTouchEventHandlers(bool need_touch_events);
   void OnSelectionChanged(const std::string& text);
   void OnSelectionBoundsChanged(
-      const gfx::Rect& start_rect, base::i18n::TextDirection start_dir,
-      const gfx::Rect& end_rect, base::i18n::TextDirection end_dir);
+      const ViewHostMsg_SelectionBounds_Params& params);
 
   void StartContentIntent(const GURL& content_url);
 
@@ -249,7 +250,8 @@
   // Methods called from native code
   // --------------------------------------------------------------------------
 
-  gfx::Rect GetBounds() const;
+  gfx::Size GetPhysicalSize() const;
+  gfx::Size GetDIPSize() const;
 
   void AttachLayer(scoped_refptr<cc::Layer> layer);
   void RemoveLayer(scoped_refptr<cc::Layer> layer);
Index: src/content/browser/android/content_startup_flags.cc
===================================================================
--- src/content/browser/android/content_startup_flags.cc	(revision 184497)
+++ src/content/browser/android/content_startup_flags.cc	(working copy)
@@ -24,6 +24,8 @@
 
   CommandLine* parsed_command_line = CommandLine::ForCurrentProcess();
 
+  parsed_command_line->AppendSwitch(cc::switches::kEnableImplSidePainting);
+
   if (parsed_command_line->HasSwitch(switches::kRendererProcessLimit)) {
     std::string limit = parsed_command_line->GetSwitchValueASCII(
         switches::kRendererProcessLimit);
@@ -54,9 +56,10 @@
       switches::kEnableAcceleratedScrollableFrames);
   parsed_command_line->AppendSwitch(
       switches::kEnableCompositedScrollingForFrames);
+  parsed_command_line->AppendSwitch(switches::kEnableAcceleratedOverflowScroll);
 
   parsed_command_line->AppendSwitch(switches::kEnableGestureTapHighlight);
-  parsed_command_line->AppendSwitch(switches::kEnableCssTransformPinch);
+  parsed_command_line->AppendSwitch(switches::kEnablePinch);
 
   // Run the GPU service as a thread in the browser instead of as a
   // standalone process.
Index: src/content/browser/android/touch_point.cc
===================================================================
--- src/content/browser/android/touch_point.cc	(revision 184497)
+++ src/content/browser/android/touch_point.cc	(working copy)
@@ -15,7 +15,10 @@
 
 namespace {
 
-void MaybeAddTouchPoint(JNIEnv* env, jobject pt, WebKit::WebTouchEvent& event) {
+void MaybeAddTouchPoint(JNIEnv* env,
+                        jobject pt,
+                        float dpi_scale,
+                        WebKit::WebTouchEvent& event) {
   WebTouchPoint::State state = static_cast<WebTouchPoint::State>(
       Java_TouchPoint_getState(env, pt));
   if (state == WebTouchPoint::StateUndefined)
@@ -34,8 +37,8 @@
   WebTouchPoint wtp;
   wtp.id = Java_TouchPoint_getId(env, pt);
   wtp.state = state;
-  wtp.position.x = Java_TouchPoint_getX(env, pt);
-  wtp.position.y = Java_TouchPoint_getY(env, pt);
+  wtp.position.x = Java_TouchPoint_getX(env, pt) / dpi_scale;
+  wtp.position.y = Java_TouchPoint_getY(env, pt) / dpi_scale;
   // TODO(joth): Raw event co-ordinates.
   wtp.screenPosition = wtp.position;
   wtp.force = Java_TouchPoint_getPressure(env, pt);
@@ -50,8 +53,8 @@
   const static double SCALE_FACTOR = 1024.0;
   const int radius = static_cast<int>(
       (sqrt(Java_TouchPoint_getSize(env, pt)) / PI) * SCALE_FACTOR);
-  wtp.radiusX = radius;
-  wtp.radiusY = radius;
+  wtp.radiusX = radius / dpi_scale;
+  wtp.radiusY = radius / dpi_scale;
   // Since our radii are equal, a rotation angle doesn't mean anything.
   wtp.rotationAngle = 0.0;
 
@@ -64,8 +67,12 @@
 
 namespace content {
 
-void TouchPoint::BuildWebTouchEvent(JNIEnv* env, jint type, jlong time_ms,
-    jobjectArray pts, WebKit::WebTouchEvent& event) {
+void TouchPoint::BuildWebTouchEvent(JNIEnv* env,
+                                    jint type,
+                                    jlong time_ms,
+                                    float dpi_scale,
+                                    jobjectArray pts,
+                                    WebKit::WebTouchEvent& event) {
   event.type = static_cast<WebTouchEvent::Type>(type);
   event.timeStampSeconds =
       static_cast<double>(time_ms) / base::Time::kMillisecondsPerSecond;
@@ -74,7 +81,7 @@
   // array has been filled
   for (int i = 0; i < arrayLength; i++) {
     jobject pt = env->GetObjectArrayElement(pts, i);
-    MaybeAddTouchPoint(env, pt, event);
+    MaybeAddTouchPoint(env, pt, dpi_scale, event);
     if (event.touchesLength >= event.touchesLengthCap)
       break;
   }
Index: src/content/browser/android/touch_point.h
===================================================================
--- src/content/browser/android/touch_point.h	(revision 184497)
+++ src/content/browser/android/touch_point.h	(working copy)
@@ -15,8 +15,12 @@
 // events into a WebKit::WebTouchEvent.
 class TouchPoint {
  public:
-  static void BuildWebTouchEvent(JNIEnv* env, jint type, jlong time_ms,
-      jobjectArray pts, WebKit::WebTouchEvent& event);
+  static void BuildWebTouchEvent(JNIEnv* env,
+                                 jint type,
+                                 jlong time_ms,
+                                 float dpi_scale,
+                                 jobjectArray pts,
+                                 WebKit::WebTouchEvent& event);
 };
 
 bool RegisterTouchPoint(JNIEnv* env);
Index: src/content/browser/web_contents/web_contents_impl.cc
===================================================================
--- src/content/browser/web_contents/web_contents_impl.cc	(revision 184497)
+++ src/content/browser/web_contents/web_contents_impl.cc	(working copy)
@@ -663,7 +663,8 @@
   prefs.number_of_cpu_cores = base::SysInfo::NumberOfProcessors();
 
   prefs.deferred_image_decoding_enabled =
-      command_line.HasSwitch(switches::kEnableDeferredImageDecoding);
+      command_line.HasSwitch(switches::kEnableDeferredImageDecoding) ||
+      command_line.HasSwitch(cc::switches::kEnableImplSidePainting);
 
   GetContentClient()->browser()->OverrideWebkitPrefs(rvh, url, &prefs);
 
Index: src/content/browser/geolocation/core_location_data_provider_mac.h
===================================================================
--- src/content/browser/geolocation/core_location_data_provider_mac.h	(revision 184497)
+++ src/content/browser/geolocation/core_location_data_provider_mac.h	(working copy)
@@ -33,11 +33,10 @@
 
   void UpdatePosition(Geoposition* position);
 
- protected:
+ private:
   friend class base::RefCountedThreadSafe<CoreLocationDataProviderMac>;
   ~CoreLocationDataProviderMac();
 
- private:
   // These must execute in BrowserThread::UI
   void StartUpdatingTask();
   void StopUpdatingTask();
Index: src/content/browser/browser_main_loop.cc
===================================================================
--- src/content/browser/browser_main_loop.cc	(revision 184497)
+++ src/content/browser/browser_main_loop.cc	(working copy)
@@ -54,6 +54,8 @@
 #include "base/android/jni_android.h"
 #include "content/browser/android/surface_texture_peer_browser_impl.h"
 #include "content/browser/device_orientation/data_fetcher_impl_android.h"
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
 #endif
 
 #if defined(OS_WIN)
@@ -637,7 +639,27 @@
 }
 
 
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+namespace {
+void SetHighThreadPriority() {
+  int nice_value = -6; // High priority.
+  setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), nice_value);
+}
+}
+#endif
+
 void BrowserMainLoop::BrowserThreadsStarted() {
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  BrowserThread::PostTask(BrowserThread::UI,
+                          FROM_HERE,
+                          base::Bind(&SetHighThreadPriority));
+  BrowserThread::PostTask(BrowserThread::IO,
+                          FROM_HERE,
+                          base::Bind(&SetHighThreadPriority));
+#endif
+
 #if !defined(OS_IOS)
   HistogramSynchronizer::GetInstance();
 
Index: src/content/browser/renderer_host/render_widget_host_view_base.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_base.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_base.cc	(working copy)
@@ -353,6 +353,10 @@
   DCHECK(!mouse_locked_);
 }
 
+bool RenderWidgetHostViewBase::OnMessageReceived(const IPC::Message& msg){
+  return false;
+}
+
 void RenderWidgetHostViewBase::SetBackground(const SkBitmap& background) {
   background_ = background;
 }
Index: src/content/browser/renderer_host/render_widget_host_view_base.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_base.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_base.h	(working copy)
@@ -45,6 +45,7 @@
   virtual ~RenderWidgetHostViewBase();
 
   // RenderWidgetHostViewPort implementation.
+  virtual bool OnMessageReceived(const IPC::Message& msg) OVERRIDE;
   virtual void SelectionChanged(const string16& text,
                                 size_t offset,
                                 const ui::Range& range) OVERRIDE;
Index: src/content/browser/renderer_host/render_widget_host_view_mac.mm
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_mac.mm	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_mac.mm	(working copy)
@@ -627,12 +627,9 @@
 }
 
 void RenderWidgetHostViewMac::SelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
-  if (start_rect == end_rect)
-    caret_rect_ = start_rect;
+    const ViewHostMsg_SelectionBounds_Params& params) {
+  if (params.anchor_rect == params.focus_rect)
+    caret_rect_ = params.anchor_rect;
 }
 
 void RenderWidgetHostViewMac::ImeCancelComposition() {
Index: src/content/browser/renderer_host/render_widget_host_view_aura.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_aura.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_aura.h	(working copy)
@@ -110,10 +110,7 @@
                                 size_t offset,
                                 const ui::Range& range) OVERRIDE;
   virtual void SelectionBoundsChanged(
-      const gfx::Rect& start_rect,
-      WebKit::WebTextDirection start_direction,
-      const gfx::Rect& end_rect,
-      WebKit::WebTextDirection end_direction) OVERRIDE;
+      const ViewHostMsg_SelectionBounds_Params& params) OVERRIDE;
   virtual BackingStore* AllocBackingStore(const gfx::Size& size) OVERRIDE;
   virtual void CopyFromCompositingSurface(
       const gfx::Rect& src_subrect,
@@ -350,9 +347,9 @@
   ui::TextInputType text_input_type_;
   bool can_compose_inline_;
 
-  // Rectangles before and after the selection.
-  gfx::Rect selection_start_rect_;
-  gfx::Rect selection_end_rect_;
+  // Rectangles for the selection anchor and focus.
+  gfx::Rect selection_anchor_rect_;
+  gfx::Rect selection_focus_rect_;
 
   // The current composition character bounds.
   std::vector<gfx::Rect> composition_character_bounds_;
Index: src/content/browser/renderer_host/image_transport_factory.cc
===================================================================
--- src/content/browser/renderer_host/image_transport_factory.cc	(revision 184497)
+++ src/content/browser/renderer_host/image_transport_factory.cc	(working copy)
@@ -341,7 +341,7 @@
   }
 
   virtual void SendFrameToParentCompositor(
-      const cc::CompositorFrame&) OVERRIDE {
+      cc::CompositorFrame*) OVERRIDE {
   }
 
   void OnUpdateVSyncParameters(
Index: src/content/browser/renderer_host/gesture_event_filter.h
===================================================================
--- src/content/browser/renderer_host/gesture_event_filter.h	(revision 184497)
+++ src/content/browser/renderer_host/gesture_event_filter.h	(working copy)
@@ -11,6 +11,7 @@
 #include "base/memory/scoped_ptr.h"
 #include "base/timer.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebInputEvent.h"
+#include "ui/gfx/transform.h"
 
 namespace content {
 class MockRenderWidgetHost;
@@ -78,8 +79,9 @@
   // hence that event should be handled now.
   bool ShouldHandleEventNow();
 
-  // Merge or append a GestureScrollUpdate into the coalescing queue.
-  void MergeOrInsertScrollEvent(
+  // Merge or append a GestureScrollUpdate or GesturePinchUpdate into
+  // the coalescing queue.
+  void MergeOrInsertScrollAndPinchEvent(
        const WebKit::WebGestureEvent& gesture_event);
 
   // Sub-filter for removing bounces from in-progress scrolls.
@@ -91,6 +93,18 @@
   bool ShouldForwardForTapDeferral(
       const WebKit::WebGestureEvent& gesture_event);
 
+  // Whether the event_in_queue is GesturePinchUpdate or
+  // GestureScrollUpdate and it has the same modifiers as the
+  // new event.
+  bool ShouldTryMerging(const WebKit::WebGestureEvent& new_event,
+      const WebKit::WebGestureEvent& event_in_queue);
+
+  // Returns the transform matrix corresponding to the gesture event.
+  // Assumes the gesture event sent is either GestureScrollUpdate or
+  // GesturePinchUpdate. Returns the identity matrix otherwise.
+  gfx::Transform GetTransformForEvent(
+      const WebKit::WebGestureEvent& gesture_event);
+
   // Only a RenderWidgetHostViewImpl can own an instance.
   RenderWidgetHostImpl* render_widget_host_;
 
@@ -101,6 +115,14 @@
   // True if a GestureScrollUpdate sequence is in progress.
   bool scrolling_in_progress_;
 
+  // True if two related gesture events were sent before without waiting
+  // for an ACK, so the next gesture ACK should be ignored.
+  bool ignore_next_ack_;
+
+  // Transform that holds the combined transform matrix for the current
+  // scroll-pinch sequence at the end of the queue.
+  gfx::Transform combined_scroll_pinch_;
+
   // Timer to release a previously deferred GestureTapDown event.
   base::OneShotTimer<GestureEventFilter> send_gtd_timer_;
 
Index: src/content/browser/renderer_host/test_render_view_host.h
===================================================================
--- src/content/browser/renderer_host/test_render_view_host.h	(revision 184497)
+++ src/content/browser/renderer_host/test_render_view_host.h	(working copy)
@@ -15,6 +15,7 @@
 #include "content/browser/renderer_host/render_widget_host_view_base.h"
 #include "content/public/common/page_transition_types.h"
 #include "content/public/test/test_renderer_host.h"
+#include "ui/gfx/vector2d_f.h"
 
 // This file provides a testing framework for mocking out the RenderProcessHost
 // layer. It allows you to test RenderViewHost, WebContentsImpl,
@@ -153,7 +154,9 @@
                                float page_scale_factor,
                                float min_page_scale_factor,
                                float max_page_scale_factor,
-                               const gfx::Size& content_size) OVERRIDE {}
+                               const gfx::Size& content_size,
+                               const gfx::Vector2dF& controls_offset,
+                               const gfx::Vector2dF& content_offset) OVERRIDE {}
   virtual void HasTouchEventHandlers(bool need_touch_events) OVERRIDE {}
 #elif defined(OS_WIN) && !defined(USE_AURA)
   virtual void WillWmDestroy() OVERRIDE;
Index: src/content/browser/renderer_host/render_widget_host_view_guest.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_guest.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_guest.cc	(working copy)
@@ -180,10 +180,7 @@
 }
 
 void RenderWidgetHostViewGuest::SelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
+    const ViewHostMsg_SelectionBounds_Params& params) {
   NOTIMPLEMENTED();
 }
 
@@ -363,7 +360,9 @@
     float page_scale_factor,
     float min_page_scale_factor,
     float max_page_scale_factor,
-    const gfx::Size& content_size) {
+    const gfx::Size& content_size,
+    const gfx::Vector2dF& controls_offset,
+    const gfx::Vector2dF& content_offset) {
   NOTIMPLEMENTED();
 }
 
Index: src/content/browser/renderer_host/render_widget_host_view_gtk.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_gtk.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_gtk.h	(working copy)
@@ -95,10 +95,7 @@
                                 size_t offset,
                                 const ui::Range& range) OVERRIDE;
   virtual void SelectionBoundsChanged(
-      const gfx::Rect& start_rect,
-      WebKit::WebTextDirection start_direction,
-      const gfx::Rect& end_rect,
-      WebKit::WebTextDirection end_direction) OVERRIDE;
+      const ViewHostMsg_SelectionBounds_Params& params) OVERRIDE;
   virtual BackingStore* AllocBackingStore(const gfx::Size& size) OVERRIDE;
   virtual void CopyFromCompositingSurface(
       const gfx::Rect& src_subrect,
Index: src/content/browser/renderer_host/gesture_event_filter.cc
===================================================================
--- src/content/browser/renderer_host/gesture_event_filter.cc	(revision 184497)
+++ src/content/browser/renderer_host/gesture_event_filter.cc	(working copy)
@@ -61,6 +61,8 @@
      : render_widget_host_(rwhv),
        fling_in_progress_(false),
        scrolling_in_progress_(false),
+       ignore_next_ack_(false),
+       combined_scroll_pinch_(gfx::Transform()),
        tap_suppression_controller_(new TapSuppressionController(rwhv)),
        maximum_tap_gap_time_ms_(GetTapDownDeferralTimeMs()),
        debounce_interval_time_ms_(kDebouncingIntervalTimeMs) {
@@ -188,8 +190,9 @@
       deferred_tap_down_event_.type = WebInputEvent::Undefined;
       coalesced_gesture_events_.push_back(gesture_event);
       return ShouldHandleEventNow();
+    case WebInputEvent::GesturePinchUpdate:
     case WebInputEvent::GestureScrollUpdate:
-      MergeOrInsertScrollEvent(gesture_event);
+      MergeOrInsertScrollAndPinchEvent(gesture_event);
       return ShouldHandleEventNow();
     default:
       coalesced_gesture_events_.push_back(gesture_event);
@@ -203,6 +206,8 @@
 void GestureEventFilter::Reset() {
   fling_in_progress_ = false;
   scrolling_in_progress_ = false;
+  ignore_next_ack_ = false;
+  combined_scroll_pinch_ = gfx::Transform();
   coalesced_gesture_events_.clear();
   deferred_tap_down_event_.type = WebInputEvent::Undefined;
   debouncing_deferral_queue_.clear();
@@ -220,10 +225,25 @@
   coalesced_gesture_events_.pop_front();
   if (type == WebInputEvent::GestureFlingCancel)
     tap_suppression_controller_->GestureFlingCancelAck(processed);
-  if (!coalesced_gesture_events_.empty()) {
-    WebGestureEvent next_gesture_event = coalesced_gesture_events_.front();
+  if (!coalesced_gesture_events_.empty() && !ignore_next_ack_) {
+    const WebGestureEvent& next_gesture_event =
+        coalesced_gesture_events_.front();
     render_widget_host_->ForwardGestureEventImmediately(next_gesture_event);
-  }
+    // TODO(yusufo): Introduce GesturePanScroll so that these can be combined
+    // into one gesture and kept inside the queue that way.
+    if (coalesced_gesture_events_.size() > 1) {
+      const WebGestureEvent& second_gesture_event =
+          coalesced_gesture_events_[1];
+      if (next_gesture_event.type == WebInputEvent::GestureScrollUpdate &&
+          second_gesture_event.type == WebInputEvent::GesturePinchUpdate) {
+        render_widget_host_->
+            ForwardGestureEventImmediately(second_gesture_event);
+        ignore_next_ack_ = true;
+        combined_scroll_pinch_ = gfx::Transform();
+      }
+    }
+  } else if (ignore_next_ack_)
+    ignore_next_ack_ = false;
 }
 
 TapSuppressionController*  GestureEventFilter::GetTapSuppressionController() {
@@ -237,7 +257,10 @@
 const WebKit::WebInputEvent&
 GestureEventFilter::GetGestureEventAwaitingAck() const {
   DCHECK(!coalesced_gesture_events_.empty());
-  return coalesced_gesture_events_.front();
+  if (!ignore_next_ack_)
+    return coalesced_gesture_events_.front();
+  else
+    return coalesced_gesture_events_.at(1);
 }
 
 void GestureEventFilter::FlingHasBeenHalted() {
@@ -273,26 +296,86 @@
   debouncing_deferral_queue_.clear();
 }
 
-void GestureEventFilter::MergeOrInsertScrollEvent(
+void GestureEventFilter::MergeOrInsertScrollAndPinchEvent(
     const WebGestureEvent& gesture_event) {
-  WebGestureEvent* last_gesture_event = coalesced_gesture_events_.empty() ? 0 :
-      &coalesced_gesture_events_.back();
+  if (coalesced_gesture_events_.size() <= 1) {
+    coalesced_gesture_events_.push_back(gesture_event);
+    return;
+  }
+  WebGestureEvent* last_event = &coalesced_gesture_events_.back();
   if (coalesced_gesture_events_.size() > 1 &&
-      last_gesture_event->type == gesture_event.type &&
-      last_gesture_event->modifiers == gesture_event.modifiers) {
-    last_gesture_event->data.scrollUpdate.deltaX +=
+      gesture_event.type == WebInputEvent::GestureScrollUpdate &&
+          last_event->type == WebInputEvent::GestureScrollUpdate &&
+              last_event->modifiers == gesture_event.modifiers) {
+    last_event->data.scrollUpdate.deltaX +=
         gesture_event.data.scrollUpdate.deltaX;
-    last_gesture_event->data.scrollUpdate.deltaY +=
+    last_event->data.scrollUpdate.deltaY +=
         gesture_event.data.scrollUpdate.deltaY;
-    DLOG_IF(WARNING,
-            gesture_event.timeStampSeconds <=
-            last_gesture_event->timeStampSeconds)
-            << "Event time not monotonic?\n";
-    DCHECK(last_gesture_event->type == WebInputEvent::GestureScrollUpdate);
-    last_gesture_event->timeStampSeconds = gesture_event.timeStampSeconds;
-  } else {
+    return;
+  } else if (coalesced_gesture_events_.size() < 3 ||
+      (coalesced_gesture_events_.size() == 3 && ignore_next_ack_) ||
+      !ShouldTryMerging(gesture_event,*last_event)) {
     coalesced_gesture_events_.push_back(gesture_event);
+    return;
   }
+  WebGestureEvent scroll_event;
+  WebGestureEvent pinch_event;
+  scroll_event.modifiers |= gesture_event.modifiers;
+  scroll_event.timeStampSeconds = gesture_event.timeStampSeconds;
+  pinch_event = scroll_event;
+  scroll_event.type = WebInputEvent::GestureScrollUpdate;
+  pinch_event.type = WebInputEvent::GesturePinchUpdate;
+  pinch_event.x = gesture_event.type == WebInputEvent::GesturePinchUpdate ?
+      gesture_event.x : last_event->x;
+  pinch_event.y = gesture_event.type == WebInputEvent::GesturePinchUpdate ?
+      gesture_event.y : last_event->y;
+
+  combined_scroll_pinch_.ConcatTransform(GetTransformForEvent(gesture_event));
+  WebGestureEvent* second_last_event = &coalesced_gesture_events_
+      [coalesced_gesture_events_.size() - 2];
+  if (ShouldTryMerging(gesture_event, *second_last_event)) {
+    coalesced_gesture_events_.pop_back();
+  } else {
+    DCHECK(combined_scroll_pinch_ == GetTransformForEvent(gesture_event));
+    combined_scroll_pinch_.
+        PreconcatTransform(GetTransformForEvent(*last_event));
+  }
+  coalesced_gesture_events_.pop_back();
+  float combined_scale = combined_scroll_pinch_.matrix().getDouble(0, 0);
+  scroll_event.data.scrollUpdate.deltaX =
+      (combined_scroll_pinch_.matrix().getDouble(0, 3) + pinch_event.x)
+          / combined_scale - pinch_event.x;
+  scroll_event.data.scrollUpdate.deltaY =
+      (combined_scroll_pinch_.matrix().getDouble(1, 3) + pinch_event.y)
+          / combined_scale - pinch_event.y;
+  coalesced_gesture_events_.push_back(scroll_event);
+  pinch_event.data.pinchUpdate.scale = combined_scale;
+  coalesced_gesture_events_.push_back(pinch_event);
 }
 
+bool GestureEventFilter::ShouldTryMerging(const WebGestureEvent& new_event,
+    const WebGestureEvent& event_in_queue) {
+  DLOG_IF(WARNING,
+          new_event.timeStampSeconds <
+          event_in_queue.timeStampSeconds)
+          << "Event time not monotonic?\n";
+  return (event_in_queue.type == WebInputEvent::GestureScrollUpdate ||
+      event_in_queue.type == WebInputEvent::GesturePinchUpdate) &&
+      event_in_queue.modifiers == new_event.modifiers;
+}
+
+gfx::Transform GestureEventFilter::GetTransformForEvent(
+    const WebGestureEvent& gesture_event) {
+  gfx::Transform gesture_transform = gfx::Transform();
+  if (gesture_event.type == WebInputEvent::GestureScrollUpdate) {
+    gesture_transform.Translate(gesture_event.data.scrollUpdate.deltaX,
+                                gesture_event.data.scrollUpdate.deltaY);
+  } else if (gesture_event.type == WebInputEvent::GesturePinchUpdate) {
+    float scale = gesture_event.data.pinchUpdate.scale;
+    gesture_transform.Translate(-gesture_event.x, -gesture_event.y);
+    gesture_transform.Scale(scale,scale);
+    gesture_transform.Translate(gesture_event.x, gesture_event.y);
+  }
+  return gesture_transform;
+}
 } // namespace content
Index: src/content/browser/renderer_host/render_widget_host_view_win.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_win.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_win.cc	(working copy)
@@ -266,6 +266,7 @@
   WebKit::WebGestureEvent gesture_event;
   gesture_event.timeStampSeconds = time_stamp;
   gesture_event.type = WebKit::WebGestureEvent::GestureFlingCancel;
+  gesture_event.sourceDevice = WebKit::WebGestureEvent::Touchscreen;
   return gesture_event;
 }
 
@@ -644,15 +645,12 @@
 }
 
 void RenderWidgetHostViewWin::SelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
+    const ViewHostMsg_SelectionBounds_Params& params) {
   bool is_enabled = (text_input_type_ != ui::TEXT_INPUT_TYPE_NONE &&
       text_input_type_ != ui::TEXT_INPUT_TYPE_PASSWORD);
   // Only update caret position if the input method is enabled.
   if (is_enabled) {
-    caret_rect_ = gfx::UnionRects(start_rect, end_rect);
+    caret_rect_ = gfx::UnionRects(params.anchor_rect, params.focus_rect);
     ime_input_.UpdateCaretRect(m_hWnd, caret_rect_);
   }
 }
Index: src/content/browser/renderer_host/render_process_host_impl.cc
===================================================================
--- src/content/browser/renderer_host/render_process_host_impl.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_process_host_impl.cc	(working copy)
@@ -838,6 +838,8 @@
     cc::switches::kEnableCompositorFrameMessage,
     cc::switches::kEnableImplSidePainting,
     cc::switches::kEnablePartialSwap,
+    cc::switches::kEnableRightAlignedScheduling,
+    cc::switches::kEnableTopControlsPositionCalculation,
     cc::switches::kNumRasterThreads,
     cc::switches::kShowPropertyChangedRects,
     cc::switches::kShowSurfaceDamageRects,
@@ -846,6 +848,9 @@
     cc::switches::kShowNonOccludingRects,
     cc::switches::kShowOccludingRects,
     cc::switches::kTraceOverdraw,
+    cc::switches::kTopControlsHeight,
+    cc::switches::kSlowDownRasterScaleFactor,
+    cc::switches::kLowResolutionContentsScaleFactor,
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                  arraysize(kSwitchNames));
Index: src/content/browser/renderer_host/web_input_event_aurax11.cc
===================================================================
--- src/content/browser/renderer_host/web_input_event_aurax11.cc	(revision 184497)
+++ src/content/browser/renderer_host/web_input_event_aurax11.cc	(working copy)
@@ -158,30 +158,27 @@
   WebKit::WebGestureEvent webkit_event;
 
   switch (event->type()) {
-    case ui::ET_SCROLL:
-      // TODO(sadrul || rjkroege): This will do touchscreen style scrolling in
-      // response to touchpad events. Currently, touchscreen and touchpad
-      // scrolls are the same. However, if the planned changes to touchscreen
-      // scrolling take place, this will no longer be so. If so, this needs to
-      // be adjusted.
-      webkit_event.type = WebKit::WebInputEvent::GestureScrollUpdate;
-      webkit_event.data.scrollUpdate.deltaX = event->x_offset();
-      webkit_event.data.scrollUpdate.deltaY = event->y_offset();
-      break;
     case ui::ET_SCROLL_FLING_START:
       webkit_event.type = WebKit::WebInputEvent::GestureFlingStart;
       webkit_event.data.flingStart.velocityX = event->x_offset();
       webkit_event.data.flingStart.velocityY = event->y_offset();
+      // FIXME(mohsen || rjkroege): Remove following line after removing uses of
+      // flingStart.sourceDevice in WebKit, but before removing the field
+      // itself.
       webkit_event.data.flingStart.sourceDevice =
           WebKit::WebGestureEvent::Touchpad;
       break;
     case ui::ET_SCROLL_FLING_CANCEL:
       webkit_event.type = WebKit::WebInputEvent::GestureFlingCancel;
       break;
+    case ui::ET_SCROLL:
+      NOTREACHED() << "Invalid gesture type: " << event->type();
+      break;
     default:
       NOTREACHED() << "Unknown gesture type: " << event->type();
   }
 
+  webkit_event.sourceDevice = WebKit::WebGestureEvent::Touchpad;
   webkit_event.modifiers = EventFlagsToWebEventModifiers(event->flags());
   webkit_event.timeStampSeconds = event->time_stamp().InSecondsF();
 
Index: src/content/browser/renderer_host/render_widget_host_impl.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_impl.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_impl.cc	(working copy)
@@ -394,6 +394,9 @@
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP_EX()
 
+  if (!handled && view_ && view_->OnMessageReceived(msg))
+    return true;
+
   if (!msg_is_ok) {
     // The message de-serialization failed. Kill the renderer process.
     RecordAction(UserMetricsAction("BadMessageTerminate_RWH"));
@@ -822,6 +825,7 @@
   result.type = type;
   result.x = x;
   result.y = y;
+  result.sourceDevice = WebGestureEvent::Touchscreen;
   result.timeStampSeconds = timestamp_seconds;
   result.modifiers = modifiers;
 
@@ -1535,7 +1539,9 @@
         frame.metadata.page_scale_factor,
         frame.metadata.min_page_scale_factor,
         frame.metadata.max_page_scale_factor,
-        gfx::ToCeiledSize(content_size));
+        gfx::ToCeiledSize(content_size),
+        frame.metadata.location_bar_offset,
+        frame.metadata.location_bar_content_translation);
   }
 #endif
 }
Index: src/content/browser/renderer_host/web_input_event_aura.cc
===================================================================
--- src/content/browser/renderer_host/web_input_event_aura.cc	(revision 184497)
+++ src/content/browser/renderer_host/web_input_event_aura.cc	(working copy)
@@ -186,6 +186,7 @@
 
   // All other fields are ignored on a GestureFlingCancel event.
   gesture_event.type = WebKit::WebInputEvent::GestureFlingCancel;
+  gesture_event.sourceDevice = WebKit::WebGestureEvent::Touchpad;
   return gesture_event;
 }
 
Index: src/content/browser/renderer_host/compositor_impl_android.cc
===================================================================
--- src/content/browser/renderer_host/compositor_impl_android.cc	(revision 184497)
+++ src/content/browser/renderer_host/compositor_impl_android.cc	(working copy)
@@ -72,7 +72,7 @@
   }
 
   virtual void SendFrameToParentCompositor(
-      const cc::CompositorFrame&) OVERRIDE {
+      cc::CompositorFrame*) OVERRIDE {
   }
 
  private:
@@ -172,6 +172,10 @@
   } else if (!host_.get()) {
     cc::LayerTreeSettings settings;
     settings.refreshRate = 60.0;
+    settings.implSidePainting = false;
+    settings.calculateTopControlsPosition = false;
+    settings.topControlsHeightPx = 0;
+    settings.useMemoryManagement = false;
 
     // Do not clear the framebuffer when rendering into external GL contexts
     // like Android View System's.
Index: src/content/browser/renderer_host/render_widget_host_view_mac_unittest.mm
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_mac_unittest.mm	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_mac_unittest.mm	(working copy)
@@ -345,13 +345,14 @@
 
   gfx::Rect caret_rect(10, 11, 0, 10);
   ui::Range caret_range(0, 0);
+  ViewHostMsg_SelectionBounds_Params params;
 
   NSRect rect;
   NSRange actual_range;
   rwhv_mac_->SelectionChanged(kDummyString, kDummyOffset, caret_range);
-  rwhv_mac_->SelectionBoundsChanged(
-       caret_rect, WebKit::WebTextDirectionLeftToRight,
-       caret_rect, WebKit::WebTextDirectionLeftToRight);
+  params.anchor_rect = params.focus_rect = caret_rect;
+  params.anchor_dir = params.focus_dir = WebKit::WebTextDirectionLeftToRight;
+  rwhv_mac_->SelectionBoundsChanged(params);
   EXPECT_TRUE(rwhv_mac_->GetCachedFirstRectForCharacterRange(
         caret_range.ToNSRange(),
         &rect,
@@ -375,10 +376,9 @@
   // Caret moved.
   caret_rect = gfx::Rect(20, 11, 0, 10);
   caret_range = ui::Range(1, 1);
+  params.anchor_rect = params.focus_rect = caret_rect;
   rwhv_mac_->SelectionChanged(kDummyString, kDummyOffset, caret_range);
-  rwhv_mac_->SelectionBoundsChanged(
-       caret_rect, WebKit::WebTextDirectionLeftToRight,
-       caret_rect, WebKit::WebTextDirectionLeftToRight);
+  rwhv_mac_->SelectionBoundsChanged(params);
   EXPECT_TRUE(rwhv_mac_->GetCachedFirstRectForCharacterRange(
         caret_range.ToNSRange(),
         &rect,
@@ -402,9 +402,9 @@
   // No caret.
   caret_range = ui::Range(1, 2);
   rwhv_mac_->SelectionChanged(kDummyString, kDummyOffset, caret_range);
-  rwhv_mac_->SelectionBoundsChanged(
-        caret_rect, WebKit::WebTextDirectionLeftToRight,
-        gfx::Rect(30, 11, 0, 10), WebKit::WebTextDirectionLeftToRight);
+  params.anchor_rect = caret_rect;
+  params.focus_rect = gfx::Rect(30, 11, 0, 10);
+  rwhv_mac_->SelectionBoundsChanged(params);
   EXPECT_FALSE(rwhv_mac_->GetCachedFirstRectForCharacterRange(
         ui::Range(0, 0).ToNSRange(),
         &rect,
Index: src/content/browser/renderer_host/surface_texture_transport_client_android.cc
===================================================================
--- src/content/browser/renderer_host/surface_texture_transport_client_android.cc	(revision 184497)
+++ src/content/browser/renderer_host/surface_texture_transport_client_android.cc	(working copy)
@@ -37,8 +37,7 @@
 
 scoped_refptr<cc::Layer> SurfaceTextureTransportClient::Initialize() {
   // Use a SurfaceTexture to stream frames to the UI thread.
-  video_layer_ = cc::VideoLayer::create(this,
-          base::Bind(webkit_media::WebVideoFrameImpl::toVideoFrame));
+  video_layer_ = cc::VideoLayer::create(this);
 
   surface_texture_ = new SurfaceTextureBridge(0);
   surface_texture_->SetFrameAvailableCallback(
@@ -62,10 +61,11 @@
 void SurfaceTextureTransportClient::SetSize(const gfx::Size& size) {
   surface_texture_->SetDefaultBufferSize(size.width(), size.height());
   video_layer_->setBounds(size);
-  video_frame_.reset();
+  video_frame_ = NULL;
 }
 
-WebKit::WebVideoFrame* SurfaceTextureTransportClient::getCurrentFrame() {
+scoped_refptr<media::VideoFrame> SurfaceTextureTransportClient::
+    GetCurrentFrame() {
   if (!texture_id_) {
     WebKit::WebGraphicsContext3D* context =
         ImageTransportFactoryAndroid::GetInstance()->GetContext3D();
@@ -73,26 +73,24 @@
     texture_id_ = context->createTexture();
     surface_texture_->AttachToGLContext(texture_id_);
   }
-  if (!video_frame_.get()) {
+  if (!video_frame_) {
     const gfx::Size size = video_layer_->bounds();
-    video_frame_.reset(
-        new webkit_media::WebVideoFrameImpl(
-            media::VideoFrame::WrapNativeTexture(
-                texture_id_, kGLTextureExternalOES,
-                size,
-                gfx::Rect(gfx::Point(), size),
-                size,
-                base::TimeDelta(),
-                media::VideoFrame::ReadPixelsCB(),
-                base::Closure())));
+    video_frame_ = media::VideoFrame::WrapNativeTexture(
+        texture_id_, kGLTextureExternalOES,
+        size,
+        gfx::Rect(gfx::Point(), size),
+        size,
+        base::TimeDelta(),
+        media::VideoFrame::ReadPixelsCB(),
+        base::Closure());
   }
   surface_texture_->UpdateTexImage();
 
-  return video_frame_.get();
+  return video_frame_;
 }
 
-void SurfaceTextureTransportClient::putCurrentFrame(
-    WebKit::WebVideoFrame* frame) {
+void SurfaceTextureTransportClient::PutCurrentFrame(
+    const scoped_refptr<media::VideoFrame>& frame) {
 }
 
 void SurfaceTextureTransportClient::OnSurfaceTextureFrameAvailable() {
Index: src/content/browser/renderer_host/render_view_host_impl.cc
===================================================================
--- src/content/browser/renderer_host/render_view_host_impl.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_view_host_impl.cc	(working copy)
@@ -1437,13 +1437,9 @@
 }
 
 void RenderViewHostImpl::OnMsgSelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
+    const ViewHostMsg_SelectionBounds_Params& params) {
   if (view_) {
-    view_->SelectionBoundsChanged(start_rect, start_direction,
-                                  end_rect, end_direction);
+    view_->SelectionBoundsChanged(params);
   }
 }
 
Index: src/content/browser/renderer_host/ime_adapter_android.cc
===================================================================
--- src/content/browser/renderer_host/ime_adapter_android.cc	(revision 184497)
+++ src/content/browser/renderer_host/ime_adapter_android.cc	(working copy)
@@ -153,7 +153,17 @@
   rwhi->ImeSetComposition(text16, underlines, new_cursor_pos, new_cursor_pos);
 }
 
+void ImeAdapterAndroid::ImeBatchStateChanged(JNIEnv* env,
+                                             jobject,
+                                             jboolean is_begin) {
+  RenderWidgetHostImpl* rwhi = RenderWidgetHostImpl::From(
+      rwhva_->GetRenderWidgetHost());
+  if (!rwhi)
+    return;
 
+  rwhi->Send(new ViewMsg_ImeBatchStateChanged(rwhi->GetRoutingID(), is_begin));
+}
+
 void ImeAdapterAndroid::CommitText(JNIEnv* env, jobject, jstring text) {
   RenderWidgetHostImpl* rwhi = RenderWidgetHostImpl::From(
       rwhva_->GetRenderWidgetHost());
Index: src/content/browser/renderer_host/render_widget_host_view_gtk.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_gtk.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_gtk.cc	(working copy)
@@ -952,11 +952,9 @@
 }
 
 void RenderWidgetHostViewGtk::SelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
-  im_context_->UpdateCaretBounds(gfx::UnionRects(start_rect, end_rect));
+    const ViewHostMsg_SelectionBounds_Params& params) {
+  im_context_->UpdateCaretBounds(
+      gfx::UnionRects(params.anchor_rect, params.focus_rect));
 }
 
 GdkEventButton* RenderWidgetHostViewGtk::GetLastMouseDown() {
Index: src/content/browser/renderer_host/render_widget_host_view_guest.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_guest.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_guest.h	(working copy)
@@ -11,8 +11,8 @@
 #include "content/browser/renderer_host/render_widget_host_view_base.h"
 #include "content/common/content_export.h"
 #include "ui/gfx/native_widget_types.h"
-#include "ui/gfx/point.h"
 #include "ui/gfx/rect.h"
+#include "ui/gfx/vector2d_f.h"
 #include "webkit/glue/webcursor.h"
 
 #if defined(TOOLKIT_GTK)
@@ -83,10 +83,7 @@
   virtual void WillDestroyRenderWidget(RenderWidgetHost* rwh) {}
   virtual void SetTooltipText(const string16& tooltip_text) OVERRIDE;
   virtual void SelectionBoundsChanged(
-      const gfx::Rect& start_rect,
-      WebKit::WebTextDirection start_direction,
-      const gfx::Rect& end_rect,
-      WebKit::WebTextDirection end_direction) OVERRIDE;
+      const ViewHostMsg_SelectionBounds_Params& params) OVERRIDE;
   virtual BackingStore* AllocBackingStore(const gfx::Size& size) OVERRIDE;
   virtual void CopyFromCompositingSurface(
       const gfx::Rect& src_subrect,
@@ -161,7 +158,9 @@
                                float page_scale_factor,
                                float min_page_scale_factor,
                                float max_page_scale_factor,
-                               const gfx::Size& content_size) OVERRIDE;
+                               const gfx::Size& content_size,
+                               const gfx::Vector2dF& controls_offset,
+                               const gfx::Vector2dF& content_offset) OVERRIDE;
   virtual void HasTouchEventHandlers(bool need_touch_events) OVERRIDE;
 #endif  // defined(OS_ANDROID)
 
Index: src/content/browser/renderer_host/surface_texture_transport_client_android.h
===================================================================
--- src/content/browser/renderer_host/surface_texture_transport_client_android.h	(revision 184497)
+++ src/content/browser/renderer_host/surface_texture_transport_client_android.h	(working copy)
@@ -7,8 +7,9 @@
 
 #include "base/memory/ref_counted.h"
 #include "base/memory/scoped_ptr.h"
-#include "third_party/WebKit/Source/Platform/chromium/public/WebVideoFrameProvider.h"
+#include "cc/video_frame_provider.h"
 #include "ui/gfx/native_widget_types.h"
+#include "ui/gfx/size.h"
 
 struct ANativeWindow;
 
@@ -20,7 +21,7 @@
 namespace content {
 class SurfaceTextureBridge;
 
-class SurfaceTextureTransportClient : public WebKit::WebVideoFrameProvider {
+class SurfaceTextureTransportClient : public cc::VideoFrameProvider {
  public:
   SurfaceTextureTransportClient();
   virtual ~SurfaceTextureTransportClient();
@@ -29,10 +30,11 @@
   gfx::GLSurfaceHandle GetCompositingSurface(int surface_id);
   void SetSize(const gfx::Size& size);
 
-  // WebKit::WebVideoFrameProvider implementation.
-  virtual void setVideoFrameProviderClient(Client*) OVERRIDE {}
-  virtual WebKit::WebVideoFrame* getCurrentFrame() OVERRIDE;
-  virtual void putCurrentFrame(WebKit::WebVideoFrame* frame) OVERRIDE;
+  // cc::VideoFrameProvider implementation.
+  virtual void SetVideoFrameProviderClient(Client*) OVERRIDE {}
+  virtual scoped_refptr<media::VideoFrame> GetCurrentFrame() OVERRIDE;
+  virtual void PutCurrentFrame(const scoped_refptr<media::VideoFrame>& frame)
+      OVERRIDE;
 
  private:
   void OnSurfaceTextureFrameAvailable();
@@ -40,7 +42,7 @@
   scoped_refptr<cc::VideoLayer> video_layer_;
   scoped_refptr<SurfaceTextureBridge> surface_texture_;
   ANativeWindow* window_;
-  scoped_ptr<WebKit::WebVideoFrame> video_frame_;
+  scoped_refptr<media::VideoFrame> video_frame_;
   uint32 texture_id_;
 
   DISALLOW_COPY_AND_ASSIGN(SurfaceTextureTransportClient);
Index: src/content/browser/renderer_host/render_widget_host_view_android.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_android.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_android.cc	(working copy)
@@ -29,27 +29,13 @@
 #include "third_party/WebKit/Source/Platform/chromium/public/WebExternalTextureLayer.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
 #include "ui/gfx/android/java_bitmap.h"
+#include "ui/gfx/display.h"
+#include "ui/gfx/screen.h"
 #include "ui/gfx/size_conversions.h"
 #include "webkit/compositor_bindings/web_compositor_support_impl.h"
 
 namespace content {
 
-namespace {
-
-// TODO(pliard): http://crbug.com/142585. Remove this helper function and update
-// the clients to deal directly with WebKit::WebTextDirection.
-base::i18n::TextDirection ConvertTextDirection(WebKit::WebTextDirection dir) {
-  switch (dir) {
-    case WebKit::WebTextDirectionDefault: return base::i18n::UNKNOWN_DIRECTION;
-    case WebKit::WebTextDirectionLeftToRight: return base::i18n::LEFT_TO_RIGHT;
-    case WebKit::WebTextDirectionRightToLeft: return base::i18n::RIGHT_TO_LEFT;
-  }
-  NOTREACHED() << "Unsupported text direction " << dir;
-  return base::i18n::UNKNOWN_DIRECTION;
-}
-
-}  // namespace
-
 RenderWidgetHostViewAndroid::RenderWidgetHostViewAndroid(
     RenderWidgetHostImpl* widget_host,
     ContentViewCoreImpl* content_view_core)
@@ -83,6 +69,18 @@
   }
 }
 
+
+bool RenderWidgetHostViewAndroid::OnMessageReceived(
+    const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(RenderWidgetHostViewAndroid, message)
+    IPC_MESSAGE_HANDLER(ViewHostMsg_ImeBatchStateChanged_ACK,
+                        ProcessImeBatchStateAck)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+  return handled;
+}
+
 void RenderWidgetHostViewAndroid::InitAsChild(gfx::NativeView parent_view) {
   NOTIMPLEMENTED();
 }
@@ -192,8 +190,7 @@
 bool RenderWidgetHostViewAndroid::HasValidFrame() const {
   return texture_id_in_layer_ != 0 &&
       content_view_core_ &&
-      !texture_size_in_layer_.IsEmpty() &&
-      texture_size_in_layer_ == content_view_core_->GetBounds().size();
+      !texture_size_in_layer_.IsEmpty();
 }
 
 gfx::NativeView RenderWidgetHostViewAndroid::GetNativeView() const {
@@ -272,7 +269,7 @@
   if (!content_view_core_)
     return gfx::Rect();
 
-  return content_view_core_->GetBounds();
+  return gfx::Rect(content_view_core_->GetDIPSize());
 }
 
 void RenderWidgetHostViewAndroid::UpdateCursor(const WebCursor& cursor) {
@@ -303,6 +300,11 @@
   return reinterpret_cast<int>(&ime_adapter_android_);
 }
 
+void RenderWidgetHostViewAndroid::ProcessImeBatchStateAck(bool is_begin) {
+  if (content_view_core_)
+    content_view_core_->ProcessImeBatchStateAck(is_begin);
+}
+
 void RenderWidgetHostViewAndroid::ImeCancelComposition() {
   ime_adapter_android_.CancelComposition();
 }
@@ -358,16 +360,9 @@
 }
 
 void RenderWidgetHostViewAndroid::SelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
+    const ViewHostMsg_SelectionBounds_Params& params) {
   if (content_view_core_) {
-    content_view_core_->OnSelectionBoundsChanged(
-        start_rect,
-        ConvertTextDirection(start_direction),
-        end_rect,
-        ConvertTextDirection(end_direction));
+    content_view_core_->OnSelectionBoundsChanged(params);
   }
 }
 
@@ -488,6 +483,7 @@
     ImageTransportFactoryAndroid::GetInstance()->DeleteTexture(
         texture_id_in_layer_);
     texture_id_in_layer_ = 0;
+    current_buffer_id_ = 0;
   }
 }
 
@@ -599,7 +595,12 @@
 
 
 void RenderWidgetHostViewAndroid::SetCachedBackgroundColor(SkColor color) {
+  if (cached_background_color_ == color)
+    return;
+
   cached_background_color_ = color;
+  if (content_view_core_)
+    content_view_core_->OnBackgroundColorChanged(color);
 }
 
 SkColor RenderWidgetHostViewAndroid::GetCachedBackgroundColor() const {
@@ -618,7 +619,9 @@
     float page_scale_factor,
     float min_page_scale_factor,
     float max_page_scale_factor,
-    const gfx::Size& content_size) {
+    const gfx::Size& content_size,
+    const gfx::Vector2dF& controls_offset,
+    const gfx::Vector2dF& content_offset) {
   if (content_view_core_) {
     content_view_core_->UpdateContentSize(content_size.width(),
                                           content_size.height());
@@ -627,6 +630,8 @@
     content_view_core_->UpdateScrollOffsetAndPageScaleFactor(scroll_offset.x(),
                                                              scroll_offset.y(),
                                                              page_scale_factor);
+    content_view_core_->UpdateOffsetsForFullscreen(controls_offset.y(),
+                                                   content_offset.y());
   }
 }
 
@@ -649,16 +654,17 @@
 // static
 void RenderWidgetHostViewPort::GetDefaultScreenInfo(
     WebKit::WebScreenInfo* results) {
+  const gfx::Display& display =
+      gfx::Screen::GetNativeScreen()->GetPrimaryDisplay();
+  results->rect = display.bounds();
+  // TODO(husky): Remove any system controls from availableRect.
+  results->availableRect = display.work_area();
+  results->deviceScaleFactor = display.device_scale_factor();
+
   DeviceInfo info;
-  const int width = info.GetWidth();
-  const int height = info.GetHeight();
-  results->deviceScaleFactor = info.GetDPIScale();
-  results->depth = info.GetBitsPerPixel();
+  results->depth = info.GetBitsPerPixel();;
   results->depthPerComponent = info.GetBitsPerComponent();
   results->isMonochrome = (results->depthPerComponent == 0);
-  results->rect = WebKit::WebRect(0, 0, width, height);
-  // TODO(husky): Remove any system controls from availableRect.
-  results->availableRect = WebKit::WebRect(0, 0, width, height);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: src/content/browser/renderer_host/ime_adapter_android.h
===================================================================
--- src/content/browser/renderer_host/ime_adapter_android.h	(revision 184497)
+++ src/content/browser/renderer_host/ime_adapter_android.h	(working copy)
@@ -36,6 +36,7 @@
                              int native_key_code,
                              int unicode_char);
   void SetComposingText(JNIEnv*, jobject, jstring text, int new_cursor_pos);
+  void ImeBatchStateChanged(JNIEnv*, jobject, jboolean is_begin);
   void CommitText(JNIEnv*, jobject, jstring text);
   void AttachImeAdapter(JNIEnv*, jobject java_object);
   void SetEditableSelectionOffsets(JNIEnv*, jobject, int start, int end);
Index: src/content/browser/renderer_host/render_widget_host_impl_android.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_impl_android.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_impl_android.cc	(working copy)
@@ -4,6 +4,7 @@
 
 #include "content/browser/renderer_host/render_widget_host_impl.h"
 #include "content/port/browser/render_widget_host_view_port.h"
+#include "ui/gfx/vector2d_f.h"
 
 namespace content {
 
@@ -18,7 +19,9 @@
                            page_scale_factor,
                            min_page_scale_factor,
                            max_page_scale_factor,
-                           content_size);
+                           content_size,
+                           gfx::Vector2dF(),
+                           gfx::Vector2dF());
 }
 
 }  // namespace content
Index: src/content/browser/renderer_host/render_widget_host_unittest.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_unittest.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_unittest.cc	(working copy)
@@ -134,14 +134,19 @@
     hung_renderer_delay_ms_ = delay_ms;
   }
 
+  unsigned GestureEventLastQueueEventSize() {
+    return gesture_event_filter_->coalesced_gesture_events_.size();
+  }
+
+  WebGestureEvent GestureEventSecondFromLastQueueEvent() {
+    return gesture_event_filter_->coalesced_gesture_events_.at(
+      GestureEventLastQueueEventSize() - 2);
+  }
+
   WebGestureEvent GestureEventLastQueueEvent() {
     return gesture_event_filter_->coalesced_gesture_events_.back();
   }
 
-  unsigned GestureEventLastQueueEventSize() {
-    return gesture_event_filter_->coalesced_gesture_events_.size();
-  }
-
   unsigned GestureEventDebouncingQueueSize() {
     return gesture_event_filter_->debouncing_deferral_queue_.size();
   }
@@ -162,6 +167,10 @@
     return gesture_event_filter_->fling_in_progress_;
   }
 
+  bool WillIgnoreNextACK() {
+    return gesture_event_filter_->ignore_next_ack_;
+  }
+
   TapSuppressionState TapSuppressionControllerState() {
     return static_cast<TapSuppressionState>(
         gesture_event_filter_->tap_suppression_controller_->state_);
@@ -556,29 +565,57 @@
     host_->ForwardWheelEvent(wheel_event);
   }
 
+  // Inject provided synthetic WebGestureEvent instance.
+  void SimulateGestureEventCore(WebInputEvent::Type type,
+                            WebGestureEvent::SourceDevice sourceDevice,
+                            WebGestureEvent* gesture_event) {
+    gesture_event->type = type;
+    gesture_event->sourceDevice = sourceDevice;
+    host_->ForwardGestureEvent(*gesture_event);
+  }
+
   // Inject simple synthetic WebGestureEvent instances.
-  void SimulateGestureEvent(WebInputEvent::Type type) {
+  void SimulateGestureEvent(WebInputEvent::Type type,
+                            WebGestureEvent::SourceDevice sourceDevice) {
     WebGestureEvent gesture_event;
-    gesture_event.type = type;
-    host_->ForwardGestureEvent(gesture_event);
+    SimulateGestureEventCore(type, sourceDevice, &gesture_event);
   }
 
   void SimulateGestureScrollUpdateEvent(float dX, float dY, int modifiers) {
     WebGestureEvent gesture_event;
-    gesture_event.type = WebInputEvent::GestureScrollUpdate;
     gesture_event.data.scrollUpdate.deltaX = dX;
     gesture_event.data.scrollUpdate.deltaY = dY;
     gesture_event.modifiers = modifiers;
-    host_->ForwardGestureEvent(gesture_event);
+    SimulateGestureEventCore(WebInputEvent::GestureScrollUpdate,
+                             WebGestureEvent::Touchscreen, &gesture_event);
   }
 
-  // Inject simple synthetic WebGestureEvent instances.
-  void SimulateGestureFlingStartEvent(float velocityX, float velocityY) {
+  void SimulateGesturePinchUpdateEvent(float scale,
+                                       float anchorX,
+                                       float anchorY,
+                                       int modifiers) {
     WebGestureEvent gesture_event;
-    gesture_event.type = WebInputEvent::GestureFlingStart;
+    gesture_event.data.pinchUpdate.scale = scale;
+    gesture_event.x = anchorX;
+    gesture_event.y = anchorY;
+    gesture_event.modifiers = modifiers;
+    SimulateGestureEventCore(WebInputEvent::GesturePinchUpdate,
+                             WebGestureEvent::Touchscreen, &gesture_event);
+  }
+
+  // Inject synthetic GestureFlingStart events.
+  void SimulateGestureFlingStartEvent(
+      float velocityX,
+      float velocityY,
+      WebGestureEvent::SourceDevice sourceDevice) {
+    WebGestureEvent gesture_event;
+    // FIXME(mohsen || rjkroege): Remove following line after removing uses of
+    // flingStart.sourceDevice in WebKit, but before removing the field itself.
+    gesture_event.data.flingStart.sourceDevice = sourceDevice;
     gesture_event.data.flingStart.velocityX = velocityX;
     gesture_event.data.flingStart.velocityY = velocityY;
-    host_->ForwardGestureEvent(gesture_event);
+    SimulateGestureEventCore(WebInputEvent::GestureFlingStart, sourceDevice,
+                             &gesture_event);
   }
 
   // Set the timestamp for the touch-event.
@@ -1084,7 +1121,7 @@
   MessageLoop::current()->RunUntilIdle();
   EXPECT_EQ(0U, process_->sink().message_count());
 
-  SimulateGestureFlingStartEvent(0.f, 0.f);
+  SimulateGestureFlingStartEvent(0.f, 0.f, WebGestureEvent::Touchpad);
   EXPECT_EQ(0U, process_->sink().message_count());
 }
 
@@ -1092,7 +1129,8 @@
   process_->sink().ClearMessages();
 
   // Send an initial gesture begin and ACK it.
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   SendInputEventACK(WebInputEvent::GestureScrollBegin, true);
   MessageLoop::current()->RunUntilIdle();
@@ -1108,7 +1146,8 @@
 
   // A gesture event should now result in the queued phase ended event being
   // transmitted before it.
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchpad);
   ASSERT_EQ(4U, process_->sink().message_count());
 
   // Verify the events that were sent.
@@ -1123,15 +1162,16 @@
   EXPECT_EQ(WebInputEvent::GestureScrollEnd, input_event->type);
 }
 
-TEST_F(RenderWidgetHostTest, CoalescesGesturesEvents) {
+TEST_F(RenderWidgetHostTest, CoalescesScrollGestureEvents) {
   // Turn off debounce handling for test isolation.
   host_->set_debounce_interval_time_ms(0);
   process_->sink().ClearMessages();
-  // Only GestureScrollUpdate events can be coalesced.
+  // Test coalescing of only GestureScrollUpdate events.
   // Simulate gesture events.
 
   // Sent.
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
 
   // Enqueued.
   SimulateGestureScrollUpdateEvent(8, -5, 0);
@@ -1160,7 +1200,8 @@
   EXPECT_EQ(1, merged_event.modifiers);
 
   // Different.
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
 
   // Check that only the first event was sent.
   EXPECT_EQ(1U, process_->sink().message_count());
@@ -1198,22 +1239,255 @@
   EXPECT_EQ(0U, process_->sink().message_count());
 }
 
+TEST_F(RenderWidgetHostTest, CoalescesScrollAndPinchEvents) {
+  // Turn off debounce handling for test isolation.
+  host_->set_debounce_interval_time_ms(0);
+  process_->sink().ClearMessages();
+  // Test coalescing of only GestureScrollUpdate events.
+  // Simulate gesture events.
+
+  // Sent.
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
+
+  // Sent.
+  SimulateGestureEvent(WebInputEvent::GesturePinchBegin,
+                       WebGestureEvent::Touchscreen);
+
+  // Enqueued.
+  SimulateGestureScrollUpdateEvent(8, -4, 1);
+
+  // Make sure that the queue contains what we think it should.
+  WebGestureEvent merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(3U, host_->GestureEventLastQueueEventSize());
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+
+  // Coalesced without changing event order. Note anchor at (60, 60). Anchoring
+  // from a poinht that is not the origin should still give us the wight scroll.
+  SimulateGesturePinchUpdateEvent(1.5, 60, 60, 1);
+  EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(1.5, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(8, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-4, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Enqueued.
+  SimulateGestureScrollUpdateEvent(6, -3, 1);
+
+  // Check whether coalesced correctly.
+  EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(1.5, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(12, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-6, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Enqueued.
+  SimulateGesturePinchUpdateEvent(2, 60, 60, 1);
+
+  // Check whether coalesced correctly.
+  EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(3, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(12, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-6, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Enqueued.
+  SimulateGesturePinchUpdateEvent(2, 60, 60, 1);
+
+  // Check whether coalesced correctly.
+  EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(6, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(12, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-6, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Check that only the first event was sent.
+  EXPECT_EQ(1U, process_->sink().message_count());
+  EXPECT_TRUE(process_->sink().GetUniqueMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  process_->sink().ClearMessages();
+
+  // Check that the ACK sends the second message.
+  SendInputEventACK(WebInputEvent::GestureScrollBegin,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(1U, process_->sink().message_count());
+  EXPECT_TRUE(process_->sink().GetUniqueMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  process_->sink().ClearMessages();
+
+  // Enqueued.
+  SimulateGestureScrollUpdateEvent(6, -6, 1);
+
+  // Check whether coalesced correctly.
+  EXPECT_EQ(3U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(6, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(13, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-7, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // At this point ACKs shouldn't be getting ignored.
+  EXPECT_FALSE(host_->WillIgnoreNextACK());
+
+  // Check that the ACK sends both scroll and pinch updates.
+  SendInputEventACK(WebInputEvent::GesturePinchBegin,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(2U, process_->sink().message_count());
+  EXPECT_TRUE(process_->sink().GetFirstMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  EXPECT_FALSE(process_->sink().GetUniqueMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  process_->sink().ClearMessages();
+
+  // The next ACK should be getting ignored.
+  EXPECT_TRUE(host_->WillIgnoreNextACK());
+
+  // Enqueued.
+  SimulateGestureScrollUpdateEvent(1, -1, 1);
+
+  // Check whether coalesced correctly.
+  EXPECT_EQ(3U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(1, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-1, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(6, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Enqueued.
+  SimulateGestureScrollUpdateEvent(2, -2, 1);
+
+  // Coalescing scrolls should still work.
+  EXPECT_EQ(3U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(3, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-3, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(6, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Enqueued.
+  SimulateGesturePinchUpdateEvent(0.5, 60, 60, 1);
+
+  // Check whether coalesced correctly.
+  EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(0.5, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(3, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-3, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Check that the ACK gets ignored.
+  SendInputEventACK(WebInputEvent::GestureScrollUpdate,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(0U, process_->sink().message_count());
+  // The flag should have been flipped back to false.
+  EXPECT_FALSE(host_->WillIgnoreNextACK());
+
+  // Enqueued.
+  SimulateGestureScrollUpdateEvent(2, -2, 2);
+
+  // Shouldn't coalesce with different modifiers.
+  EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
+  merged_event = host_->GestureEventLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GestureScrollUpdate, merged_event.type);
+  EXPECT_EQ(2, merged_event.data.scrollUpdate.deltaX);
+  EXPECT_EQ(-2, merged_event.data.scrollUpdate.deltaY);
+  EXPECT_EQ(2, merged_event.modifiers);
+  merged_event = host_->GestureEventSecondFromLastQueueEvent();
+  EXPECT_EQ(WebInputEvent::GesturePinchUpdate, merged_event.type);
+  EXPECT_EQ(0.5, merged_event.data.pinchUpdate.scale);
+  EXPECT_EQ(1, merged_event.modifiers);
+
+  // Check that the ACK sends the next scroll pinch pair.
+  SendInputEventACK(WebInputEvent::GesturePinchUpdate,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(2U, process_->sink().message_count());
+  EXPECT_TRUE(process_->sink().GetFirstMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  EXPECT_FALSE(process_->sink().GetUniqueMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  process_->sink().ClearMessages();
+
+  // Check that the ACK sends the second message.
+  SendInputEventACK(WebInputEvent::GestureScrollUpdate,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(0U, process_->sink().message_count());
+
+  // Check that the ACK sends the second message.
+  SendInputEventACK(WebInputEvent::GesturePinchUpdate,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(1U, process_->sink().message_count());
+  EXPECT_TRUE(process_->sink().GetUniqueMessageMatching(
+              ViewMsg_HandleInputEvent::ID));
+  process_->sink().ClearMessages();
+
+  // Check that the queue is empty after ACK and no messages get sent.
+  SendInputEventACK(WebInputEvent::GestureScrollUpdate,
+                    INPUT_EVENT_ACK_STATE_CONSUMED);
+  MessageLoop::current()->RunUntilIdle();
+  EXPECT_EQ(0U, process_->sink().message_count());
+  EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
+}
+
 TEST_F(RenderWidgetHostTest, GestureFlingCancelsFiltered) {
   // Turn off debounce handling for test isolation.
   host_->set_debounce_interval_time_ms(0);
   process_->sink().ClearMessages();
   // GFC without previous GFS is dropped.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
   // GFC after previous GFS is dispatched and acked.
   process_->sink().ClearMessages();
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchscreen);
   EXPECT_TRUE(host_->FlingInProgress());
   SendInputEventACK(WebInputEvent::GestureFlingStart, true);
   MessageLoop::current()->RunUntilIdle();
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   EXPECT_FALSE(host_->FlingInProgress());
   EXPECT_EQ(2U, process_->sink().message_count());
   SendInputEventACK(WebInputEvent::GestureFlingCancel, true);
@@ -1222,9 +1496,10 @@
 
   // GFC before previous GFS is acked.
   process_->sink().ClearMessages();
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchscreen);
   EXPECT_TRUE(host_->FlingInProgress());
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   EXPECT_FALSE(host_->FlingInProgress());
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
@@ -1239,7 +1514,7 @@
   // GFS is added to the queue if another event is pending
   process_->sink().ClearMessages();
   SimulateGestureScrollUpdateEvent(8, -7, 0);
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchscreen);
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(1U, process_->sink().message_count());
   WebGestureEvent merged_event = host_->GestureEventLastQueueEvent();
@@ -1248,33 +1523,37 @@
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
 
   // GFS in queue means that a GFC is added to the queue
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   merged_event =host_->GestureEventLastQueueEvent();
   EXPECT_EQ(WebInputEvent::GestureFlingCancel, merged_event.type);
   EXPECT_FALSE(host_->FlingInProgress());
   EXPECT_EQ(3U, host_->GestureEventLastQueueEventSize());
 
   // Adding a second GFC is dropped.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   EXPECT_FALSE(host_->FlingInProgress());
   EXPECT_EQ(3U, host_->GestureEventLastQueueEventSize());
 
   // Adding another GFS will add it to the queue.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchscreen);
   merged_event = host_->GestureEventLastQueueEvent();
   EXPECT_EQ(WebInputEvent::GestureFlingStart, merged_event.type);
   EXPECT_TRUE(host_->FlingInProgress());
   EXPECT_EQ(4U, host_->GestureEventLastQueueEventSize());
 
   // GFS in queue means that a GFC is added to the queue
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   merged_event = host_->GestureEventLastQueueEvent();
   EXPECT_EQ(WebInputEvent::GestureFlingCancel, merged_event.type);
   EXPECT_FALSE(host_->FlingInProgress());
   EXPECT_EQ(5U, host_->GestureEventLastQueueEventSize());
 
   // Adding another GFC with a GFC already there is dropped.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchscreen);
   merged_event = host_->GestureEventLastQueueEvent();
   EXPECT_EQ(WebInputEvent::GestureFlingCancel, merged_event.type);
   EXPECT_FALSE(host_->FlingInProgress());
@@ -1288,7 +1567,8 @@
   // Set some sort of short deferral timeout
   host_->set_maximum_tap_gap_time_ms(5);
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
@@ -1310,11 +1590,13 @@
   // Set some sort of short deferral timeout
   host_->set_maximum_tap_gap_time_ms(5);
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureTap);
+  SimulateGestureEvent(WebInputEvent::GestureTap,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureTap,
@@ -1336,7 +1618,8 @@
   // Set some sort of short deferral timeout
   host_->set_maximum_tap_gap_time_ms(5);
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
@@ -1351,7 +1634,8 @@
             host_->GestureEventLastQueueEvent().type);
 
   // Now send the tap gesture and verify we didn't get an extra TapDown.
-  SimulateGestureEvent(WebInputEvent::GestureTap);
+  SimulateGestureEvent(WebInputEvent::GestureTap,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureTap,
@@ -1365,11 +1649,13 @@
   // Set some sort of short deferral timeout
   host_->set_maximum_tap_gap_time_ms(5);
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureScrollBegin,
@@ -1391,11 +1677,13 @@
   // Set some sort of short deferral timeout
   host_->set_maximum_tap_gap_time_ms(5);
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureTapCancel);
+  SimulateGestureEvent(WebInputEvent::GestureTapCancel,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
@@ -1415,7 +1703,8 @@
   // Set some sort of short deferral timeout
   host_->set_maximum_tap_gap_time_ms(5);
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
 
@@ -1426,7 +1715,8 @@
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureTapCancel);
+  SimulateGestureEvent(WebInputEvent::GestureTapCancel,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
 }
@@ -1439,29 +1729,33 @@
 
   host_->set_debounce_interval_time_ms(3);
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate);
+  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(0U, host_->GestureEventDebouncingQueueSize());
   EXPECT_TRUE(host_->ScrollingInProgress());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate);
+  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(0U, host_->GestureEventDebouncingQueueSize());
   EXPECT_TRUE(host_->ScrollingInProgress());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(1U, host_->GestureEventDebouncingQueueSize());
 
-  SimulateGestureFlingStartEvent(0, 10);
+  SimulateGestureFlingStartEvent(0, 10, WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(2U, host_->GestureEventDebouncingQueueSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureTapDown);
+  SimulateGestureEvent(WebInputEvent::GestureTapDown,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(3U, host_->GestureEventDebouncingQueueSize());
@@ -1503,19 +1797,22 @@
   host_->set_debounce_interval_time_ms(3);
   EXPECT_FALSE(host_->ScrollingInProgress());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate);
+  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(0U, host_->GestureEventDebouncingQueueSize());
   EXPECT_TRUE(host_->ScrollingInProgress());
 
   // This event should get discarded.
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(1U, host_->GestureEventDebouncingQueueSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate);
+  SimulateGestureEvent(WebInputEvent::GestureScrollUpdate,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(2U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(0U, host_->GestureEventDebouncingQueueSize());
@@ -1540,7 +1837,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1559,7 +1856,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -1600,7 +1898,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1619,7 +1917,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -1675,7 +1974,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1694,7 +1993,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -1751,7 +2051,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1770,7 +2070,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -1827,7 +2128,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1846,7 +2147,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -1902,7 +2204,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1921,7 +2223,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -1965,7 +2268,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -1984,7 +2287,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -2027,7 +2331,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -2046,7 +2350,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -2104,7 +2409,7 @@
   process_->sink().ClearMessages();
 
   // Send GestureFlingStart.
-  SimulateGestureFlingStartEvent(0, -10);
+  SimulateGestureFlingStartEvent(0, -10, WebGestureEvent::Touchpad);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingStart,
@@ -2123,7 +2428,8 @@
   EXPECT_TRUE(host_->FlingInProgress());
 
   // Send GestureFlingCancel.
-  SimulateGestureEvent(WebInputEvent::GestureFlingCancel);
+  SimulateGestureEvent(WebInputEvent::GestureFlingCancel,
+                       WebGestureEvent::Touchpad);
   EXPECT_EQ(2U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(WebInputEvent::GestureFlingCancel,
@@ -2749,7 +3055,7 @@
   // Send a fling start, but with a small velocity, so that the overscroll is
   // aborted. The fling should proceed to the renderer, through the gesture
   // event filter.
-  SimulateGestureFlingStartEvent(0.f, 0.1f);
+  SimulateGestureFlingStartEvent(0.f, 0.1f, WebGestureEvent::Touchpad);
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_mode());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(1U, process_->sink().message_count());
@@ -2793,7 +3099,7 @@
   // Send a fling start, but with a small velocity, so that the overscroll is
   // aborted. The fling should proceed to the renderer, through the gesture
   // event filter.
-  SimulateGestureFlingStartEvent(0.f, 0.f);
+  SimulateGestureFlingStartEvent(0.f, 0.f, WebGestureEvent::Touchpad);
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_mode());
   EXPECT_EQ(0U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(0U, process_->sink().message_count());
@@ -2808,7 +3114,8 @@
   host_->set_debounce_interval_time_ms(0);
   process_->sink().ClearMessages();
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   SimulateGestureScrollUpdateEvent(8, -5, 0);
 
   // ACK both events as being processed.
@@ -2846,7 +3153,8 @@
   // Now send a scroll end. This should cancel the overscroll gesture, and send
   // the event to the renderer. The gesture-event filter should receive this
   // event.
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_mode());
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_delegate()->current_mode());
   EXPECT_EQ(1U, process_->sink().message_count());
@@ -2861,7 +3169,8 @@
   process_->sink().ClearMessages();
 
   // Start scrolling. Receive ACK as it being processed.
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   process_->sink().ClearMessages();
   SendInputEventACK(WebInputEvent::GestureScrollBegin, true);
@@ -2876,12 +3185,14 @@
 
   // Quickly end and restart the scroll gesture. These two events should get
   // discarded.
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(1U, host_->GestureEventDebouncingQueueSize());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(2U, host_->GestureEventDebouncingQueueSize());
@@ -2935,7 +3246,8 @@
   process_->sink().ClearMessages();
 
   // Start scrolling. Receive ACK as it being processed.
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   process_->sink().ClearMessages();
   SendInputEventACK(WebInputEvent::GestureScrollBegin, true);
@@ -2949,7 +3261,8 @@
   process_->sink().ClearMessages();
 
   // Send an end event. This should get in the debounce queue.
-  SimulateGestureEvent(WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   EXPECT_EQ(1U, host_->GestureEventDebouncingQueueSize());
@@ -3008,7 +3321,8 @@
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_mode());
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_delegate()->current_mode());
 
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   SimulateGestureScrollUpdateEvent(20, 4, 0);
   SendInputEventACK(WebInputEvent::GestureScrollBegin, false);
   SendInputEventACK(WebInputEvent::GestureScrollUpdate, false);
@@ -3071,7 +3385,8 @@
   SendTouchEvent();
   EXPECT_EQ(0U, process_->sink().message_count());
 
-  SimulateGestureEvent(WebKit::WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebKit::WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   MessageLoop::current()->PostDelayedTask(
       FROM_HERE, MessageLoop::QuitClosure(), TimeDelta::FromMilliseconds(10));
   MessageLoop::current()->Run();
@@ -3093,7 +3408,8 @@
   view_->Show();
 
   // Start scrolling. Receive ACK as it being processed.
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   process_->sink().ClearMessages();
@@ -3123,7 +3439,8 @@
   EXPECT_EQ(0.f, host_->overscroll_delegate()->delta_y());
 
   // Send end event.
-  SimulateGestureEvent(WebKit::WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebKit::WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_mode());
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_delegate()->current_mode());
@@ -3144,7 +3461,8 @@
   EXPECT_EQ(0U, host_->GestureEventDebouncingQueueSize());
 
   // Start scrolling. Receive ACK as it being processed.
-  SimulateGestureEvent(WebInputEvent::GestureScrollBegin);
+  SimulateGestureEvent(WebInputEvent::GestureScrollBegin,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(1U, process_->sink().message_count());
   EXPECT_EQ(1U, host_->GestureEventLastQueueEventSize());
   process_->sink().ClearMessages();
@@ -3174,7 +3492,8 @@
   EXPECT_EQ(0.f, host_->overscroll_delegate()->delta_y());
 
   // Send end event.
-  SimulateGestureEvent(WebKit::WebInputEvent::GestureScrollEnd);
+  SimulateGestureEvent(WebKit::WebInputEvent::GestureScrollEnd,
+                       WebGestureEvent::Touchscreen);
   EXPECT_EQ(0U, process_->sink().message_count());
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_mode());
   EXPECT_EQ(OVERSCROLL_NONE, host_->overscroll_delegate()->current_mode());
Index: src/content/browser/renderer_host/render_widget_host_view_aura.cc
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_aura.cc	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_aura.cc	(working copy)
@@ -681,15 +681,13 @@
 }
 
 void RenderWidgetHostViewAura::SelectionBoundsChanged(
-    const gfx::Rect& start_rect,
-    WebKit::WebTextDirection start_direction,
-    const gfx::Rect& end_rect,
-    WebKit::WebTextDirection end_direction) {
-  if (selection_start_rect_ == start_rect && selection_end_rect_ == end_rect)
+    const ViewHostMsg_SelectionBounds_Params& params) {
+  if (selection_anchor_rect_ == params.anchor_rect &&
+      selection_focus_rect_ == params.focus_rect)
     return;
 
-  selection_start_rect_ = start_rect;
-  selection_end_rect_ = end_rect;
+  selection_anchor_rect_ = params.anchor_rect;
+  selection_focus_rect_ = params.focus_rect;
 
   if (GetInputMethod())
     GetInputMethod()->OnCaretBoundsChanged(this);
@@ -1237,7 +1235,7 @@
 
 gfx::Rect RenderWidgetHostViewAura::GetCaretBounds() {
   const gfx::Rect rect =
-      gfx::UnionRects(selection_start_rect_, selection_end_rect_);
+      gfx::UnionRects(selection_anchor_rect_, selection_focus_rect_);
   return ConvertRectToScreen(rect);
 }
 
@@ -1681,6 +1679,7 @@
     // event to stop any in-progress flings.
     WebKit::WebGestureEvent fling_cancel = gesture;
     fling_cancel.type = WebKit::WebInputEvent::GestureFlingCancel;
+    fling_cancel.sourceDevice = WebKit::WebGestureEvent::Touchscreen;
     host_->ForwardGestureEvent(fling_cancel);
   }
 
Index: src/content/browser/renderer_host/render_widget_host_view_win.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_win.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_win.h	(working copy)
@@ -178,10 +178,7 @@
   virtual void TextInputStateChanged(
       const ViewHostMsg_TextInputState_Params& params) OVERRIDE;
   virtual void SelectionBoundsChanged(
-      const gfx::Rect& start_rect,
-      WebKit::WebTextDirection start_direction,
-      const gfx::Rect& end_rect,
-      WebKit::WebTextDirection end_direction) OVERRIDE;
+      const ViewHostMsg_SelectionBounds_Params& params) OVERRIDE;
   virtual void ImeCancelComposition() OVERRIDE;
   virtual void ImeCompositionRangeChanged(
       const ui::Range& range,
Index: src/content/browser/renderer_host/ui_events_helper.cc
===================================================================
--- src/content/browser/renderer_host/ui_events_helper.cc	(revision 184497)
+++ src/content/browser/renderer_host/ui_events_helper.cc	(working copy)
@@ -189,6 +189,9 @@
       gesture_event.type = WebKit::WebInputEvent::GestureFlingStart;
       gesture_event.data.flingStart.velocityX = event.details().velocity_x();
       gesture_event.data.flingStart.velocityY = event.details().velocity_y();
+      // FIXME(mohsen || rjkroege): Remove following line after removing uses of
+      // flingStart.sourceDevice in WebKit, but before removing the field
+      // itself.
       gesture_event.data.flingStart.sourceDevice =
           WebKit::WebGestureEvent::Touchscreen;
       break;
@@ -225,6 +228,7 @@
       NOTREACHED() << "Unknown gesture type: " << event.type();
   }
 
+  gesture_event.sourceDevice = WebKit::WebGestureEvent::Touchscreen;
   gesture_event.modifiers = EventFlagsToWebEventModifiers(event.flags());
   gesture_event.timeStampSeconds = event.time_stamp().InSecondsF();
 
Index: src/content/browser/renderer_host/render_widget_host_view_android.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_android.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_android.h	(working copy)
@@ -16,6 +16,7 @@
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "ui/gfx/size.h"
+#include "ui/gfx/vector2d_f.h"
 
 struct ViewHostMsg_TextInputState_Params;
 
@@ -50,6 +51,7 @@
   virtual ~RenderWidgetHostViewAndroid();
 
   // RenderWidgetHostView implementation.
+  virtual bool OnMessageReceived(const IPC::Message& msg) OVERRIDE;
   virtual void InitAsChild(gfx::NativeView parent_view) OVERRIDE;
   virtual void InitAsPopup(RenderWidgetHostView* parent_host_view,
                            const gfx::Rect& pos) OVERRIDE;
@@ -91,10 +93,7 @@
                                 size_t offset,
                                 const ui::Range& range) OVERRIDE;
   virtual void SelectionBoundsChanged(
-      const gfx::Rect& start_rect,
-      WebKit::WebTextDirection start_direction,
-      const gfx::Rect& end_rect,
-      WebKit::WebTextDirection end_direction) OVERRIDE;
+      const ViewHostMsg_SelectionBounds_Params& params) OVERRIDE;
   virtual void OnAcceleratedCompositingStateChange() OVERRIDE;
   virtual void AcceleratedSurfaceBuffersSwapped(
       const GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params& params,
@@ -136,7 +135,9 @@
                                float page_scale_factor,
                                float min_page_scale_factor,
                                float max_page_scale_factor,
-                               const gfx::Size& content_size) OVERRIDE;
+                               const gfx::Size& content_size,
+                               const gfx::Vector2dF& controls_offset,
+                               const gfx::Vector2dF& content_offset) OVERRIDE;
   virtual void ShowDisambiguationPopup(const gfx::Rect& target_rect,
                                        const SkBitmap& zoomed_bitmap) OVERRIDE;
   virtual SmoothScrollGesture* CreateSmoothScrollGesture(
@@ -152,6 +153,8 @@
   void SendMouseWheelEvent(const WebKit::WebMouseWheelEvent& event);
   void SendGestureEvent(const WebKit::WebGestureEvent& event);
 
+  void ProcessImeBatchStateAck(bool is_begin);
+
   int GetNativeImeAdapter();
 
   WebKit::WebGLId GetScaledContentTexture(float scale, gfx::Size* out_size);
Index: src/content/browser/renderer_host/render_view_host_impl.h
===================================================================
--- src/content/browser/renderer_host/render_view_host_impl.h	(revision 184497)
+++ src/content/browser/renderer_host/render_view_host_impl.h	(working copy)
@@ -35,6 +35,7 @@
 struct ViewHostMsg_CreateWindow_Params;
 struct ViewHostMsg_DidFailProvisionalLoadWithError_Params;
 struct ViewHostMsg_OpenURL_Params;
+struct ViewHostMsg_SelectionBounds_Params;
 struct ViewHostMsg_ShowPopup_Params;
 struct ViewMsg_Navigate_Params;
 struct ViewMsg_PostMessage_Params;
@@ -519,10 +520,8 @@
   void OnMsgSelectionChanged(const string16& text,
                              size_t offset,
                              const ui::Range& range);
-  void OnMsgSelectionBoundsChanged(const gfx::Rect& start_rect,
-                                   WebKit::WebTextDirection start_direction,
-                                   const gfx::Rect& end_rect,
-                                   WebKit::WebTextDirection end_direction);
+  void OnMsgSelectionBoundsChanged(
+      const ViewHostMsg_SelectionBounds_Params& params);
   void OnMsgPasteFromSelectionClipboard();
   void OnMsgRouteCloseEvent();
   void OnMsgRouteMessageEvent(const ViewMsg_PostMessage_Params& params);
Index: src/content/browser/renderer_host/render_widget_host_view_mac.h
===================================================================
--- src/content/browser/renderer_host/render_widget_host_view_mac.h	(revision 184497)
+++ src/content/browser/renderer_host/render_widget_host_view_mac.h	(working copy)
@@ -244,10 +244,7 @@
   virtual void TextInputStateChanged(
       const ViewHostMsg_TextInputState_Params& params) OVERRIDE;
   virtual void SelectionBoundsChanged(
-      const gfx::Rect& start_rect,
-      WebKit::WebTextDirection start_direction,
-      const gfx::Rect& end_rect,
-      WebKit::WebTextDirection end_direction) OVERRIDE;
+      const ViewHostMsg_SelectionBounds_Params& params) OVERRIDE;
   virtual void ImeCancelComposition() OVERRIDE;
   virtual void ImeCompositionRangeChanged(
       const ui::Range& range,
Index: src/content/content_browser.gypi
===================================================================
--- src/content/content_browser.gypi	(revision 184497)
+++ src/content/content_browser.gypi	(working copy)
@@ -1044,7 +1044,6 @@
     ['OS=="android"', {
       'dependencies': [
         '../media/media.gyp:media',
-        '../webkit/compositor_bindings/compositor_bindings.gyp:webkit_compositor_support',
         'content.gyp:content_jni_headers',
       ],
       'link_settings': {
Index: src/content/common/cc_messages.h
===================================================================
--- src/content/common/cc_messages.h	(revision 184497)
+++ src/content/common/cc_messages.h	(working copy)
@@ -155,6 +155,10 @@
   IPC_STRUCT_TRAITS_MEMBER(mask_resource_id)
   IPC_STRUCT_TRAITS_MEMBER(contents_changed_since_last_frame)
   IPC_STRUCT_TRAITS_MEMBER(mask_uv_rect)
+  IPC_STRUCT_TRAITS_MEMBER(filters)
+  // TODO(piman): filter isn't being serialized.
+  // IPC_STRUCT_TRAITS_MEMBER(filter)
+  IPC_STRUCT_TRAITS_MEMBER(background_filters)
 IPC_STRUCT_TRAITS_END()
 
 IPC_STRUCT_TRAITS_BEGIN(cc::SolidColorDrawQuad)
@@ -172,7 +176,12 @@
   IPC_STRUCT_TRAITS_PARENT(cc::DrawQuad)
   IPC_STRUCT_TRAITS_MEMBER(resource_id)
   IPC_STRUCT_TRAITS_MEMBER(premultiplied_alpha)
-  IPC_STRUCT_TRAITS_MEMBER(uv_rect)
+  IPC_STRUCT_TRAITS_MEMBER(uv_top_left)
+  IPC_STRUCT_TRAITS_MEMBER(uv_bottom_right)
+  IPC_STRUCT_TRAITS_MEMBER(vertex_opacity[0])
+  IPC_STRUCT_TRAITS_MEMBER(vertex_opacity[1])
+  IPC_STRUCT_TRAITS_MEMBER(vertex_opacity[2])
+  IPC_STRUCT_TRAITS_MEMBER(vertex_opacity[3])
   IPC_STRUCT_TRAITS_MEMBER(flipped)
 IPC_STRUCT_TRAITS_END()
 
@@ -199,7 +208,6 @@
 IPC_STRUCT_TRAITS_BEGIN(cc::SharedQuadState)
   IPC_STRUCT_TRAITS_MEMBER(content_to_target_transform)
   IPC_STRUCT_TRAITS_MEMBER(visible_content_rect)
-  IPC_STRUCT_TRAITS_MEMBER(clipped_rect_in_target)
   IPC_STRUCT_TRAITS_MEMBER(clip_rect)
   IPC_STRUCT_TRAITS_MEMBER(is_clipped)
   IPC_STRUCT_TRAITS_MEMBER(opacity)
@@ -229,6 +237,7 @@
   IPC_STRUCT_TRAITS_MEMBER(min_page_scale_factor)
   IPC_STRUCT_TRAITS_MEMBER(max_page_scale_factor)
   IPC_STRUCT_TRAITS_MEMBER(location_bar_offset)
+  IPC_STRUCT_TRAITS_MEMBER(location_bar_content_translation)
 IPC_STRUCT_TRAITS_END()
 
 IPC_STRUCT_TRAITS_BEGIN(cc::GLFrameData)
Index: src/content/common/view_messages.h
===================================================================
--- src/content/common/view_messages.h	(revision 184497)
+++ src/content/common/view_messages.h	(working copy)
@@ -470,6 +470,14 @@
   IPC_STRUCT_MEMBER(bool, show_ime_if_needed)
 IPC_STRUCT_END()
 
+IPC_STRUCT_BEGIN(ViewHostMsg_SelectionBounds_Params)
+  IPC_STRUCT_MEMBER(gfx::Rect, anchor_rect)
+  IPC_STRUCT_MEMBER(WebKit::WebTextDirection, anchor_dir)
+  IPC_STRUCT_MEMBER(gfx::Rect, focus_rect)
+  IPC_STRUCT_MEMBER(WebKit::WebTextDirection, focus_dir)
+  IPC_STRUCT_MEMBER(bool, is_anchor_first)
+IPC_STRUCT_END()
+
 IPC_STRUCT_BEGIN(ViewHostMsg_CreateWorker_Params)
   // URL for the worker script.
   IPC_STRUCT_MEMBER(GURL, url)
@@ -1416,19 +1424,10 @@
 // ViewMsg_ScrollFocusedEditableNodeIntoView was called.
 IPC_MESSAGE_ROUTED0(ViewMsg_UndoScrollFocusedEditableNodeIntoView)
 
-// Message sent when the renderer changed the background color for the view.
-IPC_MESSAGE_ROUTED1(ViewHostMsg_DidChangeBodyBackgroundColor,
-                    uint32  /* bg_color */)
+// This message relays the beginning or end of a batch event in the IME.
+IPC_MESSAGE_ROUTED1(ViewMsg_ImeBatchStateChanged,
+    bool /* is_begin */)
 
-// Information about current document scroll, scale and size. Sent on a
-// best-effort basis.
-IPC_MESSAGE_ROUTED5(ViewHostMsg_UpdateFrameInfo,
-                    gfx::Vector2d /* scroll_offset */,
-                    float /* page_scale_factor */,
-                    float /* min_page_scale_factor */,
-                    float /* max_page_scale_factor */,
-                    gfx::Size /* content_size */)
-
 #elif defined(OS_MACOSX)
 // Let the RenderView know its window has changed visibility.
 IPC_MESSAGE_ROUTED1(ViewMsg_SetWindowVisibility,
@@ -2068,11 +2067,8 @@
                     ui::Range /* selection range in the document */)
 
 // Notification that the selection bounds have changed.
-IPC_MESSAGE_ROUTED4(ViewHostMsg_SelectionBoundsChanged,
-                    gfx::Rect /* start rect */,
-                    WebKit::WebTextDirection /* start text dir */,
-                    gfx::Rect /* end rect */,
-                    WebKit::WebTextDirection /* end text dir */)
+IPC_MESSAGE_ROUTED1(ViewHostMsg_SelectionBoundsChanged,
+                    ViewHostMsg_SelectionBounds_Params)
 
 // Asks the browser to open the color chooser.
 IPC_MESSAGE_ROUTED2(ViewHostMsg_OpenColorChooser,
@@ -2454,6 +2450,25 @@
 // Start an android intent with the given URI.
 IPC_MESSAGE_ROUTED1(ViewHostMsg_StartContentIntent,
                     GURL /* content_url */)
+
+// Message sent when the renderer changed the background color for the view.
+IPC_MESSAGE_ROUTED1(ViewHostMsg_DidChangeBodyBackgroundColor,
+                    uint32  /* bg_color */)
+
+// Information about current document scroll, scale and size. Sent on a
+// best-effort basis.
+IPC_MESSAGE_ROUTED5(ViewHostMsg_UpdateFrameInfo,
+                    gfx::Vector2d /* scroll_offset */,
+                    float /* page_scale_factor */,
+                    float /* min_page_scale_factor */,
+                    float /* max_page_scale_factor */,
+                    gfx::Size /* content_size */)
+
+// This message is an ACK that the batch state change has been received by
+// the renderer and all IME related messages should be processed accordingly.
+IPC_MESSAGE_ROUTED1(ViewHostMsg_ImeBatchStateChanged_ACK,
+    bool /* is_begin */)
+
 #endif
 
 // Notifies that multiple touch targets may have been pressed, and to show
Index: src/content/common/gpu/image_transport_surface.cc
===================================================================
--- src/content/common/gpu/image_transport_surface.cc	(revision 184497)
+++ src/content/common/gpu/image_transport_surface.cc	(working copy)
@@ -225,7 +225,8 @@
   surface_->OnResize(size);
 
 #if defined(OS_ANDROID)
-  manager_->gpu_memory_manager()->ScheduleManage(true);
+  manager_->gpu_memory_manager()->ScheduleManage(
+      GpuMemoryManager::kScheduleManageNow);
 #endif
 
 #if defined(OS_WIN)
Index: src/content/common/gpu/gpu_memory_manager.h
===================================================================
--- src/content/common/gpu/gpu_memory_manager.h	(revision 184497)
+++ src/content/common/gpu/gpu_memory_manager.h	(working copy)
@@ -7,8 +7,8 @@
 
 #if defined(ENABLE_GPU)
 
-#include <set>
-#include <vector>
+#include <list>
+#include <map>
 
 #include "base/basictypes.h"
 #include "base/cancelable_callback.h"
@@ -19,35 +19,32 @@
 #include "content/common/gpu/gpu_memory_allocation.h"
 #include "content/public/common/gpu_memory_stats.h"
 #include "gpu/command_buffer/service/memory_tracking.h"
-#include "ui/gfx/size.h"
 
 namespace content {
+
 class GpuChannelManager;
 class GpuMemoryManagerClient;
-}
-
-#if defined(COMPILER_GCC)
-namespace BASE_HASH_NAMESPACE {
-template<>
-struct hash<content::GpuMemoryManagerClient*> {
-  size_t operator()(content::GpuMemoryManagerClient* ptr) const {
-    return hash<size_t>()(reinterpret_cast<size_t>(ptr));
-  }
-};
-} // namespace BASE_HASH_NAMESPACE
-#endif // COMPILER
-
-namespace content {
-class GpuMemoryManagerClient;
+class GpuMemoryManagerClientState;
 class GpuMemoryTrackingGroup;
 
 class CONTENT_EXPORT GpuMemoryManager :
     public base::SupportsWeakPtr<GpuMemoryManager> {
  public:
+#if defined(OS_ANDROID)
+  enum { kDefaultMaxSurfacesWithFrontbufferSoftLimit = 1 };
+#else
   enum { kDefaultMaxSurfacesWithFrontbufferSoftLimit = 8 };
+#endif
+  enum ScheduleManageTime {
+    // Add a call to Manage to the thread's message loop immediately.
+    kScheduleManageNow,
+    // Add a Manage call to the thread's message loop for execution 1/60th of
+    // of a second from now.
+    kScheduleManageLater,
+  };
 
   GpuMemoryManager(GpuChannelManager* channel_manager,
-                   size_t max_surfaces_with_frontbuffer_soft_limit);
+                   uint64 max_surfaces_with_frontbuffer_soft_limit);
   ~GpuMemoryManager();
 
   // Schedule a Manage() call. If immediate is true, we PostTask without delay.
@@ -55,35 +52,24 @@
   // delayed calls to "queue" up. This way, we do not spam clients in certain
   // lower priority situations. An immediate schedule manage will cancel any
   // queued delayed manage.
-  void ScheduleManage(bool immediate);
+  void ScheduleManage(ScheduleManageTime schedule_manage_time);
 
   // Retrieve GPU Resource consumption statistics for the task manager
   void GetVideoMemoryUsageStats(
-      content::GPUVideoMemoryUsageStats& video_memory_usage_stats) const;
+      content::GPUVideoMemoryUsageStats* video_memory_usage_stats) const;
   void SetWindowCount(uint32 count);
 
-  // Add and remove clients
-  void AddClient(GpuMemoryManagerClient* client,
-                 bool has_surface,
-                 bool visible,
-                 base::TimeTicks last_used_time);
-  void RemoveClient(GpuMemoryManagerClient* client);
-  void SetClientVisible(GpuMemoryManagerClient* client, bool visible);
-  void SetClientManagedMemoryStats(GpuMemoryManagerClient* client,
-                                   const GpuManagedMemoryStats& stats);
+  GpuMemoryManagerClientState* CreateClientState(
+      GpuMemoryManagerClient* client, bool has_surface, bool visible);
 
-  // Add and remove structures to track context groups' memory consumption
-  void AddTrackingGroup(GpuMemoryTrackingGroup* tracking_group);
-  void RemoveTrackingGroup(GpuMemoryTrackingGroup* tracking_group);
+  GpuMemoryTrackingGroup* CreateTrackingGroup(
+      base::ProcessId pid, gpu::gles2::MemoryTracker* memory_tracker);
 
-  // Track a change in memory allocated by any context
-  void TrackMemoryAllocatedChange(
-      size_t old_size,
-      size_t new_size,
-      gpu::gles2::MemoryTracker::Pool tracking_pool);
-
  private:
   friend class GpuMemoryManagerTest;
+  friend class GpuMemoryTrackingGroup;
+  friend class GpuMemoryManagerClientState;
+
   FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTest,
                            ComparatorTests);
   FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTest,
@@ -112,128 +98,191 @@
                            TestBackgroundCutoff);
   FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTest,
                            TestBackgroundMru);
+  FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTest,
+                           TestUnmanagedTracking);
 
-  struct ClientState {
-    ClientState(GpuMemoryManagerClient* client,
-                bool has_surface,
-                bool visible,
-                base::TimeTicks last_used_time);
-    // The client to send allocations to.
-    GpuMemoryManagerClient* client;
+  FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTestNonuniform,
+                           BackgroundMru);
+  FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTestNonuniform,
+                           BackgroundDiscardPersistent);
+  FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTestNonuniform,
+                           UnmanagedTracking);
+  FRIEND_TEST_ALL_PREFIXES(GpuMemoryManagerTestNonuniform,
+                           DefaultAllocation);
 
-    // Offscreen commandbuffers will not have a surface.
-    bool has_surface;
+  typedef std::map<gpu::gles2::MemoryTracker*, GpuMemoryTrackingGroup*>
+      TrackingGroupMap;
 
-    // The last used time is determined by the last time that visibility
-    // was changed.
-    bool visible;
-    base::TimeTicks last_used_time;
+  typedef std::list<GpuMemoryManagerClientState*> ClientStateList;
 
-    // Statistics about memory usage.
-    GpuManagedMemoryStats managed_memory_stats;
+  void Manage();
+  void SetClientsHibernatedState() const;
+  uint64 GetVisibleClientAllocation() const;
+  uint64 GetCurrentNonvisibleAvailableGpuMemory() const;
+  void AssignSurfacesAllocationsNonuniform();
+  void AssignSurfacesAllocationsUniform();
+  void AssignNonSurfacesAllocations();
 
-    // Set to disable allocating a frontbuffer or to disable allocations
-    // for clients that don't have surfaces.
-    bool hibernated;
-  };
+  // Math helper function to compute the maximum value of cap such that
+  // sum_i min(bytes[i], cap) <= bytes_sum_limit
+  static uint64 ComputeCap(std::vector<uint64> bytes, uint64 bytes_sum_limit);
 
-  class CONTENT_EXPORT ClientsComparator {
-   public:
-    bool operator()(ClientState* lhs,
-                    ClientState* rhs);
-  };
+  // Compute the allocation for clients when visible and not visible.
+  void ComputeVisibleSurfacesAllocationsNonuniform();
+  void ComputeNonvisibleSurfacesAllocationsNonuniform();
+  void DistributeRemainingMemoryToVisibleSurfaces();
 
-  typedef std::map<GpuMemoryManagerClient*, ClientState*> ClientMap;
+  // Compute the budget for a client. Allow at most bytes_above_required_cap
+  // bytes above client_state's required level. Allow at most
+  // bytes_above_minimum_cap bytes above client_state's minimum level. Allow
+  // at most bytes_overall_cap bytes total.
+  uint64 ComputeClientAllocationWhenVisible(
+      GpuMemoryManagerClientState* client_state,
+      uint64 bytes_above_required_cap,
+      uint64 bytes_above_minimum_cap,
+      uint64 bytes_overall_cap);
+  uint64 ComputeClientAllocationWhenNonvisible(
+      GpuMemoryManagerClientState* client_state);
 
-  typedef std::vector<ClientState*> ClientStateVector;
-
-  void Manage();
-  void SetClientsHibernatedState(const ClientStateVector& clients) const;
-  size_t GetVisibleClientAllocation(const ClientStateVector& clients) const;
-  size_t GetCurrentBackgroundedAvailableGpuMemory() const;
-
   // Update the amount of GPU memory we think we have in the system, based
   // on what the stubs' contexts report.
-  void UpdateAvailableGpuMemory(const ClientStateVector& clients);
-  void UpdateBackgroundedAvailableGpuMemory();
+  void UpdateAvailableGpuMemory();
+  void UpdateUnmanagedMemoryLimits();
+  void UpdateNonvisibleAvailableGpuMemory();
 
   // The amount of video memory which is available for allocation.
-  size_t GetAvailableGpuMemory() const;
+  uint64 GetAvailableGpuMemory() const;
 
   // Minimum value of available GPU memory, no matter how little the GPU
   // reports. This is the default value.
-  size_t GetDefaultAvailableGpuMemory() const;
+  uint64 GetDefaultAvailableGpuMemory() const;
 
   // Maximum cap on total GPU memory, no matter how much the GPU reports.
-  size_t GetMaximumTotalGpuMemory() const;
+  uint64 GetMaximumTotalGpuMemory() const;
 
-  // The maximum and minimum amount of memory that a tab may be assigned.
-  size_t GetMaximumTabAllocation() const;
-  size_t GetMinimumTabAllocation() const;
+  // The maximum and minimum amount of memory that a client may be assigned.
+  uint64 GetMaximumClientAllocation() const;
+  uint64 GetMinimumClientAllocation() const {
+    return bytes_minimum_per_client_;
+  }
+  // The default amount of memory that a client is assigned, if it has not
+  // reported any memory usage stats yet.
+  uint64 GetDefaultClientAllocation() const {
+    return bytes_default_per_client_;
+  }
 
-  // Get a reasonable memory limit from a viewport's surface area.
-  static size_t CalcAvailableFromViewportArea(int viewport_area);
-  static size_t CalcAvailableFromGpuTotal(size_t total_gpu_memory);
+  static uint64 CalcAvailableFromGpuTotal(uint64 total_gpu_memory);
 
   // Send memory usage stats to the browser process.
   void SendUmaStatsToBrowser();
 
   // Get the current number of bytes allocated.
-  size_t GetCurrentUsage() const {
+  uint64 GetCurrentUsage() const {
     return bytes_allocated_managed_current_ +
         bytes_allocated_unmanaged_current_;
   }
 
+  // GpuMemoryTrackingGroup interface
+  void TrackMemoryAllocatedChange(
+      GpuMemoryTrackingGroup* tracking_group,
+      uint64 old_size,
+      uint64 new_size,
+      gpu::gles2::MemoryTracker::Pool tracking_pool);
+  void OnDestroyTrackingGroup(GpuMemoryTrackingGroup* tracking_group);
+  bool EnsureGPUMemoryAvailable(uint64 size_needed);
+
+  // GpuMemoryManagerClientState interface
+  void SetClientStateVisible(
+      GpuMemoryManagerClientState* client_state, bool visible);
+  void SetClientStateManagedMemoryStats(
+      GpuMemoryManagerClientState* client_state,
+      const GpuManagedMemoryStats& stats);
+  void OnDestroyClientState(GpuMemoryManagerClientState* client);
+
+  // Add or remove a client from its clients list (visible, nonvisible, or
+  // nonsurface). When adding the client, add it to the front of the list.
+  void AddClientToList(GpuMemoryManagerClientState* client_state);
+  void RemoveClientFromList(GpuMemoryManagerClientState* client_state);
+  ClientStateList* GetClientList(GpuMemoryManagerClientState* client_state);
+
   // Interfaces for testing
-  void TestingSetClientVisible(GpuMemoryManagerClient* client, bool visible);
-  void TestingSetClientLastUsedTime(GpuMemoryManagerClient* client,
-                                    base::TimeTicks last_used_time);
-  void TestingSetClientHasSurface(GpuMemoryManagerClient* client,
-                                  bool has_surface);
-  bool TestingCompareClients(GpuMemoryManagerClient* lhs,
-                             GpuMemoryManagerClient* rhs) const;
+  void TestingSetUseNonuniformMemoryPolicy(bool use_nonuniform_memory_policy) {
+    use_nonuniform_memory_policy_ = use_nonuniform_memory_policy;
+  }
   void TestingDisableScheduleManage() { disable_schedule_manage_ = true; }
-  void TestingSetAvailableGpuMemory(size_t bytes) {
+  void TestingSetAvailableGpuMemory(uint64 bytes) {
     bytes_available_gpu_memory_ = bytes;
     bytes_available_gpu_memory_overridden_ = true;
   }
 
-  void TestingSetBackgroundedAvailableGpuMemory(size_t bytes) {
-    bytes_backgrounded_available_gpu_memory_ = bytes;
+  void TestingSetMinimumClientAllocation(uint64 bytes) {
+    bytes_minimum_per_client_ = bytes;
   }
 
+  void TestingSetDefaultClientAllocation(uint64 bytes) {
+    bytes_default_per_client_ = bytes;
+  }
+
+  void TestingSetUnmanagedLimitStep(uint64 bytes) {
+    bytes_unmanaged_limit_step_ = bytes;
+  }
+
+  void TestingSetNonvisibleAvailableGpuMemory(uint64 bytes) {
+    bytes_nonvisible_available_gpu_memory_ = bytes;
+  }
+
   GpuChannelManager* channel_manager_;
 
-  // All clients of this memory manager which have callbacks we
-  // can use to adjust memory usage
-  ClientMap clients_;
+  // The new memory policy does not uniformly assign memory to tabs, but
+  // scales the assignments to the tabs' needs.
+  bool use_nonuniform_memory_policy_;
 
+  // A list of all visible and nonvisible clients, in most-recently-used
+  // order (most recently used is first).
+  ClientStateList clients_visible_mru_;
+  ClientStateList clients_nonvisible_mru_;
+
+  // A list of all clients that don't have a surface.
+  ClientStateList clients_nonsurface_;
+
   // All context groups' tracking structures
-  std::set<GpuMemoryTrackingGroup*> tracking_groups_;
+  TrackingGroupMap tracking_groups_;
 
   base::CancelableClosure delayed_manage_callback_;
   bool manage_immediate_scheduled_;
 
-  size_t max_surfaces_with_frontbuffer_soft_limit_;
+  uint64 max_surfaces_with_frontbuffer_soft_limit_;
 
   // The maximum amount of memory that may be allocated for GPU resources
-  size_t bytes_available_gpu_memory_;
+  uint64 bytes_available_gpu_memory_;
   bool bytes_available_gpu_memory_overridden_;
 
+  // The minimum and default allocations for a single client.
+  uint64 bytes_minimum_per_client_;
+  uint64 bytes_default_per_client_;
+
   // The maximum amount of memory that can be allocated for GPU resources
-  // in backgrounded renderers.
-  size_t bytes_backgrounded_available_gpu_memory_;
+  // in nonvisible renderers.
+  uint64 bytes_nonvisible_available_gpu_memory_;
 
   // The current total memory usage, and historical maximum memory usage
-  size_t bytes_allocated_managed_current_;
-  size_t bytes_allocated_managed_visible_;
-  size_t bytes_allocated_managed_backgrounded_;
-  size_t bytes_allocated_unmanaged_current_;
-  size_t bytes_allocated_historical_max_;
+  uint64 bytes_allocated_managed_current_;
+  uint64 bytes_allocated_managed_visible_;
+  uint64 bytes_allocated_managed_nonvisible_;
+  uint64 bytes_allocated_unmanaged_current_;
+  uint64 bytes_allocated_historical_max_;
 
+  // If bytes_allocated_unmanaged_current_ leaves the interval [low_, high_),
+  // then ScheduleManage to take the change into account.
+  uint64 bytes_allocated_unmanaged_high_;
+  uint64 bytes_allocated_unmanaged_low_;
+
+  // Update bytes_allocated_unmanaged_low/high_ in intervals of step_.
+  uint64 bytes_unmanaged_limit_step_;
+
   // The number of browser windows that exist. If we ever receive a
   // GpuMsg_SetVideoMemoryWindowCount, then we use this to compute memory
-  // budgets, instead of doing more complicated stub-based calculations.
+  // allocations, instead of doing more complicated stub-based calculations.
   bool window_count_has_been_received_;
   uint32 window_count_;
 
@@ -243,26 +292,6 @@
   DISALLOW_COPY_AND_ASSIGN(GpuMemoryManager);
 };
 
-class CONTENT_EXPORT GpuMemoryManagerClient {
- public:
-  virtual ~GpuMemoryManagerClient() {}
-
-  // Returns surface size.
-  virtual gfx::Size GetSurfaceSize() const = 0;
-
-  // Returns the memory tracker for this stub.
-  virtual gpu::gles2::MemoryTracker* GetMemoryTracker() const = 0;
-
-  // Sets buffer usage depending on Memory Allocation
-  virtual void SetMemoryAllocation(
-      const GpuMemoryAllocation& allocation) = 0;
-
-  // Returns in bytes the total amount of GPU memory for the GPU which this
-  // context is currently rendering on. Returns false if no extension exists
-  // to get the exact amount of GPU memory.
-  virtual bool GetTotalGpuMemory(size_t* bytes) = 0;
-};
-
 }  // namespace content
 
 #endif
Index: src/content/common/gpu/gpu_command_buffer_stub.h
===================================================================
--- src/content/common/gpu/gpu_command_buffer_stub.h	(revision 184497)
+++ src/content/common/gpu/gpu_command_buffer_stub.h	(working copy)
@@ -15,6 +15,7 @@
 #include "content/common/content_export.h"
 #include "content/common/gpu/gpu_memory_allocation.h"
 #include "content/common/gpu/gpu_memory_manager.h"
+#include "content/common/gpu/gpu_memory_manager_client.h"
 #include "googleurl/src/gurl.h"
 #include "gpu/command_buffer/common/constants.h"
 #include "gpu/command_buffer/service/command_buffer_service.h"
@@ -45,7 +46,6 @@
 class GpuChannel;
 class GpuVideoDecodeAccelerator;
 class GpuWatchdog;
-class GpuMemoryManagerClient;
 
 class GpuCommandBufferStub
     : public GpuMemoryManagerClient,
@@ -92,7 +92,7 @@
   virtual gpu::gles2::MemoryTracker* GetMemoryTracker() const OVERRIDE;
   virtual void SetMemoryAllocation(
       const GpuMemoryAllocation& allocation) OVERRIDE;
-  virtual bool GetTotalGpuMemory(size_t* bytes) OVERRIDE;
+  virtual bool GetTotalGpuMemory(uint64* bytes) OVERRIDE;
 
   // Whether this command buffer can currently handle IPC messages.
   bool IsScheduled();
@@ -228,6 +228,8 @@
   scoped_ptr<gpu::GpuScheduler> scheduler_;
   scoped_refptr<gfx::GLSurface> surface_;
 
+  scoped_ptr<GpuMemoryManagerClientState> memory_manager_client_state_;
+
   // SetParent may be called before Initialize, in which case we need to keep
   // around the parent stub, so that Initialize can set the parent correctly.
   base::WeakPtr<GpuCommandBufferStub> parent_stub_for_initialization_;
Index: src/content/common/gpu/gpu_messages.h
===================================================================
--- src/content/common/gpu/gpu_messages.h	(revision 184497)
+++ src/content/common/gpu/gpu_messages.h	(working copy)
@@ -167,6 +167,8 @@
 
 IPC_STRUCT_TRAITS_BEGIN(content::GPUVideoMemoryUsageStats)
   IPC_STRUCT_TRAITS_MEMBER(process_map)
+  IPC_STRUCT_TRAITS_MEMBER(bytes_allocated)
+  IPC_STRUCT_TRAITS_MEMBER(bytes_allocated_historical_max)
 IPC_STRUCT_TRAITS_END()
 
 IPC_STRUCT_TRAITS_BEGIN(content::GPUMemoryUmaStats)
Index: src/content/common/gpu/gpu_memory_allocation.h
===================================================================
--- src/content/common/gpu/gpu_memory_allocation.h	(revision 184497)
+++ src/content/common/gpu/gpu_memory_allocation.h	(working copy)
@@ -30,11 +30,11 @@
   };
 
   // Limits when this renderer is visible.
-  size_t bytes_limit_when_visible;
+  uint64 bytes_limit_when_visible;
   PriorityCutoff priority_cutoff_when_visible;
 
   // Limits when this renderer is not visible.
-  size_t bytes_limit_when_not_visible;
+  uint64 bytes_limit_when_not_visible;
   PriorityCutoff priority_cutoff_when_not_visible;
   bool have_backbuffer_when_not_visible;
 
@@ -51,7 +51,7 @@
         enforce_but_do_not_keep_as_policy(false) {
   }
 
-  GpuMemoryAllocationForRenderer(size_t bytes_limit_when_visible)
+  GpuMemoryAllocationForRenderer(uint64 bytes_limit_when_visible)
       : bytes_limit_when_visible(bytes_limit_when_visible),
         priority_cutoff_when_visible(kPriorityCutoffAllowEverything),
         bytes_limit_when_not_visible(0),
@@ -105,7 +105,7 @@
   GpuMemoryAllocation() {
   }
 
-  GpuMemoryAllocation(size_t gpu_resource_size_in_bytes,
+  GpuMemoryAllocation(uint64 gpu_resource_size_in_bytes,
                       BufferAllocation buffer_allocation)
       : renderer_allocation(gpu_resource_size_in_bytes),
         browser_allocation(buffer_allocation == kHasFrontbuffer) {
@@ -121,14 +121,14 @@
 // more ideally split memory allocations across clients.
 struct GpuManagedMemoryStats {
   // Bytes required for correct rendering.
-  size_t bytes_required;
+  uint64 bytes_required;
 
   // Bytes that are not strictly required for correctness, but, if allocated,
   // will provide good performance.
-  size_t bytes_nice_to_have;
+  uint64 bytes_nice_to_have;
 
   // The number of bytes currently allocated.
-  size_t bytes_allocated;
+  uint64 bytes_allocated;
 
   // Whether or not a backbuffer is currently requested (the memory usage
   // of the buffer is known by the GPU process).
@@ -141,9 +141,9 @@
         backbuffer_requested(false) {
   }
 
-  GpuManagedMemoryStats(size_t bytes_required,
-                        size_t bytes_nice_to_have,
-                        size_t bytes_allocated,
+  GpuManagedMemoryStats(uint64 bytes_required,
+                        uint64 bytes_nice_to_have,
+                        uint64 bytes_allocated,
                         bool backbuffer_requested)
       : bytes_required(bytes_required),
         bytes_nice_to_have(bytes_nice_to_have),
Index: src/content/common/gpu/gpu_memory_tracking.h
===================================================================
--- src/content/common/gpu/gpu_memory_tracking.h	(revision 184497)
+++ src/content/common/gpu/gpu_memory_tracking.h	(working copy)
@@ -8,47 +8,28 @@
 #if defined(ENABLE_GPU)
 
 #include "base/basictypes.h"
-#include "content/common/gpu/gpu_memory_manager.h"
+#include "base/process.h"
+#include "content/common/content_export.h"
 #include "gpu/command_buffer/service/memory_tracking.h"
 
 namespace content {
 
+class GpuMemoryManager;
+
 // All decoders in a context group point to a single GpuMemoryTrackingGroup,
 // which tracks GPU resource consumption for the entire context group.
-class GpuMemoryTrackingGroup {
+class CONTENT_EXPORT GpuMemoryTrackingGroup {
  public:
-  GpuMemoryTrackingGroup(base::ProcessId pid,
-                         gpu::gles2::MemoryTracker* memory_tracker,
-                         GpuMemoryManager* memory_manager)
-      : pid_(pid),
-        size_(0),
-        memory_tracker_(memory_tracker),
-        memory_manager_(memory_manager) {
-    memory_manager_->AddTrackingGroup(this);
-  }
-  ~GpuMemoryTrackingGroup() {
-    memory_manager_->RemoveTrackingGroup(this);
-  }
+  ~GpuMemoryTrackingGroup();
   void TrackMemoryAllocatedChange(
-      size_t old_size,
-      size_t new_size,
-      gpu::gles2::MemoryTracker::Pool tracking_pool) {
-    if (old_size < new_size) {
-      size_t delta = new_size - old_size;
-      size_ += delta;
-    }
-    if (new_size < old_size) {
-      size_t delta = old_size - new_size;
-      DCHECK(size_ >= delta);
-      size_ -= delta;
-    }
-    memory_manager_->TrackMemoryAllocatedChange(
-        old_size, new_size, tracking_pool);
-  }
+      uint64 old_size,
+      uint64 new_size,
+      gpu::gles2::MemoryTracker::Pool tracking_pool);
+  bool EnsureGPUMemoryAvailable(uint64 size_needed);
   base::ProcessId GetPid() const {
     return pid_;
   }
-  size_t GetSize() const {
+  uint64 GetSize() const {
     return size_;
   }
   gpu::gles2::MemoryTracker* GetMemoryTracker() const {
@@ -56,8 +37,19 @@
   }
 
  private:
+  friend class GpuMemoryManager;
+
+  GpuMemoryTrackingGroup(base::ProcessId pid,
+                         gpu::gles2::MemoryTracker* memory_tracker,
+                         GpuMemoryManager* memory_manager);
+
   base::ProcessId pid_;
-  size_t size_;
+  uint64 size_;
+
+  // Set and used only during the Manage function, to determine which
+  // non-surface clients should be hibernated.
+  bool hibernated_;
+
   gpu::gles2::MemoryTracker* memory_tracker_;
   GpuMemoryManager* memory_manager_;
 };
Index: src/content/common/gpu/gpu_memory_manager_unittest.cc
===================================================================
--- src/content/common/gpu/gpu_memory_manager_unittest.cc	(revision 184497)
+++ src/content/common/gpu/gpu_memory_manager_unittest.cc	(working copy)
@@ -4,18 +4,33 @@
 
 #include "content/common/gpu/gpu_memory_allocation.h"
 #include "content/common/gpu/gpu_memory_manager.h"
+#include "content/common/gpu/gpu_memory_manager_client.h"
 #include "content/common/gpu/gpu_memory_tracking.h"
 #include "ui/gfx/size_conversions.h"
 
 #include "testing/gtest/include/gtest/gtest.h"
 
+#if defined(COMPILER_GCC)
+namespace BASE_HASH_NAMESPACE {
+template<>
+struct hash<content::GpuMemoryManagerClient*> {
+  uint64 operator()(content::GpuMemoryManagerClient* ptr) const {
+    return hash<uint64>()(reinterpret_cast<uint64>(ptr));
+  }
+};
+}  // namespace BASE_HASH_NAMESPACE
+#endif  // COMPILER
+
 class FakeMemoryTracker : public gpu::gles2::MemoryTracker {
  public:
-  void TrackMemoryAllocatedChange(
-      size_t old_size,
-      size_t new_size,
-      gpu::gles2::MemoryTracker::Pool pool) {
+  virtual void TrackMemoryAllocatedChange(
+      size_t /* old_size */,
+      size_t /* new_size */,
+      gpu::gles2::MemoryTracker::Pool /* pool */) {
   }
+  virtual bool EnsureGPUMemoryAvailable(size_t /* size_needed */) {
+    return true;
+  }
  private:
   ~FakeMemoryTracker() {
   }
@@ -54,36 +69,50 @@
 
 class FakeClient : public GpuMemoryManagerClient {
  public:
-  GpuMemoryManager& memmgr_;
+  GpuMemoryManager* memmgr_;
   GpuMemoryAllocation allocation_;
-  size_t total_gpu_memory_;
+  uint64 total_gpu_memory_;
+  gfx::Size surface_size_;
+  GpuMemoryManagerClient* share_group_;
   scoped_refptr<gpu::gles2::MemoryTracker> memory_tracker_;
-  gpu::gles2::MemoryTracker* overridden_memory_tracker_;
-  gfx::Size surface_size_;
+  scoped_ptr<GpuMemoryTrackingGroup> tracking_group_;
+  scoped_ptr<GpuMemoryManagerClientState> client_state_;
 
   // This will create a client with no surface
-  FakeClient(GpuMemoryManager& memmgr)
+  FakeClient(GpuMemoryManager* memmgr, GpuMemoryManagerClient* share_group)
       : memmgr_(memmgr)
       , total_gpu_memory_(0)
-      , memory_tracker_(new FakeMemoryTracker())
-      , overridden_memory_tracker_(0) {
-    memmgr_.AddClient(this, false, true, base::TimeTicks());
+      , share_group_(share_group)
+      , memory_tracker_(NULL)
+      , tracking_group_(NULL) {
+    if (!share_group_) {
+      memory_tracker_ = new FakeMemoryTracker();
+      tracking_group_.reset(
+          memmgr_->CreateTrackingGroup(0, memory_tracker_));
+    }
+    client_state_.reset(memmgr_->CreateClientState(this, false, true));
   }
 
   // This will create a client with a surface
-  FakeClient(GpuMemoryManager& memmgr,
+  FakeClient(GpuMemoryManager* memmgr,
              int32 surface_id,
-             bool visible,
-             base::TimeTicks last_used_time)
+             bool visible)
       : memmgr_(memmgr)
       , total_gpu_memory_(0)
-      , memory_tracker_(new FakeMemoryTracker())
-      , overridden_memory_tracker_(0) {
-    memmgr_.AddClient(this, surface_id != 0, visible, last_used_time);
+      , share_group_(NULL)
+      , memory_tracker_(NULL)
+      , tracking_group_(NULL) {
+    memory_tracker_ = new FakeMemoryTracker();
+    tracking_group_.reset(
+        memmgr_->CreateTrackingGroup(0, memory_tracker_));
+    client_state_.reset(memmgr_->CreateClientState(
+        this, surface_id != 0, visible));
   }
 
   ~FakeClient() {
-    memmgr_.RemoveClient(this);
+    client_state_.reset();
+    tracking_group_.reset();
+    memory_tracker_ = NULL;
   }
 
   void SetMemoryAllocation(const GpuMemoryAllocation& alloc) {
@@ -91,63 +120,54 @@
     ClientAssignmentCollector::AddClientStat(this, alloc);
   }
 
-  bool GetTotalGpuMemory(size_t* bytes) {
+  bool GetTotalGpuMemory(uint64* bytes) {
     if (total_gpu_memory_) {
       *bytes = total_gpu_memory_;
       return true;
     }
     return false;
   }
-  void SetTotalGpuMemory(size_t bytes) { total_gpu_memory_ = bytes; }
+  void SetTotalGpuMemory(uint64 bytes) { total_gpu_memory_ = bytes; }
 
   gpu::gles2::MemoryTracker* GetMemoryTracker() const OVERRIDE {
-    if (overridden_memory_tracker_)
-      return overridden_memory_tracker_;
+    if (share_group_)
+      return share_group_->GetMemoryTracker();
     return memory_tracker_.get();
   }
 
-  void SetInSameShareGroup(GpuMemoryManagerClient* stub) {
-    overridden_memory_tracker_ = stub->GetMemoryTracker();
-  }
-
   gfx::Size GetSurfaceSize() const {
     return surface_size_;
   }
   void SetSurfaceSize(gfx::Size size) { surface_size_ = size; }
 
   void SetVisible(bool visible) {
-    memmgr_.SetClientVisible(this, visible);
+    client_state_->SetVisible(visible);
   }
 
-  void SetUsageStats(size_t bytes_required,
-                     size_t bytes_nice_to_have,
-                     size_t bytes_allocated) {
-    memmgr_.SetClientManagedMemoryStats(
-        this,
-        GpuManagedMemoryStats(bytes_required,
-                              bytes_nice_to_have,
-                              bytes_allocated,
-                              false));
+  void SetManagedMemoryStats(const GpuManagedMemoryStats& stats) {
+    client_state_->SetManagedMemoryStats(stats);
   }
 
-  size_t BytesWhenNotVisible() const {
+  uint64 BytesWhenVisible() const {
+    return allocation_.renderer_allocation.bytes_limit_when_visible;
+  }
+
+  uint64 BytesWhenNotVisible() const {
     return allocation_.renderer_allocation.bytes_limit_when_not_visible;
   }
 };
 
 class GpuMemoryManagerTest : public testing::Test {
  protected:
-  static const size_t kFrontbufferLimitForTest = 3;
+  static const uint64 kFrontbufferLimitForTest = 3;
 
   GpuMemoryManagerTest()
       : memmgr_(0, kFrontbufferLimitForTest) {
     memmgr_.TestingDisableScheduleManage();
+    memmgr_.TestingSetUseNonuniformMemoryPolicy(false);
   }
 
   virtual void SetUp() {
-    older_ = base::TimeTicks::FromInternalValue(1);
-    newer_ = base::TimeTicks::FromInternalValue(2);
-    newest_ = base::TimeTicks::FromInternalValue(3);
   }
 
   static int32 GenerateUniqueSurfaceId() {
@@ -160,35 +180,35 @@
     return alloc.browser_allocation.suggest_have_frontbuffer &&
            !alloc.renderer_allocation.have_backbuffer_when_not_visible &&
            alloc.renderer_allocation.bytes_limit_when_visible >=
-               GetMinimumTabAllocation();
+               GetMinimumClientAllocation();
   }
   bool IsAllocationBackgroundForSurfaceYes(
       const GpuMemoryAllocation& alloc) {
     return alloc.browser_allocation.suggest_have_frontbuffer &&
            !alloc.renderer_allocation.have_backbuffer_when_not_visible &&
            alloc.renderer_allocation.bytes_limit_when_not_visible <=
-               memmgr_.GetCurrentBackgroundedAvailableGpuMemory();
+               memmgr_.GetCurrentNonvisibleAvailableGpuMemory();
   }
   bool IsAllocationHibernatedForSurfaceYes(
       const GpuMemoryAllocation& alloc) {
     return !alloc.browser_allocation.suggest_have_frontbuffer &&
            !alloc.renderer_allocation.have_backbuffer_when_not_visible &&
            alloc.renderer_allocation.bytes_limit_when_not_visible <=
-               memmgr_.GetCurrentBackgroundedAvailableGpuMemory();
+               memmgr_.GetCurrentNonvisibleAvailableGpuMemory();
   }
   bool IsAllocationForegroundForSurfaceNo(
       const GpuMemoryAllocation& alloc) {
     return !alloc.browser_allocation.suggest_have_frontbuffer &&
            !alloc.renderer_allocation.have_backbuffer_when_not_visible &&
            alloc.renderer_allocation.bytes_limit_when_visible ==
-               GetMinimumTabAllocation();
+               GetMinimumClientAllocation();
   }
   bool IsAllocationBackgroundForSurfaceNo(
       const GpuMemoryAllocation& alloc) {
     return !alloc.browser_allocation.suggest_have_frontbuffer &&
            !alloc.renderer_allocation.have_backbuffer_when_not_visible &&
            alloc.renderer_allocation.bytes_limit_when_visible ==
-               GetMinimumTabAllocation();
+               GetMinimumClientAllocation();
   }
   bool IsAllocationHibernatedForSurfaceNo(
       const GpuMemoryAllocation& alloc) {
@@ -202,95 +222,42 @@
     memmgr_.Manage();
   }
 
-  size_t CalcAvailableFromGpuTotal(size_t bytes) {
+  uint64 CalcAvailableFromGpuTotal(uint64 bytes) {
     return GpuMemoryManager::CalcAvailableFromGpuTotal(bytes);
   }
 
-  size_t CalcAvailableFromViewportArea(int viewport_area) {
-    return GpuMemoryManager::CalcAvailableFromViewportArea(viewport_area);
-  }
-
-  size_t CalcAvailableClamped(size_t bytes) {
+  uint64 CalcAvailableClamped(uint64 bytes) {
     bytes = std::max(bytes, memmgr_.GetDefaultAvailableGpuMemory());
     bytes = std::min(bytes, memmgr_.GetMaximumTotalGpuMemory());
     return bytes;
   }
 
-  size_t GetAvailableGpuMemory() {
+  uint64 GetAvailableGpuMemory() {
     return memmgr_.GetAvailableGpuMemory();
   }
 
-  size_t GetMaximumTabAllocation() {
-    return memmgr_.GetMaximumTabAllocation();
+  uint64 GetMaximumClientAllocation() {
+    return memmgr_.GetMaximumClientAllocation();
   }
 
-  size_t GetMinimumTabAllocation() {
-    return memmgr_.GetMinimumTabAllocation();
+  uint64 GetMinimumClientAllocation() {
+    return memmgr_.GetMinimumClientAllocation();
   }
 
-  base::TimeTicks older_, newer_, newest_;
   GpuMemoryManager memmgr_;
 };
 
-// Create fake stubs with every combination of {visibilty,last_use_time}
-// and make sure they compare correctly.  Only compare stubs with surfaces.
-// Expect {more visible, newer} surfaces to be more important, in that order.
-TEST_F(GpuMemoryManagerTest, ComparatorTests) {
-  FakeClient
-      stub_true1(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-      stub_true2(memmgr_, GenerateUniqueSurfaceId(), true, newer_),
-      stub_true3(memmgr_, GenerateUniqueSurfaceId(), true, newest_),
-      stub_false1(memmgr_, GenerateUniqueSurfaceId(), false, older_),
-      stub_false2(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-      stub_false3(memmgr_, GenerateUniqueSurfaceId(), false, newest_);
+class GpuMemoryManagerTestNonuniform : public GpuMemoryManagerTest {
+ protected:
+  void SetClientStats(
+      FakeClient* client,
+      uint64 required,
+      uint64 nicetohave) {
+    client->SetManagedMemoryStats(
+        GpuManagedMemoryStats(required, nicetohave, 0, false));
+  }
+};
 
-  // Should never be more important than self:
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_true1, &stub_true1));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_true2, &stub_true2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_true3, &stub_true3));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false1, &stub_false1));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false2, &stub_false2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false3, &stub_false3));
-
-  // Visible should always be more important than non visible:
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true1, &stub_false1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true1, &stub_false2));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true1, &stub_false3));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true2, &stub_false1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true2, &stub_false2));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true2, &stub_false3));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true3, &stub_false1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true3, &stub_false2));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true3, &stub_false3));
-
-  // Not visible should never be more important than visible:
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false1, &stub_true1));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false1, &stub_true2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false1, &stub_true3));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false2, &stub_true1));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false2, &stub_true2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false2, &stub_true3));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false3, &stub_true1));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false3, &stub_true2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false3, &stub_true3));
-
-  // Newer should always be more important than older:
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true2, &stub_true1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true3, &stub_true1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_true3, &stub_true2));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_false2, &stub_false1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_false3, &stub_false1));
-  EXPECT_TRUE(memmgr_.TestingCompareClients(&stub_false3, &stub_false2));
-
-  // Older should never be more important than newer:
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_true1, &stub_true2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_true1, &stub_true3));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_true2, &stub_true3));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false1, &stub_false2));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false1, &stub_false3));
-  EXPECT_FALSE(memmgr_.TestingCompareClients(&stub_false2, &stub_false3));
-}
-
 // Test GpuMemoryManager::Manage basic functionality.
 // Expect memory allocation to set suggest_have_frontbuffer/backbuffer
 // according to visibility and last used time for stubs with surface.
@@ -298,17 +265,15 @@
 // without a surface.
 TEST_F(GpuMemoryManagerTest, TestManageBasicFunctionality) {
   // Test stubs with surface.
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), false, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), false);
 
   Manage();
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub2.allocation_));
 
   // Test stubs without surface, with share group of 1 stub.
-  FakeClient stub3(memmgr_), stub4(memmgr_);
-  stub3.SetInSameShareGroup(&stub1);
-  stub4.SetInSameShareGroup(&stub2);
+  FakeClient stub3(&memmgr_, &stub1), stub4(&memmgr_, &stub2);
 
   Manage();
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub1.allocation_));
@@ -317,8 +282,7 @@
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub4.allocation_));
 
   // Test stub without surface, with share group of multiple stubs.
-  FakeClient stub5(memmgr_);
-  stub5.SetInSameShareGroup(&stub2);
+  FakeClient stub5(&memmgr_ , &stub2);
 
   Manage();
   EXPECT_TRUE(IsAllocationForegroundForSurfaceNo(stub4.allocation_));
@@ -330,16 +294,12 @@
 // Expect memory allocation to be shared according to share groups for stubs
 // without a surface.
 TEST_F(GpuMemoryManagerTest, TestManageChangingVisibility) {
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), false, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), false);
 
-  FakeClient stub3(memmgr_), stub4(memmgr_);
-  stub3.SetInSameShareGroup(&stub1);
-  stub4.SetInSameShareGroup(&stub2);
+  FakeClient stub3(&memmgr_, &stub1), stub4(&memmgr_, &stub2);
+  FakeClient stub5(&memmgr_ , &stub2);
 
-  FakeClient stub5(memmgr_);
-  stub5.SetInSameShareGroup(&stub2);
-
   Manage();
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub2.allocation_));
@@ -347,8 +307,8 @@
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub4.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceNo(stub5.allocation_));
 
-  memmgr_.TestingSetClientVisible(&stub1, false);
-  memmgr_.TestingSetClientVisible(&stub2, true);
+  stub1.SetVisible(false);
+  stub2.SetVisible(true);
 
   Manage();
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub1.allocation_));
@@ -362,18 +322,14 @@
 // of visible stubs.
 // Expect all allocations to continue to have frontbuffer.
 TEST_F(GpuMemoryManagerTest, TestManageManyVisibleStubs) {
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub3(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub4(memmgr_, GenerateUniqueSurfaceId(), true, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub3(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub4(&memmgr_, GenerateUniqueSurfaceId(), true);
 
-  FakeClient stub5(memmgr_), stub6(memmgr_);
-  stub5.SetInSameShareGroup(&stub1);
-  stub6.SetInSameShareGroup(&stub2);
+  FakeClient stub5(&memmgr_ , &stub1), stub6(&memmgr_ , &stub2);
+  FakeClient stub7(&memmgr_ , &stub2);
 
-  FakeClient stub7(memmgr_);
-  stub7.SetInSameShareGroup(&stub2);
-
   Manage();
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub2.allocation_));
@@ -388,18 +344,18 @@
 // of not visible stubs.
 // Expect the stubs surpassing the threshold to not have a backbuffer.
 TEST_F(GpuMemoryManagerTest, TestManageManyNotVisibleStubs) {
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stub3(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stub4(memmgr_, GenerateUniqueSurfaceId(), false, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub3(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub4(&memmgr_, GenerateUniqueSurfaceId(), true);
+  stub4.SetVisible(false);
+  stub3.SetVisible(false);
+  stub2.SetVisible(false);
+  stub1.SetVisible(false);
 
-  FakeClient stub5(memmgr_), stub6(memmgr_);
-  stub5.SetInSameShareGroup(&stub1);
-  stub6.SetInSameShareGroup(&stub4);
+  FakeClient stub5(&memmgr_ , &stub1), stub6(&memmgr_ , &stub4);
+  FakeClient stub7(&memmgr_ , &stub1);
 
-  FakeClient stub7(memmgr_);
-  stub7.SetInSameShareGroup(&stub1);
-
   Manage();
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub2.allocation_));
@@ -414,17 +370,19 @@
 // time of stubs when doing so causes change in which stubs surpass threshold.
 // Expect frontbuffer to be dropped for the older stub.
 TEST_F(GpuMemoryManagerTest, TestManageChangingLastUsedTime) {
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stub3(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stub4(memmgr_, GenerateUniqueSurfaceId(), false, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub3(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub4(&memmgr_, GenerateUniqueSurfaceId(), true);
 
-  FakeClient stub5(memmgr_), stub6(memmgr_);
-  stub5.SetInSameShareGroup(&stub3);
-  stub6.SetInSameShareGroup(&stub4);
+  FakeClient stub5(&memmgr_ , &stub3), stub6(&memmgr_ , &stub4);
+  FakeClient stub7(&memmgr_ , &stub3);
 
-  FakeClient stub7(memmgr_);
-  stub7.SetInSameShareGroup(&stub3);
+  // Make stub4 be the least-recently-used client
+  stub4.SetVisible(false);
+  stub3.SetVisible(false);
+  stub2.SetVisible(false);
+  stub1.SetVisible(false);
 
   Manage();
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub1.allocation_));
@@ -435,8 +393,11 @@
   EXPECT_TRUE(IsAllocationHibernatedForSurfaceNo(stub6.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub7.allocation_));
 
-  memmgr_.TestingSetClientLastUsedTime(&stub3, older_);
-  memmgr_.TestingSetClientLastUsedTime(&stub4, newer_);
+  // Make stub3 become the least-recently-used client.
+  stub2.SetVisible(true);
+  stub2.SetVisible(false);
+  stub4.SetVisible(true);
+  stub4.SetVisible(false);
 
   Manage();
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub1.allocation_));
@@ -453,48 +414,55 @@
 // Expect memory allocation of the stubs without surface to share memory
 // allocation with the most visible stub in share group.
 TEST_F(GpuMemoryManagerTest, TestManageChangingImportanceShareGroup) {
-  FakeClient stubIgnoreA(memmgr_, GenerateUniqueSurfaceId(), true, newer_),
-             stubIgnoreB(memmgr_, GenerateUniqueSurfaceId(), false, newer_),
-             stubIgnoreC(memmgr_, GenerateUniqueSurfaceId(), false, newer_);
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, newest_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), true, newest_);
+  FakeClient stub_ignore_a(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub_ignore_b(&memmgr_, GenerateUniqueSurfaceId(), false),
+             stub_ignore_c(&memmgr_, GenerateUniqueSurfaceId(), false);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), false),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), false);
 
-  FakeClient stub3(memmgr_), stub4(memmgr_);
-  stub3.SetInSameShareGroup(&stub2);
-  stub4.SetInSameShareGroup(&stub2);
+  FakeClient stub3(&memmgr_, &stub2), stub4(&memmgr_, &stub2);
 
+  // stub1 and stub2 keep their non-hibernated state because they're
+  // either visible or the 2 most recently used clients (through the
+  // first three checks).
+  stub1.SetVisible(true);
+  stub2.SetVisible(true);
   Manage();
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub2.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceNo(stub3.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceNo(stub4.allocation_));
 
-  memmgr_.TestingSetClientVisible(&stub1, false);
-
+  stub1.SetVisible(false);
   Manage();
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stub2.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub3.allocation_));
   EXPECT_TRUE(IsAllocationForegroundForSurfaceNo(stub4.allocation_));
 
-  memmgr_.TestingSetClientVisible(&stub2, false);
-
+  stub2.SetVisible(false);
   Manage();
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub2.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub3.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub4.allocation_));
 
-  memmgr_.TestingSetClientLastUsedTime(&stub1, older_);
-
+  // stub_ignore_b will cause stub1 to become hibernated (because
+  // stub_ignore_a, stub_ignore_b, and stub2 are all non-hibernated and more
+  // important).
+  stub_ignore_b.SetVisible(true);
+  stub_ignore_b.SetVisible(false);
   Manage();
   EXPECT_TRUE(IsAllocationHibernatedForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceYes(stub2.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub3.allocation_));
   EXPECT_TRUE(IsAllocationBackgroundForSurfaceNo(stub4.allocation_));
 
-  memmgr_.TestingSetClientLastUsedTime(&stub2, older_);
-
+  // stub_ignore_c will cause stub2 to become hibernated (because
+  // stub_ignore_a, stub_ignore_b, and stub_ignore_c are all non-hibernated
+  // and more important).
+  stub_ignore_c.SetVisible(true);
+  stub_ignore_c.SetVisible(false);
   Manage();
   EXPECT_TRUE(IsAllocationHibernatedForSurfaceYes(stub1.allocation_));
   EXPECT_TRUE(IsAllocationHibernatedForSurfaceYes(stub2.allocation_));
@@ -505,16 +473,16 @@
 // Test GpuMemoryAllocation memory allocation bonuses:
 // When the number of visible tabs is small, each tab should get a
 // gpu_resource_size_in_bytes allocation value that is greater than
-// GetMinimumTabAllocation(), and when the number of tabs is large, each should
-// get exactly GetMinimumTabAllocation() and not less.
+// GetMinimumClientAllocation(), and when the number of tabs is large,
+// each should get exactly GetMinimumClientAllocation() and not less.
 TEST_F(GpuMemoryManagerTest, TestForegroundStubsGetBonusAllocation) {
-  size_t max_stubs_before_no_bonus =
-      GetAvailableGpuMemory() / (GetMinimumTabAllocation() + 1);
+  size_t max_stubs_before_no_bonus = static_cast<size_t>(
+      GetAvailableGpuMemory() / (GetMinimumClientAllocation() + 1));
 
   std::vector<FakeClient*> stubs;
   for (size_t i = 0; i < max_stubs_before_no_bonus; ++i) {
     stubs.push_back(
-        new FakeClient(memmgr_, GenerateUniqueSurfaceId(), true, older_));
+        new FakeClient(&memmgr_, GenerateUniqueSurfaceId(), true));
   }
 
   Manage();
@@ -522,17 +490,17 @@
     EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stubs[i]->allocation_));
     EXPECT_GT(
         stubs[i]->allocation_.renderer_allocation.bytes_limit_when_visible,
-        static_cast<size_t>(GetMinimumTabAllocation()));
+        GetMinimumClientAllocation());
   }
 
-  FakeClient extra_stub(memmgr_, GenerateUniqueSurfaceId(), true, older_);
+  FakeClient extra_stub(&memmgr_, GenerateUniqueSurfaceId(), true);
 
   Manage();
   for (size_t i = 0; i < stubs.size(); ++i) {
     EXPECT_TRUE(IsAllocationForegroundForSurfaceYes(stubs[i]->allocation_));
     EXPECT_EQ(
         stubs[i]->allocation_.renderer_allocation.bytes_limit_when_visible,
-        GetMinimumTabAllocation());
+        GetMinimumClientAllocation());
   }
 
   for (size_t i = 0; i < max_stubs_before_no_bonus; ++i) {
@@ -542,29 +510,18 @@
 
 // Test GpuMemoryManager::UpdateAvailableGpuMemory functionality
 TEST_F(GpuMemoryManagerTest, TestUpdateAvailableGpuMemory) {
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), false, older_),
-             stub3(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub4(memmgr_, GenerateUniqueSurfaceId(), false, older_);
-
-#if defined(OS_ANDROID)
-  // We use the largest visible surface size to calculate the limit
-  stub1.SetSurfaceSize(gfx::Size(1024, 512)); // Surface size
-  stub2.SetSurfaceSize(gfx::Size(2048, 512)); // Larger but not visible.
-  stub3.SetSurfaceSize(gfx::Size(512, 512));  // Visible but smaller.
-  stub4.SetSurfaceSize(gfx::Size(512, 512));  // Not visible and smaller.
-  Manage();
-  size_t bytes_expected = CalcAvailableFromViewportArea(1024*512);
-#else
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), false),
+             stub3(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub4(&memmgr_, GenerateUniqueSurfaceId(), false);
   // We take the lowest GPU's total memory as the limit
-  size_t expected = 400 * 1024 * 1024;
+  uint64 expected = 400 * 1024 * 1024;
   stub1.SetTotalGpuMemory(expected); // GPU Memory
   stub2.SetTotalGpuMemory(expected - 1024 * 1024); // Smaller but not visible.
   stub3.SetTotalGpuMemory(expected + 1024 * 1024); // Visible but larger.
   stub4.SetTotalGpuMemory(expected + 1024 * 1024); // Not visible and larger.
   Manage();
-  size_t bytes_expected = CalcAvailableFromGpuTotal(expected);
-#endif
+  uint64 bytes_expected = CalcAvailableFromGpuTotal(expected);
   EXPECT_EQ(GetAvailableGpuMemory(), CalcAvailableClamped(bytes_expected));
 }
 
@@ -590,9 +547,9 @@
   suggested_buffer_allocation_values.push_back(
       GpuMemoryAllocation::kHasNoFrontbuffer);
 
-  for(size_t i = 0; i != gpu_resource_size_in_bytes_values.size(); ++i) {
-    for(size_t j = 0; j != suggested_buffer_allocation_values.size(); ++j) {
-      int sz = gpu_resource_size_in_bytes_values[i];
+  for (size_t i = 0; i != gpu_resource_size_in_bytes_values.size(); ++i) {
+    for (size_t j = 0; j != suggested_buffer_allocation_values.size(); ++j) {
+      uint64 sz = gpu_resource_size_in_bytes_values[i];
       GpuMemoryAllocation::BufferAllocation buffer_allocation =
           suggested_buffer_allocation_values[j];
       GpuMemoryAllocation allocation(sz, buffer_allocation);
@@ -602,7 +559,7 @@
       EXPECT_FALSE(allocation.Equals(
           GpuMemoryAllocation(sz+1, buffer_allocation)));
 
-      for(size_t k = 0; k != suggested_buffer_allocation_values.size(); ++k) {
+      for (size_t k = 0; k != suggested_buffer_allocation_values.size(); ++k) {
         GpuMemoryAllocation::BufferAllocation buffer_allocation_other =
             suggested_buffer_allocation_values[k];
         if (buffer_allocation == buffer_allocation_other) continue;
@@ -614,7 +571,7 @@
 }
 
 // Test GpuMemoryManager Stub Memory Stats functionality:
-// Creats various surface/non-surface stubs and switches stub visibility and
+// Creates various surface/non-surface stubs and switches stub visibility and
 // tests to see that stats data structure values are correct.
 TEST_F(GpuMemoryManagerTest, StubMemoryStatsForLastManageTests) {
   ClientAssignmentCollector::ClientMemoryStatMap stats;
@@ -623,268 +580,472 @@
   stats = ClientAssignmentCollector::GetClientStatsForLastManage();
   EXPECT_EQ(stats.size(), 0ul);
 
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
   Manage();
   stats = ClientAssignmentCollector::GetClientStatsForLastManage();
-  size_t stub1allocation1 =
+  uint64 stub1allocation1 =
       stats[&stub1].allocation.renderer_allocation.bytes_limit_when_visible;
 
   EXPECT_EQ(stats.size(), 1ul);
   EXPECT_GT(stub1allocation1, 0ul);
 
-  FakeClient stub2(memmgr_);
-  stub2.SetInSameShareGroup(&stub1);
+  FakeClient stub2(&memmgr_, &stub1);
   Manage();
   stats = ClientAssignmentCollector::GetClientStatsForLastManage();
   EXPECT_EQ(stats.count(&stub1), 1ul);
-  size_t stub1allocation2 =
+  uint64 stub1allocation2 =
       stats[&stub1].allocation.renderer_allocation.bytes_limit_when_visible;
   EXPECT_EQ(stats.count(&stub2), 1ul);
-  size_t stub2allocation2 =
+  uint64 stub2allocation2 =
       stats[&stub2].allocation.renderer_allocation.bytes_limit_when_visible;
 
   EXPECT_EQ(stats.size(), 2ul);
   EXPECT_GT(stub1allocation2, 0ul);
   EXPECT_GT(stub2allocation2, 0ul);
-  if (stub1allocation2 != GetMaximumTabAllocation())
+  if (stub1allocation2 != GetMaximumClientAllocation())
     EXPECT_LT(stub1allocation2, stub1allocation1);
 
-  FakeClient stub3(memmgr_, GenerateUniqueSurfaceId(), true, older_);
+  FakeClient stub3(&memmgr_, GenerateUniqueSurfaceId(), true);
   Manage();
   stats = ClientAssignmentCollector::GetClientStatsForLastManage();
-  size_t stub1allocation3 =
+  uint64 stub1allocation3 =
       stats[&stub1].allocation.renderer_allocation.bytes_limit_when_visible;
-  size_t stub2allocation3 =
+  uint64 stub2allocation3 =
       stats[&stub2].allocation.renderer_allocation.bytes_limit_when_visible;
-  size_t stub3allocation3 =
+  uint64 stub3allocation3 =
       stats[&stub3].allocation.renderer_allocation.bytes_limit_when_visible;
 
   EXPECT_EQ(stats.size(), 3ul);
   EXPECT_GT(stub1allocation3, 0ul);
   EXPECT_GT(stub2allocation3, 0ul);
   EXPECT_GT(stub3allocation3, 0ul);
-  if (stub1allocation3 != GetMaximumTabAllocation())
+  if (stub1allocation3 != GetMaximumClientAllocation())
     EXPECT_LT(stub1allocation3, stub1allocation2);
 
-  memmgr_.TestingSetClientVisible(&stub1, false);
+  stub1.SetVisible(false);
 
   Manage();
   stats = ClientAssignmentCollector::GetClientStatsForLastManage();
-  size_t stub1allocation4 =
+  uint64 stub1allocation4 =
       stats[&stub1].allocation.renderer_allocation.bytes_limit_when_visible;
-  size_t stub2allocation4 =
+  uint64 stub2allocation4 =
       stats[&stub2].allocation.renderer_allocation.bytes_limit_when_visible;
-  size_t stub3allocation4 =
+  uint64 stub3allocation4 =
       stats[&stub3].allocation.renderer_allocation.bytes_limit_when_visible;
 
   EXPECT_EQ(stats.size(), 3ul);
   EXPECT_GT(stub1allocation4, 0ul);
   EXPECT_GE(stub2allocation4, 0ul);
   EXPECT_GT(stub3allocation4, 0ul);
-  if (stub3allocation3 != GetMaximumTabAllocation())
+  if (stub3allocation3 != GetMaximumClientAllocation())
     EXPECT_GT(stub3allocation4, stub3allocation3);
 }
 
 // Test GpuMemoryManager's managed memory tracking
 TEST_F(GpuMemoryManagerTest, TestManagedUsageTracking) {
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-             stub2(memmgr_, GenerateUniqueSurfaceId(), false, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true),
+             stub2(&memmgr_, GenerateUniqueSurfaceId(), false);
   EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
   // Set memory allocations and verify the results are reflected.
-  memmgr_.SetClientManagedMemoryStats(
-     &stub1, GpuManagedMemoryStats(0, 0, 5, false));
-  memmgr_.SetClientManagedMemoryStats(
-     &stub2, GpuManagedMemoryStats(0, 0, 7, false));
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 5, false));
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 7, false));
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
-  // Redundantly add a client and make sure nothing changes
-  memmgr_.AddClient(&stub1, true, true, older_);
-  memmgr_.AddClient(&stub2, true, true, older_);
-  EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
-
   // Remove a visible client
-  memmgr_.RemoveClient(&stub1);
+  stub1.client_state_.reset();
   EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
-  memmgr_.SetClientManagedMemoryStats(
-     &stub1, GpuManagedMemoryStats(0, 0, 99, false));
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
   EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
-  memmgr_.AddClient(&stub1, true, true, older_);
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
+  stub1.client_state_.reset(memmgr_.CreateClientState(&stub1, true, true));
   EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
-  memmgr_.SetClientManagedMemoryStats(
-     &stub1, GpuManagedMemoryStats(0, 0, 5, false));
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 5, false));
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
-  // Remove a backgrounded client
-  memmgr_.RemoveClient(&stub2);
+  // Remove a nonvisible client
+  stub2.client_state_.reset();
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_backgrounded_);
-  memmgr_.SetClientManagedMemoryStats(
-     &stub2, GpuManagedMemoryStats(0, 0, 99, false));
+  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_nonvisible_);
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_backgrounded_);
-  memmgr_.AddClient(&stub2, true, false, older_);
+  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_nonvisible_);
+  stub2.client_state_.reset(memmgr_.CreateClientState(&stub2, true, false));
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_backgrounded_);
-  memmgr_.SetClientManagedMemoryStats(
-     &stub2, GpuManagedMemoryStats(0, 0, 7, false));
+  EXPECT_EQ(0ul, memmgr_.bytes_allocated_managed_nonvisible_);
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 7, false));
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
   // Create and then destroy some stubs, and verify their allocations go away.
   {
-    FakeClient stub3(memmgr_, GenerateUniqueSurfaceId(), true, older_),
-               stub4(memmgr_, GenerateUniqueSurfaceId(), false, older_);
-    memmgr_.SetClientManagedMemoryStats(
-       &stub3, GpuManagedMemoryStats(0, 0, 1, false));
-    memmgr_.SetClientManagedMemoryStats(
-       &stub4, GpuManagedMemoryStats(0, 0, 2, false));
+    FakeClient stub3(&memmgr_, GenerateUniqueSurfaceId(), true),
+               stub4(&memmgr_, GenerateUniqueSurfaceId(), false);
+    stub3.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 1, false));
+    stub4.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 2, false));
     EXPECT_EQ(6ul, memmgr_.bytes_allocated_managed_visible_);
-    EXPECT_EQ(9ul, memmgr_.bytes_allocated_managed_backgrounded_);
+    EXPECT_EQ(9ul, memmgr_.bytes_allocated_managed_nonvisible_);
   }
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
   // Do no-op changes to stubs' visibility and make sure nothing chnages.
-  memmgr_.SetClientVisible(&stub1, true);
-  memmgr_.SetClientVisible(&stub2, false);
+  stub1.SetVisible(true);
+  stub2.SetVisible(false);
   EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
   // Change visbility state.
-  memmgr_.SetClientVisible(&stub1, false);
-  memmgr_.SetClientVisible(&stub2, true);
+  stub1.SetVisible(false);
+  stub2.SetVisible(true);
   EXPECT_EQ(7ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(5ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
   // Increase allocation amounts.
-  memmgr_.SetClientManagedMemoryStats(
-     &stub1, GpuManagedMemoryStats(0, 0, 6, false));
-  memmgr_.SetClientManagedMemoryStats(
-     &stub2, GpuManagedMemoryStats(0, 0, 8, false));
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 6, false));
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 8, false));
   EXPECT_EQ(8ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(6ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(6ul, memmgr_.bytes_allocated_managed_nonvisible_);
 
   // Decrease allocation amounts.
-  memmgr_.SetClientManagedMemoryStats(
-     &stub1, GpuManagedMemoryStats(0, 0, 4, false));
-  memmgr_.SetClientManagedMemoryStats(
-     &stub2, GpuManagedMemoryStats(0, 0, 6, false));
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 4, false));
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(0, 0, 6, false));
   EXPECT_EQ(6ul, memmgr_.bytes_allocated_managed_visible_);
-  EXPECT_EQ(4ul, memmgr_.bytes_allocated_managed_backgrounded_);
+  EXPECT_EQ(4ul, memmgr_.bytes_allocated_managed_nonvisible_);
 }
 
 // Test GpuMemoryManager's background cutoff threshoulds
 TEST_F(GpuMemoryManagerTest, TestBackgroundCutoff) {
   memmgr_.TestingSetAvailableGpuMemory(64);
-  memmgr_.TestingSetBackgroundedAvailableGpuMemory(16);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
 
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_);
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
 
-  // stub1's requirements are not <16, so it should just dump
+  // stub1's requirements are not <=16, so it should just dump
   // everything when it goes invisible.
-  stub1.SetUsageStats(16, 24, 18);
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(17, 24, 18, false));
   Manage();
   EXPECT_EQ(0ul, stub1.BytesWhenNotVisible());
 
   // stub1 now fits, so it should have a full budget.
-  stub1.SetUsageStats(15, 24, 18);
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(16, 24, 18, false));
   Manage();
-  EXPECT_EQ(memmgr_.bytes_backgrounded_available_gpu_memory_,
-            memmgr_.GetCurrentBackgroundedAvailableGpuMemory());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
+  EXPECT_EQ(memmgr_.bytes_nonvisible_available_gpu_memory_,
+            memmgr_.GetCurrentNonvisibleAvailableGpuMemory());
+  EXPECT_EQ(memmgr_.GetCurrentNonvisibleAvailableGpuMemory(),
             stub1.BytesWhenNotVisible());
 
-  // background stub1
-  stub1.SetUsageStats(15, 24, 15);
+  // Background stub1.
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(16, 24, 16, false));
   stub1.SetVisible(false);
 
   // Add stub2 that uses almost enough memory to evict
-  // stub1, but not quite
-  FakeClient stub2(memmgr_, GenerateUniqueSurfaceId(), true, older_);
-  stub2.SetUsageStats(15, 50, 48);
+  // stub1, but not quite.
+  FakeClient stub2(&memmgr_, GenerateUniqueSurfaceId(), true);
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(16, 50, 48, false));
   Manage();
-  EXPECT_EQ(memmgr_.bytes_backgrounded_available_gpu_memory_,
-            memmgr_.GetCurrentBackgroundedAvailableGpuMemory());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
+  EXPECT_EQ(memmgr_.bytes_nonvisible_available_gpu_memory_,
+            memmgr_.GetCurrentNonvisibleAvailableGpuMemory());
+  EXPECT_EQ(memmgr_.GetCurrentNonvisibleAvailableGpuMemory(),
             stub1.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
+  EXPECT_EQ(memmgr_.GetCurrentNonvisibleAvailableGpuMemory(),
             stub2.BytesWhenNotVisible());
 
-  // Increase stub2 to break evict stub1
-  stub2.SetUsageStats(15, 50, 49);
+  // Increase stub2 to force stub1 to be evicted.
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(16, 50, 49, false));
   Manage();
   EXPECT_EQ(0ul,
             stub1.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
+  EXPECT_EQ(memmgr_.GetCurrentNonvisibleAvailableGpuMemory(),
             stub2.BytesWhenNotVisible());
 }
 
 // Test GpuMemoryManager's background MRU behavior
 TEST_F(GpuMemoryManagerTest, TestBackgroundMru) {
   memmgr_.TestingSetAvailableGpuMemory(64);
-  memmgr_.TestingSetBackgroundedAvailableGpuMemory(16);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
 
-  FakeClient stub1(memmgr_, GenerateUniqueSurfaceId(), true, older_);
-  FakeClient stub2(memmgr_, GenerateUniqueSurfaceId(), true, older_);
-  FakeClient stub3(memmgr_, GenerateUniqueSurfaceId(), true, older_);
+  uint64 bytes_when_not_visible_expected =
+      memmgr_.GetCurrentNonvisibleAvailableGpuMemory();
+#if defined (OS_ANDROID)
+  bytes_when_not_visible_expected = 0;
+#endif
 
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
+  FakeClient stub2(&memmgr_, GenerateUniqueSurfaceId(), true);
+  FakeClient stub3(&memmgr_, GenerateUniqueSurfaceId(), true);
+
   // When all are visible, they should all be allowed to have memory
-  // should they become backgrounded.
-  stub1.SetUsageStats(7, 24, 7);
-  stub2.SetUsageStats(7, 24, 7);
-  stub3.SetUsageStats(7, 24, 7);
+  // should they become nonvisible.
+  stub1.SetManagedMemoryStats(GpuManagedMemoryStats(7, 24, 7, false));
+  stub2.SetManagedMemoryStats(GpuManagedMemoryStats(7, 24, 7, false));
+  stub3.SetManagedMemoryStats(GpuManagedMemoryStats(7, 24, 7, false));
   Manage();
-  EXPECT_EQ(memmgr_.bytes_backgrounded_available_gpu_memory_,
-            memmgr_.GetCurrentBackgroundedAvailableGpuMemory());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub1.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub2.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub3.BytesWhenNotVisible());
+  EXPECT_EQ(memmgr_.bytes_nonvisible_available_gpu_memory_,
+            memmgr_.GetCurrentNonvisibleAvailableGpuMemory());
+  EXPECT_EQ(stub1.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
+  EXPECT_EQ(stub2.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
+  EXPECT_EQ(stub3.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
 
-
   // Background stubs 1 and 2, and they should fit
   stub2.SetVisible(false);
-  // XXX - the MRU ordering is determined by taking the timestamp
-  //       at which visibility changed. This does not have high
-  //       enough resolution on all platforms to distinguish
-  //       between the three SetVisible calls, so we have to
-  //       explicitly set the timestamp.
-  memmgr_.TestingSetClientLastUsedTime(&stub2, older_);
   stub1.SetVisible(false);
-  memmgr_.TestingSetClientLastUsedTime(&stub1, newer_);
   Manage();
-  EXPECT_EQ(memmgr_.bytes_backgrounded_available_gpu_memory_,
-            memmgr_.GetCurrentBackgroundedAvailableGpuMemory());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub1.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub2.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub3.BytesWhenNotVisible());
+  EXPECT_EQ(memmgr_.bytes_nonvisible_available_gpu_memory_,
+            bytes_when_not_visible_expected);
+  EXPECT_EQ(stub1.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
+  EXPECT_EQ(stub2.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
+  EXPECT_EQ(stub3.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
 
   // Now background stub 3, and it should cause stub 2 to be
   // evicted because it was set non-visible first
   stub3.SetVisible(false);
-  memmgr_.TestingSetClientLastUsedTime(&stub3, newer_);
   Manage();
-  EXPECT_EQ(memmgr_.bytes_backgrounded_available_gpu_memory_,
-            memmgr_.GetCurrentBackgroundedAvailableGpuMemory());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub1.BytesWhenNotVisible());
-  EXPECT_EQ(0ul,
-            stub2.BytesWhenNotVisible());
-  EXPECT_EQ(memmgr_.GetCurrentBackgroundedAvailableGpuMemory(),
-            stub3.BytesWhenNotVisible());
+  EXPECT_EQ(memmgr_.bytes_nonvisible_available_gpu_memory_,
+            memmgr_.GetCurrentNonvisibleAvailableGpuMemory());
+  EXPECT_EQ(stub1.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
+  EXPECT_EQ(stub2.BytesWhenNotVisible(),
+            0ul);
+  EXPECT_EQ(stub3.BytesWhenNotVisible(),
+            bytes_when_not_visible_expected);
 }
 
+// Test GpuMemoryManager's tracking of unmanaged (e.g, WebGL) memory.
+TEST_F(GpuMemoryManagerTest, TestUnmanagedTracking) {
+  memmgr_.TestingSetAvailableGpuMemory(64);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
+  memmgr_.TestingSetUnmanagedLimitStep(16);
+  memmgr_.TestingSetMinimumClientAllocation(8);
+
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
+
+  // Expect that the one stub get the maximum tab allocation.
+  Manage();
+  EXPECT_EQ(memmgr_.GetMaximumClientAllocation(),
+            stub1.BytesWhenVisible());
+
+  // Now allocate some unmanaged memory and make sure the amount
+  // goes down.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      0,
+      48,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+  Manage();
+  EXPECT_GT(memmgr_.GetMaximumClientAllocation(),
+            stub1.BytesWhenVisible());
+
+  // Now allocate the entire FB worth of unmanaged memory, and
+  // make sure that we stay stuck at the minimum tab allocation.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      48,
+      64,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+  Manage();
+  EXPECT_EQ(memmgr_.GetMinimumClientAllocation(),
+            stub1.BytesWhenVisible());
+
+  // Far-oversubscribe the entire FB, and make sure we stay at
+  // the minimum allocation, and don't blow up.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      64,
+      999,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+  Manage();
+  EXPECT_EQ(memmgr_.GetMinimumClientAllocation(),
+            stub1.BytesWhenVisible());
+
+  // Delete all tracked memory so we don't hit leak checks.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      999,
+      0,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+}
+
+// Test nonvisible MRU behavior (the most recently used nonvisible clients
+// keep their contents).
+TEST_F(GpuMemoryManagerTestNonuniform, BackgroundMru) {
+  // Set memory manager constants for this test
+  memmgr_.TestingSetUseNonuniformMemoryPolicy(true);
+  memmgr_.TestingSetAvailableGpuMemory(64);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
+  memmgr_.TestingSetMinimumClientAllocation(8);
+
+  uint64 bytes_when_not_visible_expected = 6u;
+#if defined (OS_ANDROID)
+  bytes_when_not_visible_expected = 0;
+#endif
+
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
+  FakeClient stub2(&memmgr_, GenerateUniqueSurfaceId(), true);
+  FakeClient stub3(&memmgr_, GenerateUniqueSurfaceId(), true);
+
+  // When all are visible, they should all be allowed to have memory
+  // should they become nonvisible.
+  SetClientStats(&stub1, 6, 23);
+  SetClientStats(&stub2, 6, 23);
+  SetClientStats(&stub3, 6, 23);
+  Manage();
+  EXPECT_GE(stub1.BytesWhenVisible(), 20u);
+  EXPECT_GE(stub2.BytesWhenVisible(), 20u);
+  EXPECT_GE(stub3.BytesWhenVisible(), 20u);
+  EXPECT_LT(stub1.BytesWhenVisible(), 22u);
+  EXPECT_LT(stub2.BytesWhenVisible(), 22u);
+  EXPECT_LT(stub3.BytesWhenVisible(), 22u);
+  EXPECT_GE(stub1.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  EXPECT_GE(stub2.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  EXPECT_GE(stub3.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+
+  // Background stubs 1 and 2, and they should fit. All stubs should
+  // have their full nicetohave budget should they become visible.
+  stub2.SetVisible(false);
+  stub1.SetVisible(false);
+  Manage();
+  EXPECT_GE(stub1.BytesWhenVisible(), 23u);
+  EXPECT_GE(stub2.BytesWhenVisible(), 23u);
+  EXPECT_GE(stub3.BytesWhenVisible(), 23u);
+  EXPECT_LT(stub1.BytesWhenVisible(), 32u);
+  EXPECT_LT(stub2.BytesWhenVisible(), 32u);
+  EXPECT_GE(stub1.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  EXPECT_GE(stub2.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  EXPECT_GE(stub3.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+
+  // Now background stub 3, and it should cause stub 2 to be
+  // evicted because it was set non-visible first
+  stub3.SetVisible(false);
+  Manage();
+  EXPECT_GE(stub1.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  EXPECT_EQ(stub2.BytesWhenNotVisible(), 0u);
+  EXPECT_GE(stub3.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+}
+
+// Test that once a backgrounded client has dropped its resources, it
+// doesn't get them back until it becomes visible again.
+TEST_F(GpuMemoryManagerTestNonuniform, BackgroundDiscardPersistent) {
+  // Set memory manager constants for this test
+  memmgr_.TestingSetUseNonuniformMemoryPolicy(true);
+  memmgr_.TestingSetAvailableGpuMemory(64);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
+  memmgr_.TestingSetMinimumClientAllocation(8);
+
+  uint64 bytes_when_not_visible_expected = 10ul;
+#if defined (OS_ANDROID)
+  bytes_when_not_visible_expected = 0;
+#endif
+
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
+  FakeClient stub2(&memmgr_, GenerateUniqueSurfaceId(), true);
+
+  // Both clients should be able to keep their contents should one of
+  // them become nonvisible.
+  SetClientStats(&stub1, 10, 20);
+  SetClientStats(&stub2, 10, 20);
+  Manage();
+  EXPECT_GE(stub1.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  EXPECT_GE(stub2.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+
+  // If they both go nonvisible, then only the most recently used client
+  // should keep its contents.
+  stub1.SetVisible(false);
+  stub2.SetVisible(false);
+  Manage();
+  EXPECT_EQ(stub1.BytesWhenNotVisible(), 0u);
+  EXPECT_GE(stub2.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+
+  // When becoming visible, stub 2 should get its contents back, and
+  // retain them next time it is made nonvisible.
+  stub2.SetVisible(true);
+  Manage();
+  EXPECT_GE(stub2.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+  stub2.SetVisible(false);
+  Manage();
+  EXPECT_GE(stub2.BytesWhenNotVisible(), bytes_when_not_visible_expected);
+}
+
+// Test tracking of unmanaged (e.g, WebGL) memory.
+TEST_F(GpuMemoryManagerTestNonuniform, UnmanagedTracking) {
+  // Set memory manager constants for this test
+  memmgr_.TestingSetUseNonuniformMemoryPolicy(true);
+  memmgr_.TestingSetAvailableGpuMemory(64);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
+  memmgr_.TestingSetMinimumClientAllocation(8);
+  memmgr_.TestingSetUnmanagedLimitStep(16);
+
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
+
+  // Expect that the one stub get its nicetohave level.
+  SetClientStats(&stub1, 16, 32);
+  Manage();
+  EXPECT_GE(stub1.BytesWhenVisible(), 32u);
+
+  // Now allocate some unmanaged memory and make sure the amount
+  // goes down.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      0,
+      48,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+  Manage();
+  EXPECT_LT(stub1.BytesWhenVisible(), 24u);
+
+  // Now allocate the entire FB worth of unmanaged memory, and
+  // make sure that we stay stuck at the minimum tab allocation.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      48,
+      64,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+  Manage();
+  EXPECT_EQ(stub1.BytesWhenVisible(), 8u);
+
+  // Far-oversubscribe the entire FB, and make sure we stay at
+  // the minimum allocation, and don't blow up.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      64,
+      999,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+  Manage();
+  EXPECT_EQ(stub1.BytesWhenVisible(), 8u);
+
+  // Delete all tracked memory so we don't hit leak checks.
+  memmgr_.TrackMemoryAllocatedChange(
+      stub1.tracking_group_.get(),
+      999,
+      0,
+      gpu::gles2::MemoryTracker::kUnmanaged);
+}
+
+// Test the default allocation levels are used.
+TEST_F(GpuMemoryManagerTestNonuniform, DefaultAllocation) {
+  // Set memory manager constants for this test
+  memmgr_.TestingSetUseNonuniformMemoryPolicy(true);
+  memmgr_.TestingSetAvailableGpuMemory(64);
+  memmgr_.TestingSetNonvisibleAvailableGpuMemory(16);
+  memmgr_.TestingSetMinimumClientAllocation(8);
+  memmgr_.TestingSetDefaultClientAllocation(16);
+
+  FakeClient stub1(&memmgr_, GenerateUniqueSurfaceId(), true);
+
+  // Expect that a client which has not sent stats receive at
+  // least the default allocation.
+  Manage();
+  EXPECT_GE(stub1.BytesWhenVisible(),
+            memmgr_.GetDefaultClientAllocation());
+  EXPECT_EQ(stub1.BytesWhenNotVisible(), 0u);
+}
+
 }  // namespace content
Index: src/content/common/gpu/gpu_memory_manager.cc
===================================================================
--- src/content/common/gpu/gpu_memory_manager.cc	(revision 184497)
+++ src/content/common/gpu/gpu_memory_manager.cc	(working copy)
@@ -14,9 +14,9 @@
 #include "base/message_loop.h"
 #include "base/process_util.h"
 #include "base/string_number_conversions.h"
-#include "base/sys_info.h"
 #include "content/common/gpu/gpu_channel_manager.h"
 #include "content/common/gpu/gpu_memory_allocation.h"
+#include "content/common/gpu/gpu_memory_manager_client.h"
 #include "content/common/gpu/gpu_memory_tracking.h"
 #include "content/common/gpu/gpu_memory_uma_stats.h"
 #include "content/common/gpu/gpu_messages.h"
@@ -27,66 +27,103 @@
 
 const int kDelayedScheduleManageTimeoutMs = 67;
 
-void TrackValueChanged(size_t old_size, size_t new_size, size_t* total_size) {
+const uint64 kBytesAllocatedUnmanagedStep = 16 * 1024 * 1024;
+
+void TrackValueChanged(uint64 old_size, uint64 new_size, uint64* total_size) {
   DCHECK(new_size > old_size || *total_size >= (old_size - new_size));
   *total_size += (new_size - old_size);
 }
 
+template<typename T>
+T RoundUp(T n, T mul) {
+  return ((n + mul - 1) / mul) * mul;
 }
 
+template<typename T>
+T RoundDown(T n, T mul) {
+  return (n / mul) * mul;
+}
+
+}
+
 GpuMemoryManager::GpuMemoryManager(
     GpuChannelManager* channel_manager,
-    size_t max_surfaces_with_frontbuffer_soft_limit)
+    uint64 max_surfaces_with_frontbuffer_soft_limit)
     : channel_manager_(channel_manager),
+      use_nonuniform_memory_policy_(true),
       manage_immediate_scheduled_(false),
       max_surfaces_with_frontbuffer_soft_limit_(
           max_surfaces_with_frontbuffer_soft_limit),
       bytes_available_gpu_memory_(0),
       bytes_available_gpu_memory_overridden_(false),
-      bytes_backgrounded_available_gpu_memory_(0),
+      bytes_minimum_per_client_(0),
+      bytes_default_per_client_(0),
+      bytes_nonvisible_available_gpu_memory_(0),
       bytes_allocated_managed_current_(0),
       bytes_allocated_managed_visible_(0),
-      bytes_allocated_managed_backgrounded_(0),
+      bytes_allocated_managed_nonvisible_(0),
       bytes_allocated_unmanaged_current_(0),
       bytes_allocated_historical_max_(0),
+      bytes_allocated_unmanaged_high_(0),
+      bytes_allocated_unmanaged_low_(0),
+      bytes_unmanaged_limit_step_(kBytesAllocatedUnmanagedStep),
       window_count_has_been_received_(false),
       window_count_(0),
       disable_schedule_manage_(false)
 {
   CommandLine* command_line = CommandLine::ForCurrentProcess();
+
+#if defined(OS_ANDROID)
+  bytes_default_per_client_ = 32 * 1024 * 1024;
+  bytes_minimum_per_client_ = 32 * 1024 * 1024;
+#else
+  bytes_default_per_client_ = 64 * 1024 * 1024;
+  bytes_minimum_per_client_ = 64 * 1024 * 1024;
+#endif
+
+  if (command_line->HasSwitch(switches::kDisableNonuniformGpuMemPolicy))
+    use_nonuniform_memory_policy_ = false;
+
   if (command_line->HasSwitch(switches::kForceGpuMemAvailableMb)) {
-    base::StringToSizeT(
-      command_line->GetSwitchValueASCII(switches::kForceGpuMemAvailableMb),
-      &bytes_available_gpu_memory_);
+    base::StringToUint64(
+        command_line->GetSwitchValueASCII(switches::kForceGpuMemAvailableMb),
+        &bytes_available_gpu_memory_);
     bytes_available_gpu_memory_ *= 1024 * 1024;
     bytes_available_gpu_memory_overridden_ = true;
   } else
     bytes_available_gpu_memory_ = GetDefaultAvailableGpuMemory();
-  UpdateBackgroundedAvailableGpuMemory();
+
+  UpdateNonvisibleAvailableGpuMemory();
 }
 
 GpuMemoryManager::~GpuMemoryManager() {
   DCHECK(tracking_groups_.empty());
-  DCHECK(clients_.empty());
+  DCHECK(clients_visible_mru_.empty());
+  DCHECK(clients_nonvisible_mru_.empty());
+  DCHECK(clients_nonsurface_.empty());
   DCHECK(!bytes_allocated_managed_current_);
   DCHECK(!bytes_allocated_unmanaged_current_);
   DCHECK(!bytes_allocated_managed_visible_);
-  DCHECK(!bytes_allocated_managed_backgrounded_);
+  DCHECK(!bytes_allocated_managed_nonvisible_);
 }
 
-size_t GpuMemoryManager::GetAvailableGpuMemory() const {
-  return bytes_available_gpu_memory_;
+uint64 GpuMemoryManager::GetAvailableGpuMemory() const {
+  // Allow unmanaged allocations to over-subscribe by at most (high_ - low_)
+  // before restricting managed (compositor) memory based on unmanaged usage.
+  if (bytes_allocated_unmanaged_low_ > bytes_available_gpu_memory_)
+    return 0;
+  return bytes_available_gpu_memory_ - bytes_allocated_unmanaged_low_;
 }
 
-size_t GpuMemoryManager::GetCurrentBackgroundedAvailableGpuMemory() const {
+uint64 GpuMemoryManager::GetCurrentNonvisibleAvailableGpuMemory() const {
   if (bytes_allocated_managed_visible_ < GetAvailableGpuMemory()) {
-    return std::min(bytes_backgrounded_available_gpu_memory_,
+    return std::min(bytes_nonvisible_available_gpu_memory_,
                     GetAvailableGpuMemory() - bytes_allocated_managed_visible_);
   }
   return 0;
 }
 
-size_t GpuMemoryManager::GetDefaultAvailableGpuMemory() const {
+uint64 GpuMemoryManager::GetDefaultAvailableGpuMemory() const {
 #if defined(OS_ANDROID)
   return 32 * 1024 * 1024;
 #elif defined(OS_CHROMEOS)
@@ -96,7 +133,7 @@
 #endif
 }
 
-size_t GpuMemoryManager::GetMaximumTotalGpuMemory() const {
+uint64 GpuMemoryManager::GetMaximumTotalGpuMemory() const {
 #if defined(OS_ANDROID)
   return 256 * 1024 * 1024;
 #else
@@ -104,7 +141,7 @@
 #endif
 }
 
-size_t GpuMemoryManager::GetMaximumTabAllocation() const {
+uint64 GpuMemoryManager::GetMaximumClientAllocation() const {
 #if defined(OS_ANDROID) || defined(OS_CHROMEOS)
   return bytes_available_gpu_memory_;
 #else
@@ -115,91 +152,51 @@
 #endif
 }
 
-size_t GpuMemoryManager::GetMinimumTabAllocation() const {
+uint64 GpuMemoryManager::CalcAvailableFromGpuTotal(uint64 total_gpu_memory) {
 #if defined(OS_ANDROID)
-  return 32 * 1024 * 1024;
-#elif defined(OS_CHROMEOS)
-  return 64 * 1024 * 1024;
+  // We don't need to reduce the total on Android, since
+  // the total is an estimate to begin with.
+  return total_gpu_memory;
 #else
-  return 64 * 1024 * 1024;
-#endif
-}
-
-size_t GpuMemoryManager::CalcAvailableFromViewportArea(int viewport_area) {
-  // We can't query available GPU memory from the system on Android, but
-  // 18X the viewport and 50% of the dalvik heap size give us a good
-  // estimate of available GPU memory on a wide range of devices.
-  const int kViewportMultiplier = 18;
-  const unsigned int kComponentsPerPixel = 4; // GraphicsContext3D::RGBA
-  const unsigned int kBytesPerComponent = 1; // sizeof(GC3Dubyte)
-  size_t viewport_limit = viewport_area * kViewportMultiplier *
-                                          kComponentsPerPixel *
-                                          kBytesPerComponent;
-#if !defined(OS_ANDROID)
-  return viewport_limit;
-#else
-  static size_t dalvik_limit = 0;
-  if (!dalvik_limit)
-      dalvik_limit = (base::SysInfo::DalvikHeapSizeMB() / 2) * 1024 * 1024;
-  return std::min(viewport_limit, dalvik_limit);
-#endif
-}
-
-size_t GpuMemoryManager::CalcAvailableFromGpuTotal(size_t total_gpu_memory) {
   // Allow Chrome to use 75% of total GPU memory, or all-but-64MB of GPU
   // memory, whichever is less.
   return std::min(3 * total_gpu_memory / 4, total_gpu_memory - 64*1024*1024);
+#endif
 }
 
-void GpuMemoryManager::UpdateAvailableGpuMemory(
-   const ClientStateVector& clients) {
+void GpuMemoryManager::UpdateAvailableGpuMemory() {
   // If the amount of video memory to use was specified at the command
   // line, never change it.
   if (bytes_available_gpu_memory_overridden_)
     return;
 
-#if defined(OS_ANDROID)
-  // On Android we use the surface size, so this finds the largest visible
-  // surface size instead of lowest gpu's limit.
-  int max_surface_area = 0;
-#else
   // On non-Android, we use an operating system query when possible.
   // We do not have a reliable concept of multiple GPUs existing in
   // a system, so just be safe and go with the minimum encountered.
-  size_t bytes_min = 0;
-#endif
+  uint64 bytes_min = 0;
 
   // Only use the clients that are visible, because otherwise the set of clients
   // we are querying could become extremely large.
-  for (ClientStateVector::const_iterator it = clients.begin();
-      it != clients.end(); ++it) {
-    ClientState* client_state = *it;
-    if (!client_state->has_surface)
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+      it != clients_visible_mru_.end();
+      ++it) {
+    const GpuMemoryManagerClientState* client_state = *it;
+    if (!client_state->has_surface_)
       continue;
-    if (!client_state->visible)
+    if (!client_state->visible_)
       continue;
 
-#if defined(OS_ANDROID)
-    gfx::Size surface_size = client_state->client->GetSurfaceSize();
-    max_surface_area = std::max(max_surface_area, surface_size.width() *
-                                                  surface_size.height());
-#else
-    size_t bytes = 0;
-    if (client_state->client->GetTotalGpuMemory(&bytes)) {
+    uint64 bytes = 0;
+    if (client_state->client_->GetTotalGpuMemory(&bytes)) {
       if (!bytes_min || bytes < bytes_min)
         bytes_min = bytes;
     }
-#endif
   }
 
-#if defined(OS_ANDROID)
-  bytes_available_gpu_memory_ = CalcAvailableFromViewportArea(max_surface_area);
-#else
   if (!bytes_min)
     return;
 
   bytes_available_gpu_memory_ = CalcAvailableFromGpuTotal(bytes_min);
-#endif
 
   // Never go below the default allocation
   bytes_available_gpu_memory_ = std::max(bytes_available_gpu_memory_,
@@ -208,40 +205,37 @@
   // Never go above the maximum.
   bytes_available_gpu_memory_ = std::min(bytes_available_gpu_memory_,
                                          GetMaximumTotalGpuMemory());
+}
 
-  // Update the backgrounded available gpu memory because it depends on
-  // the available GPU memory.
-  UpdateBackgroundedAvailableGpuMemory();
+void GpuMemoryManager::UpdateUnmanagedMemoryLimits() {
+  // Set the limit to be [current_, current_ + step_ / 4), with the endpoints
+  // of the intervals rounded down and up to the nearest step_, to avoid
+  // thrashing the interval.
+  bytes_allocated_unmanaged_high_ = RoundUp(
+      bytes_allocated_unmanaged_current_ + bytes_unmanaged_limit_step_ / 4,
+      bytes_unmanaged_limit_step_);
+  bytes_allocated_unmanaged_low_ = RoundDown(
+      bytes_allocated_unmanaged_current_,
+      bytes_unmanaged_limit_step_);
 }
 
-void GpuMemoryManager::UpdateBackgroundedAvailableGpuMemory() {
-  // Be conservative and disable saving backgrounded tabs' textures on Android
+void GpuMemoryManager::UpdateNonvisibleAvailableGpuMemory() {
+  // Be conservative and disable saving nonvisible clients' textures on Android
   // for the moment
 #if defined(OS_ANDROID)
-  bytes_backgrounded_available_gpu_memory_ = 0;
+  bytes_nonvisible_available_gpu_memory_ = 0;
 #else
-  bytes_backgrounded_available_gpu_memory_ = bytes_available_gpu_memory_ / 4;
+  bytes_nonvisible_available_gpu_memory_ = GetAvailableGpuMemory() / 4;
 #endif
 }
 
-bool GpuMemoryManager::ClientsComparator::operator()(
-    ClientState* lhs,
-    ClientState* rhs) {
-  if (lhs->has_surface != rhs->has_surface)
-    return lhs->has_surface > rhs->has_surface;
-  if (lhs->visible != rhs->visible)
-    return lhs->visible > rhs->visible;
-  if (lhs->last_used_time != rhs->last_used_time)
-    return lhs->last_used_time > rhs->last_used_time;
-  return lhs > rhs;
-};
-
-void GpuMemoryManager::ScheduleManage(bool immediate) {
+void GpuMemoryManager::ScheduleManage(
+    ScheduleManageTime schedule_manage_time) {
   if (disable_schedule_manage_)
     return;
   if (manage_immediate_scheduled_)
     return;
-  if (immediate) {
+  if (schedule_manage_time == kScheduleManageNow) {
     MessageLoop::current()->PostTask(
       FROM_HERE,
       base::Bind(&GpuMemoryManager::Manage, AsWeakPtr()));
@@ -261,9 +255,11 @@
 }
 
 void GpuMemoryManager::TrackMemoryAllocatedChange(
-    size_t old_size,
-    size_t new_size,
+    GpuMemoryTrackingGroup* tracking_group,
+    uint64 old_size,
+    uint64 new_size,
     gpu::gles2::MemoryTracker::Pool tracking_pool) {
+  TrackValueChanged(old_size, new_size, &tracking_group->size_);
   switch (tracking_pool) {
     case gpu::gles2::MemoryTracker::kManaged:
       TrackValueChanged(old_size, new_size, &bytes_allocated_managed_current_);
@@ -282,6 +278,14 @@
                    "GpuMemoryUsage",
                    GetCurrentUsage());
   }
+
+  // If we've gone past our current limit on unmanaged memory, schedule a
+  // re-manage to take int account the unmanaged memory.
+  if (bytes_allocated_unmanaged_current_ >= bytes_allocated_unmanaged_high_)
+    ScheduleManage(kScheduleManageNow);
+  if (bytes_allocated_unmanaged_current_ < bytes_allocated_unmanaged_low_)
+    ScheduleManage(kScheduleManageLater);
+
   if (GetCurrentUsage() > bytes_allocated_historical_max_) {
       bytes_allocated_historical_max_ = GetCurrentUsage();
       // If we're blowing into new memory usage territory, spam the browser
@@ -290,134 +294,136 @@
   }
 }
 
-void GpuMemoryManager::AddClient(GpuMemoryManagerClient* client,
-                                 bool has_surface,
-                                 bool visible,
-                                 base::TimeTicks last_used_time) {
-  if (clients_.count(client))
-    return;
-  ClientState* client_state =
-      new ClientState(client, has_surface, visible, last_used_time);
-  TrackValueChanged(0, client_state->managed_memory_stats.bytes_allocated,
-                    client_state->visible ?
+bool GpuMemoryManager::EnsureGPUMemoryAvailable(uint64 /* size_needed */) {
+  // TODO: Check if there is enough space. Lose contexts until there is.
+  return true;
+}
+
+GpuMemoryManagerClientState* GpuMemoryManager::CreateClientState(
+    GpuMemoryManagerClient* client,
+    bool has_surface,
+    bool visible) {
+  TrackingGroupMap::iterator tracking_group_it =
+      tracking_groups_.find(client->GetMemoryTracker());
+  DCHECK(tracking_group_it != tracking_groups_.end());
+  GpuMemoryTrackingGroup* tracking_group = tracking_group_it->second;
+
+  GpuMemoryManagerClientState* client_state = new GpuMemoryManagerClientState(
+      this, client, tracking_group, has_surface, visible);
+  TrackValueChanged(0, client_state->managed_memory_stats_.bytes_allocated,
+                    client_state->visible_ ?
                         &bytes_allocated_managed_visible_ :
-                        &bytes_allocated_managed_backgrounded_);
-  clients_.insert(std::make_pair(client, client_state));
-  ScheduleManage(true);
+                        &bytes_allocated_managed_nonvisible_);
+  AddClientToList(client_state);
+  ScheduleManage(kScheduleManageNow);
+  return client_state;
 }
 
-void GpuMemoryManager::RemoveClient(GpuMemoryManagerClient* client) {
-  ClientMap::iterator it = clients_.find(client);
-  if (it == clients_.end())
-    return;
-  ClientState* client_state = it->second;
-  TrackValueChanged(client_state->managed_memory_stats.bytes_allocated, 0,
-                    client_state->visible ?
+void GpuMemoryManager::OnDestroyClientState(
+    GpuMemoryManagerClientState* client_state) {
+  RemoveClientFromList(client_state);
+  TrackValueChanged(client_state->managed_memory_stats_.bytes_allocated, 0,
+                    client_state->visible_ ?
                         &bytes_allocated_managed_visible_ :
-                        &bytes_allocated_managed_backgrounded_);
-  delete client_state;
-  clients_.erase(it);
-  ScheduleManage(false);
+                        &bytes_allocated_managed_nonvisible_);
+  ScheduleManage(kScheduleManageLater);
 }
 
-void GpuMemoryManager::SetClientVisible(GpuMemoryManagerClient* client,
-                                        bool visible)
-{
-  ClientMap::const_iterator it = clients_.find(client);
-  if (it == clients_.end())
+void GpuMemoryManager::SetClientStateVisible(
+    GpuMemoryManagerClientState* client_state, bool visible) {
+  DCHECK(client_state->has_surface_);
+  if (client_state->visible_ == visible)
     return;
-  ClientState* client_state = it->second;
-  if (client_state->visible == visible)
-    return;
-  client_state->visible = visible;
-  client_state->last_used_time = base::TimeTicks::Now();
-  TrackValueChanged(client_state->managed_memory_stats.bytes_allocated, 0,
-                    client_state->visible ?
-                        &bytes_allocated_managed_backgrounded_ :
+
+  RemoveClientFromList(client_state);
+  client_state->visible_ = visible;
+  AddClientToList(client_state);
+
+  TrackValueChanged(client_state->managed_memory_stats_.bytes_allocated, 0,
+                    client_state->visible_ ?
+                        &bytes_allocated_managed_nonvisible_ :
                         &bytes_allocated_managed_visible_);
-  TrackValueChanged(0, client_state->managed_memory_stats.bytes_allocated,
-                    client_state->visible ?
+  TrackValueChanged(0, client_state->managed_memory_stats_.bytes_allocated,
+                    client_state->visible_ ?
                         &bytes_allocated_managed_visible_ :
-                        &bytes_allocated_managed_backgrounded_);
-  ScheduleManage(visible);
+                        &bytes_allocated_managed_nonvisible_);
+  ScheduleManage(visible ? kScheduleManageNow : kScheduleManageLater);
 }
 
-void GpuMemoryManager::SetClientManagedMemoryStats(
-    GpuMemoryManagerClient* client,
+void GpuMemoryManager::SetClientStateManagedMemoryStats(
+    GpuMemoryManagerClientState* client_state,
     const GpuManagedMemoryStats& stats)
 {
-  ClientMap::const_iterator it = clients_.find(client);
-  if (it == clients_.end())
-    return;
-  ClientState* client_state = it->second;
-  TrackValueChanged(client_state->managed_memory_stats.bytes_allocated,
+  TrackValueChanged(client_state->managed_memory_stats_.bytes_allocated,
                     stats.bytes_allocated,
-                    client_state->visible ?
+                    client_state->visible_ ?
                         &bytes_allocated_managed_visible_ :
-                        &bytes_allocated_managed_backgrounded_);
-  client_state->managed_memory_stats = stats;
+                        &bytes_allocated_managed_nonvisible_);
+  client_state->managed_memory_stats_ = stats;
 
-  // If this allocation pushed our usage of backgrounded tabs memory over the
-  // limit, then schedule a drop of backgrounded memory.
-  if (bytes_allocated_managed_backgrounded_ >
-      GetCurrentBackgroundedAvailableGpuMemory())
-    ScheduleManage(false);
-}
+  // If this is the first time that stats have been received for this
+  // client, use them immediately.
+  if (!client_state->managed_memory_stats_received_) {
+    client_state->managed_memory_stats_received_ = true;
+    ScheduleManage(kScheduleManageNow);
+    return;
+  }
 
-void GpuMemoryManager::TestingSetClientVisible(
-    GpuMemoryManagerClient* client, bool visible) {
-  DCHECK(clients_.count(client));
-  clients_[client]->visible = visible;
+  if (use_nonuniform_memory_policy_) {
+    // If these statistics sit outside of the range that we used in our
+    // computation of memory allocations then recompute the allocations.
+    if (client_state->managed_memory_stats_.bytes_nice_to_have >
+        client_state->bytes_nicetohave_limit_high_) {
+      ScheduleManage(kScheduleManageNow);
+    } else if (client_state->managed_memory_stats_.bytes_nice_to_have <
+               client_state->bytes_nicetohave_limit_low_) {
+      ScheduleManage(kScheduleManageLater);
+    }
+  } else {
+    // If this allocation pushed our usage of nonvisible clients' memory over
+    // the limit, then schedule a drop of nonvisible memory.
+    if (bytes_allocated_managed_nonvisible_ >
+        GetCurrentNonvisibleAvailableGpuMemory())
+      ScheduleManage(kScheduleManageLater);
+  }
 }
 
-void GpuMemoryManager::TestingSetClientLastUsedTime(
-    GpuMemoryManagerClient* client, base::TimeTicks last_used_time) {
-  DCHECK(clients_.count(client));
-  clients_[client]->last_used_time = last_used_time;
+GpuMemoryTrackingGroup* GpuMemoryManager::CreateTrackingGroup(
+    base::ProcessId pid, gpu::gles2::MemoryTracker* memory_tracker) {
+  GpuMemoryTrackingGroup* tracking_group = new GpuMemoryTrackingGroup(
+      pid, memory_tracker, this);
+  DCHECK(!tracking_groups_.count(tracking_group->GetMemoryTracker()));
+  tracking_groups_.insert(std::make_pair(tracking_group->GetMemoryTracker(),
+                                         tracking_group));
+  return tracking_group;
 }
 
-void GpuMemoryManager::TestingSetClientHasSurface(
-    GpuMemoryManagerClient* client, bool has_surface) {
-  DCHECK(clients_.count(client));
-  clients_[client]->has_surface = has_surface;
-}
-
-bool GpuMemoryManager::TestingCompareClients(
-    GpuMemoryManagerClient* lhs, GpuMemoryManagerClient* rhs) const {
-  ClientMap::const_iterator it_lhs = clients_.find(lhs);
-  ClientMap::const_iterator it_rhs = clients_.find(rhs);
-  DCHECK(it_lhs != clients_.end());
-  DCHECK(it_rhs != clients_.end());
-  ClientsComparator comparator;
-  return comparator.operator()(it_lhs->second, it_rhs->second);
-}
-
-void GpuMemoryManager::AddTrackingGroup(
+void GpuMemoryManager::OnDestroyTrackingGroup(
     GpuMemoryTrackingGroup* tracking_group) {
-  tracking_groups_.insert(tracking_group);
+  DCHECK(tracking_groups_.count(tracking_group->GetMemoryTracker()));
+  tracking_groups_.erase(tracking_group->GetMemoryTracker());
 }
 
-void GpuMemoryManager::RemoveTrackingGroup(
-    GpuMemoryTrackingGroup* tracking_group) {
-  tracking_groups_.erase(tracking_group);
-}
-
 void GpuMemoryManager::GetVideoMemoryUsageStats(
-    GPUVideoMemoryUsageStats& video_memory_usage_stats) const {
+    GPUVideoMemoryUsageStats* video_memory_usage_stats) const {
   // For each context group, assign its memory usage to its PID
-  video_memory_usage_stats.process_map.clear();
-  for (std::set<GpuMemoryTrackingGroup*>::const_iterator i =
+  video_memory_usage_stats->process_map.clear();
+  for (TrackingGroupMap::const_iterator i =
        tracking_groups_.begin(); i != tracking_groups_.end(); ++i) {
-    const GpuMemoryTrackingGroup* tracking_group = (*i);
-    video_memory_usage_stats.process_map[
+    const GpuMemoryTrackingGroup* tracking_group = i->second;
+    video_memory_usage_stats->process_map[
         tracking_group->GetPid()].video_memory += tracking_group->GetSize();
   }
 
   // Assign the total across all processes in the GPU process
-  video_memory_usage_stats.process_map[
+  video_memory_usage_stats->process_map[
       base::GetCurrentProcId()].video_memory = GetCurrentUsage();
-  video_memory_usage_stats.process_map[
+  video_memory_usage_stats->process_map[
       base::GetCurrentProcId()].has_duplicates = true;
+
+  video_memory_usage_stats->bytes_allocated = GetCurrentUsage();
+  video_memory_usage_stats->bytes_allocated_historical_max =
+      bytes_allocated_historical_max_;
 }
 
 void GpuMemoryManager::SetWindowCount(uint32 window_count) {
@@ -426,7 +432,7 @@
   window_count_has_been_received_ = true;
   window_count_ = window_count;
   if (should_schedule_manage)
-    ScheduleManage(true);
+    ScheduleManage(kScheduleManageNow);
 }
 
 // The current Manage algorithm simply classifies contexts (clients) into
@@ -462,145 +468,549 @@
   manage_immediate_scheduled_ = false;
   delayed_manage_callback_.Cancel();
 
-  // Create a vector of clients, sorted by
-  // - visible clients with surfaces, sorted in MRU order
-  // - backgrounded clients with surfaces, sorted in MRU order
-  // - clients without surfaces
-  ClientStateVector clients;
-  for (ClientMap::iterator it = clients_.begin(); it != clients_.end(); ++it) {
-    clients.push_back(it->second);
-  }
-  std::sort(clients.begin(), clients.end(), ClientsComparator());
-  DCHECK(std::unique(clients.begin(), clients.end()) == clients.end());
-
   // Update the amount of GPU memory available on the system.
-  UpdateAvailableGpuMemory(clients);
+  UpdateAvailableGpuMemory();
 
+  // Update the limit on unmanaged memory.
+  UpdateUnmanagedMemoryLimits();
+
+  // Update the nonvisible available gpu memory because it depends on
+  // the available GPU memory.
+  UpdateNonvisibleAvailableGpuMemory();
+
   // Determine which clients are "hibernated" (which determines the
   // distribution of frontbuffers and memory among clients that don't have
   // surfaces).
-  SetClientsHibernatedState(clients);
+  SetClientsHibernatedState();
 
-  // Determine how much memory to assign to give to visible and backgrounded
-  // clients.
-  size_t bytes_limit_when_visible = GetVisibleClientAllocation(clients);
+  // Assign memory allocations to clients that have surfaces.
+  if (use_nonuniform_memory_policy_)
+    AssignSurfacesAllocationsNonuniform();
+  else
+    AssignSurfacesAllocationsUniform();
 
-  // Now give out allocations to everyone.
-  size_t bytes_allocated_backgrounded = 0;
-  for (ClientStateVector::iterator it = clients.begin();
+  // Assign memory allocations to clients that don't have surfaces.
+  AssignNonSurfacesAllocations();
+
+  SendUmaStatsToBrowser();
+}
+
+// static
+uint64 GpuMemoryManager::ComputeCap(
+    std::vector<uint64> bytes, uint64 bytes_sum_limit)
+{
+  size_t bytes_size = bytes.size();
+  uint64 bytes_sum = 0;
+
+  if (bytes_size == 0)
+    return std::numeric_limits<uint64>::max();
+
+  // Sort and add up all entries
+  std::sort(bytes.begin(), bytes.end());
+  for (size_t i = 0; i < bytes_size; ++i)
+    bytes_sum += bytes[i];
+
+  // As we go through the below loop, let bytes_partial_sum be the
+  // sum of bytes[0] + ... + bytes[bytes_size - i - 1]
+  uint64 bytes_partial_sum = bytes_sum;
+
+  // Try using each entry as a cap, and see where we get cut off.
+  for (size_t i = 0; i < bytes_size; ++i) {
+    // Try limiting cap to bytes[bytes_size - i - 1]
+    uint64 test_cap = bytes[bytes_size - i - 1];
+    uint64 bytes_sum_with_test_cap = i * test_cap + bytes_partial_sum;
+
+    // If that fits, raise test_cap to give an even distribution to the
+    // last i entries.
+    if (bytes_sum_with_test_cap <= bytes_sum_limit) {
+      if (i == 0)
+        return std::numeric_limits<uint64>::max();
+      else
+        return test_cap + (bytes_sum_limit - bytes_sum_with_test_cap) / i;
+    } else {
+      bytes_partial_sum -= test_cap;
+    }
+  }
+
+  // If we got here, then we can't fully accommodate any of the clients,
+  // so distribute bytes_sum_limit evenly.
+  return bytes_sum_limit / bytes_size;
+}
+
+uint64 GpuMemoryManager::ComputeClientAllocationWhenVisible(
+    GpuMemoryManagerClientState* client_state,
+    uint64 bytes_above_required_cap,
+    uint64 bytes_above_minimum_cap,
+    uint64 bytes_overall_cap) {
+  GpuManagedMemoryStats* stats = &client_state->managed_memory_stats_;
+
+  if (!client_state->managed_memory_stats_received_)
+    return GetDefaultClientAllocation();
+
+  uint64 bytes_required = 9 * stats->bytes_required / 8;
+  bytes_required = std::min(bytes_required, GetMaximumClientAllocation());
+  bytes_required = std::max(bytes_required, GetMinimumClientAllocation());
+
+  uint64 bytes_nicetohave = 4 * stats->bytes_nice_to_have / 3;
+  bytes_nicetohave = std::min(bytes_nicetohave, GetMaximumClientAllocation());
+  bytes_nicetohave = std::max(bytes_nicetohave, GetMinimumClientAllocation());
+  bytes_nicetohave = std::max(bytes_nicetohave, bytes_required);
+
+  uint64 allocation = GetMinimumClientAllocation();
+  allocation += std::min(bytes_required - GetMinimumClientAllocation(),
+                         bytes_above_minimum_cap);
+  allocation += std::min(bytes_nicetohave - bytes_required,
+                         bytes_above_required_cap);
+  allocation = std::min(allocation,
+                        bytes_overall_cap);
+  return allocation;
+}
+
+uint64 GpuMemoryManager::ComputeClientAllocationWhenNonvisible(
+    GpuMemoryManagerClientState* client_state) {
+
+  if (!client_state->managed_memory_stats_received_)
+    return 0;
+
+  return 9 * client_state->managed_memory_stats_.bytes_required / 8;
+}
+
+void GpuMemoryManager::ComputeVisibleSurfacesAllocationsNonuniform() {
+  uint64 bytes_available_total = GetAvailableGpuMemory();
+  uint64 bytes_above_required_cap = std::numeric_limits<uint64>::max();
+  uint64 bytes_above_minimum_cap = std::numeric_limits<uint64>::max();
+  uint64 bytes_overall_cap_visible = GetMaximumClientAllocation();
+
+  // Compute memory usage at three levels
+  // - painting everything that is nicetohave for visible clients
+  // - painting only what that is visible
+  // - giving every client the minimum allocation
+  uint64 bytes_nicetohave_visible = 0;
+  uint64 bytes_required_visible = 0;
+  uint64 bytes_minimum_visible = 0;
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    client_state->bytes_allocation_ideal_nicetohave_ =
+        ComputeClientAllocationWhenVisible(
+            client_state,
+            bytes_above_required_cap,
+            bytes_above_minimum_cap,
+            bytes_overall_cap_visible);
+    client_state->bytes_allocation_ideal_required_ =
+        ComputeClientAllocationWhenVisible(
+            client_state,
+            0,
+            bytes_above_minimum_cap,
+            bytes_overall_cap_visible);
+    client_state->bytes_allocation_ideal_minimum_ =
+        ComputeClientAllocationWhenVisible(
+            client_state,
+            0,
+            0,
+            bytes_overall_cap_visible);
+
+    bytes_nicetohave_visible +=
+        client_state->bytes_allocation_ideal_nicetohave_;
+    bytes_required_visible +=
+        client_state->bytes_allocation_ideal_required_;
+    bytes_minimum_visible +=
+        client_state->bytes_allocation_ideal_minimum_;
+  }
+
+  // Determine which of those three points we can satisfy, and limit
+  // bytes_above_required_cap and bytes_above_minimum_cap to not go
+  // over the limit.
+  if (bytes_minimum_visible > bytes_available_total) {
+    bytes_above_required_cap = 0;
+    bytes_above_minimum_cap = 0;
+  } else if (bytes_required_visible > bytes_available_total) {
+    std::vector<uint64> bytes_to_fit;
+    for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+         it != clients_visible_mru_.end();
+         ++it) {
+      GpuMemoryManagerClientState* client_state = *it;
+      bytes_to_fit.push_back(client_state->bytes_allocation_ideal_required_ -
+                             client_state->bytes_allocation_ideal_minimum_);
+    }
+    bytes_above_required_cap = 0;
+    bytes_above_minimum_cap = ComputeCap(
+        bytes_to_fit, bytes_available_total - bytes_minimum_visible);
+  } else if (bytes_nicetohave_visible > bytes_available_total) {
+    std::vector<uint64> bytes_to_fit;
+    for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+         it != clients_visible_mru_.end();
+         ++it) {
+      GpuMemoryManagerClientState* client_state = *it;
+      bytes_to_fit.push_back(client_state->bytes_allocation_ideal_nicetohave_ -
+                             client_state->bytes_allocation_ideal_required_);
+    }
+    bytes_above_required_cap = ComputeCap(
+        bytes_to_fit, bytes_available_total - bytes_required_visible);
+    bytes_above_minimum_cap = std::numeric_limits<uint64>::max();
+  }
+
+  // Given those computed limits, set the actual memory allocations for the
+  // visible clients, tracking the largest allocation and the total allocation
+  // for future use.
+  uint64 bytes_allocated_visible = 0;
+  uint64 bytes_allocated_max_client_allocation = 0;
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    client_state->bytes_allocation_when_visible_ =
+        ComputeClientAllocationWhenVisible(
+            client_state,
+            bytes_above_required_cap,
+            bytes_above_minimum_cap,
+            bytes_overall_cap_visible);
+    bytes_allocated_visible += client_state->bytes_allocation_when_visible_;
+    bytes_allocated_max_client_allocation = std::max(
+        bytes_allocated_max_client_allocation,
+        client_state->bytes_allocation_when_visible_);
+  }
+
+  // Set the limit for nonvisible clients for when they become visible.
+  // Use the same formula, with a lowered overall cap to in case any of the
+  // currently-nonvisible clients are much more resource-intensive than any
+  // of the existing clients.
+  uint64 bytes_overall_cap_nonvisible = bytes_allocated_max_client_allocation;
+  if (bytes_available_total > bytes_allocated_visible) {
+    bytes_overall_cap_nonvisible +=
+        bytes_available_total - bytes_allocated_visible;
+  }
+  bytes_overall_cap_nonvisible = std::min(bytes_overall_cap_nonvisible,
+                                          GetMaximumClientAllocation());
+  for (ClientStateList::const_iterator it = clients_nonvisible_mru_.begin();
+       it != clients_nonvisible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    client_state->bytes_allocation_when_visible_ =
+        ComputeClientAllocationWhenVisible(
+            client_state,
+            bytes_above_required_cap,
+            bytes_above_minimum_cap,
+            bytes_overall_cap_nonvisible);
+  }
+}
+
+void GpuMemoryManager::ComputeNonvisibleSurfacesAllocationsNonuniform() {
+  uint64 bytes_allocated_visible = 0;
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    bytes_allocated_visible += client_state->bytes_allocation_when_visible_;
+  }
+
+  // Allow up to 1/4 of the memory that was available for visible clients to
+  // go to nonvisible clients.
+  uint64 bytes_available_total = GetAvailableGpuMemory();
+  uint64 bytes_available_nonvisible = 0;
+  uint64 bytes_allocated_nonvisible = 0;
+  if (bytes_available_total > bytes_allocated_visible) {
+    bytes_available_nonvisible = std::min(
+        bytes_available_total / 4,
+        bytes_available_total - bytes_allocated_visible);
+  }
+
+  // On Android, always discard everything that is nonvisible.
+#if defined(OS_ANDROID)
+  bytes_available_nonvisible = 0;
+#endif
+
+  // Determine which now-visible clients should keep their contents when
+  // they are made nonvisible.
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+
+    // Compute the amount of space available have for this renderer when it is
+    // nonvisible. Do not count this client's allocation while visible against
+    // the nonvisible clients' allocation total.
+    uint64 bytes_available_nonvisible_adjusted = std::min(
+        bytes_available_nonvisible +
+            client_state->bytes_allocation_when_visible_ / 4,
+        bytes_available_total / 4);
+
+    // Allow this client to keep its contents if they fit in the allocation.
+    client_state->bytes_allocation_when_nonvisible_ =
+        ComputeClientAllocationWhenNonvisible(client_state);
+    if (client_state->bytes_allocation_when_nonvisible_ >
+        bytes_available_nonvisible_adjusted)
+      client_state->bytes_allocation_when_nonvisible_ = 0;
+  }
+
+  // Compute which currently nonvisible clients should keep their contents.
+  for (ClientStateList::const_iterator it = clients_nonvisible_mru_.begin();
+       it != clients_nonvisible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+
+    // If this client is nonvisible and has already had its contents discarded,
+    // don't re-generate the contents until the client becomes visible again.
+    if (!client_state->bytes_allocation_when_nonvisible_)
+      continue;
+
+    client_state->bytes_allocation_when_nonvisible_ =
+        ComputeClientAllocationWhenNonvisible(client_state);
+
+    // Take into account all more recently used nonvisible clients, and only if
+    // this client still fits, all it to keep its contents.
+    if (bytes_allocated_nonvisible +
+        client_state->bytes_allocation_when_nonvisible_ >
+        bytes_available_nonvisible) {
+      client_state->bytes_allocation_when_nonvisible_ = 0;
+    }
+    bytes_allocated_nonvisible +=
+        client_state->bytes_allocation_when_nonvisible_;
+  }
+}
+
+void GpuMemoryManager::DistributeRemainingMemoryToVisibleSurfaces() {
+  uint64 bytes_available_total = GetAvailableGpuMemory();
+  uint64 bytes_allocated_total = 0;
+
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    bytes_allocated_total += client_state->bytes_allocation_when_visible_;
+  }
+  for (ClientStateList::const_iterator it = clients_nonvisible_mru_.begin();
+       it != clients_nonvisible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    bytes_allocated_total += client_state->bytes_allocation_when_nonvisible_;
+  }
+
+  if (bytes_allocated_total >= bytes_available_total)
+    return;
+
+  std::vector<uint64> bytes_extra_requests;
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    CHECK(GetMaximumClientAllocation() >=
+          client_state->bytes_allocation_when_visible_);
+    uint64 bytes_extra = GetMaximumClientAllocation() -
+                         client_state->bytes_allocation_when_visible_;
+    bytes_extra_requests.push_back(bytes_extra);
+  }
+  uint64 bytes_extra_cap = ComputeCap(
+      bytes_extra_requests, bytes_available_total - bytes_allocated_total);
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    uint64 bytes_extra = GetMaximumClientAllocation() -
+                         client_state->bytes_allocation_when_visible_;
+    client_state->bytes_allocation_when_visible_ += std::min(
+        bytes_extra, bytes_extra_cap);
+  }
+}
+
+void GpuMemoryManager::AssignSurfacesAllocationsNonuniform() {
+  // Compute allocation when for all clients.
+  ComputeVisibleSurfacesAllocationsNonuniform();
+  ComputeNonvisibleSurfacesAllocationsNonuniform();
+
+  // Distribute the remaining memory to visible clients.
+  DistributeRemainingMemoryToVisibleSurfaces();
+
+  // Send that allocation to the clients.
+  ClientStateList clients = clients_visible_mru_;
+  clients.insert(clients.end(),
+                 clients_nonvisible_mru_.begin(),
+                 clients_nonvisible_mru_.end());
+  for (ClientStateList::const_iterator it = clients.begin();
        it != clients.end();
        ++it) {
-    ClientState* client_state = *it;
+    GpuMemoryManagerClientState* client_state = *it;
+
+    // Re-assign memory limits to this client when its "nice to have" bucket
+    // grows or shrinks by 1/4.
+    client_state->bytes_nicetohave_limit_high_ =
+        5 * client_state->managed_memory_stats_.bytes_nice_to_have / 4;
+    client_state->bytes_nicetohave_limit_low_ =
+        3 * client_state->managed_memory_stats_.bytes_nice_to_have / 4;
+
+    // Populate and send the allocation to the client
     GpuMemoryAllocation allocation;
-    if (client_state->has_surface) {
-      allocation.browser_allocation.suggest_have_frontbuffer =
-          !client_state->hibernated;
 
-      // Set the state when visible.
-      allocation.renderer_allocation.bytes_limit_when_visible =
-          bytes_limit_when_visible;
-      // Experiment to determine if aggressively discarding tiles on OS X
-      // results in greater stability.
+    allocation.browser_allocation.suggest_have_frontbuffer =
+        !client_state->hibernated_;
+
+    allocation.renderer_allocation.bytes_limit_when_visible =
+        client_state->bytes_allocation_when_visible_;
+    allocation.renderer_allocation.priority_cutoff_when_visible =
 #if defined(OS_MACOSX)
-      allocation.renderer_allocation.priority_cutoff_when_visible =
-          GpuMemoryAllocationForRenderer::kPriorityCutoffAllowNiceToHave;
+        GpuMemoryAllocationForRenderer::kPriorityCutoffAllowNiceToHave;
 #else
-      allocation.renderer_allocation.priority_cutoff_when_visible =
-          GpuMemoryAllocationForRenderer::kPriorityCutoffAllowEverything;
+        GpuMemoryAllocationForRenderer::kPriorityCutoffAllowEverything;
 #endif
 
-      // Set the state when backgrounded.
-      bool allow_allocation_when_backgrounded = false;
-      if (client_state->visible) {
-        // If the client is visible, then allow it to keep its textures, should
-        // it be backgrounded, but only if all textures required to draw will
-        // fit in total backgrounded memory limit.
-        allow_allocation_when_backgrounded =
-            client_state->managed_memory_stats.bytes_required <
-            bytes_backgrounded_available_gpu_memory_;
-      } else {
-        // If the client is backgrounded, then allow it to keep its textures
-        // if everything required to draw fits in-budget.
-        allow_allocation_when_backgrounded =
-            client_state->managed_memory_stats.bytes_required +
-            bytes_allocated_backgrounded <
-            GetCurrentBackgroundedAvailableGpuMemory();
-        if (allow_allocation_when_backgrounded) {
-          bytes_allocated_backgrounded +=
-              client_state->managed_memory_stats.bytes_allocated;
-        }
-      }
-      if (allow_allocation_when_backgrounded) {
-        allocation.renderer_allocation.bytes_limit_when_not_visible =
-            GetCurrentBackgroundedAvailableGpuMemory();
-        allocation.renderer_allocation.priority_cutoff_when_not_visible =
-            GpuMemoryAllocationForRenderer::kPriorityCutoffAllowOnlyRequired;
-      } else {
+    allocation.renderer_allocation.bytes_limit_when_not_visible =
+        client_state->bytes_allocation_when_nonvisible_;
+    allocation.renderer_allocation.priority_cutoff_when_not_visible =
+        GpuMemoryAllocationForRenderer::kPriorityCutoffAllowOnlyRequired;
+
+    client_state->client_->SetMemoryAllocation(allocation);
+  }
+}
+
+void GpuMemoryManager::AssignSurfacesAllocationsUniform() {
+  // Determine how much memory to assign to give to visible and nonvisible
+  // clients.
+  uint64 bytes_limit_when_visible = GetVisibleClientAllocation();
+
+  // Experiment to determine if aggressively discarding tiles on OS X
+  // results in greater stability.
+#if defined(OS_MACOSX)
+  GpuMemoryAllocationForRenderer::PriorityCutoff priority_cutoff_when_visible =
+      GpuMemoryAllocationForRenderer::kPriorityCutoffAllowNiceToHave;
+#else
+  GpuMemoryAllocationForRenderer::PriorityCutoff priority_cutoff_when_visible =
+      GpuMemoryAllocationForRenderer::kPriorityCutoffAllowEverything;
+#endif
+
+  // Assign memory allocations to visible clients.
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    GpuMemoryAllocation allocation;
+
+    allocation.browser_allocation.suggest_have_frontbuffer = true;
+    allocation.renderer_allocation.bytes_limit_when_visible =
+        bytes_limit_when_visible;
+    allocation.renderer_allocation.priority_cutoff_when_visible =
+        priority_cutoff_when_visible;
+
+    // Allow this client to keep its textures when nonvisible if they
+    // aren't so expensive that they won't fit.
+    if (client_state->managed_memory_stats_.bytes_required <=
+        bytes_nonvisible_available_gpu_memory_) {
+      allocation.renderer_allocation.bytes_limit_when_not_visible =
+          GetCurrentNonvisibleAvailableGpuMemory();
+      allocation.renderer_allocation.priority_cutoff_when_not_visible =
+          GpuMemoryAllocationForRenderer::kPriorityCutoffAllowOnlyRequired;
+    } else {
         allocation.renderer_allocation.bytes_limit_when_not_visible = 0;
         allocation.renderer_allocation.priority_cutoff_when_not_visible =
             GpuMemoryAllocationForRenderer::kPriorityCutoffAllowNothing;
-      }
+    }
+
+    client_state->client_->SetMemoryAllocation(allocation);
+  }
+
+  // Assign memory allocations to nonvisible clients.
+  uint64 bytes_allocated_nonvisible = 0;
+  for (ClientStateList::const_iterator it = clients_nonvisible_mru_.begin();
+       it != clients_nonvisible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    GpuMemoryAllocation allocation;
+
+    allocation.browser_allocation.suggest_have_frontbuffer =
+        !client_state->hibernated_;
+    allocation.renderer_allocation.bytes_limit_when_visible =
+        bytes_limit_when_visible;
+    allocation.renderer_allocation.priority_cutoff_when_visible =
+        priority_cutoff_when_visible;
+
+    if (client_state->managed_memory_stats_.bytes_required +
+        bytes_allocated_nonvisible <=
+        GetCurrentNonvisibleAvailableGpuMemory()) {
+      bytes_allocated_nonvisible +=
+          client_state->managed_memory_stats_.bytes_required;
+      allocation.renderer_allocation.bytes_limit_when_not_visible =
+          GetCurrentNonvisibleAvailableGpuMemory();
+      allocation.renderer_allocation.priority_cutoff_when_not_visible =
+          GpuMemoryAllocationForRenderer::kPriorityCutoffAllowOnlyRequired;
     } else {
-      if (!client_state->hibernated) {
-        allocation.renderer_allocation.bytes_limit_when_visible =
-            GetMinimumTabAllocation();
-        allocation.renderer_allocation.priority_cutoff_when_visible =
-            GpuMemoryAllocationForRenderer::kPriorityCutoffAllowEverything;
-      }
+      allocation.renderer_allocation.bytes_limit_when_not_visible = 0;
+      allocation.renderer_allocation.priority_cutoff_when_not_visible =
+          GpuMemoryAllocationForRenderer::kPriorityCutoffAllowNothing;
     }
-    client_state->client->SetMemoryAllocation(allocation);
+
+    client_state->client_->SetMemoryAllocation(allocation);
   }
+}
 
-  SendUmaStatsToBrowser();
+void GpuMemoryManager::AssignNonSurfacesAllocations() {
+  for (ClientStateList::const_iterator it = clients_nonsurface_.begin();
+       it != clients_nonsurface_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    GpuMemoryAllocation allocation;
+
+    if (!client_state->hibernated_) {
+      allocation.renderer_allocation.bytes_limit_when_visible =
+          GetMinimumClientAllocation();
+      allocation.renderer_allocation.priority_cutoff_when_visible =
+          GpuMemoryAllocationForRenderer::kPriorityCutoffAllowEverything;
+    }
+
+    client_state->client_->SetMemoryAllocation(allocation);
+  }
 }
 
-void GpuMemoryManager::SetClientsHibernatedState(
-    const ClientStateVector& clients) const {
-  std::set<gpu::gles2::MemoryTracker*> memory_trackers_not_hibernated;
-  size_t non_hibernated_clients = 0;
-  for (ClientStateVector::const_iterator it = clients.begin();
-       it != clients.end();
+void GpuMemoryManager::SetClientsHibernatedState() const {
+  // Re-set all tracking groups as being hibernated.
+  for (TrackingGroupMap::const_iterator it = tracking_groups_.begin();
+       it != tracking_groups_.end();
        ++it) {
-    ClientState* client_state = *it;
-    if (client_state->has_surface) {
-      // All clients with surfaces that are visible are non-hibernated. Then
-      // an additional few clients with surfaces are non-hibernated too, up to
-      // a fixed limit.
-      if (client_state->visible) {
-        client_state->hibernated = false;
-      } else {
-        client_state->hibernated = non_hibernated_clients >=
-                                   max_surfaces_with_frontbuffer_soft_limit_;
-      }
-      if (!client_state->hibernated) {
-        non_hibernated_clients++;
-        memory_trackers_not_hibernated.insert(
-            client_state->client->GetMemoryTracker());
-      }
+    GpuMemoryTrackingGroup* tracking_group = it->second;
+    tracking_group->hibernated_ = true;
+  }
+  // All clients with surfaces that are visible are non-hibernated.
+  uint64 non_hibernated_clients = 0;
+  for (ClientStateList::const_iterator it = clients_visible_mru_.begin();
+       it != clients_visible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    client_state->hibernated_ = false;
+    client_state->tracking_group_->hibernated_ = false;
+    non_hibernated_clients++;
+  }
+  // Then an additional few clients with surfaces are non-hibernated too, up to
+  // a fixed limit.
+  for (ClientStateList::const_iterator it = clients_nonvisible_mru_.begin();
+       it != clients_nonvisible_mru_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    if (non_hibernated_clients < max_surfaces_with_frontbuffer_soft_limit_) {
+      client_state->hibernated_ = false;
+      client_state->tracking_group_->hibernated_ = false;
+      non_hibernated_clients++;
     } else {
-      // Clients that don't have surfaces are non-hibernated if they are
-      // in a GL share group with a non-hibernated surface.
-      client_state->hibernated = !memory_trackers_not_hibernated.count(
-          client_state->client->GetMemoryTracker());
+      client_state->hibernated_ = true;
     }
   }
+  // Clients that don't have surfaces are non-hibernated if they are
+  // in a GL share group with a non-hibernated surface.
+  for (ClientStateList::const_iterator it = clients_nonsurface_.begin();
+       it != clients_nonsurface_.end();
+       ++it) {
+    GpuMemoryManagerClientState* client_state = *it;
+    client_state->hibernated_ = client_state->tracking_group_->hibernated_;
+  }
 }
 
-size_t GpuMemoryManager::GetVisibleClientAllocation(
-    const ClientStateVector& clients) const {
+uint64 GpuMemoryManager::GetVisibleClientAllocation() const {
   // Count how many clients will get allocations.
-  size_t clients_with_surface_visible_count = 0;
+  size_t clients_with_surface_visible_count = clients_visible_mru_.size();
   size_t clients_without_surface_not_hibernated_count = 0;
-  for (ClientStateVector::const_iterator it = clients.begin();
-       it != clients.end();
+  for (ClientStateList::const_iterator it = clients_nonsurface_.begin();
+       it != clients_nonsurface_.end();
        ++it) {
-    ClientState* client_state = *it;
-    if (client_state->has_surface &&
-        client_state->visible &&
-        !client_state->hibernated)
-      clients_with_surface_visible_count++;
-    if (!client_state->has_surface &&
-        !client_state->hibernated)
+    GpuMemoryManagerClientState* client_state = *it;
+    if (!client_state->hibernated_)
       clients_without_surface_not_hibernated_count++;
   }
 
@@ -608,14 +1018,14 @@
   // after giving out the minimum to those that need it.
   size_t num_clients_need_mem = clients_with_surface_visible_count +
                                 clients_without_surface_not_hibernated_count;
-  size_t base_allocation_size = GetMinimumTabAllocation() *
+  uint64 base_allocation_size = GetMinimumClientAllocation() *
                                 num_clients_need_mem;
-  size_t bonus_allocation = 0;
+  uint64 bonus_allocation = 0;
   if (base_allocation_size < GetAvailableGpuMemory() &&
       clients_with_surface_visible_count)
     bonus_allocation = (GetAvailableGpuMemory() - base_allocation_size) /
                        clients_with_surface_visible_count;
-  size_t clients_allocation_when_visible = GetMinimumTabAllocation() +
+  uint64 clients_allocation_when_visible = GetMinimumClientAllocation() +
                                            bonus_allocation;
 
   // If we have received a window count message, then override the client-based
@@ -627,8 +1037,8 @@
   }
 
   // Limit the memory per client to its maximum allowed level.
-  if (clients_allocation_when_visible >= GetMaximumTabAllocation())
-    clients_allocation_when_visible = GetMaximumTabAllocation();
+  if (clients_allocation_when_visible >= GetMaximumClientAllocation())
+    clients_allocation_when_visible = GetMaximumClientAllocation();
 
   return clients_allocation_when_visible;
 }
@@ -644,18 +1054,34 @@
   channel_manager_->Send(new GpuHostMsg_GpuMemoryUmaStats(params));
 }
 
-GpuMemoryManager::ClientState::ClientState(
-    GpuMemoryManagerClient* client,
-    bool has_surface,
-    bool visible,
-    base::TimeTicks last_used_time)
-    : client(client),
-      has_surface(has_surface),
-      visible(visible),
-      last_used_time(last_used_time),
-      hibernated(false) {
+GpuMemoryManager::ClientStateList* GpuMemoryManager::GetClientList(
+    GpuMemoryManagerClientState* client_state) {
+  if (client_state->has_surface_) {
+    if (client_state->visible_)
+      return &clients_visible_mru_;
+    else
+      return &clients_nonvisible_mru_;
+  }
+  return &clients_nonsurface_;
 }
 
+void GpuMemoryManager::AddClientToList(
+    GpuMemoryManagerClientState* client_state) {
+  DCHECK(!client_state->list_iterator_valid_);
+  ClientStateList* client_list = GetClientList(client_state);
+  client_state->list_iterator_ = client_list->insert(
+      client_list->begin(), client_state);
+  client_state->list_iterator_valid_ = true;
+}
+
+void GpuMemoryManager::RemoveClientFromList(
+    GpuMemoryManagerClientState* client_state) {
+  DCHECK(client_state->list_iterator_valid_);
+  ClientStateList* client_list = GetClientList(client_state);
+  client_list->erase(client_state->list_iterator_);
+  client_state->list_iterator_valid_ = false;
+}
+
 }  // namespace content
 
 #endif
Index: src/content/common/gpu/gpu_command_buffer_stub.cc
===================================================================
--- src/content/common/gpu/gpu_command_buffer_stub.cc	(revision 184497)
+++ src/content/common/gpu/gpu_command_buffer_stub.cc	(working copy)
@@ -46,25 +46,26 @@
 // ContextGroup's memory type managers and the GpuMemoryManager class.
 class GpuCommandBufferMemoryTracker : public gpu::gles2::MemoryTracker {
  public:
-  GpuCommandBufferMemoryTracker(GpuChannel* channel) {
-    gpu_memory_manager_tracking_group_ = new GpuMemoryTrackingGroup(
-        channel->renderer_pid(),
-        this,
-        channel->gpu_channel_manager()->gpu_memory_manager());
+  GpuCommandBufferMemoryTracker(GpuChannel* channel) :
+      tracking_group_(channel->gpu_channel_manager()->gpu_memory_manager()->
+          CreateTrackingGroup(channel->renderer_pid(), this)) {
   }
 
   void TrackMemoryAllocatedChange(size_t old_size,
                                   size_t new_size,
                                   gpu::gles2::MemoryTracker::Pool pool) {
-    gpu_memory_manager_tracking_group_->TrackMemoryAllocatedChange(
+    tracking_group_->TrackMemoryAllocatedChange(
         old_size, new_size, pool);
   }
 
+  virtual bool EnsureGPUMemoryAvailable(size_t size_needed) {
+    return tracking_group_->EnsureGPUMemoryAvailable(size_needed);
+  };
+
  private:
   ~GpuCommandBufferMemoryTracker() {
-    delete gpu_memory_manager_tracking_group_;
   }
-  GpuMemoryTrackingGroup* gpu_memory_manager_tracking_group_;
+  scoped_ptr<GpuMemoryTrackingGroup> tracking_group_;
 
   DISALLOW_COPY_AND_ASSIGN(GpuCommandBufferMemoryTracker);
 };
@@ -307,11 +308,14 @@
         active_url_));
   }
 
-  GetMemoryManager()->RemoveClient(this);
+  memory_manager_client_state_.reset();
 
   while (!sync_points_.empty())
     OnRetireSyncPoint(sync_points_.front());
 
+  if (decoder_.get())
+    decoder_->set_engine(NULL);
+
   // The scheduler has raw references to the decoder and the command buffer so
   // destroy it before those.
   scheduler_.reset();
@@ -761,8 +765,8 @@
 
 void GpuCommandBufferStub::OnSetSurfaceVisible(bool visible) {
   TRACE_EVENT0("gpu", "GpuCommandBufferStub::OnSetSurfaceVisible");
-  GetMemoryManager()->
-      SetClientVisible(this, visible);
+  if (memory_manager_client_state_.get())
+    memory_manager_client_state_->SetVisible(visible);
 }
 
 void GpuCommandBufferStub::OnDiscardBackbuffer() {
@@ -840,8 +844,8 @@
   TRACE_EVENT0(
       "gpu",
       "GpuCommandBufferStub::OnReceivedClientManagedMemoryStats");
-  GetMemoryManager()->
-      SetClientManagedMemoryStats(this, stats);
+  if (memory_manager_client_state_.get())
+    memory_manager_client_state_->SetManagedMemoryStats(stats);
 }
 
 void GpuCommandBufferStub::OnSetClientHasMemoryAllocationChangedCallback(
@@ -850,14 +854,12 @@
       "gpu",
       "GpuCommandBufferStub::OnSetClientHasMemoryAllocationChangedCallback");
   if (has_callback) {
-    GetMemoryManager()->AddClient(
-        this,
-        surface_id_ != 0,
-        true,
-        base::TimeTicks::Now());
+    if (!memory_manager_client_state_.get()) {
+      memory_manager_client_state_.reset(GetMemoryManager()->CreateClientState(
+          this, surface_id_ != 0, true));
+    }
   } else {
-    GetMemoryManager()->RemoveClient(
-        this);
+    memory_manager_client_state_.reset();
   }
 }
 
@@ -890,7 +892,7 @@
     scheduler_->SetPreemptByFlag(preemption_flag_);
 }
 
-bool GpuCommandBufferStub::GetTotalGpuMemory(size_t* bytes) {
+bool GpuCommandBufferStub::GetTotalGpuMemory(uint64* bytes) {
   *bytes = total_gpu_memory_;
   return !!total_gpu_memory_;
 }
Index: src/content/common/gpu/texture_image_transport_surface.cc
===================================================================
--- src/content/common/gpu/texture_image_transport_surface.cc	(revision 184497)
+++ src/content/common/gpu/texture_image_transport_surface.cc	(working copy)
@@ -117,10 +117,7 @@
     return true;
   }
 
-  if (!context_.get()) {
-    DCHECK(helper_->stub());
-    context_ = helper_->stub()->decoder()->GetGLContext();
-  }
+  context_ = context;
 
   if (!fbo_id_) {
     glGenFramebuffersEXT(1, &fbo_id_);
@@ -384,6 +381,22 @@
   if (backbuffer_.service_id && backbuffer_.size == current_size_)
     return;
 
+  // On Qualcomm we couldn't resize an FBO texture past a certain
+  // size, after we allocated it as 1x1. So here we simply delete
+  // the previous texture on resize, to insure we don't 'run out of
+  // memory'.
+  if (backbuffer_.service_id &&
+      helper_->stub()
+             ->decoder()
+             ->GetContextGroup()
+             ->feature_info()
+             ->workarounds()
+             .delete_instead_of_resize_fbo) {
+    glDeleteTextures(1, &backbuffer_.service_id);
+    backbuffer_.service_id = 0;
+    mailbox_name(backbuffer_.surface_handle) = MailboxName();
+  }
+
   if (!backbuffer_.service_id) {
     MailboxName new_mailbox_name;
     MailboxName& name = mailbox_name(backbuffer_.surface_handle);
Index: src/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc
===================================================================
--- src/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc	(revision 184497)
+++ src/content/common/gpu/client/webgraphicscontext3d_command_buffer_impl.cc	(working copy)
@@ -64,6 +64,12 @@
   }
 }
 
+size_t ClampUint64ToSizeT(uint64 value) {
+  value = std::min(value,
+                   static_cast<uint64>(std::numeric_limits<size_t>::max()));
+  return static_cast<size_t>(value);
+}
+
 const int32 kCommandBufferSize = 1024 * 1024;
 // TODO(kbr): make the transfer buffer size configurable via context
 // creation attributes.
@@ -1456,11 +1462,11 @@
   // Convert the gpu structure to the WebKit structure.
   WebGraphicsMemoryAllocation web_allocation;
   web_allocation.bytesLimitWhenVisible =
-      allocation.bytes_limit_when_visible;
+      ClampUint64ToSizeT(allocation.bytes_limit_when_visible);
   web_allocation.priorityCutoffWhenVisible =
       WebkitPriorityCutoff(allocation.priority_cutoff_when_visible);
   web_allocation.bytesLimitWhenNotVisible =
-      allocation.bytes_limit_when_not_visible;
+      ClampUint64ToSizeT(allocation.bytes_limit_when_not_visible);
   web_allocation.priorityCutoffWhenNotVisible =
       WebkitPriorityCutoff(allocation.priority_cutoff_when_not_visible);
   web_allocation.haveBackbufferWhenNotVisible =
@@ -1471,7 +1477,7 @@
   // Populate deprecated WebKit fields. These may be removed when references to
   // them in WebKit are removed.
   web_allocation.gpuResourceSizeInBytes =
-      allocation.bytes_limit_when_visible;
+      ClampUint64ToSizeT(allocation.bytes_limit_when_visible);
   web_allocation.suggestHaveBackbuffer =
       allocation.have_backbuffer_when_not_visible;
 
Index: src/content/common/gpu/client/command_buffer_proxy_impl.cc
===================================================================
--- src/content/common/gpu/client/command_buffer_proxy_impl.cc	(revision 184497)
+++ src/content/common/gpu/client/command_buffer_proxy_impl.cc	(working copy)
@@ -194,6 +194,11 @@
   return last_state_;
 }
 
+int32 CommandBufferProxyImpl::GetLastToken() {
+  TryUpdateState();
+  return last_state_.token;
+}
+
 void CommandBufferProxyImpl::Flush(int32 put_offset) {
   if (last_state_.error != gpu::error::kNoError)
     return;
Index: src/content/common/gpu/client/command_buffer_proxy_impl.h
===================================================================
--- src/content/common/gpu/client/command_buffer_proxy_impl.h	(revision 184497)
+++ src/content/common/gpu/client/command_buffer_proxy_impl.h	(working copy)
@@ -72,6 +72,7 @@
   virtual bool Initialize() OVERRIDE;
   virtual State GetState() OVERRIDE;
   virtual State GetLastState() OVERRIDE;
+  virtual int32 GetLastToken() OVERRIDE;
   virtual void Flush(int32 put_offset) OVERRIDE;
   virtual State FlushSync(int32 put_offset, int32 last_known_get) OVERRIDE;
   virtual void SetGetBuffer(int32 shm_id) OVERRIDE;
Index: src/content/common/cc_messages_unittest.cc
===================================================================
--- src/content/common/cc_messages_unittest.cc	(revision 184497)
+++ src/content/common/cc_messages_unittest.cc	(working copy)
@@ -43,15 +43,11 @@
     EXPECT_EQ(a->has_transparent_background, b->has_transparent_background);
     EXPECT_EQ(a->has_occlusion_from_outside_target_surface,
               b->has_occlusion_from_outside_target_surface);
-    EXPECT_EQ(a->filters, b->filters);
-    EXPECT_EQ(a->filter, b->filter);
-    EXPECT_EQ(a->background_filters, b->background_filters);
   }
 
   void Compare(const SharedQuadState* a, const SharedQuadState* b) {
     EXPECT_EQ(a->content_to_target_transform, b->content_to_target_transform);
     EXPECT_EQ(a->visible_content_rect, b->visible_content_rect);
-    EXPECT_EQ(a->clipped_rect_in_target, b->clipped_rect_in_target);
     EXPECT_EQ(a->clip_rect, b->clip_rect);
     EXPECT_EQ(a->is_clipped, b->is_clipped);
     EXPECT_EQ(a->opacity, b->opacity);
@@ -130,6 +126,9 @@
     EXPECT_EQ(a->contents_changed_since_last_frame,
               b->contents_changed_since_last_frame);
     EXPECT_EQ(a->mask_uv_rect.ToString(), b->mask_uv_rect.ToString());
+    EXPECT_EQ(a->filters, b->filters);
+    EXPECT_EQ(a->filter, b->filter);
+    EXPECT_EQ(a->background_filters, b->background_filters);
   }
 
   void Compare(const SolidColorDrawQuad* a, const SolidColorDrawQuad* b) {
@@ -144,7 +143,12 @@
   void Compare(const TextureDrawQuad* a, const TextureDrawQuad* b) {
     EXPECT_EQ(a->resource_id, b->resource_id);
     EXPECT_EQ(a->premultiplied_alpha, b->premultiplied_alpha);
-    EXPECT_EQ(a->uv_rect, b->uv_rect);
+    EXPECT_EQ(a->uv_top_left, b->uv_top_left);
+    EXPECT_EQ(a->uv_bottom_right, b->uv_bottom_right);
+    EXPECT_EQ(a->vertex_opacity[0], b->vertex_opacity[0]);
+    EXPECT_EQ(a->vertex_opacity[1], b->vertex_opacity[1]);
+    EXPECT_EQ(a->vertex_opacity[2], b->vertex_opacity[2]);
+    EXPECT_EQ(a->vertex_opacity[3], b->vertex_opacity[3]);
     EXPECT_EQ(a->flipped, b->flipped);
   }
 
@@ -196,11 +200,18 @@
   gfx::Size arbitrary_size3(75, 1281);
   gfx::RectF arbitrary_rectf1(4.2f, -922.1f, 15.6f, 29.5f);
   gfx::SizeF arbitrary_sizef1(15.2f, 104.6f);
+  gfx::PointF arbitrary_pointf1(31.4f, 15.9f);
+  gfx::PointF arbitrary_pointf2(26.5f, -35.8f);
   float arbitrary_float1 = 0.7f;
   float arbitrary_float2 = 0.3f;
   float arbitrary_float3 = 0.9f;
+  float arbitrary_float_array[4] = {3.5f, 6.2f, 9.3f, 12.3f};
   bool arbitrary_bool1 = true;
   bool arbitrary_bool2 = false;
+  bool arbitrary_bool3 = true;
+  bool arbitrary_bool4 = true;
+  bool arbitrary_bool5 = false;
+  bool arbitrary_bool6 = true;
   int arbitrary_int = 5;
   SkColor arbitrary_color = SkColorSetARGB(25, 36, 47, 58);
   IOSurfaceDrawQuad::Orientation arbitrary_orientation =
@@ -238,7 +249,6 @@
   shared_state1_in->SetAll(arbitrary_matrix,
                            arbitrary_rect1,
                            arbitrary_rect2,
-                           arbitrary_rect3,
                            arbitrary_bool1,
                            arbitrary_float1);
   scoped_ptr<SharedQuadState> shared_state1_cmp = shared_state1_in->Copy();
@@ -290,7 +300,10 @@
                         arbitrary_bool2,
                         arbitrary_resourceid,
                         arbitrary_rect1,
-                        arbitrary_rectf1);
+                        arbitrary_rectf1,
+                        arbitrary_filters1,
+                        arbitrary_filter, // TODO(piman): not serialized.
+                        arbitrary_filters2);
   scoped_ptr<RenderPassDrawQuad> renderpass_cmp = renderpass_in->Copy(
       renderpass_in->shared_quad_state, renderpass_in->render_pass_id);
 
@@ -298,7 +311,6 @@
   shared_state2_in->SetAll(arbitrary_matrix,
                            arbitrary_rect2,
                            arbitrary_rect3,
-                           arbitrary_rect1,
                            arbitrary_bool1,
                            arbitrary_float2);
   scoped_ptr<SharedQuadState> shared_state2_cmp = shared_state2_in->Copy();
@@ -307,7 +319,6 @@
   shared_state3_in->SetAll(arbitrary_matrix,
                            arbitrary_rect3,
                            arbitrary_rect1,
-                           arbitrary_rect2,
                            arbitrary_bool1,
                            arbitrary_float3);
   scoped_ptr<SharedQuadState> shared_state3_cmp = shared_state3_in->Copy();
@@ -335,6 +346,38 @@
   scoped_ptr<DrawQuad> streamvideo_cmp = streamvideo_in->Copy(
       streamvideo_in->shared_quad_state);
 
+  scoped_ptr<TextureDrawQuad> texture_in = TextureDrawQuad::Create();
+  texture_in->SetAll(shared_state1_in.get(),
+                     arbitrary_rect2,
+                     arbitrary_rect3,
+                     arbitrary_rect1,
+                     arbitrary_bool1,
+                     arbitrary_resourceid,
+                     arbitrary_bool2,
+                     arbitrary_pointf1,
+                     arbitrary_pointf2,
+                     arbitrary_float_array,
+                     arbitrary_bool3);
+  scoped_ptr<DrawQuad> texture_cmp = texture_in->Copy(
+      texture_in->shared_quad_state);
+
+  scoped_ptr<TileDrawQuad> tile_in = TileDrawQuad::Create();
+  tile_in->SetAll(shared_state1_in.get(),
+                  arbitrary_rect2,
+                  arbitrary_rect3,
+                  arbitrary_rect1,
+                  arbitrary_bool1,
+                  arbitrary_resourceid,
+                  arbitrary_rectf1,
+                  arbitrary_size1,
+                  arbitrary_bool2,
+                  arbitrary_bool3,
+                  arbitrary_bool4,
+                  arbitrary_bool5,
+                  arbitrary_bool6);
+  scoped_ptr<DrawQuad> tile_cmp = tile_in->Copy(
+      tile_in->shared_quad_state);
+
   scoped_ptr<YUVVideoDrawQuad> yuvvideo_in =
       YUVVideoDrawQuad::Create();
   yuvvideo_in->SetAll(shared_state1_in.get(),
@@ -355,21 +398,20 @@
                   arbitrary_rectf1,
                   arbitrary_matrix,
                   arbitrary_bool1,
-                  arbitrary_bool2,
-                  arbitrary_filters1,
-                  arbitrary_filter, // TODO(danakj): filter is not serialized.
-                  arbitrary_filters2);
+                  arbitrary_bool2);
 
-  pass_in->shared_quad_state_list.append(shared_state1_in.Pass());
-  pass_in->quad_list.append(checkerboard_in.PassAs<DrawQuad>());
-  pass_in->quad_list.append(debugborder_in.PassAs<DrawQuad>());
-  pass_in->quad_list.append(iosurface_in.PassAs<DrawQuad>());
-  pass_in->quad_list.append(renderpass_in.PassAs<DrawQuad>());
-  pass_in->shared_quad_state_list.append(shared_state2_in.Pass());
-  pass_in->shared_quad_state_list.append(shared_state3_in.Pass());
-  pass_in->quad_list.append(solidcolor_in.PassAs<DrawQuad>());
-  pass_in->quad_list.append(streamvideo_in.PassAs<DrawQuad>());
-  pass_in->quad_list.append(yuvvideo_in.PassAs<DrawQuad>());
+  pass_in->shared_quad_state_list.push_back(shared_state1_in.Pass());
+  pass_in->quad_list.push_back(checkerboard_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(debugborder_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(iosurface_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(renderpass_in.PassAs<DrawQuad>());
+  pass_in->shared_quad_state_list.push_back(shared_state2_in.Pass());
+  pass_in->shared_quad_state_list.push_back(shared_state3_in.Pass());
+  pass_in->quad_list.push_back(solidcolor_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(streamvideo_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(texture_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(tile_in.PassAs<DrawQuad>());
+  pass_in->quad_list.push_back(yuvvideo_in.PassAs<DrawQuad>());
 
   scoped_ptr<RenderPass> pass_cmp = RenderPass::Create();
   pass_cmp->SetAll(arbitrary_id,
@@ -377,33 +419,32 @@
                    arbitrary_rectf1,
                    arbitrary_matrix,
                    arbitrary_bool1,
-                   arbitrary_bool2,
-                   arbitrary_filters1,
-                   arbitrary_filter, // TODO(danakj): filter is not serialized.
-                   arbitrary_filters2);
+                   arbitrary_bool2);
 
-  pass_cmp->shared_quad_state_list.append(shared_state1_cmp.Pass());
-  pass_cmp->quad_list.append(checkerboard_cmp.PassAs<DrawQuad>());
-  pass_cmp->quad_list.append(debugborder_cmp.PassAs<DrawQuad>());
-  pass_cmp->quad_list.append(iosurface_cmp.PassAs<DrawQuad>());
-  pass_cmp->quad_list.append(renderpass_cmp.PassAs<DrawQuad>());
-  pass_cmp->shared_quad_state_list.append(shared_state2_cmp.Pass());
-  pass_cmp->shared_quad_state_list.append(shared_state3_cmp.Pass());
-  pass_cmp->quad_list.append(solidcolor_cmp.PassAs<DrawQuad>());
-  pass_cmp->quad_list.append(streamvideo_cmp.PassAs<DrawQuad>());
-  pass_cmp->quad_list.append(yuvvideo_cmp.PassAs<DrawQuad>());
+  pass_cmp->shared_quad_state_list.push_back(shared_state1_cmp.Pass());
+  pass_cmp->quad_list.push_back(checkerboard_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(debugborder_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(iosurface_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(renderpass_cmp.PassAs<DrawQuad>());
+  pass_cmp->shared_quad_state_list.push_back(shared_state2_cmp.Pass());
+  pass_cmp->shared_quad_state_list.push_back(shared_state3_cmp.Pass());
+  pass_cmp->quad_list.push_back(solidcolor_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(streamvideo_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(texture_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(tile_cmp.PassAs<DrawQuad>());
+  pass_cmp->quad_list.push_back(yuvvideo_cmp.PassAs<DrawQuad>());
 
   // Make sure the in and cmp RenderPasses match.
   Compare(pass_cmp.get(), pass_in.get());
   ASSERT_EQ(3u, pass_in->shared_quad_state_list.size());
-  ASSERT_EQ(7u, pass_in->quad_list.size());
+  ASSERT_EQ(9u, pass_in->quad_list.size());
   for (size_t i = 0; i < 3; ++i) {
     Compare(pass_cmp->shared_quad_state_list[i],
             pass_in->shared_quad_state_list[i]);
   }
-  for (size_t i = 0; i < 7; ++i)
+  for (size_t i = 0; i < pass_in->quad_list.size(); ++i)
     Compare(pass_cmp->quad_list[i], pass_in->quad_list[i]);
-  for (size_t i = 1; i < 7; ++i) {
+  for (size_t i = 1; i < pass_in->quad_list.size(); ++i) {
     bool same_shared_quad_state_cmp =
         pass_cmp->quad_list[i]->shared_quad_state ==
         pass_cmp->quad_list[i - 1]->shared_quad_state;
@@ -415,7 +456,7 @@
 
   DelegatedFrameData frame_in;
   frame_in.size = arbitrary_size1;
-  frame_in.render_pass_list.append(pass_in.Pass());
+  frame_in.render_pass_list.push_back(pass_in.Pass());
 
   IPC::ParamTraits<DelegatedFrameData>::Write(&msg, frame_in);
 
@@ -427,17 +468,18 @@
   EXPECT_EQ(arbitrary_size1, frame_out.size);
 
   // Make sure the out and cmp RenderPasses match.
-  scoped_ptr<RenderPass> pass_out = frame_out.render_pass_list.take(0);
+  scoped_ptr<RenderPass> pass_out = frame_out.render_pass_list.take(
+      frame_out.render_pass_list.begin());
   Compare(pass_cmp.get(), pass_out.get());
   ASSERT_EQ(3u, pass_out->shared_quad_state_list.size());
-  ASSERT_EQ(7u, pass_out->quad_list.size());
+  ASSERT_EQ(9u, pass_out->quad_list.size());
   for (size_t i = 0; i < 3; ++i) {
     Compare(pass_cmp->shared_quad_state_list[i],
             pass_out->shared_quad_state_list[i]);
   }
-  for (size_t i = 0; i < 7; ++i)
+  for (size_t i = 0; i < pass_out->quad_list.size(); ++i)
     Compare(pass_cmp->quad_list[i], pass_out->quad_list[i]);
-  for (size_t i = 1; i < 7; ++i) {
+  for (size_t i = 1; i < pass_out->quad_list.size(); ++i) {
     bool same_shared_quad_state_cmp =
         pass_cmp->quad_list[i]->shared_quad_state ==
         pass_cmp->quad_list[i - 1]->shared_quad_state;
Index: src/content/common/child_process.cc
===================================================================
--- src/content/common/child_process.cc	(revision 184497)
+++ src/content/common/child_process.cc	(working copy)
@@ -18,6 +18,8 @@
 
 #if defined(OS_ANDROID)
 #include "base/debug/debugger.h"
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
 #endif
 
 #if defined(OS_POSIX) && !defined(OS_ANDROID)
@@ -28,6 +30,16 @@
 
 ChildProcess* ChildProcess::child_process_;
 
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+namespace {
+void SetHighThreadPriority() {
+  int nice_value = -6; // High priority.
+  setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), nice_value);
+}
+}
+#endif
+
 ChildProcess::ChildProcess()
     : ref_count_(0),
       shutdown_event_(true, false),
@@ -40,6 +52,12 @@
   // We can't recover from failing to start the IO thread.
   CHECK(io_thread_.StartWithOptions(
             base::Thread::Options(MessageLoop::TYPE_IO, 0)));
+
+#if defined(OS_ANDROID)
+  // TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  io_thread_.message_loop()->PostTask(FROM_HERE,
+                                      base::Bind(&SetHighThreadPriority));
+#endif
 }
 
 ChildProcess::~ChildProcess() {
Index: src/content/common/cc_messages.cc
===================================================================
--- src/content/common/cc_messages.cc	(revision 184497)
+++ src/content/common/cc_messages.cc	(working copy)
@@ -295,9 +295,6 @@
   WriteParam(m, p.transform_to_root_target);
   WriteParam(m, p.has_transparent_background);
   WriteParam(m, p.has_occlusion_from_outside_target_surface);
-  WriteParam(m, p.filters);
-  // TODO(danakj): filter isn't being serialized.
-  WriteParam(m, p.background_filters);
   WriteParam(m, p.shared_quad_state_list.size());
   WriteParam(m, p.quad_list.size());
 
@@ -387,9 +384,6 @@
   gfx::Transform transform_to_root_target;
   bool has_transparent_background;
   bool has_occlusion_from_outside_target_surface;
-  WebKit::WebFilterOperations filters;
-  skia::RefPtr<SkImageFilter> filter;
-  WebKit::WebFilterOperations background_filters;
   size_t shared_quad_state_list_size;
   size_t quad_list_size;
 
@@ -399,8 +393,6 @@
       !ReadParam(m, iter, &transform_to_root_target) ||
       !ReadParam(m, iter, &has_transparent_background) ||
       !ReadParam(m, iter, &has_occlusion_from_outside_target_surface) ||
-      !ReadParam(m, iter, &filters) ||
-      !ReadParam(m, iter, &background_filters) ||
       !ReadParam(m, iter, &shared_quad_state_list_size) ||
       !ReadParam(m, iter, &quad_list_size))
     return false;
@@ -410,16 +402,13 @@
             damage_rect,
             transform_to_root_target,
             has_transparent_background,
-            has_occlusion_from_outside_target_surface,
-            filters,
-            filter, // TODO(danakj): filter isn't being serialized.
-            background_filters);
+            has_occlusion_from_outside_target_surface);
 
   for (size_t i = 0; i < shared_quad_state_list_size; ++i) {
     scoped_ptr<cc::SharedQuadState> state(cc::SharedQuadState::Create());
     if (!ReadParam(m, iter, state.get()))
       return false;
-    p->shared_quad_state_list.append(state.Pass());
+    p->shared_quad_state_list.push_back(state.Pass());
   }
 
   size_t last_shared_quad_state_index = 0;
@@ -476,7 +465,7 @@
     draw_quad->shared_quad_state =
         p->shared_quad_state_list[shared_quad_state_index];
 
-    p->quad_list.append(draw_quad.Pass());
+    p->quad_list.push_back(draw_quad.Pass());
   }
 
   return true;
@@ -497,11 +486,6 @@
   l->append(", ");
   LogParam(p.has_occlusion_from_outside_target_surface, l);
   l->append(", ");
-  LogParam(p.filters, l);
-  l->append(", ");
-  // TODO(danakj): filter isn't being serialized.
-  LogParam(p.background_filters, l);
-  l->append(", ");
 
   l->append("[");
   for (size_t i = 0; i < p.shared_quad_state_list.size(); ++i) {
@@ -653,7 +637,7 @@
     scoped_ptr<cc::RenderPass> render_pass = cc::RenderPass::Create();
     if (!ReadParam(m, iter, render_pass.get()))
       return false;
-    p->render_pass_list.append(render_pass.Pass());
+    p->render_pass_list.push_back(render_pass.Pass());
   }
   return true;
 }
Index: src/content/gpu/gpu_child_thread.cc
===================================================================
--- src/content/gpu/gpu_child_thread.cc	(revision 184497)
+++ src/content/gpu/gpu_child_thread.cc	(working copy)
@@ -21,6 +21,11 @@
 #include "ipc/ipc_sync_message_filter.h"
 #include "ui/gl/gl_implementation.h"
 
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
+#endif
+
 namespace content {
 namespace {
 
@@ -64,8 +69,10 @@
 #if defined(OS_WIN)
   target_services_ = NULL;
 #endif
-  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) ||
-      CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU)) {
+  in_browser_process_ =
+      CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) ||
+      CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU);
+  if (in_browser_process_) {
     // For single process and in-process GPU mode, we need to load and
     // initialize the GL implementation and locate the GL entry points here.
     if (!gfx::GLSurface::InitializeOneOff()) {
@@ -123,10 +130,15 @@
     return;
   }
 
+#if defined(OS_ANDROID)
+  // TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  int nice_value = -6; // High priority
+  setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), nice_value);
+#endif
+
   // We don't need to pipe log messages if we are running the GPU thread in
   // the browser process.
-  if (!CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) &&
-      !CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU))
+  if (!in_browser_process_)
     logging::SetLogMessageHandler(GpuProcessLogMessageHandler);
 
   // Record initialization only after collecting the GPU info because that can
@@ -144,7 +156,8 @@
 
   // Ensure the browser process receives the GPU info before a reply to any
   // subsequent IPC it might send.
-  Send(new GpuHostMsg_GraphicsInfoCollected(gpu_info_));
+  if (!in_browser_process_)
+    Send(new GpuHostMsg_GraphicsInfoCollected(gpu_info_));
 }
 
 void GpuChildThread::StopWatchdog() {
@@ -159,8 +172,7 @@
   // or single process/in-process gpu mode on Windows.
   CommandLine* command_line = CommandLine::ForCurrentProcess();
   DCHECK(command_line->HasSwitch(switches::kDisableGpuSandbox) ||
-         command_line->HasSwitch(switches::kSingleProcess) ||
-         command_line->HasSwitch(switches::kInProcessGPU));
+         in_browser_process_);
 #endif  // OS_WIN
 
   if (!gpu_info_collector::CollectContextGraphicsInfo(&gpu_info_))
@@ -178,8 +190,7 @@
   Send(new GpuHostMsg_GraphicsInfoCollected(gpu_info_));
 
 #if defined(OS_WIN)
-  if (!command_line->HasSwitch(switches::kSingleProcess) &&
-      !command_line->HasSwitch(switches::kInProcessGPU)) {
+  if (!in_browser_process_) {
     // The unsandboxed GPU process fulfilled its duty.  Rest in peace.
     MessageLoop::current()->Quit();
   }
@@ -190,7 +201,7 @@
   GPUVideoMemoryUsageStats video_memory_usage_stats;
   if (gpu_channel_manager_.get())
     gpu_channel_manager_->gpu_memory_manager()->GetVideoMemoryUsageStats(
-        video_memory_usage_stats);
+        &video_memory_usage_stats);
   Send(new GpuHostMsg_VideoMemoryUsageStats(video_memory_usage_stats));
 }
 
Index: src/content/gpu/gpu_child_thread.h
===================================================================
--- src/content/gpu/gpu_child_thread.h	(revision 184497)
+++ src/content/gpu/gpu_child_thread.h	(working copy)
@@ -82,6 +82,9 @@
   // Information about the GPU, such as device and vendor ID.
   GPUInfo gpu_info_;
 
+  // Whether the GPU thread is running in the browser process.
+  bool in_browser_process_;
+
   DISALLOW_COPY_AND_ASSIGN(GpuChildThread);
 };
 
Index: src/content/gpu/gpu_info_collector_android.cc
===================================================================
--- src/content/gpu/gpu_info_collector_android.cc	(revision 184497)
+++ src/content/gpu/gpu_info_collector_android.cc	(working copy)
@@ -4,12 +4,15 @@
 
 #include "content/gpu/gpu_info_collector.h"
 
+#include "base/android/build_info.h"
 #include "base/command_line.h"
 #include "base/logging.h"
 #include "base/string_number_conversions.h"
 #include "base/string_piece.h"
 #include "base/string_split.h"
 #include "base/string_util.h"
+#include "cc/switches.h"
+#include "content/common/android/device_info.h"
 #include "content/public/common/content_switches.h"
 
 namespace {
@@ -63,16 +66,66 @@
   bool is_img = vendor.find("imagination") != std::string::npos;
   bool is_arm = vendor.find("arm") != std::string::npos;
   bool is_qualcomm = vendor.find("qualcomm") != std::string::npos;
-  bool is_nvidia = vendor.find("nvidia") != std::string::npos;
   bool is_mali_t604 = is_arm && renderer.find("mali-t604") != std::string::npos;
 
+  base::android::BuildInfo* build_info =
+      base::android::BuildInfo::GetInstance();
+  std::string model = build_info->model();
+  model = StringToLowerASCII(model);
+  bool is_nexus7 = model.find("nexus 7") != std::string::npos;
+  bool is_nexus10 = model.find("nexus 10") != std::string::npos;
+
   // IMG: avoid context switching perf problems, crashes with share groups
   // Mali-T604: http://crbug.com/154715
   // QualComm, NVIDIA: Crashes with share groups
-  if (is_img || is_mali_t604 || is_qualcomm || is_nvidia) {
+  if (is_img || is_mali_t604 || is_qualcomm || is_nexus7) {
     CommandLine::ForCurrentProcess()->AppendSwitch(
         switches::kEnableVirtualGLContexts);
   }
+
+  content::DeviceInfo info;
+  int default_tile_size = 256;
+
+  // For very high resolution displays (eg. Nexus 10), set the default
+  // tile size to be 512. This should be removed in favour of a generic
+  // hueristic that works across all platforms and devices, once that
+  // exists: http://crbug.com/159524. This switches to 512 for screens
+  // containing 40 or more 256x256 tiles, such that 1080p devices do
+  // not use 512x512 tiles (eg. 1920x1280 requires 37.5 tiles)
+  int numTiles = (info.GetWidth() *
+                  info.GetHeight()) / (256 * 256);
+  if (numTiles >= 40)
+    default_tile_size = 512;
+
+  // IMG: Fast async texture uploads only work with non-power-of-two,
+  // but still multiple-of-eight sizes.
+  // http://crbug.com/168099
+  if (is_img)
+    default_tile_size -= 8;
+
+  // Set the command line if it isn't already set and we changed
+  // the default tile size.
+  if (default_tile_size != 256 &&
+      !CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDefaultTileWidth) &&
+      !CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDefaultTileHeight)) {
+    std::stringstream size;
+    size << default_tile_size;
+    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
+        switches::kDefaultTileWidth, size.str());
+    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
+        switches::kDefaultTileHeight, size.str());
+  }
+
+  // Increase the resolution of low resolution tiles for Nexus 10.
+  if (is_nexus10 &&
+      !CommandLine::ForCurrentProcess()->HasSwitch(
+          cc::switches::kLowResolutionContentsScaleFactor)) {
+    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
+        cc::switches::kLowResolutionContentsScaleFactor, "0.25");
+  }
+
   return true;
 }
 
Index: src/content/port/browser/render_widget_host_view_port.h
===================================================================
--- src/content/port/browser/render_widget_host_view_port.h	(revision 184497)
+++ src/content/port/browser/render_widget_host_view_port.h	(working copy)
@@ -11,6 +11,7 @@
 #include "content/common/content_export.h"
 #include "content/port/common/input_event_ack_state.h"
 #include "content/public/browser/render_widget_host_view.h"
+#include "ipc/ipc_listener.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebPopupType.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebTextDirection.h"
 #include "ui/base/ime/text_input_type.h"
@@ -23,6 +24,7 @@
 struct GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params;
 struct GpuHostMsg_AcceleratedSurfacePostSubBuffer_Params;
 struct ViewHostMsg_TextInputState_Params;
+struct ViewHostMsg_SelectionBounds_Params;
 
 namespace webkit {
 namespace npapi {
@@ -48,7 +50,8 @@
 // This is the larger RenderWidgetHostView interface exposed only
 // within content/ and to embedders looking to port to new platforms.
 // RenderWidgetHostView class hierarchy described in render_widget_host_view.h.
-class CONTENT_EXPORT RenderWidgetHostViewPort : public RenderWidgetHostView {
+class CONTENT_EXPORT RenderWidgetHostViewPort : public RenderWidgetHostView,
+                                                public IPC::Listener {
  public:
   virtual ~RenderWidgetHostViewPort() {}
 
@@ -147,10 +150,8 @@
   // |start_rect| and |end_rect| are the bounds end of the selection in the
   // coordinate system of the render view. |start_direction| and |end_direction|
   // indicates the direction at which the selection was made on touch devices.
-  virtual void SelectionBoundsChanged(const gfx::Rect& start_rect,
-                                      WebKit::WebTextDirection start_direction,
-                                      const gfx::Rect& end_rect,
-                                      WebKit::WebTextDirection end_direction) {}
+  virtual void SelectionBoundsChanged(
+      const ViewHostMsg_SelectionBounds_Params& params) {}
 
   // Notifies the view that the scroll offset has changed.
   virtual void ScrollOffsetChanged() {}
@@ -240,7 +241,9 @@
                                float page_scale_factor,
                                float min_page_scale_factor,
                                float max_page_scale_factor,
-                               const gfx::Size& content_size) = 0;
+                               const gfx::Size& content_size,
+                               const gfx::Vector2dF& controls_offset,
+                               const gfx::Vector2dF& content_offset) = 0;
   virtual void HasTouchEventHandlers(bool need_touch_events) = 0;
 #endif
 
Index: src/content/content_common.gypi
===================================================================
--- src/content/content_common.gypi	(revision 184497)
+++ src/content/content_common.gypi	(working copy)
@@ -223,6 +223,9 @@
     'common/gpu/gpu_memory_allocation.h',
     'common/gpu/gpu_memory_manager.cc',
     'common/gpu/gpu_memory_manager.h',
+    'common/gpu/gpu_memory_manager_client.cc',
+    'common/gpu/gpu_memory_manager_client.h',
+    'common/gpu/gpu_memory_tracking.cc',
     'common/gpu/gpu_memory_tracking.h',
     'common/gpu/gpu_memory_uma_stats.h',
     'common/gpu/gpu_messages.h',
Index: src/content/content_tests.gypi
===================================================================
--- src/content/content_tests.gypi	(revision 184497)
+++ src/content/content_tests.gypi	(working copy)
@@ -683,6 +683,7 @@
             'browser/fileapi/blob_layout_browsertest.cc',
             'browser/fileapi/file_system_browsertest.cc',
             'browser/gpu/gpu_crash_browsertest.cc',
+            'browser/gpu/gpu_memory_test.cc',
             'browser/gpu/webgl_conformance_test.cc',
             'browser/gpu/webgl_conformance_test_list_autogen.h',
             'browser/in_process_webkit/indexed_db_browsertest.cc',
Index: src/content/renderer/render_view_impl.cc
===================================================================
--- src/content/renderer/render_view_impl.cc	(revision 184497)
+++ src/content/renderer/render_view_impl.cc	(working copy)
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <cmath>
 
+#include "base/auto_reset.h"
 #include "base/bind.h"
 #include "base/bind_helpers.h"
 #include "base/command_line.h"
@@ -186,6 +187,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/point.h"
 #include "ui/gfx/rect.h"
+#include "ui/gfx/rect_conversions.h"
 #include "ui/gfx/size_conversions.h"
 #include "v8/include/v8.h"
 #include "webkit/appcache/web_application_cache_host_impl.h"
@@ -1309,6 +1311,7 @@
   if (!webview())
     return;
 
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->executeCommand(WebString::fromUTF8("Cut"));
 }
 
@@ -1316,6 +1319,7 @@
   if (!webview())
     return;
 
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->executeCommand(WebString::fromUTF8("Copy"),
                                             context_menu_node_);
 }
@@ -1340,6 +1344,7 @@
   if (!webview())
     return;
 
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->executeCommand(WebString::fromUTF8("Paste"));
 }
 
@@ -1347,6 +1352,7 @@
   if (!webview())
     return;
 
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->executeCommand(
       WebString::fromUTF8("PasteAndMatchStyle"));
 }
@@ -1372,6 +1378,7 @@
   if (!webview())
     return;
 
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->executeCommand(
       WebString::fromUTF8("SelectAll"));
 }
@@ -1380,11 +1387,17 @@
   if (!webview())
     return;
 
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->executeCommand(WebString::fromUTF8("Unselect"));
 }
 
 void RenderViewImpl::OnSetEditableSelectionOffsets(int start, int end) {
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
+  DCHECK(!handling_ime_event_);
+  handling_ime_event_ = true;
   webview()->setEditableSelectionOffsets(start, end);
+  handling_ime_event_ = false;
+  UpdateTextInputState(DO_NOT_SHOW_IME);
 }
 
 void RenderViewImpl::OnSetCompositionFromExistingText(
@@ -1392,13 +1405,21 @@
     const std::vector<WebKit::WebCompositionUnderline>& underlines) {
   if (!webview())
     return;
+  DCHECK(!handling_ime_event_);
+  handling_ime_event_ = true;
   webview()->setCompositionFromExistingText(start, end, underlines);
+  handling_ime_event_ = false;
+  UpdateTextInputState(DO_NOT_SHOW_IME);
 }
 
 void RenderViewImpl::OnExtendSelectionAndDelete(int before, int after) {
   if (!webview())
     return;
+  DCHECK(!handling_ime_event_);
+  handling_ime_event_ = true;
   webview()->extendSelectionAndDelete(before, after);
+  handling_ime_event_ = false;
+  UpdateTextInputState(DO_NOT_SHOW_IME);
 }
 
 void RenderViewImpl::OnSelectRange(const gfx::Point& start,
@@ -1408,9 +1429,8 @@
 
   Send(new ViewHostMsg_SelectRange_ACK(routing_id_));
 
-  handling_select_range_ = true;
+  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
   webview()->focusedFrame()->selectRange(start, end);
-  handling_select_range_ = false;
 }
 
 void RenderViewImpl::OnMoveCaret(const gfx::Point& point) {
@@ -2045,15 +2065,19 @@
 #endif
 }
 
+void RenderViewImpl::didCancelCompositionOnSelectionChange() {
+  Send(new ViewHostMsg_ImeCancelComposition(routing_id()));
+}
+
 void RenderViewImpl::didChangeSelection(bool is_empty_selection) {
   if (!handling_input_event_ && !handling_select_range_)
-      return;
-  handling_select_range_ = false;
+    return;
 
   if (is_empty_selection)
     selection_text_.clear();
 
   SyncSelectionIfRequired();
+  UpdateTextInputState(DO_NOT_SHOW_IME);
 }
 
 void RenderViewImpl::didExecuteCommand(const WebString& command_name) {
@@ -2090,18 +2114,6 @@
   return did_execute_command;
 }
 
-void RenderViewImpl::didHandleGestureEvent(const WebGestureEvent& event,
-                                           bool event_swallowed) {
-#if defined(OS_ANDROID)
-  if (event.type == WebInputEvent::GestureTap ||
-      event.type == WebInputEvent::GestureLongPress) {
-    UpdateTextInputState(SHOW_IME_IF_NEEDED);
-  }
-#endif
-  FOR_EACH_OBSERVER(RenderViewObserver, observers_,
-                    DidHandleGestureEvent(event));
-}
-
 WebKit::WebColorChooser* RenderViewImpl::createColorChooser(
     WebKit::WebColorChooserClient* client,
     const WebKit::WebColor& initial_color) {
@@ -2239,10 +2251,8 @@
   gfx::Rect start_rect;
   gfx::Rect end_rect;
   GetSelectionBounds(&start_rect, &end_rect);
-  params.selection_start =
-      gfx::Point(start_rect.x(), start_rect.bottom()) + GetScrollOffset();
-  params.selection_end =
-      gfx::Point(end_rect.right(), end_rect.bottom()) + GetScrollOffset();
+  params.selection_start = gfx::Point(start_rect.x(), start_rect.bottom());
+  params.selection_end = gfx::Point(end_rect.right(), end_rect.bottom());
 #endif
 
   Send(new ViewHostMsg_ContextMenu(routing_id_, params));
@@ -2279,6 +2289,13 @@
   }
 }
 
+gfx::RectF RenderViewImpl::ClientRectToPhysicalWindowRect(
+    const gfx::RectF& rect) const {
+  gfx::RectF window_rect = rect;
+  window_rect.Scale(device_scale_factor_ * webview()->pageScaleFactor());
+  return window_rect;
+}
+
 void RenderViewImpl::StartNavStateSyncTimerIfNecessary() {
   // No need to update state if no page has committed yet.
   if (page_id_ == -1)
@@ -2515,6 +2532,14 @@
   ProcessAcceleratedPinchZoomFlags(*CommandLine::ForCurrentProcess());
 }
 
+void RenderViewImpl::didHandleGestureEvent(
+    const WebGestureEvent& event,
+    bool event_cancelled) {
+  RenderWidget::didHandleGestureEvent(event, event_cancelled);
+  FOR_EACH_OBSERVER(RenderViewObserver, observers_,
+                    DidHandleGestureEvent(event));
+}
+
 // WebKit::WebFrameClient -----------------------------------------------------
 
 WebPlugin* RenderViewImpl::createPlugin(WebFrame* frame,
@@ -4681,7 +4706,6 @@
     selection_text_offset_ = offset;
     selection_range_ = range;
     Send(new ViewHostMsg_SelectionChanged(routing_id_, text, offset, range));
-    UpdateTextInputState(DO_NOT_SHOW_IME);
   }
 }
 
@@ -6497,13 +6521,16 @@
       event.x - event.data.tap.width / 2, event.y - event.data.tap.height / 2,
       event.data.tap.width, event.data.tap.height);
   gfx::Rect zoom_rect;
-  float scale = DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(
-      finger_rect, target_rects, GetSize(), &zoom_rect);
-  if (!scale)
+  float new_total_scale =
+      DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(
+          finger_rect, target_rects, GetSize(),
+          gfx::Rect(webview()->mainFrame()->visibleContentRect()).size(),
+          device_scale_factor_ * webview()->pageScaleFactor(), &zoom_rect);
+  if (!new_total_scale)
     return false;
 
-  gfx::Size canvas_size = zoom_rect.size();
-  canvas_size = ToCeiledSize(gfx::ScaleSize(canvas_size, scale));
+  gfx::Size canvas_size = gfx::ToCeiledSize(gfx::ScaleSize(zoom_rect.size(),
+                                                           new_total_scale));
   TransportDIB* transport_dib = NULL;
   {
     scoped_ptr<skia::PlatformCanvas> canvas(
@@ -6512,14 +6539,23 @@
     if (!canvas.get())
       return false;
 
-    canvas->scale(scale, scale);
+    // TODO(trchen): Cleanup the device scale factor mess.
+    // device scale will be applied in WebKit
+    // --> zoom_rect doesn't include device scale,
+    //     but WebKit will still draw on zoom_rect * device_scale_factor_
+    canvas->scale(new_total_scale / device_scale_factor_,
+                  new_total_scale / device_scale_factor_);
+    canvas->translate(-zoom_rect.x() * device_scale_factor_,
+                      -zoom_rect.y() * device_scale_factor_);
 
-    canvas->translate(-zoom_rect.x(), -zoom_rect.y());
     webwidget_->paint(webkit_glue::ToWebCanvas(canvas.get()), zoom_rect,
         WebWidget::ForceSoftwareRenderingAndIgnoreGPUResidentContent);
   }
+
+  gfx::Rect physical_window_zoom_rect = gfx::ToEnclosingRect(
+      ClientRectToPhysicalWindowRect(gfx::RectF(zoom_rect)));
   Send(new ViewHostMsg_ShowDisambiguationPopup(routing_id_,
-                                               zoom_rect,
+                                               physical_window_zoom_rect,
                                                canvas_size,
                                                transport_dib->id()));
 
Index: src/content/renderer/disambiguation_popup_helper.cc
===================================================================
--- src/content/renderer/disambiguation_popup_helper.cc	(revision 184497)
+++ src/content/renderer/disambiguation_popup_helper.cc	(working copy)
@@ -29,20 +29,22 @@
 
 // Compute the scaling factor to ensure the smallest touch candidate reaches
 // a certain clickable size after zooming
-float FindOptimalScaleFactor(const WebVector<WebRect>& target_rects) {
+float FindOptimalScaleFactor(const WebVector<WebRect>& target_rects,
+                             float total_scale) {
   using std::min;
   using std::max;
   if (!target_rects.size()) // shall never reach
     return kDisambiguationPopupMinScale;
-  int smallest_target = min(target_rects[0].width, target_rects[0].height);
+  float smallest_target = min(target_rects[0].width * total_scale,
+                              target_rects[0].height * total_scale);
   for (size_t i = 1; i < target_rects.size(); i++) {
-    smallest_target = min(smallest_target, target_rects[i].width);
-    smallest_target = min(smallest_target, target_rects[i].height);
+    smallest_target = min(smallest_target, target_rects[i].width * total_scale);
+    smallest_target = min(smallest_target,
+        target_rects[i].height * total_scale);
   }
-  smallest_target = max(smallest_target, 1);
+  smallest_target = max(smallest_target, 1.0f);
   return min(kDisambiguationPopupMaxScale, max(kDisambiguationPopupMinScale,
-      static_cast<float>(kDisambiguationPopupMinimumTouchSize)
-          / smallest_target));
+      kDisambiguationPopupMinimumTouchSize / smallest_target)) * total_scale;
 }
 
 void TrimEdges(int *e1, int *e2, int max_combined) {
@@ -88,19 +90,23 @@
 float DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(
     const gfx::Rect& tap_rect,
     const WebVector<WebRect>& target_rects,
-    const gfx::Size& viewport_size,
+    const gfx::Size& screen_size,
+    const gfx::Size& visible_content_size,
+    float total_scale,
     gfx::Rect* zoom_rect) {
   *zoom_rect = tap_rect;
   for (size_t i = 0; i < target_rects.size(); i++)
     zoom_rect->Union(gfx::Rect(target_rects[i]));
   zoom_rect->Inset(-kDisambiguationPopupPadding, -kDisambiguationPopupPadding);
-  zoom_rect->Intersect(gfx::Rect(viewport_size));
 
-  float scale = FindOptimalScaleFactor(target_rects);
+  zoom_rect->Intersect(gfx::Rect(visible_content_size));
+
+  float new_total_scale =
+      FindOptimalScaleFactor(target_rects, total_scale);
   *zoom_rect = CropZoomArea(
-      *zoom_rect, viewport_size, tap_rect.CenterPoint(), scale);
+      *zoom_rect, screen_size, tap_rect.CenterPoint(), new_total_scale);
 
-  return scale;
+  return new_total_scale;
 }
 
 } // namespace content
Index: src/content/renderer/render_view_impl.h
===================================================================
--- src/content/renderer/render_view_impl.h	(revision 184497)
+++ src/content/renderer/render_view_impl.h	(working copy)
@@ -406,6 +406,8 @@
   virtual void requestPointerUnlock();
   virtual bool isPointerLocked();
   virtual void didActivateCompositor(int input_handler_identifier);
+  virtual void didHandleGestureEvent(const WebKit::WebGestureEvent& event,
+                                     bool event_cancelled) OVERRIDE;
 
   // WebKit::WebViewClient implementation --------------------------------------
 
@@ -438,11 +440,10 @@
                                      double load_progress);
   virtual bool isSmartInsertDeleteEnabled();
   virtual bool isSelectTrailingWhitespaceEnabled();
+  virtual void didCancelCompositionOnSelectionChange();
   virtual void didChangeSelection(bool is_selection_empty);
   virtual void didExecuteCommand(const WebKit::WebString& command_name);
   virtual bool handleCurrentKeyboardEvent();
-  virtual void didHandleGestureEvent(const WebKit::WebGestureEvent& event,
-                                     bool event_swallowed) OVERRIDE;
   virtual WebKit::WebColorChooser* createColorChooser(
       WebKit::WebColorChooserClient*, const WebKit::WebColor& initial_color);
   virtual bool runFileChooser(
@@ -1193,6 +1194,10 @@
   // If |url| is empty, show |fallback_url|.
   void UpdateTargetURL(const GURL& url, const GURL& fallback_url);
 
+  // Coordinate conversion -----------------------------------------------------
+
+  gfx::RectF ClientRectToPhysicalWindowRect(const gfx::RectF& rect) const;
+
   // ---------------------------------------------------------------------------
   // ADDING NEW FUNCTIONS? Please keep private functions alphabetized and put
   // it in the same order in the .cc file as it was in the header.
Index: src/content/renderer/disambiguation_popup_helper_unittest.cc
===================================================================
--- src/content/renderer/disambiguation_popup_helper_unittest.cc	(revision 184497)
+++ src/content/renderer/disambiguation_popup_helper_unittest.cc	(working copy)
@@ -22,9 +22,13 @@
 class DisambiguationPopupHelperUnittest : public testing::Test {
  public:
   DisambiguationPopupHelperUnittest()
-      : kViewportSize_(640, 480) { }
+      : kScreenSize_(640, 480)
+      , kVisibleContentSize_(640, 480)
+      , kImplScale_(1) { }
  protected:
-  const gfx::Size kViewportSize_;
+  const gfx::Size kScreenSize_;
+  const gfx::Size kVisibleContentSize_;
+  const float kImplScale_;
 };
 
 TEST_F(DisambiguationPopupHelperUnittest, ClipByViewport) {
@@ -34,13 +38,14 @@
 
   gfx::Rect zoom_rect;
   float scale = DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(
-      tap_rect, target_rects, kViewportSize_, &zoom_rect);
+      tap_rect, target_rects, kScreenSize_, kVisibleContentSize_, kImplScale_,
+      &zoom_rect);
 
-  EXPECT_TRUE(gfx::Rect(kViewportSize_).Contains(zoom_rect));
+  EXPECT_TRUE(gfx::Rect(kVisibleContentSize_).Contains(zoom_rect));
   EXPECT_LE(kDisambiguationPopupMinScale, scale);
 
   gfx::Size scaled_size = ToCeiledSize(ScaleSize(zoom_rect.size(), scale));
-  EXPECT_TRUE(gfx::Rect(kViewportSize_).Contains(gfx::Rect(scaled_size)));
+  EXPECT_TRUE(gfx::Rect(kScreenSize_).Contains(gfx::Rect(scaled_size)));
 }
 
 TEST_F(DisambiguationPopupHelperUnittest, MiniTarget) {
@@ -50,14 +55,15 @@
 
   gfx::Rect zoom_rect;
   float scale = DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(
-      tap_rect, target_rects, kViewportSize_, &zoom_rect);
+      tap_rect, target_rects, kScreenSize_, kVisibleContentSize_, kImplScale_,
+      &zoom_rect);
 
-  EXPECT_TRUE(gfx::Rect(kViewportSize_).Contains(zoom_rect));
+  EXPECT_TRUE(gfx::Rect(kVisibleContentSize_).Contains(zoom_rect));
   EXPECT_EQ(kDisambiguationPopupMaxScale, scale);
   EXPECT_TRUE(zoom_rect.Contains(target_rects[0]));
 
   gfx::Size scaled_size = ToCeiledSize(ScaleSize(zoom_rect.size(), scale));
-  EXPECT_TRUE(gfx::Rect(kViewportSize_).Contains(gfx::Rect(scaled_size)));
+  EXPECT_TRUE(gfx::Rect(kScreenSize_).Contains(gfx::Rect(scaled_size)));
 }
 
 TEST_F(DisambiguationPopupHelperUnittest, LongLinks) {
@@ -68,14 +74,15 @@
 
   gfx::Rect zoom_rect;
   float scale = DisambiguationPopupHelper::ComputeZoomAreaAndScaleFactor(
-      tap_rect, target_rects, kViewportSize_, &zoom_rect);
+      tap_rect, target_rects, kScreenSize_, kVisibleContentSize_, kImplScale_,
+      &zoom_rect);
 
-  EXPECT_TRUE(gfx::Rect(kViewportSize_).Contains(zoom_rect));
+  EXPECT_TRUE(gfx::Rect(kVisibleContentSize_).Contains(zoom_rect));
   EXPECT_EQ(kDisambiguationPopupMaxScale, scale);
   EXPECT_TRUE(zoom_rect.Contains(tap_rect));
 
   gfx::Size scaled_size = ToCeiledSize(ScaleSize(zoom_rect.size(), scale));
-  EXPECT_TRUE(gfx::Rect(kViewportSize_).Contains(gfx::Rect(scaled_size)));
+  EXPECT_TRUE(gfx::Rect(kScreenSize_).Contains(gfx::Rect(scaled_size)));
 }
 
 } // namespace content
Index: src/content/renderer/render_widget.cc
===================================================================
--- src/content/renderer/render_widget.cc	(revision 184497)
+++ src/content/renderer/render_widget.cc	(working copy)
@@ -96,6 +96,7 @@
       needs_repainting_on_restore_(false),
       has_focus_(false),
       handling_input_event_(false),
+      handling_ime_event_(false),
       closing_(false),
       is_swapped_out_(swapped_out),
       input_method_is_active_(false),
@@ -251,6 +252,9 @@
     IPC_MESSAGE_HANDLER(ViewMsg_Move_ACK, OnRequestMoveAck)
     IPC_MESSAGE_HANDLER(ViewMsg_ScreenInfoChanged, OnScreenInfoChanged)
     IPC_MESSAGE_HANDLER(ViewMsg_UpdateScreenRects, OnUpdateScreenRects)
+#if defined(OS_ANDROID)
+    IPC_MESSAGE_HANDLER(ViewMsg_ImeBatchStateChanged, OnImeBatchStateChanged)
+#endif
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
@@ -742,7 +746,7 @@
       base::TimeDelta paint_time =
           base::TimeTicks::HighResNow() - paint_begin_ticks;
       if (!is_accelerated_compositing_active_)
-        software_stats_.totalPaintTimeInSeconds += paint_time.InSecondsF();
+        software_stats_.totalPaintTime += paint_time;
     }
   } else {
     // Normal painting case.
@@ -756,7 +760,7 @@
       base::TimeDelta paint_time =
           base::TimeTicks::HighResNow() - paint_begin_ticks;
       if (!is_accelerated_compositing_active_)
-        software_stats_.totalPaintTimeInSeconds += paint_time.InSecondsF();
+        software_stats_.totalPaintTime += paint_time;
     }
 
     // Flush to underlying bitmap.  TODO(darin): is this needed?
@@ -769,7 +773,7 @@
   if (kEnableGpuBenchmarking) {
     base::TimeDelta rasterize_time =
         base::TimeTicks::HighResNow() - rasterize_begin_ticks;
-    software_stats_.totalRasterizeTimeInSeconds += rasterize_time.InSecondsF();
+    software_stats_.totalRasterizeTime += rasterize_time;
 
     int64 num_pixels_processed = rect.width() * rect.height();
     software_stats_.totalPixelsPainted += num_pixels_processed;
@@ -1241,9 +1245,7 @@
   // The following two can result in further layout and possibly
   // enable GPU acceleration so they need to be called before any painting
   // is done.
-#if !defined(OS_ANDROID)
   UpdateTextInputState(DO_NOT_SHOW_IME);
-#endif  // OS_ANDROID
   UpdateSelectionBounds();
 
   WillInitiatePaint();
@@ -1458,6 +1460,8 @@
     int selection_start, int selection_end) {
   if (!webwidget_)
     return;
+  DCHECK(!handling_ime_event_);
+  handling_ime_event_ = true;
   if (webwidget_->setComposition(
       text, WebVector<WebCompositionUnderline>(underlines),
       selection_start, selection_end)) {
@@ -1492,13 +1496,16 @@
     }
     UpdateCompositionInfo(range, std::vector<gfx::Rect>());
   }
+  handling_ime_event_ = false;
+  UpdateTextInputState(DO_NOT_SHOW_IME);
 }
 
 void RenderWidget::OnImeConfirmComposition(
     const string16& text, const ui::Range& replacement_range) {
   if (!webwidget_)
     return;
-
+  DCHECK(!handling_ime_event_);
+  handling_ime_event_ = true;
   handling_input_event_ = true;
   webwidget_->confirmComposition(text);
   handling_input_event_ = false;
@@ -1511,6 +1518,8 @@
     range.set_end(location + length);
   }
   UpdateCompositionInfo(range, std::vector<gfx::Rect>());
+  handling_ime_event_ = false;
+  UpdateTextInputState(DO_NOT_SHOW_IME);
 }
 
 // This message causes the renderer to render an image of the
@@ -1635,6 +1644,12 @@
   Send(new ViewHostMsg_UpdateScreenRects_ACK(routing_id()));
 }
 
+#if defined(OS_ANDROID)
+void RenderWidget::OnImeBatchStateChanged(bool is_begin) {
+  Send(new ViewHostMsg_ImeBatchStateChanged_ACK(routing_id(), is_begin));
+}
+#endif
+
 void RenderWidget::SetDeviceScaleFactor(float device_scale_factor) {
   if (device_scale_factor_ == device_scale_factor)
     return;
@@ -1735,6 +1750,8 @@
 
 
 void RenderWidget::UpdateTextInputState(ShowIme show_ime) {
+  if (handling_ime_event_)
+    return;
   bool show_ime_if_needed = (show_ime == SHOW_IME_IF_NEEDED);
   if (!show_ime_if_needed && !input_method_is_active_)
     return;
@@ -1770,29 +1787,27 @@
   }
 }
 
-void RenderWidget::GetSelectionBounds(gfx::Rect* start, gfx::Rect* end) {
-  WebRect start_webrect;
-  WebRect end_webrect;
-  webwidget_->selectionBounds(start_webrect, end_webrect);
-  *start = start_webrect;
-  *end = end_webrect;
+void RenderWidget::GetSelectionBounds(gfx::Rect* focus, gfx::Rect* anchor) {
+  WebRect focus_webrect;
+  WebRect anchor_webrect;
+  webwidget_->selectionBounds(focus_webrect, anchor_webrect);
+  *focus = focus_webrect;
+  *anchor = anchor_webrect;
 }
 
 void RenderWidget::UpdateSelectionBounds() {
   if (!webwidget_)
     return;
 
-  gfx::Rect start_rect;
-  gfx::Rect end_rect;
-  GetSelectionBounds(&start_rect, &end_rect);
-  if (selection_start_rect_ != start_rect || selection_end_rect_ != end_rect) {
-    selection_start_rect_ = start_rect;
-    selection_end_rect_ = end_rect;
-    WebTextDirection start_dir = WebKit::WebTextDirectionLeftToRight;
-    WebTextDirection end_dir = WebKit::WebTextDirectionLeftToRight;
-    webwidget_->selectionTextDirection(start_dir, end_dir);
-    Send(new ViewHostMsg_SelectionBoundsChanged(routing_id_,
-        selection_start_rect_, start_dir, selection_end_rect_, end_dir));
+  ViewHostMsg_SelectionBounds_Params params;
+  GetSelectionBounds(&params.anchor_rect, &params.focus_rect);
+  if (selection_anchor_rect_ != params.anchor_rect ||
+      selection_focus_rect_ != params.focus_rect) {
+    selection_anchor_rect_ = params.anchor_rect;
+    selection_focus_rect_ = params.focus_rect;
+    webwidget_->selectionTextDirection(params.focus_dir, params.anchor_dir);
+    params.is_anchor_first = webwidget_->isSelectionAnchorFirst();
+    Send(new ViewHostMsg_SelectionBoundsChanged(routing_id_, params));
   }
 
   std::vector<gfx::Rect> character_bounds;
@@ -1904,6 +1919,19 @@
   UpdateCompositionInfo(range, std::vector<gfx::Rect>());
 }
 
+void RenderWidget::didHandleGestureEvent(
+    const WebGestureEvent& event,
+    bool event_cancelled) {
+#if defined(OS_ANDROID)
+  if (event_cancelled)
+    return;
+  if (event.type == WebInputEvent::GestureTap ||
+      event.type == WebInputEvent::GestureLongPress) {
+    UpdateTextInputState(SHOW_IME_IF_NEEDED);
+  }
+#endif
+}
+
 void RenderWidget::SchedulePluginMove(
     const webkit::npapi::WebPluginGeometry& move) {
   size_t i = 0;
@@ -1940,12 +1968,12 @@
       software_stats_.numAnimationFrames;
   stats.rendering_stats.numFramesSentToScreen +=
       software_stats_.numFramesSentToScreen;
-  stats.rendering_stats.totalPaintTimeInSeconds +=
-      software_stats_.totalPaintTimeInSeconds;
+  stats.rendering_stats.totalPaintTime +=
+      software_stats_.totalPaintTime;
   stats.rendering_stats.totalPixelsPainted +=
       software_stats_.totalPixelsPainted;
-  stats.rendering_stats.totalRasterizeTimeInSeconds +=
-      software_stats_.totalRasterizeTimeInSeconds;
+  stats.rendering_stats.totalRasterizeTime +=
+      software_stats_.totalRasterizeTime;
   stats.rendering_stats.totalPixelsRasterized +=
       software_stats_.totalPixelsRasterized;
 }
Index: src/content/renderer/webplugin_delegate_proxy.cc
===================================================================
--- src/content/renderer/webplugin_delegate_proxy.cc	(revision 184497)
+++ src/content/renderer/webplugin_delegate_proxy.cc	(working copy)
@@ -941,10 +941,14 @@
       render_view_->routing_id(),
       params));
 
+  ViewHostMsg_SelectionBounds_Params bounds_params;
+  bounds_params.anchor_rect = bounds_params.focus_rect = caret_rect;
+  bounds_params.anchor_dir = bounds_params.focus_dir =
+      WebKit::WebTextDirectionLeftToRight;
+  bounds_params.is_anchor_first = true;
   render_view_->Send(new ViewHostMsg_SelectionBoundsChanged(
       render_view_->routing_id(),
-      caret_rect, WebKit::WebTextDirectionLeftToRight,
-      caret_rect, WebKit::WebTextDirectionLeftToRight));
+      bounds_params));
 }
 #endif
 
Index: src/content/renderer/gpu/compositor_output_surface.cc
===================================================================
--- src/content/renderer/gpu/compositor_output_surface.cc	(revision 184497)
+++ src/content/renderer/gpu/compositor_output_surface.cc	(working copy)
@@ -14,10 +14,21 @@
 #include "ipc/ipc_sync_message_filter.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
+#endif
+
 using cc::CompositorFrame;
 using cc::SoftwareOutputDevice;
 using WebKit::WebGraphicsContext3D;
 
+namespace {
+// There are several compositor surfaces in a process, but they share the same
+// compositor thread, so we use a simple int here to track prefer-smoothness.
+int g_prefer_smoothness_count = 0;
+} // namespace
+
 namespace content {
 
 //------------------------------------------------------------------------------
@@ -41,7 +52,9 @@
       client_(NULL),
       routing_id_(routing_id),
       context3D_(context3D),
-      software_device_(software_device) {
+      software_device_(software_device),
+      prefers_smoothness_(false),
+      main_thread_id_(base::PlatformThread::CurrentId()) {
   DCHECK(output_surface_filter_);
   capabilities_.has_parent_compositor = false;
   DetachFromThread();
@@ -51,6 +64,7 @@
   DCHECK(CalledOnValidThread());
   if (!client_)
     return;
+  UpdateSmoothnessTakesPriority(false);
   output_surface_proxy_->ClearOutputSurface();
   output_surface_filter_->RemoveRoute(routing_id_);
 }
@@ -91,9 +105,9 @@
 }
 
 void CompositorOutputSurface::SendFrameToParentCompositor(
-    const cc::CompositorFrame& frame) {
+    cc::CompositorFrame* frame) {
   DCHECK(CalledOnValidThread());
-  Send(new ViewHostMsg_SwapCompositorFrame(routing_id_, frame));
+  Send(new ViewHostMsg_SwapCompositorFrame(routing_id_, *frame));
 }
 
 void CompositorOutputSurface::OnMessageReceived(const IPC::Message& message) {
@@ -116,4 +130,46 @@
   return ChildThread::current()->sync_message_filter()->Send(message);
 }
 
+namespace {
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  void SetThreadsPriorityToIdle(base::PlatformThreadId id) {
+    int nice_value = 10; // Idle priority.
+    setpriority(PRIO_PROCESS, id, nice_value);
+  }
+  void SetThreadsPriorityToDefault(base::PlatformThreadId id) {
+    int nice_value = 0; // Default priority.
+    setpriority(PRIO_PROCESS, id, nice_value);
+  }
+#else
+  void SetThreadsPriorityToIdle(base::PlatformThreadId id) {}
+  void SetThreadsPriorityToDefault(base::PlatformThreadId id) {}
+#endif
+}
+
+void CompositorOutputSurface::UpdateSmoothnessTakesPriority(
+    bool prefers_smoothness) {
+#ifndef NDEBUG
+  // If we use different compositor threads, we need to
+  // use an atomic int to track prefer smoothness count.
+  base::PlatformThreadId g_last_thread = base::PlatformThread::CurrentId();
+  DCHECK_EQ(g_last_thread, base::PlatformThread::CurrentId());
+#endif
+  if (prefers_smoothness_ == prefers_smoothness)
+    return;
+  // If this is the first surface to start preferring smoothness,
+  // Throttle the main thread's priority.
+  if (prefers_smoothness_ == false &&
+      ++g_prefer_smoothness_count == 1) {
+    SetThreadsPriorityToIdle(main_thread_id_);
+  }
+  // If this is the last surface to stop preferring smoothness,
+  // Reset the main thread's priority to the default.
+  if (prefers_smoothness_ == true &&
+      --g_prefer_smoothness_count == 0) {
+    SetThreadsPriorityToDefault(main_thread_id_);
+  }
+  prefers_smoothness_ = prefers_smoothness;
+}
+
 }  // namespace content
Index: src/content/renderer/gpu/compositor_output_surface.h
===================================================================
--- src/content/renderer/gpu/compositor_output_surface.h	(revision 184497)
+++ src/content/renderer/gpu/compositor_output_surface.h	(working copy)
@@ -10,6 +10,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/threading/non_thread_safe.h"
+#include "base/threading/platform_thread.h"
 #include "base/time.h"
 #include "cc/output_surface.h"
 #include "cc/software_output_device.h"
@@ -44,9 +45,12 @@
   virtual const struct Capabilities& Capabilities() const OVERRIDE;
   virtual WebKit::WebGraphicsContext3D* Context3D() const OVERRIDE;
   virtual cc::SoftwareOutputDevice* SoftwareDevice() const OVERRIDE;
-  virtual void SendFrameToParentCompositor(
-      const cc::CompositorFrame&) OVERRIDE;
+  virtual void SendFrameToParentCompositor(cc::CompositorFrame*) OVERRIDE;
 
+  // TODO(epenner): This seems out of place here and would be a better fit
+  // int CompositorThread after it is fully refactored (http://crbug/170828)
+  virtual void UpdateSmoothnessTakesPriority(bool prefer_smoothness) OVERRIDE;
+
  private:
   class CompositorOutputSurfaceProxy :
       public base::RefCountedThreadSafe<CompositorOutputSurfaceProxy> {
@@ -80,6 +84,8 @@
   struct Capabilities capabilities_;
   scoped_ptr<WebKit::WebGraphicsContext3D> context3D_;
   scoped_ptr<cc::SoftwareOutputDevice> software_device_;
+  bool prefers_smoothness_;
+  base::PlatformThreadId main_thread_id_;
 };
 
 }  // namespace content
Index: src/content/renderer/gpu/compositor_thread.cc
===================================================================
--- src/content/renderer/gpu/compositor_thread.cc	(revision 184497)
+++ src/content/renderer/gpu/compositor_thread.cc	(working copy)
@@ -12,6 +12,11 @@
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebCompositorInputHandler.h"
 #include "third_party/WebKit/Source/WebKit/chromium/public/WebView.h"
 
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
+#endif
+
 using WebKit::WebCompositorInputHandler;
 using WebKit::WebInputEvent;
 
@@ -83,6 +88,16 @@
 
 //------------------------------------------------------------------------------
 
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+namespace {
+void SetHighThreadPriority() {
+  int nice_value = -6; // High priority.
+  setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), nice_value);
+}
+}
+#endif
+
 CompositorThread::CompositorThread(IPC::Listener* main_listener)
     : thread_("Compositor") {
   filter_ =
@@ -90,6 +105,11 @@
                            thread_.message_loop()->message_loop_proxy(),
                            base::Bind(&CompositorThread::HandleInputEvent,
                                       base::Unretained(this)));
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  thread_.message_loop()->PostTask(FROM_HERE,
+                                   base::Bind(&SetHighThreadPriority));
+#endif
 }
 
 CompositorThread::~CompositorThread() {
Index: src/content/renderer/disambiguation_popup_helper.h
===================================================================
--- src/content/renderer/disambiguation_popup_helper.h	(revision 184497)
+++ src/content/renderer/disambiguation_popup_helper.h	(working copy)
@@ -25,7 +25,9 @@
   CONTENT_EXPORT static float ComputeZoomAreaAndScaleFactor(
       const gfx::Rect& tap_rect,
       const WebKit::WebVector<WebKit::WebRect>& target_rects,
-      const gfx::Size& viewport_size,
+      const gfx::Size& screen_size,
+      const gfx::Size& visible_content_size,
+      float total_scale,
       gfx::Rect* zoom_rect);
 };
 
Index: src/content/renderer/render_widget.h
===================================================================
--- src/content/renderer/render_widget.h	(revision 184497)
+++ src/content/renderer/render_widget.h	(working copy)
@@ -141,6 +141,8 @@
   virtual WebKit::WebScreenInfo screenInfo();
   virtual float deviceScaleFactor();
   virtual void resetInputMethod();
+  virtual void didHandleGestureEvent(const WebKit::WebGestureEvent& event,
+                                     bool event_cancelled);
 
   // Called when a plugin is moved.  These events are queued up and sent with
   // the next paint or scroll message to the host.
@@ -288,6 +290,9 @@
   void OnScreenInfoChanged(const WebKit::WebScreenInfo& screen_info);
   void OnUpdateScreenRects(const gfx::Rect& view_screen_rect,
                            const gfx::Rect& window_screen_rect);
+#if defined(OS_ANDROID)
+  void OnImeBatchStateChanged(bool is_begin);
+#endif
 
   virtual void SetDeviceScaleFactor(float device_scale_factor);
 
@@ -530,6 +535,9 @@
   // Are we currently handling an input event?
   bool handling_input_event_;
 
+  // Are we currently handling an ime event?
+  bool handling_ime_event_;
+
   // True if we have requested this widget be closed.  No more messages will
   // be sent, except for a Close.
   bool closing_;
@@ -552,8 +560,8 @@
   bool can_compose_inline_;
 
   // Stores the current selection bounds.
-  gfx::Rect selection_start_rect_;
-  gfx::Rect selection_end_rect_;
+  gfx::Rect selection_focus_rect_;
+  gfx::Rect selection_anchor_rect_;
 
   // Stores the current composition character bounds.
   std::vector<gfx::Rect> composition_character_bounds_;
Index: src/ash/system/user/tray_user.cc
===================================================================
--- src/ash/system/user/tray_user.cc	(revision 184497)
+++ src/ash/system/user/tray_user.cc	(working copy)
@@ -432,8 +432,9 @@
 
     // Give the remaining space to the user card.
     gfx::Rect user_card_area = contents_area;
-    user_card_area.set_width(contents_area.width() -
-        (logout_area.width() + kTrayPopupPaddingBetweenItems));
+    int remaining_width = contents_area.width() -
+        (logout_area.width() + kTrayPopupPaddingBetweenItems);
+    user_card_area.set_width(std::max(0, remaining_width));
     user_card_->SetBoundsRect(user_card_area);
   } else if (user_card_) {
     user_card_->SetBoundsRect(contents_area);
Index: src/cc/compositor_frame.cc
===================================================================
--- src/cc/compositor_frame.cc	(revision 184497)
+++ src/cc/compositor_frame.cc	(working copy)
@@ -10,4 +10,10 @@
 
 CompositorFrame::~CompositorFrame() {}
 
+void CompositorFrame::AssignTo(CompositorFrame* target) {
+  target->delegated_frame_data = delegated_frame_data.Pass();
+  target->gl_frame_data = gl_frame_data.Pass();
+  target->metadata = metadata;
+}
+
 }  // namespace cc
Index: src/cc/picture_image_layer.cc
===================================================================
--- src/cc/picture_image_layer.cc	(revision 184497)
+++ src/cc/picture_image_layer.cc	(working copy)
@@ -4,6 +4,7 @@
 
 #include "cc/picture_image_layer.h"
 
+#include "cc/picture_image_layer_impl.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 
 namespace cc {
@@ -23,6 +24,15 @@
   clearClient();
 }
 
+scoped_ptr<LayerImpl> PictureImageLayer::createLayerImpl(
+    LayerTreeImpl* treeImpl) {
+  return PictureImageLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+bool PictureImageLayer::drawsContent() const {
+  return !bitmap_.isNull() && PictureLayer::drawsContent();
+}
+
 void PictureImageLayer::setBitmap(const SkBitmap& bitmap)
 {
   // setBitmap() currently gets called whenever there is any
@@ -36,21 +46,6 @@
   setNeedsDisplay();
 }
 
-void PictureImageLayer::update(
-    ResourceUpdateQueue& queue,
-    const OcclusionTracker* tracker,
-    RenderingStats& stats) {
-  if (bounds() != bounds_) {
-    // Pictures are recorded in layer space, so if the layer size changes,
-    // then the picture needs to be re-scaled, as a directly composited image
-    // always fills its entire layer bounds.  This could be improved by
-    // recording pictures of images at their actual resolution somehow.
-    bounds_ = bounds();
-    setNeedsDisplay();
-  }
-  PictureLayer::update(queue, tracker, stats);
-}
-
 void PictureImageLayer::paintContents(
     SkCanvas* canvas,
     const gfx::Rect& clip,
Index: src/cc/stream_video_draw_quad.h
===================================================================
--- src/cc/stream_video_draw_quad.h	(revision 184497)
+++ src/cc/stream_video_draw_quad.h	(working copy)
@@ -33,6 +33,9 @@
   unsigned texture_id;
   gfx::Transform matrix;
 
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources)
+      OVERRIDE;
+
   static const StreamVideoDrawQuad* MaterialCast(const DrawQuad*);
  private:
   StreamVideoDrawQuad();
Index: src/cc/layer_tree_host_impl.h
===================================================================
--- src/cc/layer_tree_host_impl.h	(revision 184497)
+++ src/cc/layer_tree_host_impl.h	(working copy)
@@ -9,6 +9,7 @@
 #include "base/memory/scoped_ptr.h"
 #include "base/time.h"
 #include "cc/animation_events.h"
+#include "cc/animation_registrar.h"
 #include "cc/cc_export.h"
 #include "cc/input_handler.h"
 #include "cc/output_surface_client.h"
@@ -16,7 +17,10 @@
 #include "cc/render_pass_sink.h"
 #include "cc/renderer.h"
 #include "cc/tile_manager.h"
+#include "cc/top_controls_manager_client.h"
+#include "skia/ext/refptr.h"
 #include "third_party/skia/include/core/SkColor.h"
+#include "third_party/skia/include/core/SkPicture.h"
 #include "ui/gfx/rect.h"
 
 namespace cc {
@@ -29,8 +33,11 @@
 class LayerTreeHostImplTimeSourceAdapter;
 class LayerTreeImpl;
 class PageScaleAnimation;
+class PaintTimeCounter;
+class MemoryHistory;
 class RenderPassDrawQuad;
 class ResourceProvider;
+class TopControlsManager;
 struct RendererCapabilities;
 struct RenderingStats;
 
@@ -41,79 +48,26 @@
     virtual void onSwapBuffersCompleteOnImplThread() = 0;
     virtual void onVSyncParametersChanged(base::TimeTicks timebase, base::TimeDelta interval) = 0;
     virtual void onCanDrawStateChanged(bool canDraw) = 0;
+    virtual void onHasPendingTreeStateChanged(bool hasPendingTree) = 0;
     virtual void setNeedsRedrawOnImplThread() = 0;
+    virtual void didUploadVisibleHighResolutionTileOnImplThread() = 0;
     virtual void setNeedsCommitOnImplThread() = 0;
     virtual void setNeedsManageTilesOnImplThread() = 0;
     virtual void postAnimationEventsToMainThreadOnImplThread(scoped_ptr<AnimationEventsVector>, base::Time wallClockTime) = 0;
     // Returns true if resources were deleted by this call.
     virtual bool reduceContentsTextureMemoryOnImplThread(size_t limitBytes, int priorityCutoff) = 0;
+    virtual void reduceWastedContentsTextureMemoryOnImplThread() = 0;
     virtual void sendManagedMemoryStats() = 0;
+    virtual bool isInsideDraw() = 0;
+    virtual void renewTreePriority() = 0;
 };
 
-// PinchZoomViewport models the bounds and offset of the viewport that is used during a pinch-zoom operation.
-// It tracks the layout-space dimensions of the viewport before any applied scale, and then tracks the layout-space
-// coordinates of the viewport respecting the pinch settings.
-class PinchZoomViewport {
-public:
-    PinchZoomViewport();
-
-    float totalPageScaleFactor() const;
-
-    void setPageScaleFactor(float factor) { m_pageScaleFactor = factor; }
-    float pageScaleFactor() const { return m_pageScaleFactor; }
-
-    void setPageScaleDelta(float delta);
-    float pageScaleDelta() const  { return m_pageScaleDelta; }
-
-    float minPageScaleFactor() const { return m_minPageScaleFactor; }
-    float maxPageScaleFactor() const { return m_maxPageScaleFactor; }
-
-    void setSentPageScaleDelta(float delta) { m_sentPageScaleDelta = delta; }
-    float sentPageScaleDelta() const { return m_sentPageScaleDelta; }
-
-    void setDeviceScaleFactor(float factor) { m_deviceScaleFactor = factor; }
-    float deviceScaleFactor() const { return m_deviceScaleFactor; }
-
-    // Returns true if the passed parameters were different from those previously
-    // cached.
-    bool setPageScaleFactorAndLimits(float pageScaleFactor,
-                                     float minPageScaleFactor,
-                                     float maxPageScaleFactor);
-
-    // Returns the bounds and offset of the scaled and translated viewport to use for pinch-zoom.
-    gfx::RectF bounds() const;
-    const gfx::Vector2dF& zoomedViewportOffset() const { return m_zoomedViewportOffset; }
-
-    void setLayoutViewportSize(const gfx::SizeF& size) { m_layoutViewportSize = size; }
-
-    // Apply the scroll offset in layout space to the offset of the pinch-zoom viewport. The viewport cannot be
-    // scrolled outside of the layout viewport bounds. Returns the component of the scroll that is un-applied due to
-    // this constraint.
-    gfx::Vector2dF applyScroll(const gfx::Vector2dF&);
-
-    // The implTransform goes from the origin of the unzoomedDeviceViewport to the
-    // origin of the zoomedDeviceViewport.
-    //
-    // implTransform = S[pageScale] * Tr[-zoomedDeviceViewportOffset]
-    gfx::Transform implTransform(bool pageScalePinchZoomEnabled) const;
-
-private:
-    float m_pageScaleFactor;
-    float m_pageScaleDelta;
-    float m_sentPageScaleDelta;
-    float m_maxPageScaleFactor;
-    float m_minPageScaleFactor;
-    float m_deviceScaleFactor;
-
-    gfx::Vector2dF m_zoomedViewportOffset;
-    gfx::SizeF m_layoutViewportSize;
-};
-
 // LayerTreeHostImpl owns the LayerImpl tree as well as associated rendering state
 class CC_EXPORT LayerTreeHostImpl : public InputHandlerClient,
                                     public RendererClient,
                                     public TileManagerClient,
-                                    public OutputSurfaceClient {
+                                    public OutputSurfaceClient,
+                                    public TopControlsManagerClient {
     typedef std::vector<LayerImpl*> LayerList;
 
 public:
@@ -131,6 +85,12 @@
     virtual void scheduleAnimation() OVERRIDE;
     virtual bool haveTouchEventHandlersAt(const gfx::Point&) OVERRIDE;
 
+    // TopControlsManagerClient implementation.
+    virtual void setActiveTreeNeedsUpdateDrawProperties() OVERRIDE;
+    virtual void setNeedsRedraw() OVERRIDE;
+    virtual bool haveRootScrollLayer() const OVERRIDE;
+    virtual float rootScrollLayerTotalScrollY() const OVERRIDE;
+
     struct CC_EXPORT FrameData : public RenderPassSink {
         FrameData();
         ~FrameData();
@@ -139,8 +99,9 @@
         std::vector<gfx::Rect> nonOccludingScreenSpaceRects;
         RenderPassList renderPasses;
         RenderPassIdHashMap renderPassesById;
-        LayerList* renderSurfaceLayerList;
+        const LayerList* renderSurfaceLayerList;
         LayerList willDrawLayers;
+        bool containsIncompleteTile;
 
         // RenderPassSink implementation.
         virtual void appendRenderPass(scoped_ptr<RenderPass>) OVERRIDE;
@@ -176,7 +137,7 @@
 
     // TileManagerClient implementation.
     virtual void ScheduleManageTiles() OVERRIDE;
-    virtual void ScheduleCheckForCompletedSetPixels() OVERRIDE;
+    virtual void DidUploadVisibleHighResolutionTile() OVERRIDE;
 
     // OutputSurfaceClient implementation.
     virtual void OnVSyncParametersChanged(base::TimeTicks timebase, base::TimeDelta interval) OVERRIDE;
@@ -206,27 +167,23 @@
     void readback(void* pixels, const gfx::Rect&);
 
     LayerTreeImpl* activeTree() { return m_activeTree.get(); }
+    const LayerTreeImpl* activeTree() const { return m_activeTree.get(); }
     LayerTreeImpl* pendingTree() { return m_pendingTree.get(); }
+    const LayerTreeImpl* pendingTree() const { return m_pendingTree.get(); }
+    const LayerTreeImpl* recycleTree() const { return m_recycleTree.get(); }
+    void createPendingTree();
+    void checkForCompletedTileUploads();
+    scoped_ptr<base::Value> activationStateAsValue() const;
+    virtual void activatePendingTreeIfNeeded();
 
-    // TODO(nduca): Remove these in favor of LayerTreeImpl.
-    void setRootLayer(scoped_ptr<LayerImpl>);
+    // Shortcuts to layers on the active tree.
     LayerImpl* rootLayer() const;
-
-    // Release ownership of the current layer tree and replace it with an empty
-    // tree. Returns the root layer of the detached tree.
-    scoped_ptr<LayerImpl> detachLayerTree();
-
     LayerImpl* rootScrollLayer() const;
-
-    // TOOD(nduca): This goes away when scrolling moves to LayerTreeImpl.
     LayerImpl* currentlyScrollingLayer() const;
 
     bool visible() const { return m_visible; }
     void setVisible(bool);
 
-    bool contentsTexturesPurged() const { return m_contentsTexturesPurged; }
-    void setContentsTexturesPurged();
-    void resetContentsTexturesPurged();
     size_t memoryAllocationLimitBytes() const { return m_managedMemoryPolicy.bytesLimitWhenVisible; }
 
     void setViewportSize(const gfx::Size& layoutViewportSize, const gfx::Size& deviceViewportSize);
@@ -235,46 +192,35 @@
     float deviceScaleFactor() const { return m_deviceScaleFactor; }
     void setDeviceScaleFactor(float);
 
-    float pageScaleFactor() const;
-    void setPageScaleFactorAndLimits(float pageScaleFactor, float minPageScaleFactor, float maxPageScaleFactor);
-
     scoped_ptr<ScrollAndScaleSet> processScrollDeltas();
-    gfx::Transform implTransform() const;
 
     void startPageScaleAnimation(gfx::Vector2d targetOffset, bool useAnchor, float scale, base::TimeDelta duration);
 
-    SkColor backgroundColor() const { return m_backgroundColor; }
-    void setBackgroundColor(SkColor color) { m_backgroundColor = color; }
+    bool needsAnimateLayers() const { return !m_animationRegistrar->active_animation_controllers().empty(); }
 
-    bool hasTransparentBackground() const { return m_hasTransparentBackground; }
-    void setHasTransparentBackground(bool transparent) { m_hasTransparentBackground = transparent; }
-
-    bool needsAnimateLayers() const { return m_needsAnimateLayers; }
-    void setNeedsAnimateLayers() { m_needsAnimateLayers = true; }
-
-    bool needsUpdateDrawProperties() const { return m_needsUpdateDrawProperties; }
-    void setNeedsUpdateDrawProperties() { m_needsUpdateDrawProperties = true; }
-
-    void setNeedsRedraw();
-
     void renderingStats(RenderingStats*) const;
 
-    void updateRootScrollLayerImplTransform();
-
     void sendManagedMemoryStats(
        size_t memoryVisibleBytes,
        size_t memoryVisibleAndNearbyBytes,
        size_t memoryUseBytes);
 
     FrameRateCounter* fpsCounter() const { return m_fpsCounter.get(); }
+    PaintTimeCounter* paintTimeCounter() const { return m_paintTimeCounter.get(); }
+    MemoryHistory* memoryHistory() const { return m_memoryHistory.get(); }
     DebugRectHistory* debugRectHistory() const { return m_debugRectHistory.get(); }
     ResourceProvider* resourceProvider() const { return m_resourceProvider.get(); }
+    TopControlsManager* topControlsManager() const { return m_topControlsManager.get(); }
 
     Proxy* proxy() const { return m_proxy; }
 
+    AnimationRegistrar* animationRegistrar() const { return m_animationRegistrar.get(); }
+
     void setDebugState(const LayerTreeDebugState& debugState) { m_debugState = debugState; }
     const LayerTreeDebugState& debugState() const { return m_debugState; }
 
+    void savePaintTime(const base::TimeDelta& totalPaintTime);
+
     class CC_EXPORT CullRenderPassesWithCachedTextures {
     public:
         bool shouldRemoveRenderPass(const RenderPassDrawQuad&, const FrameData&) const;
@@ -305,33 +251,41 @@
     template<typename RenderPassCuller>
     static void removeRenderPasses(RenderPassCuller, FrameData&);
 
-protected:
-    LayerTreeHostImpl(const LayerTreeSettings&, LayerTreeHostImplClient*, Proxy*);
+    skia::RefPtr<SkPicture> capturePicture();
 
-    void animatePageScale(base::TimeTicks monotonicTime);
-    void animateScrollbars(base::TimeTicks monotonicTime);
+    bool pinchGestureActive() const { return m_pinchGestureActive; }
 
-    void updateDrawProperties();
+    void setTreePriority(TreePriority priority);
 
-    // Exposed for testing.
-    void calculateRenderSurfaceLayerList(LayerList&);
-    void resetNeedsUpdateDrawPropertiesForTesting() { m_needsUpdateDrawProperties = false; }
+    void beginNextFrame();
+    base::TimeTicks currentFrameTime();
 
+protected:
+    LayerTreeHostImpl(const LayerTreeSettings&, LayerTreeHostImplClient*, Proxy*);
+    void activatePendingTree();
+
     // Virtual for testing.
     virtual void animateLayers(base::TimeTicks monotonicTime, base::Time wallClockTime);
 
     // Virtual for testing.
     virtual base::TimeDelta lowFrequencyAnimationInterval() const;
 
+    const AnimationRegistrar::AnimationControllerMap& activeAnimationControllers() const { return m_animationRegistrar->active_animation_controllers(); }
+
     LayerTreeHostImplClient* m_client;
     Proxy* m_proxy;
 
 private:
+    void animatePageScale(base::TimeTicks monotonicTime);
+    void animateScrollbars(base::TimeTicks monotonicTime);
+
     void computeDoubleTapZoomDeltas(ScrollAndScaleSet* scrollInfo);
     void computePinchZoomDeltas(ScrollAndScaleSet* scrollInfo);
     void makeScrollAndScaleSet(ScrollAndScaleSet* scrollInfo, gfx::Vector2d scrollOffset, float pageScale);
 
     void setPageScaleDelta(float);
+    gfx::Vector2dF scrollLayerWithViewportSpaceDelta(LayerImpl* layerImpl, float scaleFromViewportToScreenSpace, gfx::PointF viewportPoint, gfx::Vector2dF viewportDelta);
+
     void updateMaxScrollOffset();
     void trackDamageForAllSurfaces(LayerImpl* rootDrawLayer, const LayerList& renderSurfaceLayerList);
 
@@ -341,7 +295,6 @@
     bool calculateRenderPasses(FrameData&);
     void animateLayersRecursive(LayerImpl*, base::TimeTicks monotonicTime, base::Time wallClockTime, AnimationEventsVector*, bool& didAnimate, bool& needsAnimateLayers);
     void setBackgroundTickingEnabled(bool);
-    gfx::Size contentSize() const;
 
     void sendDidLoseOutputSurfaceRecursive(LayerImpl*);
     void clearRenderSurfaces();
@@ -352,45 +305,48 @@
 
     void dumpRenderSurfaces(std::string*, int indent, const LayerImpl*) const;
 
+    static LayerImpl* getNonCompositedContentLayerRecursive(LayerImpl* layer);
+
     scoped_ptr<OutputSurface> m_outputSurface;
     scoped_ptr<ResourceProvider> m_resourceProvider;
     scoped_ptr<Renderer> m_renderer;
     scoped_ptr<TileManager> m_tileManager;
 
-    scoped_ptr<LayerTreeImpl> m_pendingTree;
+    // Tree currently being drawn.
     scoped_ptr<LayerTreeImpl> m_activeTree;
 
-    bool m_scrollDeltaIsInViewportSpace;
+    // In impl-side painting mode, tree with possibly incomplete rasterized
+    // content. May be promoted to active by activatePendingTreeIfNeeded().
+    scoped_ptr<LayerTreeImpl> m_pendingTree;
+
+    // In impl-side painting mode, inert tree with layers that can be recycled
+    // by the next sync from the main thread.
+    scoped_ptr<LayerTreeImpl> m_recycleTree;
+
+    bool m_didLockScrollingLayer;
+    bool m_shouldBubbleScrolls;
+    bool m_wheelScrolling;
     LayerTreeSettings m_settings;
     LayerTreeDebugState m_debugState;
     gfx::Size m_layoutViewportSize;
     gfx::Size m_deviceViewportSize;
     float m_deviceScaleFactor;
     bool m_visible;
-    bool m_contentsTexturesPurged;
     ManagedMemoryPolicy m_managedMemoryPolicy;
 
-    SkColor m_backgroundColor;
-    bool m_hasTransparentBackground;
-
-    // If this is true, it is necessary to traverse the layer tree ticking the animators.
-    bool m_needsAnimateLayers;
-    bool m_needsUpdateDrawProperties;
     bool m_pinchGestureActive;
     gfx::Point m_previousPinchAnchor;
 
+    scoped_ptr<TopControlsManager> m_topControlsManager;
+
     scoped_ptr<PageScaleAnimation> m_pageScaleAnimation;
 
     // This is used for ticking animations slowly when hidden.
     scoped_ptr<LayerTreeHostImplTimeSourceAdapter> m_timeSourceClientAdapter;
 
-    // List of visible layers for the most recently prepared frame. Used for
-    // rendering and input event hit testing.
-    LayerList m_renderSurfaceLayerList;
-
-    PinchZoomViewport m_pinchZoomViewport;
-
     scoped_ptr<FrameRateCounter> m_fpsCounter;
+    scoped_ptr<PaintTimeCounter> m_paintTimeCounter;
+    scoped_ptr<MemoryHistory> m_memoryHistory;
     scoped_ptr<DebugRectHistory> m_debugRectHistory;
 
     int64 m_numImplThreadScrolls;
@@ -404,6 +360,10 @@
     size_t m_lastSentMemoryVisibleAndNearbyBytes;
     size_t m_lastSentMemoryUseBytes;
 
+    base::TimeTicks m_currentFrameTime;
+
+    scoped_ptr<AnimationRegistrar> m_animationRegistrar;
+
     DISALLOW_COPY_AND_ASSIGN(LayerTreeHostImpl);
 };
 
Index: src/cc/prioritized_resource.cc
===================================================================
--- src/cc/prioritized_resource.cc	(revision 184497)
+++ src/cc/prioritized_resource.cc	(working copy)
@@ -4,14 +4,13 @@
 
 #include "cc/prioritized_resource.h"
 
+#include <algorithm>
+
 #include "cc/platform_color.h"
 #include "cc/prioritized_resource_manager.h"
 #include "cc/priority_calculator.h"
 #include "cc/proxy.h"
-#include <algorithm>
 
-using namespace std;
-
 namespace cc {
 
 PrioritizedResource::PrioritizedResource(PrioritizedResourceManager* manager, gfx::Size size, GLenum format)
Index: src/cc/tree_synchronizer.cc
===================================================================
--- src/cc/tree_synchronizer.cc	(revision 184497)
+++ src/cc/tree_synchronizer.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "cc/tree_synchronizer.h"
 
 #include "base/debug/trace_event.h"
+#include "base/logging.h"
 #include "cc/layer.h"
 #include "cc/layer_impl.h"
 #include "cc/scrollbar_animation_controller.h"
@@ -13,8 +14,28 @@
 
 namespace cc {
 
-scoped_ptr<LayerImpl> TreeSynchronizer::synchronizeTrees(Layer* layerRoot, scoped_ptr<LayerImpl> oldLayerImplRoot, LayerTreeImpl* treeImpl)
+typedef ScopedPtrHashMap<int, LayerImpl> ScopedPtrLayerImplMap;
+typedef base::hash_map<int, LayerImpl*> RawPtrLayerImplMap;
+
+void collectExistingLayerImplRecursive(ScopedPtrLayerImplMap& oldLayers, scoped_ptr<LayerImpl> layerImpl)
 {
+    if (!layerImpl)
+        return;
+
+    ScopedPtrVector<LayerImpl>& children = layerImpl->children();
+    for (ScopedPtrVector<LayerImpl>::iterator it = children.begin(); it != children.end(); ++it)
+        collectExistingLayerImplRecursive(oldLayers, children.take(it));
+
+    collectExistingLayerImplRecursive(oldLayers, layerImpl->takeMaskLayer());
+    collectExistingLayerImplRecursive(oldLayers, layerImpl->takeReplicaLayer());
+
+    int id = layerImpl->id();
+    oldLayers.set(id, layerImpl.Pass());
+}
+
+template <typename LayerType>
+scoped_ptr<LayerImpl> synchronizeTreesInternal(LayerType* layerRoot, scoped_ptr<LayerImpl> oldLayerImplRoot, LayerTreeImpl* treeImpl)
+{
     DCHECK(treeImpl);
 
     TRACE_EVENT0("cc", "TreeSynchronizer::synchronizeTrees");
@@ -23,30 +44,25 @@
 
     collectExistingLayerImplRecursive(oldLayers, oldLayerImplRoot.Pass());
 
-    scoped_ptr<LayerImpl> newTree = synchronizeTreeRecursive(newLayers, oldLayers, layerRoot, treeImpl);
+    scoped_ptr<LayerImpl> newTree = synchronizeTreesRecursive(newLayers, oldLayers, layerRoot, treeImpl);
 
     updateScrollbarLayerPointersRecursive(newLayers, layerRoot);
 
     return newTree.Pass();
 }
 
-void TreeSynchronizer::collectExistingLayerImplRecursive(ScopedPtrLayerImplMap& oldLayers, scoped_ptr<LayerImpl> layerImpl)
+scoped_ptr<LayerImpl> TreeSynchronizer::synchronizeTrees(Layer* layerRoot, scoped_ptr<LayerImpl> oldLayerImplRoot, LayerTreeImpl* treeImpl)
 {
-    if (!layerImpl)
-        return;
+    return synchronizeTreesInternal(layerRoot, oldLayerImplRoot.Pass(), treeImpl);
+}
 
-    ScopedPtrVector<LayerImpl>& children = layerImpl->m_children;
-    for (size_t i = 0; i < children.size(); ++i)
-        collectExistingLayerImplRecursive(oldLayers, children.take(i));
-
-    collectExistingLayerImplRecursive(oldLayers, layerImpl->takeMaskLayer());
-    collectExistingLayerImplRecursive(oldLayers, layerImpl->takeReplicaLayer());
-
-    int id = layerImpl->id();
-    oldLayers.set(id, layerImpl.Pass());
+scoped_ptr<LayerImpl> TreeSynchronizer::synchronizeTrees(LayerImpl* layerRoot, scoped_ptr<LayerImpl> oldLayerImplRoot, LayerTreeImpl* treeImpl)
+{
+    return synchronizeTreesInternal(layerRoot, oldLayerImplRoot.Pass(), treeImpl);
 }
 
-scoped_ptr<LayerImpl> TreeSynchronizer::reuseOrCreateLayerImpl(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, Layer* layer, LayerTreeImpl* treeImpl)
+template <typename LayerType>
+scoped_ptr<LayerImpl> reuseOrCreateLayerImpl(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, LayerType* layer, LayerTreeImpl* treeImpl)
 {
     scoped_ptr<LayerImpl> layerImpl = oldLayers.take(layer->id());
 
@@ -57,7 +73,8 @@
     return layerImpl.Pass();
 }
 
-scoped_ptr<LayerImpl> TreeSynchronizer::synchronizeTreeRecursive(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, Layer* layer, LayerTreeImpl* treeImpl)
+template <typename LayerType>
+scoped_ptr<LayerImpl> synchronizeTreesRecursiveInternal(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, LayerType* layer, LayerTreeImpl* treeImpl)
 {
     if (!layer)
         return scoped_ptr<LayerImpl>();
@@ -65,34 +82,39 @@
     scoped_ptr<LayerImpl> layerImpl = reuseOrCreateLayerImpl(newLayers, oldLayers, layer, treeImpl);
 
     layerImpl->clearChildList();
-    const std::vector<scoped_refptr<Layer> >& children = layer->children();
-    for (size_t i = 0; i < children.size(); ++i)
-        layerImpl->addChild(synchronizeTreeRecursive(newLayers, oldLayers, children[i].get(), treeImpl));
+    for (size_t i = 0; i < layer->children().size(); ++i)
+        layerImpl->addChild(synchronizeTreesRecursiveInternal(newLayers, oldLayers, layer->childAt(i), treeImpl));
 
-    layerImpl->setMaskLayer(synchronizeTreeRecursive(newLayers, oldLayers, layer->maskLayer(), treeImpl));
-    layerImpl->setReplicaLayer(synchronizeTreeRecursive(newLayers, oldLayers, layer->replicaLayer(), treeImpl));
+    layerImpl->setMaskLayer(synchronizeTreesRecursiveInternal(newLayers, oldLayers, layer->maskLayer(), treeImpl));
+    layerImpl->setReplicaLayer(synchronizeTreesRecursiveInternal(newLayers, oldLayers, layer->replicaLayer(), treeImpl));
 
-    layer->pushPropertiesTo(layerImpl.get());
-
     // Remove all dangling pointers. The pointers will be setup later in updateScrollbarLayerPointersRecursive phase
-    if (ScrollbarAnimationController* scrollbarController = layerImpl->scrollbarAnimationController()) {
-        scrollbarController->setHorizontalScrollbarLayer(0);
-        scrollbarController->setVerticalScrollbarLayer(0);
-    }
+    layerImpl->setHorizontalScrollbarLayer(0);
+    layerImpl->setVerticalScrollbarLayer(0);
 
     return layerImpl.Pass();
 }
 
-void TreeSynchronizer::updateScrollbarLayerPointersRecursive(const RawPtrLayerImplMap& newLayers, Layer* layer)
+scoped_ptr<LayerImpl> synchronizeTreesRecursive(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, Layer* layer, LayerTreeImpl* treeImpl)
 {
+    return synchronizeTreesRecursiveInternal(newLayers, oldLayers, layer, treeImpl);
+}
+
+scoped_ptr<LayerImpl> synchronizeTreesRecursive(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, LayerImpl* layer, LayerTreeImpl* treeImpl)
+{
+    return synchronizeTreesRecursiveInternal(newLayers, oldLayers, layer, treeImpl);
+}
+
+template <typename LayerType, typename ScrollbarLayerType>
+void updateScrollbarLayerPointersRecursiveInternal(const RawPtrLayerImplMap& newLayers, LayerType* layer)
+{
     if (!layer)
         return;
 
-    const std::vector<scoped_refptr<Layer> >& children = layer->children();
-    for (size_t i = 0; i < children.size(); ++i)
-        updateScrollbarLayerPointersRecursive(newLayers, children[i].get());
+    for (size_t i = 0; i < layer->children().size(); ++i)
+        updateScrollbarLayerPointersRecursiveInternal<LayerType, ScrollbarLayerType>(newLayers, layer->childAt(i));
 
-    ScrollbarLayer* scrollbarLayer = layer->toScrollbarLayer();
+    ScrollbarLayerType* scrollbarLayer = layer->toScrollbarLayer();
     if (!scrollbarLayer)
         return;
 
@@ -104,10 +126,53 @@
     DCHECK(scrollbarLayerImpl);
     DCHECK(scrollLayerImpl);
 
-    if (scrollbarLayerImpl->orientation() == WebKit::WebScrollbar::Horizontal)
+    if (scrollbarLayer->orientation() == WebKit::WebScrollbar::Horizontal)
         scrollLayerImpl->setHorizontalScrollbarLayer(scrollbarLayerImpl);
     else
         scrollLayerImpl->setVerticalScrollbarLayer(scrollbarLayerImpl);
 }
 
+void updateScrollbarLayerPointersRecursive(const RawPtrLayerImplMap& newLayers, Layer* layer)
+{
+    updateScrollbarLayerPointersRecursiveInternal<Layer, ScrollbarLayer>(newLayers, layer);
+}
+
+void updateScrollbarLayerPointersRecursive(const RawPtrLayerImplMap& newLayers, LayerImpl* layer)
+{
+    updateScrollbarLayerPointersRecursiveInternal<LayerImpl, ScrollbarLayerImpl>(newLayers, layer);
+}
+
+template <typename LayerType>
+void pushPropertiesInternal(LayerType* layer, LayerImpl* layerImpl)
+{
+    if (!layer) {
+        DCHECK(!layerImpl);
+        return;
+    }
+
+    DCHECK_EQ(layer->id(), layerImpl->id());
+    layer->pushPropertiesTo(layerImpl);
+
+    pushPropertiesInternal(layer->maskLayer(), layerImpl->maskLayer());
+    pushPropertiesInternal(layer->replicaLayer(), layerImpl->replicaLayer());
+
+    const ScopedPtrVector<LayerImpl>& implChildren = layerImpl->children();
+    DCHECK_EQ(layer->children().size(), implChildren.size());
+
+    for (size_t i = 0; i < layer->children().size(); ++i) {
+        pushPropertiesInternal(layer->childAt(i), implChildren[i]);
+    }
+}
+
+void TreeSynchronizer::pushProperties(Layer* layer, LayerImpl* layerImpl)
+{
+    pushPropertiesInternal(layer, layerImpl);
+}
+
+void TreeSynchronizer::pushProperties(LayerImpl* layer, LayerImpl* layerImpl)
+{
+    pushPropertiesInternal(layer, layerImpl);
+}
+
+
 }  // namespace cc
Index: src/cc/scheduler.h
===================================================================
--- src/cc/scheduler.h	(revision 184497)
+++ src/cc/scheduler.h	(working copy)
@@ -11,6 +11,7 @@
 #include "cc/cc_export.h"
 #include "cc/frame_rate_controller.h"
 #include "cc/layer_tree_host.h"
+#include "cc/scheduler_settings.h"
 #include "cc/scheduler_state_machine.h"
 
 namespace cc {
@@ -38,6 +39,8 @@
     virtual ScheduledActionDrawAndSwapResult scheduledActionDrawAndSwapIfPossible() = 0;
     virtual ScheduledActionDrawAndSwapResult scheduledActionDrawAndSwapForced() = 0;
     virtual void scheduledActionCommit() = 0;
+    virtual void scheduledActionCheckForCompletedTileUploads() = 0;
+    virtual void scheduledActionActivatePendingTreeIfNeeded() = 0;
     virtual void scheduledActionBeginContextRecreation() = 0;
     virtual void scheduledActionAcquireLayerTexturesForMainThread() = 0;
     virtual void didAnticipatedDrawTimeChange(base::TimeTicks) = 0;
@@ -48,9 +51,11 @@
 
 class CC_EXPORT Scheduler : FrameRateControllerClient {
 public:
-    static scoped_ptr<Scheduler> create(SchedulerClient* client, scoped_ptr<FrameRateController> frameRateController)
+    static scoped_ptr<Scheduler> create(SchedulerClient* client,
+                                        scoped_ptr<FrameRateController> frameRateController,
+                                        const SchedulerSettings& schedulerSettings)
     {
-        return make_scoped_ptr(new Scheduler(client, frameRateController.Pass()));
+        return make_scoped_ptr(new Scheduler(client, frameRateController.Pass(), schedulerSettings));
     }
 
     virtual ~Scheduler();
@@ -59,6 +64,7 @@
 
     void setVisible(bool);
     void setCanDraw(bool);
+    void setHasPendingTree(bool);
 
     void setNeedsCommit();
 
@@ -72,10 +78,14 @@
     // Like setNeedsRedraw(), but ensures the draw will definitely happen even if we are not visible.
     void setNeedsForcedRedraw();
 
+    void didSwapUseIncompleteTile();
+
     void beginFrameComplete();
     void beginFrameAborted();
 
     void setMaxFramesPending(int);
+    int maxFramesPending() const;
+
     void setSwapBuffersCompleteSupported(bool);
     void didSwapBuffersComplete();
 
@@ -93,10 +103,12 @@
     virtual void vsyncTick(bool throttled) OVERRIDE;
 
 private:
-    Scheduler(SchedulerClient*, scoped_ptr<FrameRateController>);
+    Scheduler(SchedulerClient*, scoped_ptr<FrameRateController>,
+              const SchedulerSettings& schedulerSettings);
 
     void processScheduledActions();
 
+    const SchedulerSettings m_settings;
     SchedulerClient* m_client;
     scoped_ptr<FrameRateController> m_frameRateController;
     SchedulerStateMachine m_stateMachine;
Index: src/cc/nine_patch_layer_impl_unittest.cc
===================================================================
--- src/cc/nine_patch_layer_impl_unittest.cc	(revision 184497)
+++ src/cc/nine_patch_layer_impl_unittest.cc	(working copy)
@@ -82,7 +82,7 @@
     for (size_t i = 0; i < quads.size(); ++i) {
         DrawQuad* quad = quads[i];
         const TextureDrawQuad* texQuad = TextureDrawQuad::MaterialCast(quad);
-        gfx::RectF texRect = texQuad->uv_rect;
+        gfx::RectF texRect = gfx::BoundingRect(texQuad->uv_top_left, texQuad->uv_bottom_right);
         texRect.Scale(bitmapSize.width(), bitmapSize.height());
         texRemaining.Subtract(Region(ToRoundedIntRect(texRect)));
     }
@@ -135,7 +135,7 @@
     for (size_t i = 0; i < quads.size(); ++i) {
         DrawQuad* quad = quads[i];
         const TextureDrawQuad* texQuad = TextureDrawQuad::MaterialCast(quad);
-        gfx::RectF texRect = texQuad->uv_rect;
+        gfx::RectF texRect = gfx::BoundingRect(texQuad->uv_top_left, texQuad->uv_bottom_right);
         texRect.Scale(bitmapSize.width(), bitmapSize.height());
         texRemaining.Subtract(Region(ToRoundedIntRect(texRect)));
     }
Index: src/cc/content_layer_updater.cc
===================================================================
--- src/cc/content_layer_updater.cc	(revision 184497)
+++ src/cc/content_layer_updater.cc	(working copy)
@@ -51,7 +51,7 @@
     gfx::RectF opaqueLayerRect;
     base::TimeTicks paintBeginTime = base::TimeTicks::Now();
     m_painter->paint(canvas, layerRect, opaqueLayerRect);
-    stats.totalPaintTimeInSeconds += (base::TimeTicks::Now() - paintBeginTime).InSecondsF();
+    stats.totalPaintTime += base::TimeTicks::Now() - paintBeginTime;
     canvas->restore();
 
     stats.totalPixelsPainted += contentRect.width() * contentRect.height();
Index: src/cc/render_pass_draw_quad.cc
===================================================================
--- src/cc/render_pass_draw_quad.cc	(revision 184497)
+++ src/cc/render_pass_draw_quad.cc	(working copy)
@@ -12,6 +12,9 @@
       mask_resource_id(-1) {
 }
 
+RenderPassDrawQuad::~RenderPassDrawQuad() {
+}
+
 scoped_ptr<RenderPassDrawQuad> RenderPassDrawQuad::Create() {
     return make_scoped_ptr(new RenderPassDrawQuad);
 }
@@ -19,44 +22,50 @@
 scoped_ptr<RenderPassDrawQuad> RenderPassDrawQuad::Copy(
     const SharedQuadState* copied_shared_quad_state,
     RenderPass::Id copied_render_pass_id) const {
-  scoped_ptr<RenderPassDrawQuad> copy_quad(new RenderPassDrawQuad(*MaterialCast(this)));
+  scoped_ptr<RenderPassDrawQuad> copy_quad(
+      new RenderPassDrawQuad(*MaterialCast(this)));
   copy_quad->shared_quad_state = copied_shared_quad_state;
   copy_quad->render_pass_id = copied_render_pass_id;
   return copy_quad.Pass();
 }
 
-void RenderPassDrawQuad::SetNew(const SharedQuadState* shared_quad_state,
-                                gfx::Rect rect,
-                                RenderPass::Id render_pass_id,
-                                bool is_replica,
-                                ResourceProvider::ResourceId mask_resource_id,
-                                gfx::Rect contents_changed_since_last_frame,
-                                gfx::RectF mask_uv_rect) {
+void RenderPassDrawQuad::SetNew(
+    const SharedQuadState* shared_quad_state,
+    gfx::Rect rect,
+    RenderPass::Id render_pass_id,
+    bool is_replica,
+    ResourceProvider::ResourceId mask_resource_id,
+    gfx::Rect contents_changed_since_last_frame,
+    gfx::RectF mask_uv_rect,
+    const WebKit::WebFilterOperations& filters,
+    skia::RefPtr<SkImageFilter> filter,
+    const WebKit::WebFilterOperations& background_filters) {
   DCHECK(render_pass_id.layer_id > 0);
   DCHECK(render_pass_id.index >= 0);
 
   gfx::Rect opaque_rect;
   gfx::Rect visible_rect = rect;
   bool needs_blending = false;
-  DrawQuad::SetAll(shared_quad_state, DrawQuad::RENDER_PASS, rect, opaque_rect,
-                   visible_rect, needs_blending);
-  this->render_pass_id = render_pass_id;
-  this->is_replica = is_replica;
-  this->mask_resource_id = mask_resource_id;
-  this->contents_changed_since_last_frame = contents_changed_since_last_frame;
-  this->mask_uv_rect = mask_uv_rect;
+  SetAll(shared_quad_state, rect, opaque_rect, visible_rect, needs_blending,
+         render_pass_id, is_replica, mask_resource_id,
+         contents_changed_since_last_frame, mask_uv_rect, filters, filter,
+         background_filters);
 }
 
-void RenderPassDrawQuad::SetAll(const SharedQuadState* shared_quad_state,
-                                gfx::Rect rect,
-                                gfx::Rect opaque_rect,
-                                gfx::Rect visible_rect,
-                                bool needs_blending,
-                                RenderPass::Id render_pass_id,
-                                bool is_replica,
-                                ResourceProvider::ResourceId mask_resource_id,
-                                gfx::Rect contents_changed_since_last_frame,
-                                gfx::RectF mask_uv_rect) {
+void RenderPassDrawQuad::SetAll(
+    const SharedQuadState* shared_quad_state,
+    gfx::Rect rect,
+    gfx::Rect opaque_rect,
+    gfx::Rect visible_rect,
+    bool needs_blending,
+    RenderPass::Id render_pass_id,
+    bool is_replica,
+    ResourceProvider::ResourceId mask_resource_id,
+    gfx::Rect contents_changed_since_last_frame,
+    gfx::RectF mask_uv_rect,
+    const WebKit::WebFilterOperations& filters,
+    skia::RefPtr<SkImageFilter> filter,
+    const WebKit::WebFilterOperations& background_filters) {
   DCHECK(render_pass_id.layer_id > 0);
   DCHECK(render_pass_id.index >= 0);
 
@@ -67,8 +76,16 @@
   this->mask_resource_id = mask_resource_id;
   this->contents_changed_since_last_frame = contents_changed_since_last_frame;
   this->mask_uv_rect = mask_uv_rect;
+  this->filters = filters;
+  this->filter = filter;
+  this->background_filters = background_filters;
 }
 
+void RenderPassDrawQuad::AppendResources(
+    ResourceProvider::ResourceIdArray* resources) {
+  resources->push_back(mask_resource_id);
+}
+
 const RenderPassDrawQuad* RenderPassDrawQuad::MaterialCast(
     const DrawQuad* quad) {
   DCHECK(quad->material == DrawQuad::RENDER_PASS);
Index: src/cc/tile_priority_unittest.cc
===================================================================
--- src/cc/tile_priority_unittest.cc	(revision 184497)
+++ src/cc/tile_priority_unittest.cc	(working copy)
@@ -10,6 +10,7 @@
 namespace {
 
 TEST(TilePriorityTest, TimeForBoundsToIntersectWithScroll) {
+  const float inf = std::numeric_limits<float>::infinity();
   gfx::Rect target(0, 0, 800, 600);
   gfx::Rect current(100, 100, 100, 100);
   EXPECT_EQ(0, TilePriority::TimeForBoundsToIntersect(
@@ -20,15 +21,16 @@
       gfx::Rect(400, 400, 100, 100), current, 1, target));
 
   current = gfx::Rect(-300, -300, 100, 100);
-  EXPECT_EQ(1000, TilePriority::TimeForBoundsToIntersect(
+  EXPECT_EQ(inf, TilePriority::TimeForBoundsToIntersect(
       gfx::Rect(0, 0, 100, 100), current, 1, target));
-  EXPECT_EQ(1000, TilePriority::TimeForBoundsToIntersect(
+  EXPECT_EQ(inf, TilePriority::TimeForBoundsToIntersect(
       gfx::Rect(-200, -200, 100, 100), current, 1, target));
   EXPECT_EQ(2, TilePriority::TimeForBoundsToIntersect(
       gfx::Rect(-400, -400, 100, 100), current, 1, target));
 }
 
 TEST(TilePriorityTest, TimeForBoundsToIntersectWithScale) {
+  const float inf = std::numeric_limits<float>::infinity();
   gfx::Rect target(0, 0, 800, 600);
   gfx::Rect current(100, 100, 100, 100);
   EXPECT_EQ(0, TilePriority::TimeForBoundsToIntersect(
@@ -39,7 +41,7 @@
       gfx::Rect(400, 400, 400, 400), current, 1, target));
 
   current = gfx::Rect(-300, -300, 100, 100);
-  EXPECT_EQ(1000, TilePriority::TimeForBoundsToIntersect(
+  EXPECT_EQ(inf, TilePriority::TimeForBoundsToIntersect(
       gfx::Rect(-400, -400, 300, 300), current, 1, target));
   EXPECT_EQ(8, TilePriority::TimeForBoundsToIntersect(
       gfx::Rect(-275, -275, 50, 50), current, 1, target));
Index: src/cc/quad_culler_unittest.cc
===================================================================
--- src/cc/quad_culler_unittest.cc	(revision 184497)
+++ src/cc/quad_culler_unittest.cc	(working copy)
@@ -72,12 +72,14 @@
         gfx::Rect rectInTarget = MathUtil::mapClippedRect(layer->drawTransform(), layer->visibleContentRect());
         if (!parent) {
             layer->createRenderSurface();
+            layer->renderSurface()->setContentRect(rectInTarget);
             surfaceLayerList.push_back(layer.get());
             layer->renderSurface()->layerList().push_back(layer.get());
         } else {
             layer->drawProperties().render_target = parent->renderTarget();
             parent->renderSurface()->layerList().push_back(layer.get());
             rectInTarget.Union(MathUtil::mapClippedRect(parent->drawTransform(), parent->visibleContentRect()));
+            parent->renderSurface()->setContentRect(rectInTarget);
         }
         layer->drawProperties().drawable_content_rect = rectInTarget;
 
Index: src/cc/io_surface_draw_quad.cc
===================================================================
--- src/cc/io_surface_draw_quad.cc	(revision 184497)
+++ src/cc/io_surface_draw_quad.cc	(working copy)
@@ -47,6 +47,12 @@
   this->orientation = orientation;
 }
 
+void IOSurfaceDrawQuad::AppendResources(
+    ResourceProvider::ResourceIdArray* resources) {
+  // TODO(danakj): Convert to TextureDrawQuad?
+  NOTIMPLEMENTED();
+}
+
 const IOSurfaceDrawQuad* IOSurfaceDrawQuad::MaterialCast(
     const DrawQuad* quad) {
   DCHECK(quad->material == DrawQuad::IO_SURFACE_CONTENT);
Index: src/cc/render_pass.h
===================================================================
--- src/cc/render_pass.h	(revision 184497)
+++ src/cc/render_pass.h	(working copy)
@@ -5,17 +5,15 @@
 #ifndef CC_RENDER_PASS_H_
 #define CC_RENDER_PASS_H_
 
-#include <public/WebFilterOperations.h>
 #include <vector>
 
 #include "base/basictypes.h"
 #include "cc/cc_export.h"
-#include "cc/draw_quad.h"
 #include "cc/hash_pair.h"
 #include "cc/scoped_ptr_hash_map.h"
 #include "cc/scoped_ptr_vector.h"
-#include "cc/shared_quad_state.h"
 #include "skia/ext/refptr.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkImageFilter.h"
 #include "ui/gfx/rect_f.h"
@@ -23,6 +21,9 @@
 
 namespace cc {
 
+class DrawQuad;
+class SharedQuadState;
+
 // A list of DrawQuad objects, sorted internally in front-to-back order.
 class QuadList : public ScopedPtrVector<DrawQuad> {
  public:
@@ -74,10 +75,7 @@
               gfx::RectF damage_rect,
               const gfx::Transform& transform_to_root_target,
               bool has_transparent_background,
-              bool has_occlusion_from_outside_target_surface,
-              const WebKit::WebFilterOperations& filters,
-              const skia::RefPtr<SkImageFilter>& filter,
-              const WebKit::WebFilterOperations& background_filters);
+              bool has_occlusion_from_outside_target_surface);
 
   // Uniquely identifies the render pass in the compositor's current frame.
   Id id;
@@ -97,16 +95,6 @@
   // complete, since they are occluded.
   bool has_occlusion_from_outside_target_surface;
 
-  // Deprecated post-processing filters, applied to the pixels in the render
-  // pass' texture.
-  WebKit::WebFilterOperations filters;
-  // Post-processing filter applied to the pixels in the render pass' texture.
-  skia::RefPtr<SkImageFilter> filter;
-
-  // Post-processing filters, applied to the pixels showing through the
-  // background of the render pass, from behind it.
-  WebKit::WebFilterOperations background_filters;
-
   QuadList quad_list;
   SharedQuadStateList shared_quad_state_list;
 
@@ -139,8 +127,8 @@
 }
 
 namespace cc {
-typedef std::vector<RenderPass*> RenderPassList;
-typedef ScopedPtrHashMap<RenderPass::Id, RenderPass> RenderPassIdHashMap;
+typedef ScopedPtrVector<RenderPass> RenderPassList;
+typedef base::hash_map<RenderPass::Id, RenderPass*> RenderPassIdHashMap;
 } // namespace cc
 
 #endif  // CC_RENDER_PASS_H_
Index: src/cc/draw_quad.cc
===================================================================
--- src/cc/draw_quad.cc	(revision 184497)
+++ src/cc/draw_quad.cc	(working copy)
@@ -89,4 +89,6 @@
   return copy_quad.Pass();
 }
 
+void DrawQuad::AppendResources(ResourceProvider::ResourceIdArray* resources) {}
+
 }  // namespace cc
Index: src/cc/layer_tree_host_impl_unittest.cc
===================================================================
--- src/cc/layer_tree_host_impl_unittest.cc	(revision 184497)
+++ src/cc/layer_tree_host_impl_unittest.cc	(working copy)
@@ -27,6 +27,7 @@
 #include "cc/test/animation_test_common.h"
 #include "cc/test/fake_output_surface.h"
 #include "cc/test/fake_proxy.h"
+#include "cc/test/fake_video_frame_provider.h"
 #include "cc/test/fake_web_graphics_context_3d.h"
 #include "cc/test/fake_web_scrollbar_theme_geometry.h"
 #include "cc/test/geometry_test_utils.h"
@@ -38,20 +39,17 @@
 #include "cc/tiled_layer_impl.h"
 #include "cc/video_layer_impl.h"
 #include "media/base/media.h"
-#include "media/base/video_frame.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/size_conversions.h"
 #include "ui/gfx/vector2d_conversions.h"
-#include <public/WebVideoFrame.h>
-#include <public/WebVideoFrameProvider.h>
 
-using media::VideoFrame;
 using ::testing::Mock;
 using ::testing::Return;
 using ::testing::AnyNumber;
 using ::testing::AtLeast;
 using ::testing::_;
+using media::VideoFrame;
 
 namespace cc {
 namespace {
@@ -66,8 +64,10 @@
         , m_alwaysImplThread(&m_proxy)
         , m_alwaysMainThreadBlocked(&m_proxy)
         , m_onCanDrawStateChangedCalled(false)
+        , m_hasPendingTree(false)
         , m_didRequestCommit(false)
         , m_didRequestRedraw(false)
+        , m_didUploadVisibleHighResolutionTile(false)
         , m_reduceMemoryResult(true)
     {
         media::InitializeMediaLibraryForTesting();
@@ -92,12 +92,17 @@
     virtual void onSwapBuffersCompleteOnImplThread() OVERRIDE { }
     virtual void onVSyncParametersChanged(base::TimeTicks, base::TimeDelta) OVERRIDE { }
     virtual void onCanDrawStateChanged(bool canDraw) OVERRIDE { m_onCanDrawStateChangedCalled = true; }
+    virtual void onHasPendingTreeStateChanged(bool hasPendingTree) OVERRIDE { m_hasPendingTree = hasPendingTree; }
     virtual void setNeedsRedrawOnImplThread() OVERRIDE { m_didRequestRedraw = true; }
+    virtual void didUploadVisibleHighResolutionTileOnImplThread() OVERRIDE { m_didUploadVisibleHighResolutionTile = true; }
     virtual void setNeedsCommitOnImplThread() OVERRIDE { m_didRequestCommit = true; }
     virtual void setNeedsManageTilesOnImplThread() OVERRIDE { }
     virtual void postAnimationEventsToMainThreadOnImplThread(scoped_ptr<AnimationEventsVector>, base::Time wallClockTime) OVERRIDE { }
     virtual bool reduceContentsTextureMemoryOnImplThread(size_t limitBytes, int priorityCutoff) OVERRIDE { return m_reduceMemoryResult; }
+    virtual void reduceWastedContentsTextureMemoryOnImplThread() OVERRIDE { }
     virtual void sendManagedMemoryStats() OVERRIDE { }
+    virtual bool isInsideDraw() OVERRIDE { return false; }
+    virtual void renewTreePriority() OVERRIDE { }
 
     void setReduceMemoryResult(bool reduceMemoryResult) { m_reduceMemoryResult = reduceMemoryResult; }
 
@@ -121,7 +126,7 @@
         root->setContentBounds(gfx::Size(10, 10));
         root->setDrawsContent(true);
         root->drawProperties().visible_content_rect = gfx::Rect(0, 0, 10, 10);
-        m_hostImpl->setRootLayer(root.Pass());
+        m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     }
 
     static void expectClearedScrollDeltasRecursive(LayerImpl* layer)
@@ -176,7 +181,8 @@
         contents->setPosition(gfx::PointF(0, 0));
         contents->setAnchorPoint(gfx::PointF(0, 0));
         root->addChild(contents.Pass());
-        m_hostImpl->setRootLayer(root.Pass());
+        m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+        m_hostImpl->activeTree()->DidBecomeActive();
     }
 
     scoped_ptr<LayerImpl> createScrollableLayer(int id, const gfx::Size& size)
@@ -207,14 +213,22 @@
 protected:
     virtual scoped_ptr<OutputSurface> createOutputSurface() { return createFakeOutputSurface(); }
 
+    void drawOneFrame() {
+      LayerTreeHostImpl::FrameData frameData;
+      m_hostImpl->prepareToDraw(frameData);
+      m_hostImpl->didDrawAllLayers(frameData);
+    }
+
     FakeProxy m_proxy;
     DebugScopedSetImplThread m_alwaysImplThread;
     DebugScopedSetMainThreadBlocked m_alwaysMainThreadBlocked;
 
     scoped_ptr<LayerTreeHostImpl> m_hostImpl;
     bool m_onCanDrawStateChangedCalled;
+    bool m_hasPendingTree;
     bool m_didRequestCommit;
     bool m_didRequestRedraw;
+    bool m_didUploadVisibleHighResolutionTile;
     bool m_reduceMemoryResult;
 };
 
@@ -237,7 +251,7 @@
     m_onCanDrawStateChangedCalled = false;
 
     // Toggle the root layer to make sure it toggles canDraw
-    m_hostImpl->setRootLayer(scoped_ptr<LayerImpl>());
+    m_hostImpl->activeTree()->SetRootLayer(scoped_ptr<LayerImpl>());
     EXPECT_FALSE(m_hostImpl->canDraw());
     EXPECT_TRUE(m_onCanDrawStateChangedCalled);
     m_onCanDrawStateChangedCalled = false;
@@ -275,7 +289,7 @@
     EXPECT_TRUE(m_onCanDrawStateChangedCalled);
     m_onCanDrawStateChangedCalled = false;
 
-    m_hostImpl->resetContentsTexturesPurged();
+    m_hostImpl->activeTree()->ResetContentsTexturesPurged();
     EXPECT_TRUE(m_hostImpl->canDraw());
     EXPECT_TRUE(m_onCanDrawStateChangedCalled);
     m_onCanDrawStateChangedCalled = false;
@@ -298,7 +312,7 @@
         root->children()[1]->addChild(LayerImpl::create(m_hostImpl->activeTree(), 4));
         root->children()[1]->addChild(LayerImpl::create(m_hostImpl->activeTree(), 5));
         root->children()[1]->children()[0]->addChild(LayerImpl::create(m_hostImpl->activeTree(), 6));
-        m_hostImpl->setRootLayer(root.Pass());
+        m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     }
     LayerImpl* root = m_hostImpl->rootLayer();
 
@@ -325,7 +339,7 @@
         root->setScrollable(true);
         root->setMaxScrollOffset(gfx::Vector2d(100, 100));
         root->scrollBy(scrollDelta);
-        m_hostImpl->setRootLayer(root.Pass());
+        m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     }
     LayerImpl* root = m_hostImpl->rootLayer();
 
@@ -392,7 +406,7 @@
 
     // We should not crash if the tree is replaced while we are scrolling.
     EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
-    m_hostImpl->detachLayerTree();
+    m_hostImpl->activeTree()->DetachLayerTree();
 
     setupScrollAndContentsLayers(gfx::Size(100, 100));
 
@@ -413,7 +427,7 @@
     // We should be able to scroll even if the root layer loses its render surface after the most
     // recent render.
     m_hostImpl->rootLayer()->clearRenderSurface();
-    m_hostImpl->setNeedsUpdateDrawProperties();
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
 
     EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
 }
@@ -526,23 +540,6 @@
     EXPECT_TRUE(m_hostImpl->scrollBy(gfx::Point(), gfx::Vector2d(5000, 5000)));
 }
 
-TEST_P(LayerTreeHostImplTest, maxScrollOffsetChangedByDeviceScaleFactor)
-{
-    setupScrollAndContentsLayers(gfx::Size(100, 100));
-
-    float deviceScaleFactor = 2;
-    gfx::Size layoutViewport(25, 25);
-    gfx::Size deviceViewport(gfx::ToFlooredSize(gfx::ScaleSize(layoutViewport, deviceScaleFactor)));
-    m_hostImpl->setViewportSize(layoutViewport, deviceViewport);
-    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-    EXPECT_EQ(m_hostImpl->rootLayer()->maxScrollOffset(), gfx::Vector2d(25, 25));
-
-    deviceScaleFactor = 1;
-    m_hostImpl->setViewportSize(layoutViewport, layoutViewport);
-    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-    EXPECT_EQ(m_hostImpl->rootLayer()->maxScrollOffset(), gfx::Vector2d(75, 75));
-}
-
 TEST_P(LayerTreeHostImplTest, clearRootRenderSurfaceAndHitTestTouchHandlerRegion)
 {
     setupScrollAndContentsLayers(gfx::Size(100, 100));
@@ -552,7 +549,7 @@
     // We should be able to hit test for touch event handlers even if the root layer loses
     // its render surface after the most recent render.
     m_hostImpl->rootLayer()->clearRenderSurface();
-    m_hostImpl->setNeedsUpdateDrawProperties();
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
 
     EXPECT_EQ(m_hostImpl->haveTouchEventHandlersAt(gfx::Point(0, 0)), false);
 }
@@ -573,9 +570,10 @@
     const float minPageScale = 1, maxPageScale = 4;
     const gfx::Transform identityScaleTransform;
 
-    // The impl-based pinch zoom should not adjust the max scroll position.
+    // The impl-based pinch zoom should adjust the max scroll position.
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleDelta(1);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
 
@@ -589,13 +587,14 @@
         scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
         EXPECT_EQ(scrollInfo->pageScaleDelta, pageScaleDelta);
 
-        EXPECT_EQ(m_hostImpl->rootLayer()->maxScrollOffset(), gfx::Vector2d(50, 50));
+        EXPECT_EQ(gfx::Vector2d(75, 75), m_hostImpl->rootLayer()->maxScrollOffset());
     }
 
     // Scrolling after a pinch gesture should always be in local space.  The scroll deltas do not
     // have the page scale factor applied.
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleDelta(1);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
 
@@ -616,6 +615,10 @@
 
 TEST_P(LayerTreeHostImplTest, pinchGesture)
 {
+    // This test is specific to the page-scale based pinch zoom.
+    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
+        return;
+
     setupScrollAndContentsLayers(gfx::Size(100, 100));
     m_hostImpl->setViewportSize(gfx::Size(50, 50), gfx::Size(50, 50));
     initializeRendererAndDrawFrame();
@@ -629,7 +632,7 @@
 
     // Basic pinch zoom in gesture
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
 
@@ -646,7 +649,7 @@
 
     // Zoom-in clamping
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
         float pageScaleDelta = 10;
@@ -661,7 +664,7 @@
 
     // Zoom-out clamping
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
         scrollLayer->setScrollOffset(gfx::Vector2d(50, 50));
@@ -684,7 +687,7 @@
 
     // Two-finger panning should not happen based on pinch events only
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
         scrollLayer->setScrollOffset(gfx::Vector2d(20, 20));
@@ -702,7 +705,7 @@
 
     // Two-finger panning should work with interleaved scroll events
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollDelta(gfx::Vector2d());
         scrollLayer->setScrollOffset(gfx::Vector2d(20, 20));
@@ -741,7 +744,7 @@
 
     // Non-anchor zoom-in
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollOffset(gfx::Vector2d(50, 50));
 
@@ -758,7 +761,7 @@
 
     // Anchor zoom-out
     {
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
         scrollLayer->setImplTransform(identityScaleTransform);
         scrollLayer->setScrollOffset(gfx::Vector2d(50, 50));
 
@@ -774,7 +777,7 @@
     }
 }
 
-TEST_P(LayerTreeHostImplTest, inhibitScrollAndPageScaleUpdatesWhilePinchZooming)
+TEST_P(LayerTreeHostImplTest, pageScaleAnimationNoOp)
 {
     setupScrollAndContentsLayers(gfx::Size(100, 100));
     m_hostImpl->setViewportSize(gfx::Size(50, 50), gfx::Size(50, 50));
@@ -783,110 +786,95 @@
     LayerImpl* scrollLayer = m_hostImpl->rootScrollLayer();
     DCHECK(scrollLayer);
 
-    const float minPageScale = m_hostImpl->settings().pageScalePinchZoomEnabled ? 1 : 0.5;
+    const float minPageScale = 0.5;
     const float maxPageScale = 4;
+    const base::TimeTicks startTime = base::TimeTicks() + base::TimeDelta::FromSeconds(1);
+    const base::TimeDelta duration = base::TimeDelta::FromMilliseconds(100);
+    const base::TimeTicks halfwayThroughAnimation = startTime + duration / 2;
+    const base::TimeTicks endTime = startTime + duration;
+    const gfx::Transform identityScaleTransform;
 
-    // Pinch zoom in.
+    // Anchor zoom with unchanged page scale should not change scroll or scale.
     {
-        // Start a pinch in gesture at the bottom right corner of the viewport.
-        const float zoomInDelta = 2;
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
-        m_hostImpl->pinchGestureBegin();
-        m_hostImpl->pinchGestureUpdate(zoomInDelta, gfx::Point(50, 50));
+        m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
+        scrollLayer->setImplTransform(identityScaleTransform);
+        scrollLayer->setScrollOffset(gfx::Vector2d(50, 50));
 
-        // Because we are pinch zooming in, we shouldn't get any scroll or page
-        // scale deltas.
+        m_hostImpl->startPageScaleAnimation(gfx::Vector2d(0, 0), true, 1, startTime, duration);
+        m_hostImpl->animate(halfwayThroughAnimation, base::Time());
+        EXPECT_TRUE(m_didRequestRedraw);
+        m_hostImpl->animate(endTime, base::Time());
+        EXPECT_TRUE(m_didRequestCommit);
+
         scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
         EXPECT_EQ(scrollInfo->pageScaleDelta, 1);
-        EXPECT_EQ(scrollInfo->scrolls.size(), 0u);
-
-        // Once the gesture ends, we get the final scroll and page scale values.
-        m_hostImpl->pinchGestureEnd();
-        scrollInfo = m_hostImpl->processScrollDeltas();
-        EXPECT_EQ(scrollInfo->pageScaleDelta, zoomInDelta);
-        if (!m_hostImpl->settings().pageScalePinchZoomEnabled) {
-            expectContains(*scrollInfo, scrollLayer->id(), gfx::Vector2d(25, 25));
-        } else {
-            EXPECT_TRUE(scrollInfo->scrolls.empty());
-        }
+        expectNone(*scrollInfo, scrollLayer->id());
     }
-
-    // Pinch zoom out.
-    {
-        // Start a pinch out gesture at the bottom right corner of the viewport.
-        const float zoomOutDelta = 0.75;
-        m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
-        m_hostImpl->pinchGestureBegin();
-        m_hostImpl->pinchGestureUpdate(zoomOutDelta, gfx::Point(50, 50));
-
-        // Since we are pinch zooming out, we should get an update to zoom all
-        // the way out to the minimum page scale.
-        scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
-        if (!m_hostImpl->settings().pageScalePinchZoomEnabled) {
-            EXPECT_EQ(scrollInfo->pageScaleDelta, minPageScale);
-            expectContains(*scrollInfo, scrollLayer->id(), gfx::Vector2d(0, 0));
-        } else {
-            EXPECT_EQ(scrollInfo->pageScaleDelta, 1);
-            EXPECT_TRUE(scrollInfo->scrolls.empty());
-        }
-
-        // Once the gesture ends, we get the final scroll and page scale values.
-        m_hostImpl->pinchGestureEnd();
-        scrollInfo = m_hostImpl->processScrollDeltas();
-        if (m_hostImpl->settings().pageScalePinchZoomEnabled) {
-            EXPECT_EQ(scrollInfo->pageScaleDelta, minPageScale);
-            expectContains(*scrollInfo, scrollLayer->id(), gfx::Vector2d(25, 25));
-        } else {
-            EXPECT_EQ(scrollInfo->pageScaleDelta, zoomOutDelta);
-            expectContains(*scrollInfo, scrollLayer->id(), gfx::Vector2d(8, 8));
-        }
-    }
 }
 
-TEST_P(LayerTreeHostImplTest, inhibitScrollAndPageScaleUpdatesWhileAnimatingPageScale)
+TEST_P(LayerTreeHostImplTest, compositorFrameMetadata)
 {
+    // This test is specific to the page-scale based pinch zoom.
+    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
+        return;
+
     setupScrollAndContentsLayers(gfx::Size(100, 100));
     m_hostImpl->setViewportSize(gfx::Size(50, 50), gfx::Size(50, 50));
+    m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1.0f, 0.5f, 4.0f);
     initializeRendererAndDrawFrame();
 
-    LayerImpl* scrollLayer = m_hostImpl->rootScrollLayer();
-    DCHECK(scrollLayer);
+    {
+        CompositorFrameMetadata metadata = m_hostImpl->makeCompositorFrameMetadata();
+        EXPECT_EQ(gfx::Vector2dF(0.0f, 0.0f), metadata.root_scroll_offset);
+        EXPECT_EQ(1.0f, metadata.page_scale_factor);
+        EXPECT_EQ(gfx::SizeF(50.0f, 50.0f), metadata.viewport_size);
+        EXPECT_EQ(gfx::SizeF(100.0f, 100.0f), metadata.root_layer_size);
+        EXPECT_EQ(0.5f, metadata.min_page_scale_factor);
+        EXPECT_EQ(4.0f, metadata.max_page_scale_factor);
+    }
 
-    const float minPageScale = 0.5;
-    const float maxPageScale = 4;
-    const base::TimeTicks startTime = base::TimeTicks() + base::TimeDelta::FromSeconds(1);
-    const base::TimeDelta duration = base::TimeDelta::FromMilliseconds(100);
-    const base::TimeTicks halfwayThroughAnimation = startTime + duration / 2;
-    const base::TimeTicks endTime = startTime + duration;
+    // Scrolling should update metadata immediately.
+    EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
+    m_hostImpl->scrollBy(gfx::Point(), gfx::Vector2d(0, 10));
+    {
+        CompositorFrameMetadata metadata = m_hostImpl->makeCompositorFrameMetadata();
+        EXPECT_EQ(gfx::Vector2dF(0.0f, 10.0f), metadata.root_scroll_offset);
+    }
+    m_hostImpl->scrollEnd();
 
-    const float pageScaleDelta = 2;
-    gfx::Vector2d target(25, 25);
-    gfx::Vector2d scaledTarget = target;
-    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
-      scaledTarget = gfx::Vector2d(12, 12);
+    {
+        CompositorFrameMetadata metadata = m_hostImpl->makeCompositorFrameMetadata();
+        EXPECT_EQ(gfx::Vector2dF(0.0f, 10.0f), metadata.root_scroll_offset);
+    }
 
-    m_hostImpl->setPageScaleFactorAndLimits(1, minPageScale, maxPageScale);
-    m_hostImpl->startPageScaleAnimation(target, false, pageScaleDelta, startTime, duration);
+    // Page scale should update metadata correctly (shrinking only the viewport).
+    m_hostImpl->pinchGestureBegin();
+    m_hostImpl->pinchGestureUpdate(2.0f, gfx::Point(0, 0));
+    m_hostImpl->pinchGestureEnd();
 
-    // We should immediately get the final zoom and scroll values for the
-    // animation.
-    m_hostImpl->animate(halfwayThroughAnimation, base::Time());
-    scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
-    EXPECT_EQ(scrollInfo->pageScaleDelta, pageScaleDelta);
-    expectContains(*scrollInfo, scrollLayer->id(), scaledTarget);
+    {
+        CompositorFrameMetadata metadata = m_hostImpl->makeCompositorFrameMetadata();
+        EXPECT_EQ(gfx::Vector2dF(0.0f, 10.0f), metadata.root_scroll_offset);
+        EXPECT_EQ(2, metadata.page_scale_factor);
+        EXPECT_EQ(gfx::SizeF(25.0f, 25.0f), metadata.viewport_size);
+        EXPECT_EQ(gfx::SizeF(100.0f, 100.0f), metadata.root_layer_size);
+        EXPECT_EQ(0.5f, metadata.min_page_scale_factor);
+        EXPECT_EQ(4.0f, metadata.max_page_scale_factor);
+    }
 
-    // Scrolling during the animation is ignored.
-    const gfx::Vector2d scrollDelta(0, 10);
-    EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(target.x(), target.y()), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-
-    // The final page scale and scroll deltas should match what we got
-    // earlier.
-    m_hostImpl->animate(endTime, base::Time());
-    scrollInfo = m_hostImpl->processScrollDeltas();
-    EXPECT_EQ(scrollInfo->pageScaleDelta, pageScaleDelta);
-    expectContains(*scrollInfo, scrollLayer->id(), scaledTarget);
+    // Likewise if set from the main thread.
+    m_hostImpl->processScrollDeltas();
+    m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(4.0f, 0.5f, 4.0f);
+    m_hostImpl->activeTree()->SetPageScaleDelta(1.0f);
+    {
+        CompositorFrameMetadata metadata = m_hostImpl->makeCompositorFrameMetadata();
+        EXPECT_EQ(gfx::Vector2dF(0.0f, 10.0f), metadata.root_scroll_offset);
+        EXPECT_EQ(4.0f, metadata.page_scale_factor);
+        EXPECT_EQ(gfx::SizeF(12.5f, 12.5f), metadata.viewport_size);
+        EXPECT_EQ(gfx::SizeF(100.0f, 100.0f), metadata.root_layer_size);
+        EXPECT_EQ(0.5f, metadata.min_page_scale_factor);
+        EXPECT_EQ(4.0f, metadata.max_page_scale_factor);
+    }
 }
 
 class DidDrawCheckLayer : public TiledLayerImpl {
@@ -939,7 +927,7 @@
 {
     // The root layer is always drawn, so run this test on a child layer that
     // will be masked out by the root layer's bounds.
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
     DidDrawCheckLayer* root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
     root->setMasksToBounds(true);
 
@@ -985,7 +973,7 @@
     gfx::Size bigSize(1000, 1000);
     m_hostImpl->setViewportSize(bigSize, bigSize);
 
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
     DidDrawCheckLayer* root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
 
     root->addChild(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 2));
@@ -1017,7 +1005,7 @@
 
 TEST_P(LayerTreeHostImplTest, didDrawCalledOnAllLayers)
 {
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
     DidDrawCheckLayer* root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
 
     root->addChild(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 2));
@@ -1063,6 +1051,7 @@
         setSkipsDraw(skipsDraw);
         if (!tileMissing) {
             ResourceProvider::ResourceId resource = resourceProvider->createResource(gfx::Size(), GL_RGBA, ResourceProvider::TextureUsageAny);
+            resourceProvider->allocateForTesting(resource);
             pushTileProperties(0, 0, resource, gfx::Rect(), false);
         }
         if (animating)
@@ -1073,7 +1062,7 @@
 TEST_P(LayerTreeHostImplTest, prepareToDrawFailsWhenAnimationUsesCheckerboard)
 {
     // When the texture is not missing, we draw as usual.
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 1));
     DidDrawCheckLayer* root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
     root->addChild(MissingTextureAnimatingLayer::create(m_hostImpl->activeTree(), 2, false, false, true, m_hostImpl->resourceProvider()));
 
@@ -1084,7 +1073,7 @@
     m_hostImpl->didDrawAllLayers(frame);
 
     // When a texture is missing and we're not animating, we draw as usual with checkerboarding.
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 3));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 3));
     root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
     root->addChild(MissingTextureAnimatingLayer::create(m_hostImpl->activeTree(), 4, true, false, false, m_hostImpl->resourceProvider()));
 
@@ -1093,7 +1082,7 @@
     m_hostImpl->didDrawAllLayers(frame);
 
     // When a texture is missing and we're animating, we don't want to draw anything.
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 5));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 5));
     root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
     root->addChild(MissingTextureAnimatingLayer::create(m_hostImpl->activeTree(), 6, true, false, true, m_hostImpl->resourceProvider()));
 
@@ -1102,7 +1091,7 @@
     m_hostImpl->didDrawAllLayers(frame);
 
     // When the layer skips draw and we're animating, we still draw the frame.
-    m_hostImpl->setRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 7));
+    m_hostImpl->activeTree()->SetRootLayer(DidDrawCheckLayer::create(m_hostImpl->activeTree(), 7));
     root = static_cast<DidDrawCheckLayer*>(m_hostImpl->rootLayer());
     root->addChild(MissingTextureAnimatingLayer::create(m_hostImpl->activeTree(), 8, false, true, true, m_hostImpl->resourceProvider()));
 
@@ -1115,7 +1104,7 @@
 {
     scoped_ptr<LayerImpl> root = LayerImpl::create(m_hostImpl->activeTree(), 1);
     root->setScrollable(false);
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     initializeRendererAndDrawFrame();
 
     // Scroll event is ignored because layer is not scrollable.
@@ -1147,7 +1136,7 @@
     scrollLayer->setAnchorPoint(gfx::PointF(0, 0));
     scrollLayer->addChild(contentLayer.Pass());
 
-    m_hostImpl->setRootLayer(scrollLayer.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(scrollLayer.Pass());
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
 
@@ -1165,7 +1154,7 @@
     root->setBounds(surfaceSize);
     root->setContentBounds(surfaceSize);
     root->addChild(createScrollableLayer(2, surfaceSize));
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
 
@@ -1181,7 +1170,7 @@
     gfx::Size surfaceSize(10, 10);
     scoped_ptr<LayerImpl> root = LayerImpl::create(m_hostImpl->activeTree(), 1);
     root->addChild(createScrollableLayer(2, surfaceSize));
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
 
@@ -1199,12 +1188,12 @@
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
 
     gfx::Transform matrix;
-    MathUtil::rotateEulerAngles(&matrix, 180, 0, 0);
+    matrix.RotateAboutXAxis(180);
     child->setTransform(matrix);
     child->setDoubleSided(false);
 
     root->addChild(child.Pass());
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     initializeRendererAndDrawFrame();
 
     // Scroll event is ignored because the scrollable layer is not facing the viewer and there is
@@ -1224,7 +1213,7 @@
     scoped_ptr<LayerImpl> scrollLayer = createScrollableLayer(2, surfaceSize);
     scrollLayer->addChild(contentLayer.Pass());
 
-    m_hostImpl->setRootLayer(scrollLayer.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(scrollLayer.Pass());
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
 
@@ -1234,10 +1223,15 @@
 
 TEST_P(LayerTreeHostImplTest, scrollRootAndChangePageScaleOnMainThread)
 {
+    // This test is specific to the page-scale based pinch zoom.
+    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
+        return;
+
     gfx::Size surfaceSize(10, 10);
     float pageScale = 2;
     scoped_ptr<LayerImpl> root = createScrollableLayer(1, surfaceSize);
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+    m_hostImpl->activeTree()->DidBecomeActive();
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
 
@@ -1249,7 +1243,7 @@
     m_hostImpl->scrollEnd();
 
     // Set new page scale from main thread.
-    m_hostImpl->setPageScaleFactorAndLimits(pageScale, pageScale, pageScale);
+    m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(pageScale, pageScale, pageScale);
 
     if (!m_hostImpl->settings().pageScalePinchZoomEnabled) {
         // The scale should apply to the scroll delta.
@@ -1289,9 +1283,10 @@
     gfx::Size surfaceSize(10, 10);
     float pageScale = 2;
     scoped_ptr<LayerImpl> root = createScrollableLayer(1, surfaceSize);
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+    m_hostImpl->activeTree()->DidBecomeActive();
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
-    m_hostImpl->setPageScaleFactorAndLimits(1, 1, pageScale);
+    m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(1, 1, pageScale);
     initializeRendererAndDrawFrame();
 
     gfx::Vector2d scrollDelta(0, 10);
@@ -1305,7 +1300,7 @@
     m_hostImpl->pinchGestureBegin();
     m_hostImpl->pinchGestureUpdate(pageScale, gfx::Point());
     m_hostImpl->pinchGestureEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
+    drawOneFrame();
 
     // The scroll delta is not scaled because the main thread did not scale.
     scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
@@ -1343,7 +1338,7 @@
     m_hostImpl->pinchGestureBegin();
     m_hostImpl->pinchGestureUpdate(newPageScale, gfx::Point());
     m_hostImpl->pinchGestureEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
+    drawOneFrame();
 
     // The page scale delta should only be applied to the scrollable root layer.
     EXPECT_EQ(root->implTransform(), newPageScaleMatrix);
@@ -1367,6 +1362,10 @@
 
 TEST_P(LayerTreeHostImplTest, scrollChildAndChangePageScaleOnMainThread)
 {
+    // This test is specific to the page-scale based pinch zoom.
+    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
+        return;
+
     gfx::Size surfaceSize(10, 10);
     scoped_ptr<LayerImpl> root = LayerImpl::create(m_hostImpl->activeTree(), 1);
     root->setBounds(surfaceSize);
@@ -1375,7 +1374,8 @@
     root->setScrollable(true);
     int scrollLayerId = 2;
     root->addChild(createScrollableLayer(scrollLayerId, surfaceSize));
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+    m_hostImpl->activeTree()->DidBecomeActive();
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
 
@@ -1389,9 +1389,9 @@
     m_hostImpl->scrollEnd();
 
     float pageScale = 2;
-    m_hostImpl->setPageScaleFactorAndLimits(pageScale, 1, pageScale);
+    m_hostImpl->activeTree()->SetPageScaleFactorAndLimits(pageScale, 1, pageScale);
 
-    m_hostImpl->updateRootScrollLayerImplTransform();
+    drawOneFrame();
 
     if (!m_hostImpl->settings().pageScalePinchZoomEnabled) {
         // The scale should apply to the scroll delta.
@@ -1424,7 +1424,8 @@
     child->addChild(grandChild.Pass());
 
     root->addChild(child.Pass());
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+    m_hostImpl->activeTree()->DidBecomeActive();
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
     initializeRendererAndDrawFrame();
     {
@@ -1445,19 +1446,91 @@
     }
 }
 
+TEST_P(LayerTreeHostImplTest, scrollWithoutBubbling)
+{
+    // Scroll a child layer beyond its maximum scroll range and make sure the
+    // the scroll doesn't bubble up to the parent layer.
+    gfx::Size surfaceSize(10, 10);
+    scoped_ptr<LayerImpl> root = createScrollableLayer(1, surfaceSize);
+
+    scoped_ptr<LayerImpl> grandChild = createScrollableLayer(3, surfaceSize);
+    grandChild->setScrollOffset(gfx::Vector2d(0, 2));
+
+    scoped_ptr<LayerImpl> child = createScrollableLayer(2, surfaceSize);
+    child->setScrollOffset(gfx::Vector2d(0, 3));
+    child->addChild(grandChild.Pass());
+
+    root->addChild(child.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+    m_hostImpl->activeTree()->DidBecomeActive();
+    m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
+    initializeRendererAndDrawFrame();
+    {
+        gfx::Vector2d scrollDelta(0, -10);
+        EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::NonBubblingGesture), InputHandlerClient::ScrollStarted);
+        m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
+        m_hostImpl->scrollEnd();
+
+        scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
+
+        // The grand child should have scrolled up to its limit.
+        LayerImpl* child = m_hostImpl->rootLayer()->children()[0];
+        LayerImpl* grandChild = child->children()[0];
+        expectContains(*scrollInfo.get(), grandChild->id(), gfx::Vector2d(0, -2));
+
+        // The child should not have scrolled.
+        expectNone(*scrollInfo.get(), child->id());
+
+        // The next time we scroll we should only scroll the parent.
+        scrollDelta = gfx::Vector2d(0, -3);
+        EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::NonBubblingGesture), InputHandlerClient::ScrollStarted);
+        EXPECT_EQ(m_hostImpl->currentlyScrollingLayer(), grandChild);
+        m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
+        EXPECT_EQ(m_hostImpl->currentlyScrollingLayer(), child);
+        m_hostImpl->scrollEnd();
+
+        scrollInfo = m_hostImpl->processScrollDeltas();
+
+        // The child should have scrolled up to its limit.
+        expectContains(*scrollInfo.get(), child->id(), gfx::Vector2d(0, -3));
+
+        // The grand child should not have scrolled.
+        expectContains(*scrollInfo.get(), grandChild->id(), gfx::Vector2d(0, -2));
+
+        // After scrolling the parent, another scroll on the opposite direction
+        // should still scroll the child.
+        scrollDelta = gfx::Vector2d(0, 7);
+        EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::NonBubblingGesture), InputHandlerClient::ScrollStarted);
+        EXPECT_EQ(m_hostImpl->currentlyScrollingLayer(), grandChild);
+        m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
+        EXPECT_EQ(m_hostImpl->currentlyScrollingLayer(), grandChild);
+        m_hostImpl->scrollEnd();
+
+        scrollInfo = m_hostImpl->processScrollDeltas();
+
+        // The grand child should have scrolled.
+        expectContains(*scrollInfo.get(), grandChild->id(), gfx::Vector2d(0, 5));
+
+        // The child should not have scrolled.
+        expectContains(*scrollInfo.get(), child->id(), gfx::Vector2d(0, -3));
+    }
+}
+
 TEST_P(LayerTreeHostImplTest, scrollEventBubbling)
 {
     // When we try to scroll a non-scrollable child layer, the scroll delta
     // should be applied to one of its ancestors if possible.
     gfx::Size surfaceSize(10, 10);
-    scoped_ptr<LayerImpl> root = createScrollableLayer(1, surfaceSize);
-    scoped_ptr<LayerImpl> child = createScrollableLayer(2, surfaceSize);
+    gfx::Size contentSize(20, 20);
+    scoped_ptr<LayerImpl> root = createScrollableLayer(1, contentSize);
+    scoped_ptr<LayerImpl> child = createScrollableLayer(2, contentSize);
 
     child->setScrollable(false);
     root->addChild(child.Pass());
 
-    m_hostImpl->setRootLayer(root.Pass());
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
+    m_hostImpl->activeTree()->DidBecomeActive();
     initializeRendererAndDrawFrame();
     {
         gfx::Vector2d scrollDelta(0, 4);
@@ -1476,13 +1549,15 @@
 TEST_P(LayerTreeHostImplTest, scrollBeforeRedraw)
 {
     gfx::Size surfaceSize(10, 10);
-    m_hostImpl->setRootLayer(createScrollableLayer(1, surfaceSize));
+    m_hostImpl->activeTree()->SetRootLayer(createScrollableLayer(1, surfaceSize));
+    m_hostImpl->activeTree()->DidBecomeActive();
     m_hostImpl->setViewportSize(surfaceSize, surfaceSize);
 
     // Draw one frame and then immediately rebuild the layer tree to mimic a tree synchronization.
     initializeRendererAndDrawFrame();
-    m_hostImpl->detachLayerTree();
-    m_hostImpl->setRootLayer(createScrollableLayer(2, surfaceSize));
+    m_hostImpl->activeTree()->DetachLayerTree();
+    m_hostImpl->activeTree()->SetRootLayer(createScrollableLayer(2, surfaceSize));
+    m_hostImpl->activeTree()->DidBecomeActive();
 
     // Scrolling should still work even though we did not draw yet.
     EXPECT_EQ(m_hostImpl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
@@ -1688,6 +1763,7 @@
         , m_quadVisibleRect(5, 5, 5, 5)
         , m_resourceId(resourceProvider->createResource(gfx::Size(1, 1), GL_RGBA, ResourceProvider::TextureUsageAny))
     {
+        resourceProvider->allocateForTesting(m_resourceId);
         setAnchorPoint(gfx::PointF(0, 0));
         setBounds(gfx::Size(10, 10));
         setContentBounds(gfx::Size(10, 10));
@@ -1711,7 +1787,7 @@
         root->setBounds(gfx::Size(10, 10));
         root->setContentBounds(root->bounds());
         root->setDrawsContent(false);
-        m_hostImpl->setRootLayer(root.Pass());
+        m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     }
     LayerImpl* root = m_hostImpl->rootLayer();
 
@@ -1898,12 +1974,12 @@
 TEST_P(LayerTreeHostImplTest, viewportCovered)
 {
     m_hostImpl->initializeRenderer(createOutputSurface());
-    m_hostImpl->setBackgroundColor(SK_ColorGRAY);
+    m_hostImpl->activeTree()->set_background_color(SK_ColorGRAY);
 
     gfx::Size viewportSize(1000, 1000);
     m_hostImpl->setViewportSize(viewportSize, viewportSize);
 
-    m_hostImpl->setRootLayer(LayerImpl::create(m_hostImpl->activeTree(), 1));
+    m_hostImpl->activeTree()->SetRootLayer(LayerImpl::create(m_hostImpl->activeTree(), 1));
     m_hostImpl->rootLayer()->addChild(BlendStateCheckLayer::create(m_hostImpl->activeTree(), 2, m_hostImpl->resourceProvider()));
     BlendStateCheckLayer* child = static_cast<BlendStateCheckLayer*>(m_hostImpl->rootLayer()->children()[0]);
     child->setExpectation(false, false);
@@ -2016,7 +2092,7 @@
     root->setAnchorPoint(gfx::PointF(0, 0));
     root->setBounds(gfx::Size(10, 10));
     root->setDrawsContent(true);
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
     EXPECT_FALSE(reshapeTracker->reshapeCalled());
 
     LayerTreeHostImpl::FrameData frame;
@@ -2074,7 +2150,7 @@
     root->setContentBounds(gfx::Size(500, 500));
     root->setDrawsContent(true);
     root->addChild(child.Pass());
-    layerTreeHostImpl->setRootLayer(root.Pass());
+    layerTreeHostImpl->activeTree()->SetRootLayer(root.Pass());
 
     LayerTreeHostImpl::FrameData frame;
 
@@ -2138,7 +2214,7 @@
     root->setOpacity(0.7f);
     root->addChild(child.Pass());
 
-    m_hostImpl->setRootLayer(root.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(root.Pass());
 
     LayerTreeHostImpl::FrameData frame;
 
@@ -2230,8 +2306,7 @@
             .WillOnce(Return())
             .RetiresOnSaturation();
 
-        // 1 is hardcoded return value of fake createProgram()
-        EXPECT_CALL(*m_context, useProgram(1))
+        EXPECT_CALL(*m_context, useProgram(_))
             .WillOnce(Return())
             .RetiresOnSaturation();
 
@@ -2415,7 +2490,7 @@
     child->addChild(grandChild.Pass());
     root->addChild(child.Pass());
 
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
     return myHostImpl.Pass();
 }
 
@@ -2459,509 +2534,6 @@
     }
 }
 
-// Make sure that output surface lost notifications are propagated through the tree.
-class OutputSurfaceLostNotificationCheckLayer : public LayerImpl {
-public:
-    static scoped_ptr<LayerImpl> create(LayerTreeImpl* treeImpl, int id) { return scoped_ptr<LayerImpl>(new OutputSurfaceLostNotificationCheckLayer(treeImpl, id)); }
-
-    virtual void didLoseOutputSurface() OVERRIDE
-    {
-        m_didLoseOutputSurfaceCalled = true;
-    }
-
-    bool didLoseOutputSurfaceCalled() const { return m_didLoseOutputSurfaceCalled; }
-
-private:
-    OutputSurfaceLostNotificationCheckLayer(LayerTreeImpl* treeImpl, int id)
-        : LayerImpl(treeImpl, id)
-        , m_didLoseOutputSurfaceCalled(false)
-    {
-    }
-
-    bool m_didLoseOutputSurfaceCalled;
-};
-
-TEST_P(LayerTreeHostImplTest, outputSurfaceLostAndRestoredNotificationSentToAllLayers)
-{
-    m_hostImpl->setRootLayer(OutputSurfaceLostNotificationCheckLayer::create(m_hostImpl->activeTree(), 1));
-    OutputSurfaceLostNotificationCheckLayer* root = static_cast<OutputSurfaceLostNotificationCheckLayer*>(m_hostImpl->rootLayer());
-
-    root->addChild(OutputSurfaceLostNotificationCheckLayer::create(m_hostImpl->activeTree(), 2));
-    OutputSurfaceLostNotificationCheckLayer* layer1 = static_cast<OutputSurfaceLostNotificationCheckLayer*>(root->children()[0]);
-
-    layer1->addChild(OutputSurfaceLostNotificationCheckLayer::create(m_hostImpl->activeTree(), 3));
-    OutputSurfaceLostNotificationCheckLayer* layer2 = static_cast<OutputSurfaceLostNotificationCheckLayer*>(layer1->children()[0]);
-
-    EXPECT_FALSE(root->didLoseOutputSurfaceCalled());
-    EXPECT_FALSE(layer1->didLoseOutputSurfaceCalled());
-    EXPECT_FALSE(layer2->didLoseOutputSurfaceCalled());
-
-    m_hostImpl->initializeRenderer(createOutputSurface());
-
-    EXPECT_TRUE(root->didLoseOutputSurfaceCalled());
-    EXPECT_TRUE(layer1->didLoseOutputSurfaceCalled());
-    EXPECT_TRUE(layer2->didLoseOutputSurfaceCalled());
-}
-
-TEST_P(LayerTreeHostImplTest, finishAllRenderingAfterContextLost)
-{
-    LayerTreeSettings settings;
-    m_hostImpl = LayerTreeHostImpl::create(settings, this, &m_proxy);
-
-    // The context initialization will fail, but we should still be able to call finishAllRendering() without any ill effects.
-    m_hostImpl->initializeRenderer(FakeOutputSurface::Create3d(scoped_ptr<WebKit::WebGraphicsContext3D>(new FakeWebGraphicsContext3DMakeCurrentFails)).PassAs<OutputSurface>());
-    m_hostImpl->finishAllRendering();
-}
-
-class FakeWebGraphicsContext3DMakeCurrentFailsEventually : public FakeWebGraphicsContext3D {
-public:
-    explicit FakeWebGraphicsContext3DMakeCurrentFailsEventually(unsigned succeedCount) : m_succeedCount(succeedCount) { }
-    virtual bool makeContextCurrent() {
-        if (!m_succeedCount)
-            return false;
-        --m_succeedCount;
-        return true;
-    }
-
-private:
-    unsigned m_succeedCount;
-};
-
-TEST_P(LayerTreeHostImplTest, context3DLostDuringInitialize)
-{
-    LayerTreeSettings settings;
-    m_hostImpl = LayerTreeHostImpl::create(settings, this, &m_proxy);
-
-    // Initialize into a known successful state.
-    EXPECT_TRUE(m_hostImpl->initializeRenderer(createOutputSurface()));
-    EXPECT_TRUE(m_hostImpl->outputSurface());
-    EXPECT_TRUE(m_hostImpl->renderer());
-    EXPECT_TRUE(m_hostImpl->resourceProvider());
-
-    // We will make the context get lost after a numer of makeContextCurrent
-    // calls. The exact number of calls to make it succeed is dependent on the
-    // implementation and doesn't really matter (i.e. can be changed to make the
-    // tests pass after some refactoring).
-    const unsigned kMakeCurrentSuccessesNeededForSuccessfulInitialization = 3;
-
-    for (unsigned i = 0; i < kMakeCurrentSuccessesNeededForSuccessfulInitialization; ++i) {
-        // The context will get lost during initialization, we shouldn't crash. We
-        // should also be in a consistent state.
-        EXPECT_FALSE(m_hostImpl->initializeRenderer(FakeOutputSurface::Create3d(scoped_ptr<WebKit::WebGraphicsContext3D>(new FakeWebGraphicsContext3DMakeCurrentFailsEventually(i))).PassAs<OutputSurface>()));
-        EXPECT_EQ(0, m_hostImpl->outputSurface());
-        EXPECT_EQ(0, m_hostImpl->renderer());
-        EXPECT_EQ(0, m_hostImpl->resourceProvider());
-        EXPECT_TRUE(m_hostImpl->initializeRenderer(createOutputSurface()));
-    }
-
-    EXPECT_TRUE(m_hostImpl->initializeRenderer(FakeOutputSurface::Create3d(scoped_ptr<WebKit::WebGraphicsContext3D>(new FakeWebGraphicsContext3DMakeCurrentFailsEventually(kMakeCurrentSuccessesNeededForSuccessfulInitialization))).PassAs<OutputSurface>()));
-    EXPECT_TRUE(m_hostImpl->outputSurface());
-    EXPECT_TRUE(m_hostImpl->renderer());
-    EXPECT_TRUE(m_hostImpl->resourceProvider());
-}
-
-// Fake WebKit::WebGraphicsContext3D that will cause a failure if trying to use a
-// resource that wasn't created by it (resources created by
-// FakeWebGraphicsContext3D have an id of 1).
-class StrictWebGraphicsContext3D : public FakeWebGraphicsContext3D {
-public:
-    StrictWebGraphicsContext3D()
-        : FakeWebGraphicsContext3D()
-    {
-        m_nextTextureId = 8; // Start allocating texture ids larger than any other resource IDs so we can tell if someone's mixing up their resource types.
-    }
-
-    virtual WebKit::WebGLId createBuffer() { return 2; }
-    virtual WebKit::WebGLId createFramebuffer() { return 3; }
-    virtual WebKit::WebGLId createProgram() { return 4; }
-    virtual WebKit::WebGLId createRenderbuffer() { return 5; }
-    virtual WebKit::WebGLId createShader(WebKit::WGC3Denum) { return 6; }
-
-    static const WebKit::WebGLId kExternalTextureId = 7;
-
-    virtual void deleteBuffer(WebKit::WebGLId id)
-    {
-        if (id != 2)
-            ADD_FAILURE() << "Trying to delete buffer id " << id;
-    }
-
-    virtual void deleteFramebuffer(WebKit::WebGLId id)
-    {
-        if (id != 3)
-            ADD_FAILURE() << "Trying to delete framebuffer id " << id;
-    }
-
-    virtual void deleteProgram(WebKit::WebGLId id)
-    {
-        if (id != 4)
-            ADD_FAILURE() << "Trying to delete program id " << id;
-    }
-
-    virtual void deleteRenderbuffer(WebKit::WebGLId id)
-    {
-        if (id != 5)
-            ADD_FAILURE() << "Trying to delete renderbuffer id " << id;
-    }
-
-    virtual void deleteShader(WebKit::WebGLId id)
-    {
-        if (id != 6)
-            ADD_FAILURE() << "Trying to delete shader id " << id;
-    }
-
-    virtual WebKit::WebGLId createTexture()
-    {
-        unsigned textureId = FakeWebGraphicsContext3D::createTexture();
-        m_allocatedTextureIds.insert(textureId);
-        return textureId;
-    }
-    virtual void deleteTexture(WebKit::WebGLId id)
-    {
-        if (id == kExternalTextureId)
-            ADD_FAILURE() << "Trying to delete external texture";
-        if (!ContainsKey(m_allocatedTextureIds, id))
-            ADD_FAILURE() << "Trying to delete texture id " << id;
-        m_allocatedTextureIds.erase(id);
-    }
-
-    virtual void bindBuffer(WebKit::WGC3Denum, WebKit::WebGLId id)
-    {
-        if (id != 2 && id)
-            ADD_FAILURE() << "Trying to bind buffer id " << id;
-    }
-
-    virtual void bindFramebuffer(WebKit::WGC3Denum, WebKit::WebGLId id)
-    {
-        if (id != 3 && id)
-            ADD_FAILURE() << "Trying to bind framebuffer id " << id;
-    }
-
-    virtual void useProgram(WebKit::WebGLId id)
-    {
-        if (id != 4)
-            ADD_FAILURE() << "Trying to use program id " << id;
-    }
-
-    virtual void bindRenderbuffer(WebKit::WGC3Denum, WebKit::WebGLId id)
-    {
-        if (id != 5 && id)
-            ADD_FAILURE() << "Trying to bind renderbuffer id " << id;
-    }
-
-    virtual void attachShader(WebKit::WebGLId program, WebKit::WebGLId shader)
-    {
-        if ((program != 4) || (shader != 6))
-            ADD_FAILURE() << "Trying to attach shader id " << shader << " to program id " << program;
-    }
-
-    virtual void bindTexture(WebKit::WGC3Denum, WebKit::WebGLId id)
-    {
-        if (id && id != kExternalTextureId && !ContainsKey(m_allocatedTextureIds, id))
-            ADD_FAILURE() << "Trying to bind texture id " << id;
-    }
-
-private:
-    base::hash_set<unsigned> m_allocatedTextureIds;
-};
-
-// Fake WebKit::WebVideoFrame wrapper of media::VideoFrame.
-class FakeVideoFrame: public WebKit::WebVideoFrame {
-public:
-    explicit FakeVideoFrame(const scoped_refptr<VideoFrame>& frame) : m_frame(frame) { }
-    virtual ~FakeVideoFrame() { }
-
-    virtual Format format() const { NOTREACHED(); return FormatInvalid; }
-    virtual unsigned width() const { NOTREACHED(); return 0; }
-    virtual unsigned height() const { NOTREACHED(); return 0; }
-    virtual unsigned planes() const { NOTREACHED(); return 0; }
-    virtual int stride(unsigned plane) const { NOTREACHED(); return 0; }
-    virtual const void* data(unsigned plane) const { NOTREACHED(); return NULL; }
-    virtual unsigned textureId() const { NOTREACHED(); return 0; }
-    virtual unsigned textureTarget() const { NOTREACHED(); return 0; }
-    virtual WebKit::WebRect visibleRect() const { NOTREACHED(); return WebKit::WebRect(0, 0, 0, 0); }
-    virtual WebKit::WebSize textureSize() const { NOTREACHED(); return WebKit::WebSize(4, 4); }
-
-    static VideoFrame* toVideoFrame(WebKit::WebVideoFrame* web_video_frame) {
-        FakeVideoFrame* wrapped_frame =
-            static_cast<FakeVideoFrame*>(web_video_frame);
-        if (wrapped_frame)
-            return wrapped_frame->m_frame.get();
-        return NULL;
-    }
-
-private:
-    scoped_refptr<VideoFrame> m_frame;
-};
-
-// Fake video frame provider that always provides the same FakeVideoFrame.
-class FakeVideoFrameProvider: public WebKit::WebVideoFrameProvider {
-public:
-    FakeVideoFrameProvider() : m_frame(0), m_client(0) { }
-    virtual ~FakeVideoFrameProvider()
-    {
-        if (m_client)
-            m_client->stopUsingProvider();
-    }
-
-    virtual void setVideoFrameProviderClient(Client* client) { m_client = client; }
-    virtual WebKit::WebVideoFrame* getCurrentFrame() { return m_frame; }
-    virtual void putCurrentFrame(WebKit::WebVideoFrame*) { }
-
-    void setFrame(WebKit::WebVideoFrame* frame) { m_frame = frame; }
-
-private:
-    WebKit::WebVideoFrame* m_frame;
-    Client* m_client;
-};
-
-class StrictWebGraphicsContext3DWithIOSurface : public StrictWebGraphicsContext3D {
-public:
-    virtual WebKit::WebString getString(WebKit::WGC3Denum name) OVERRIDE
-    {
-        if (name == GL_EXTENSIONS)
-            return WebKit::WebString("GL_CHROMIUM_iosurface GL_ARB_texture_rectangle");
-
-        return WebKit::WebString();
-    }
-};
-
-class FakeWebGraphicsContext3DWithIOSurface : public FakeWebGraphicsContext3D {
-public:
-    virtual WebKit::WebString getString(WebKit::WGC3Denum name) OVERRIDE
-    {
-        if (name == GL_EXTENSIONS)
-            return WebKit::WebString("GL_CHROMIUM_iosurface GL_ARB_texture_rectangle");
-
-        return WebKit::WebString();
-    }
-};
-
-class FakeWebScrollbarThemeGeometryNonEmpty : public FakeWebScrollbarThemeGeometry {
-    virtual WebKit::WebRect trackRect(WebKit::WebScrollbar*) OVERRIDE { return WebKit::WebRect(0, 0, 10, 10); }
-    virtual WebKit::WebRect thumbRect(WebKit::WebScrollbar*) OVERRIDE { return WebKit::WebRect(0, 5, 5, 2); }
-    virtual void splitTrack(WebKit::WebScrollbar*, const WebKit::WebRect& track, WebKit::WebRect& startTrack, WebKit::WebRect& thumb, WebKit::WebRect& endTrack) OVERRIDE
-    {
-        thumb = WebKit::WebRect(0, 5, 5, 2);
-        startTrack = WebKit::WebRect(0, 5, 0, 5);
-        endTrack = WebKit::WebRect(0, 0, 0, 5);
-    }
-};
-
-class FakeScrollbarLayerImpl : public ScrollbarLayerImpl {
-public:
-    static scoped_ptr<FakeScrollbarLayerImpl> create(LayerTreeImpl* treeImpl, int id)
-    {
-        return make_scoped_ptr(new FakeScrollbarLayerImpl(treeImpl, id));
-    }
-
-    void createResources(ResourceProvider* provider)
-    {
-        DCHECK(provider);
-        gfx::Size size(10, 10);
-        GLenum format = GL_RGBA;
-        ResourceProvider::TextureUsageHint hint = ResourceProvider::TextureUsageAny;
-        setScrollbarGeometry(ScrollbarGeometryFixedThumb::create(FakeWebScrollbarThemeGeometryNonEmpty::create()));
-
-        setBackTrackResourceId(provider->createResource(size, format, hint));
-        setForeTrackResourceId(provider->createResource(size, format, hint));
-        setThumbResourceId(provider->createResource(size, format, hint));
-    }
-
-protected:
-    FakeScrollbarLayerImpl(LayerTreeImpl* treeImpl, int id)
-        : ScrollbarLayerImpl(treeImpl, id)
-    {
-    }
-};
-
-static inline scoped_ptr<RenderPass> createRenderPassWithResource(ResourceProvider* provider)
-{
-    ResourceProvider::ResourceId resourceId = provider->createResource(gfx::Size(1, 1), GL_RGBA, ResourceProvider::TextureUsageAny);
-
-    scoped_ptr<TestRenderPass> pass = TestRenderPass::Create();
-    pass->SetNew(RenderPass::Id(1, 1), gfx::Rect(0, 0, 1, 1), gfx::Rect(0, 0, 1, 1), gfx::Transform());
-    scoped_ptr<SharedQuadState> sharedState = SharedQuadState::Create();
-    sharedState->SetAll(gfx::Transform(), gfx::Rect(0, 0, 1, 1), gfx::Rect(0, 0, 1, 1), gfx::Rect(0, 0, 1, 1), false, 1);
-    const float vertex_opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
-    scoped_ptr<TextureDrawQuad> quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedState.get(), gfx::Rect(0, 0, 1, 1), gfx::Rect(0, 0, 1, 1), resourceId, false, gfx::RectF(0, 0, 1, 1), vertex_opacity, false);
-
-    pass->AppendSharedQuadState(sharedState.Pass());
-    pass->AppendQuad(quad.PassAs<DrawQuad>());
-
-    return pass.PassAs<RenderPass>();
-}
-
-TEST_P(LayerTreeHostImplTest, dontUseOldResourcesAfterLostOutputSurface)
-{
-    int layerId = 1;
-
-    scoped_ptr<LayerImpl> rootLayer(LayerImpl::create(m_hostImpl->activeTree(), layerId++));
-    rootLayer->setBounds(gfx::Size(10, 10));
-    rootLayer->setAnchorPoint(gfx::PointF(0, 0));
-
-    scoped_ptr<TiledLayerImpl> tileLayer = TiledLayerImpl::create(m_hostImpl->activeTree(), layerId++);
-    tileLayer->setBounds(gfx::Size(10, 10));
-    tileLayer->setAnchorPoint(gfx::PointF(0, 0));
-    tileLayer->setContentBounds(gfx::Size(10, 10));
-    tileLayer->setDrawsContent(true);
-    tileLayer->setSkipsDraw(false);
-    scoped_ptr<LayerTilingData> tilingData(LayerTilingData::create(gfx::Size(10, 10), LayerTilingData::NoBorderTexels));
-    tilingData->setBounds(gfx::Size(10, 10));
-    tileLayer->setTilingData(*tilingData);
-    tileLayer->pushTileProperties(0, 0, 1, gfx::Rect(0, 0, 10, 10), false);
-    rootLayer->addChild(tileLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<TextureLayerImpl> textureLayer = TextureLayerImpl::create(m_hostImpl->activeTree(), layerId++);
-    textureLayer->setBounds(gfx::Size(10, 10));
-    textureLayer->setAnchorPoint(gfx::PointF(0, 0));
-    textureLayer->setContentBounds(gfx::Size(10, 10));
-    textureLayer->setDrawsContent(true);
-    textureLayer->setTextureId(StrictWebGraphicsContext3D::kExternalTextureId);
-    rootLayer->addChild(textureLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<TiledLayerImpl> maskLayer = TiledLayerImpl::create(m_hostImpl->activeTree(), layerId++);
-    maskLayer->setBounds(gfx::Size(10, 10));
-    maskLayer->setAnchorPoint(gfx::PointF(0, 0));
-    maskLayer->setContentBounds(gfx::Size(10, 10));
-    maskLayer->setDrawsContent(true);
-    maskLayer->setSkipsDraw(false);
-    maskLayer->setTilingData(*tilingData);
-    maskLayer->pushTileProperties(0, 0, 1, gfx::Rect(0, 0, 10, 10), false);
-
-    scoped_ptr<TextureLayerImpl> textureLayerWithMask = TextureLayerImpl::create(m_hostImpl->activeTree(), layerId++);
-    textureLayerWithMask->setBounds(gfx::Size(10, 10));
-    textureLayerWithMask->setAnchorPoint(gfx::PointF(0, 0));
-    textureLayerWithMask->setContentBounds(gfx::Size(10, 10));
-    textureLayerWithMask->setDrawsContent(true);
-    textureLayerWithMask->setTextureId(StrictWebGraphicsContext3D::kExternalTextureId);
-    textureLayerWithMask->setMaskLayer(maskLayer.PassAs<LayerImpl>());
-    rootLayer->addChild(textureLayerWithMask.PassAs<LayerImpl>());
-
-    FakeVideoFrame videoFrame(VideoFrame::CreateColorFrame(gfx::Size(4, 4),
-                                                           0x80, 0x80, 0x80,
-                                                           base::TimeDelta()));
-    VideoLayerImpl::FrameUnwrapper unwrapper =
-        base::Bind(FakeVideoFrame::toVideoFrame);
-    FakeVideoFrameProvider provider;
-    provider.setFrame(&videoFrame);
-    scoped_ptr<VideoLayerImpl> videoLayer = VideoLayerImpl::create(m_hostImpl->activeTree(), layerId++, &provider, unwrapper);
-    videoLayer->setBounds(gfx::Size(10, 10));
-    videoLayer->setAnchorPoint(gfx::PointF(0, 0));
-    videoLayer->setContentBounds(gfx::Size(10, 10));
-    videoLayer->setDrawsContent(true);
-    rootLayer->addChild(videoLayer.PassAs<LayerImpl>());
-
-    FakeVideoFrameProvider providerScaled;
-    scoped_ptr<VideoLayerImpl> videoLayerScaled = VideoLayerImpl::create(m_hostImpl->activeTree(), layerId++, &providerScaled, unwrapper);
-    videoLayerScaled->setBounds(gfx::Size(10, 10));
-    videoLayerScaled->setAnchorPoint(gfx::PointF(0, 0));
-    videoLayerScaled->setContentBounds(gfx::Size(10, 10));
-    videoLayerScaled->setDrawsContent(true);
-    rootLayer->addChild(videoLayerScaled.PassAs<LayerImpl>());
-
-    FakeVideoFrameProvider hwProvider;
-    scoped_ptr<VideoLayerImpl> hwVideoLayer = VideoLayerImpl::create(m_hostImpl->activeTree(), layerId++, &hwProvider, unwrapper);
-    hwVideoLayer->setBounds(gfx::Size(10, 10));
-    hwVideoLayer->setAnchorPoint(gfx::PointF(0, 0));
-    hwVideoLayer->setContentBounds(gfx::Size(10, 10));
-    hwVideoLayer->setDrawsContent(true);
-    rootLayer->addChild(hwVideoLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<IOSurfaceLayerImpl> ioSurfaceLayer = IOSurfaceLayerImpl::create(m_hostImpl->activeTree(), layerId++);
-    ioSurfaceLayer->setBounds(gfx::Size(10, 10));
-    ioSurfaceLayer->setAnchorPoint(gfx::PointF(0, 0));
-    ioSurfaceLayer->setContentBounds(gfx::Size(10, 10));
-    ioSurfaceLayer->setDrawsContent(true);
-    ioSurfaceLayer->setIOSurfaceProperties(1, gfx::Size(10, 10));
-    rootLayer->addChild(ioSurfaceLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<HeadsUpDisplayLayerImpl> hudLayer = HeadsUpDisplayLayerImpl::create(m_hostImpl->activeTree(), layerId++);
-    hudLayer->setBounds(gfx::Size(10, 10));
-    hudLayer->setAnchorPoint(gfx::PointF(0, 0));
-    hudLayer->setContentBounds(gfx::Size(10, 10));
-    hudLayer->setDrawsContent(true);
-    rootLayer->addChild(hudLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<FakeScrollbarLayerImpl> scrollbarLayer(FakeScrollbarLayerImpl::create(m_hostImpl->activeTree(), layerId++));
-    scrollbarLayer->setBounds(gfx::Size(10, 10));
-    scrollbarLayer->setContentBounds(gfx::Size(10, 10));
-    scrollbarLayer->setDrawsContent(true);
-    scrollbarLayer->createResources(m_hostImpl->resourceProvider());
-    rootLayer->addChild(scrollbarLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<DelegatedRendererLayerImpl> delegatedRendererLayer(DelegatedRendererLayerImpl::create(m_hostImpl->activeTree(), layerId++));
-    delegatedRendererLayer->setBounds(gfx::Size(10, 10));
-    delegatedRendererLayer->setContentBounds(gfx::Size(10, 10));
-    delegatedRendererLayer->setDrawsContent(true);
-    ScopedPtrVector<RenderPass> passList;
-    passList.append(createRenderPassWithResource(m_hostImpl->resourceProvider()));
-    delegatedRendererLayer->setRenderPasses(passList);
-    EXPECT_TRUE(passList.isEmpty());
-    rootLayer->addChild(delegatedRendererLayer.PassAs<LayerImpl>());
-
-    // Use a context that supports IOSurfaces
-    m_hostImpl->initializeRenderer(FakeOutputSurface::Create3d(scoped_ptr<WebKit::WebGraphicsContext3D>(new FakeWebGraphicsContext3DWithIOSurface)).PassAs<OutputSurface>());
-
-    FakeVideoFrame hwVideoFrame(
-        VideoFrame::WrapNativeTexture(
-            m_hostImpl->resourceProvider()->graphicsContext3D()->createTexture(),
-            GL_TEXTURE_2D,
-            gfx::Size(4, 4), gfx::Rect(0, 0, 4, 4), gfx::Size(4, 4), base::TimeDelta(),
-            VideoFrame::ReadPixelsCB(), base::Closure()));
-    hwProvider.setFrame(&hwVideoFrame);
-
-    FakeVideoFrame videoFrameScaled(
-        VideoFrame::WrapNativeTexture(
-            m_hostImpl->resourceProvider()->graphicsContext3D()->createTexture(),
-            GL_TEXTURE_2D,
-            gfx::Size(4, 4), gfx::Rect(0, 0, 3, 2), gfx::Size(4, 4), base::TimeDelta(),
-            VideoFrame::ReadPixelsCB(), base::Closure()));
-    providerScaled.setFrame(&videoFrameScaled);
-
-    m_hostImpl->setRootLayer(rootLayer.Pass());
-
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
-    m_hostImpl->swapBuffers();
-
-    unsigned numResources = m_hostImpl->resourceProvider()->numResources();
-
-    // Lose the WebKit::WebGraphicsContext3D, replacing it with a StrictWebGraphicsContext3DWithIOSurface,
-    // that will warn if any resource from the previous context gets used.
-    m_hostImpl->initializeRenderer(FakeOutputSurface::Create3d(scoped_ptr<WebKit::WebGraphicsContext3D>(new StrictWebGraphicsContext3DWithIOSurface)).PassAs<OutputSurface>());
-
-    // Create dummy resources so that looking up an old resource will get an
-    // invalid texture id mapping.
-    for (unsigned i = 0; i < numResources; ++i)
-        m_hostImpl->resourceProvider()->createResourceFromExternalTexture(StrictWebGraphicsContext3D::kExternalTextureId);
-
-    // The WebKit::WebVideoFrameProvider is expected to recreate its textures after a
-    // lost output surface (or not serve a frame).
-    hwProvider.setFrame(0);
-    providerScaled.setFrame(0);
-
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
-    m_hostImpl->swapBuffers();
-
-    FakeVideoFrame hwVideoFrame2(
-        VideoFrame::WrapNativeTexture(
-            m_hostImpl->resourceProvider()->graphicsContext3D()->createTexture(),
-            GL_TEXTURE_2D,
-            gfx::Size(4, 4), gfx::Rect(0, 0, 4, 4), gfx::Size(4, 4), base::TimeDelta(),
-            VideoFrame::ReadPixelsCB(), base::Closure()));
-    hwProvider.setFrame(&hwVideoFrame2);
-
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
-    m_hostImpl->swapBuffers();
-}
-
 // Fake WebKit::WebGraphicsContext3D that tracks the number of textures in use.
 class TrackingWebGraphicsContext3D : public FakeWebGraphicsContext3D {
 public:
@@ -3003,36 +2575,38 @@
     unsigned m_numTextures;
 };
 
+static unsigned createResourceId(ResourceProvider* resourceProvider)
+{
+    return resourceProvider->createResource(
+        gfx::Size(20, 12),
+        resourceProvider->bestTextureFormat(),
+        ResourceProvider::TextureUsageAny);
+}
+
+static unsigned createTextureId(ResourceProvider* resourceProvider)
+{
+    return ResourceProvider::ScopedReadLockGL(
+        resourceProvider, createResourceId(resourceProvider)).textureId();
+}
+
 TEST_P(LayerTreeHostImplTest, layersFreeTextures)
 {
+    scoped_ptr<FakeWebGraphicsContext3D> context =
+            FakeWebGraphicsContext3D::Create();
+    FakeWebGraphicsContext3D* context3d = context.get();
+    scoped_ptr<OutputSurface> outputSurface = FakeOutputSurface::Create3d(
+        context.PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
+    m_hostImpl->initializeRenderer(outputSurface.Pass());
+
     scoped_ptr<LayerImpl> rootLayer(LayerImpl::create(m_hostImpl->activeTree(), 1));
     rootLayer->setBounds(gfx::Size(10, 10));
     rootLayer->setAnchorPoint(gfx::PointF(0, 0));
 
-    scoped_ptr<TiledLayerImpl> tileLayer = TiledLayerImpl::create(m_hostImpl->activeTree(), 2);
-    tileLayer->setBounds(gfx::Size(10, 10));
-    tileLayer->setAnchorPoint(gfx::PointF(0, 0));
-    tileLayer->setContentBounds(gfx::Size(10, 10));
-    tileLayer->setDrawsContent(true);
-    tileLayer->setSkipsDraw(false);
-    scoped_ptr<LayerTilingData> tilingData(LayerTilingData::create(gfx::Size(10, 10), LayerTilingData::NoBorderTexels));
-    tilingData->setBounds(gfx::Size(10, 10));
-    tileLayer->setTilingData(*tilingData);
-    tileLayer->pushTileProperties(0, 0, 1, gfx::Rect(0, 0, 10, 10), false);
-    rootLayer->addChild(tileLayer.PassAs<LayerImpl>());
-
-    scoped_ptr<TextureLayerImpl> textureLayer = TextureLayerImpl::create(m_hostImpl->activeTree(), 3);
-    textureLayer->setBounds(gfx::Size(10, 10));
-    textureLayer->setAnchorPoint(gfx::PointF(0, 0));
-    textureLayer->setContentBounds(gfx::Size(10, 10));
-    textureLayer->setDrawsContent(true);
-    textureLayer->setTextureId(1);
-    rootLayer->addChild(textureLayer.PassAs<LayerImpl>());
-
-    VideoLayerImpl::FrameUnwrapper unwrapper =
-        base::Bind(FakeVideoFrame::toVideoFrame);
+    scoped_refptr<VideoFrame> softwareFrame(media::VideoFrame::CreateColorFrame(
+        gfx::Size(4, 4), 0x80, 0x80, 0x80, base::TimeDelta()));
     FakeVideoFrameProvider provider;
-    scoped_ptr<VideoLayerImpl> videoLayer = VideoLayerImpl::create(m_hostImpl->activeTree(), 4, &provider, unwrapper);
+    provider.set_frame(softwareFrame);
+    scoped_ptr<VideoLayerImpl> videoLayer = VideoLayerImpl::create(m_hostImpl->activeTree(), 4, &provider);
     videoLayer->setBounds(gfx::Size(10, 10));
     videoLayer->setAnchorPoint(gfx::PointF(0, 0));
     videoLayer->setContentBounds(gfx::Size(10, 10));
@@ -3047,12 +2621,9 @@
     ioSurfaceLayer->setIOSurfaceProperties(1, gfx::Size(10, 10));
     rootLayer->addChild(ioSurfaceLayer.PassAs<LayerImpl>());
 
-    // Lose the WebGraphicsContext3D, replacing it with a TrackingWebGraphicsContext3D (which the LayerTreeHostImpl takes ownership of).
-    scoped_ptr<OutputSurface> outputSurface(FakeOutputSurface::Create3d(scoped_ptr<WebKit::WebGraphicsContext3D>(new TrackingWebGraphicsContext3D)));
-    TrackingWebGraphicsContext3D* trackingWebGraphicsContext3D = static_cast<TrackingWebGraphicsContext3D*>(outputSurface->Context3D());
-    m_hostImpl->initializeRenderer(outputSurface.Pass());
+    m_hostImpl->activeTree()->SetRootLayer(rootLayer.Pass());
 
-    m_hostImpl->setRootLayer(rootLayer.Pass());
+    EXPECT_EQ(0u, context3d->NumTextures());
 
     LayerTreeHostImpl::FrameData frame;
     EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
@@ -3060,12 +2631,12 @@
     m_hostImpl->didDrawAllLayers(frame);
     m_hostImpl->swapBuffers();
 
-    EXPECT_GT(trackingWebGraphicsContext3D->numTextures(), 0u);
+    EXPECT_GT(context3d->NumTextures(), 0u);
 
     // Kill the layer tree.
-    m_hostImpl->setRootLayer(LayerImpl::create(m_hostImpl->activeTree(), 100));
+    m_hostImpl->activeTree()->SetRootLayer(LayerImpl::create(m_hostImpl->activeTree(), 100));
     // There should be no textures left in use after.
-    EXPECT_EQ(0u, trackingWebGraphicsContext3D->numTextures());
+    EXPECT_EQ(0u, context3d->NumTextures());
 }
 
 class MockDrawQuadsToFillScreenContext : public FakeWebGraphicsContext3D {
@@ -3082,10 +2653,10 @@
     // Run test case
     createLayerTreeHost(false, outputSurface.Pass());
     setupRootLayerImpl(LayerImpl::create(m_hostImpl->activeTree(), 1));
-    m_hostImpl->setBackgroundColor(SK_ColorWHITE);
+    m_hostImpl->activeTree()->set_background_color(SK_ColorWHITE);
 
     // Verify one quad is drawn when transparent background set is not set.
-    m_hostImpl->setHasTransparentBackground(false);
+    m_hostImpl->activeTree()->set_has_transparent_background(false);
     EXPECT_CALL(*mockContext, useProgram(_))
         .Times(1);
     EXPECT_CALL(*mockContext, drawElements(_, _, _, _))
@@ -3097,7 +2668,7 @@
     Mock::VerifyAndClearExpectations(&mockContext);
 
     // Verify no quads are drawn when transparent background is set.
-    m_hostImpl->setHasTransparentBackground(true);
+    m_hostImpl->activeTree()->set_has_transparent_background(true);
     EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
     m_hostImpl->drawLayers(frame);
     m_hostImpl->didDrawAllLayers(frame);
@@ -3196,7 +2767,7 @@
     root->setContentBounds(rootSize);
     root->setDrawsContent(true);
     root->setMasksToBounds(true);
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
 
     addDrawingLayerTo(rootPtr, 2, gfx::Rect(300, 300, 300, 300), &layerS1Ptr);
     layerS1Ptr->setForceRenderSurface(true);
@@ -3308,7 +2879,7 @@
     root->setContentBounds(rootSize);
     root->setDrawsContent(true);
     root->setMasksToBounds(true);
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
 
     addDrawingLayerTo(rootPtr, 2, gfx::Rect(0, 0, 800, 800), &layerS1Ptr);
     layerS1Ptr->setForceRenderSurface(true);
@@ -3421,7 +2992,7 @@
     root->setContentBounds(rootSize);
     root->setDrawsContent(true);
     root->setMasksToBounds(true);
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
 
     addDrawingLayerTo(rootPtr, 2, gfx::Rect(0, 0, 400, 400), &layerS1Ptr);
     layerS1Ptr->setForceRenderSurface(true);
@@ -3503,7 +3074,7 @@
     root->setContentBounds(rootSize);
     root->setDrawsContent(true);
     root->setMasksToBounds(true);
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
 
     addDrawingLayerTo(rootPtr, 2, gfx::Rect(0, 0, 400, 400), &layerS1Ptr);
     layerS1Ptr->setForceRenderSurface(true);
@@ -3588,7 +3159,7 @@
     root->setContentBounds(rootSize);
     root->setDrawsContent(true);
     root->setMasksToBounds(true);
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
 
     addDrawingLayerTo(rootPtr, 2, gfx::Rect(300, 300, 300, 300), &layerS1Ptr);
     layerS1Ptr->setForceRenderSurface(true);
@@ -3726,7 +3297,7 @@
 
     child->addChild(grandChild.Pass());
     root->addChild(child.PassAs<LayerImpl>());
-    myHostImpl->setRootLayer(root.Pass());
+    myHostImpl->activeTree()->SetRootLayer(root.Pass());
     myHostImpl->setViewportSize(rootRect.size(), rootRect.size());
 
     EXPECT_FALSE(myHostImpl->renderer()->haveCachedResourcesForRenderPassId(childPassId));
@@ -3791,7 +3362,8 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[1]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[1]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
+        RenderPass* targetPass = frame.renderPassesById[quad->render_pass_id];
+        ASSERT_TRUE(targetPass);
         EXPECT_FALSE(targetPass->damage_rect.IsEmpty());
 
         myHostImpl->drawLayers(frame);
@@ -3809,8 +3381,7 @@
         EXPECT_EQ(1U, frame.renderPasses[0]->quad_list.size());
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
-        EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
+        EXPECT_TRUE(frame.renderPassesById.find(quad->render_pass_id) == frame.renderPassesById.end());
 
         myHostImpl->drawLayers(frame);
         myHostImpl->didDrawAllLayers(frame);
@@ -3828,8 +3399,7 @@
         EXPECT_EQ(1U, frame.renderPasses[0]->quad_list.size());
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
-        EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
+        EXPECT_TRUE(frame.renderPassesById.find(quad->render_pass_id) == frame.renderPassesById.end());
 
         myHostImpl->drawLayers(frame);
         myHostImpl->didDrawAllLayers(frame);
@@ -3849,7 +3419,8 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[1]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[1]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
+        RenderPass* targetPass = frame.renderPassesById[quad->render_pass_id];
+        ASSERT_TRUE(targetPass);
         EXPECT_FALSE(targetPass->damage_rect.IsEmpty());
 
         myHostImpl->drawLayers(frame);
@@ -3876,7 +3447,8 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[1]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[1]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
+        RenderPass* targetPass = frame.renderPassesById[quad->render_pass_id];
+        ASSERT_TRUE(targetPass);
         EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
 
         // Was our surface evicted?
@@ -3897,8 +3469,7 @@
         EXPECT_EQ(1U, frame.renderPasses[0]->quad_list.size());
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
-        EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
+        EXPECT_TRUE(frame.renderPassesById.find(quad->render_pass_id) == frame.renderPassesById.end());
 
         myHostImpl->drawLayers(frame);
         myHostImpl->didDrawAllLayers(frame);
@@ -3918,8 +3489,7 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
-        EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
+        EXPECT_TRUE(frame.renderPassesById.find(quad->render_pass_id) == frame.renderPassesById.end());
 
         myHostImpl->drawLayers(frame);
         myHostImpl->didDrawAllLayers(frame);
@@ -3951,7 +3521,7 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[1]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[1]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
+        RenderPass* targetPass = frame.renderPassesById[quad->render_pass_id];
         EXPECT_FALSE(targetPass->damage_rect.IsEmpty());
 
         EXPECT_FALSE(frame.renderPasses[0]->damage_rect.IsEmpty());
@@ -3993,8 +3563,7 @@
         EXPECT_EQ(1U, frame.renderPasses[0]->quad_list.size());
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
-        EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
+        EXPECT_TRUE(frame.renderPassesById.find(quad->render_pass_id) == frame.renderPassesById.end());
 
         myHostImpl->drawLayers(frame);
         myHostImpl->didDrawAllLayers(frame);
@@ -4014,7 +3583,8 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[1]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[1]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
+        RenderPass* targetPass = frame.renderPassesById[quad->render_pass_id];
+        ASSERT_TRUE(targetPass);
         EXPECT_FALSE(targetPass->damage_rect.IsEmpty());
 
         myHostImpl->drawLayers(frame);
@@ -4041,7 +3611,8 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[1]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[1]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
+        RenderPass* targetPass = frame.renderPassesById[quad->render_pass_id];
+        ASSERT_TRUE(targetPass);
         EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
 
         // Was our surface evicted?
@@ -4080,8 +3651,7 @@
 
         EXPECT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        RenderPass* targetPass = frame.renderPassesById.get(quad->render_pass_id);
-        EXPECT_TRUE(targetPass->damage_rect.IsEmpty());
+        EXPECT_TRUE(frame.renderPassesById.find(quad->render_pass_id) == frame.renderPassesById.end());
 
         myHostImpl->drawLayers(frame);
         myHostImpl->didDrawAllLayers(frame);
@@ -4165,7 +3735,7 @@
 
     // One shared state for all quads - we don't need the correct details
     testData.sharedQuadState = SharedQuadState::Create();
-    testData.sharedQuadState->SetAll(gfx::Transform(), gfx::Rect(), gfx::Rect(), gfx::Rect(), false, 1.0);
+    testData.sharedQuadState->SetAll(gfx::Transform(), gfx::Rect(), gfx::Rect(), false, 1.0);
 
     const char* currentChar = testScript;
 
@@ -4239,12 +3809,12 @@
                 gfx::Rect quadRect = gfx::Rect(0, 0, 1, 1);
                 gfx::Rect contentsChangedRect = contentsChanged ? quadRect : gfx::Rect();
                 scoped_ptr<RenderPassDrawQuad> quad = RenderPassDrawQuad::Create();
-                quad->SetNew(testData.sharedQuadState.get(), quadRect, newRenderPassId, isReplica, 1, contentsChangedRect, gfx::RectF(0, 0, 1, 1));
+                quad->SetNew(testData.sharedQuadState.get(), quadRect, newRenderPassId, isReplica, 1, contentsChangedRect, gfx::RectF(0, 0, 1, 1), WebKit::WebFilterOperations(), skia::RefPtr<SkImageFilter>(), WebKit::WebFilterOperations());
                 renderPass->AppendQuad(quad.PassAs<DrawQuad>());
             }
         }
-        testData.renderPasses.insert(testData.renderPasses.begin(), renderPass.get());
-        testData.renderPassesById.add(renderPassId, renderPass.PassAs<RenderPass>());
+        testData.renderPassesById[renderPassId] = renderPass.get();
+        testData.renderPasses.insert(testData.renderPasses.begin(), renderPass.PassAs<RenderPass>());
         if (*currentChar)
             currentChar++;
     }
@@ -4454,370 +4024,13 @@
     }
 }
 
-// Make sure that scrolls that only pan the pinch viewport, and not the document,
-// still force redraw/commit.
-void LayerTreeHostImplTest::pinchZoomPanViewportForcesCommitRedraw(const float deviceScaleFactor)
-{
-    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-
-    gfx::Size layoutSurfaceSize(10, 20);
-    gfx::Size deviceSurfaceSize(layoutSurfaceSize.width() * static_cast<int>(deviceScaleFactor),
-                                layoutSurfaceSize.height() * static_cast<int>(deviceScaleFactor));
-    float pageScale = 2;
-    scoped_ptr<LayerImpl> root = createScrollableLayer(1, layoutSurfaceSize);
-    // For this test we want to force scrolls to only pan the pinchZoomViewport
-    // and not the document, we can verify commit/redraw are requested.
-    root->setMaxScrollOffset(gfx::Vector2d());
-    m_hostImpl->setRootLayer(root.Pass());
-    m_hostImpl->setViewportSize(layoutSurfaceSize, deviceSurfaceSize);
-    m_hostImpl->setPageScaleFactorAndLimits(1, 1, pageScale);
-    initializeRendererAndDrawFrame();
-
-    // Set new page scale on impl thread by pinching.
-    m_hostImpl->pinchGestureBegin();
-    m_hostImpl->pinchGestureUpdate(pageScale, gfx::Point());
-    m_hostImpl->pinchGestureEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    gfx::Transform expectedImplTransform;
-    expectedImplTransform.Scale(pageScale, pageScale);
-
-    // Verify the pinch zoom took place.
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-
-    // The implTransform ignores the scroll if !pageScalePinchZoomEnabled,
-    // so no point in continuing without it.
-    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
-        return;
-
-    m_didRequestCommit = false;
-    m_didRequestRedraw = false;
-
-    // This scroll will force the viewport to pan horizontally.
-    gfx::Vector2d scrollDelta(5, 0);
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-
-    EXPECT_EQ(true, m_didRequestCommit);
-    EXPECT_EQ(true, m_didRequestRedraw);
-
-    m_didRequestCommit = false;
-    m_didRequestRedraw = false;
-
-    // This scroll will force the viewport to pan vertically.
-    scrollDelta = gfx::Vector2d(0, 5);
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-
-    EXPECT_EQ(true, m_didRequestCommit);
-    EXPECT_EQ(true, m_didRequestRedraw);
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportForcesCommitDeviceScaleFactor1)
-{
-    pinchZoomPanViewportForcesCommitRedraw(1);
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportForcesCommitDeviceScaleFactor2)
-{
-    pinchZoomPanViewportForcesCommitRedraw(2);
-}
-
-// The following test confirms correct operation of scroll of the pinchZoomViewport.
-// The device scale factor directly affects computation of the implTransform, so
-// we test the two most common use cases.
-void LayerTreeHostImplTest::pinchZoomPanViewportTest(const float deviceScaleFactor)
-{
-    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-
-    gfx::Size layoutSurfaceSize(10, 20);
-    gfx::Size deviceSurfaceSize(layoutSurfaceSize.width() * static_cast<int>(deviceScaleFactor),
-                                layoutSurfaceSize.height() * static_cast<int>(deviceScaleFactor));
-    float pageScale = 2;
-    scoped_ptr<LayerImpl> root = createScrollableLayer(1, layoutSurfaceSize);
-    // For this test we want to force scrolls to move the pinchZoomViewport so
-    // we can see the scroll component on the implTransform.
-    root->setMaxScrollOffset(gfx::Vector2d());
-    m_hostImpl->setRootLayer(root.Pass());
-    m_hostImpl->setViewportSize(layoutSurfaceSize, deviceSurfaceSize);
-    m_hostImpl->setPageScaleFactorAndLimits(1, 1, pageScale);
-    initializeRendererAndDrawFrame();
-
-    // Set new page scale on impl thread by pinching.
-    m_hostImpl->pinchGestureBegin();
-    m_hostImpl->pinchGestureUpdate(pageScale, gfx::Point());
-    m_hostImpl->pinchGestureEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    gfx::Transform expectedImplTransform;
-    expectedImplTransform.Scale(pageScale, pageScale);
-
-    EXPECT_EQ(m_hostImpl->rootLayer()->implTransform(), expectedImplTransform);
-
-    // The implTransform ignores the scroll if !pageScalePinchZoomEnabled,
-    // so no point in continuing without it.
-    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
-        return;
-
-    gfx::Vector2d scrollDelta(5, 0);
-    gfx::Vector2d expectedMaxScroll(m_hostImpl->rootLayer()->maxScrollOffset());
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    gfx::Vector2dF expectedTranslation = gfx::ScaleVector2d(scrollDelta, m_hostImpl->deviceScaleFactor());
-    expectedImplTransform.Translate(-expectedTranslation.x(), -expectedTranslation.y());
-
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-    // No change expected.
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-    // None of the scroll delta should have been used for document scroll.
-    scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
-    expectNone(*scrollInfo.get(), m_hostImpl->rootLayer()->id());
-
-    // Test scroll in y-direction also.
-    scrollDelta = gfx::Vector2d(0, 5);
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    expectedTranslation = gfx::ScaleVector2d(scrollDelta, m_hostImpl->deviceScaleFactor());
-    expectedImplTransform.Translate(-expectedTranslation.x(), -expectedTranslation.y());
-
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-    // No change expected.
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-    // None of the scroll delta should have been used for document scroll.
-    scrollInfo = m_hostImpl->processScrollDeltas();
-    expectNone(*scrollInfo.get(), m_hostImpl->rootLayer()->id());
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportWithDeviceScaleFactor1)
-{
-    pinchZoomPanViewportTest(1);
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportWithDeviceScaleFactor2)
-{
-    pinchZoomPanViewportTest(2);
-}
-
-// This test verifies the correct behaviour of the document-then-pinchZoomViewport
-// scrolling model, in both x- and y-directions.
-void LayerTreeHostImplTest::pinchZoomPanViewportAndScrollTest(const float deviceScaleFactor)
-{
-    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-
-    gfx::Size layoutSurfaceSize(10, 20);
-    gfx::Size deviceSurfaceSize(layoutSurfaceSize.width() * static_cast<int>(deviceScaleFactor),
-                                layoutSurfaceSize.height() * static_cast<int>(deviceScaleFactor));
-    float pageScale = 2;
-    scoped_ptr<LayerImpl> root = createScrollableLayer(1, layoutSurfaceSize);
-    // For this test we want to scrolls to move both the document and the
-    // pinchZoomViewport so we can see some scroll component on the implTransform.
-    root->setMaxScrollOffset(gfx::Vector2d(3, 4));
-    m_hostImpl->setRootLayer(root.Pass());
-    m_hostImpl->setViewportSize(layoutSurfaceSize, deviceSurfaceSize);
-    m_hostImpl->setPageScaleFactorAndLimits(1, 1, pageScale);
-    initializeRendererAndDrawFrame();
-
-    // Set new page scale on impl thread by pinching.
-    m_hostImpl->pinchGestureBegin();
-    m_hostImpl->pinchGestureUpdate(pageScale, gfx::Point());
-    m_hostImpl->pinchGestureEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    gfx::Transform expectedImplTransform;
-    expectedImplTransform.Scale(pageScale, pageScale);
-
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-
-    // The implTransform ignores the scroll if !pageScalePinchZoomEnabled,
-    // so no point in continuing without it.
-    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
-        return;
-
-    // Scroll document only: scrollDelta chosen to move document horizontally
-    // to its max scroll offset.
-    gfx::Vector2d scrollDelta(3, 0);
-    gfx::Vector2d expectedScrollDelta(scrollDelta);
-    gfx::Vector2d expectedMaxScroll(m_hostImpl->rootLayer()->maxScrollOffset());
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    // The scroll delta is not scaled because the main thread did not scale.
-    scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
-    expectContains(*scrollInfo.get(), m_hostImpl->rootLayer()->id(), expectedScrollDelta);
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-
-    // Verify we did not change the implTransform this time.
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-
-    // Further scrolling should move the pinchZoomViewport only.
-    scrollDelta = gfx::Vector2d(2, 0);
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    gfx::Vector2d expectedPanDelta(scrollDelta);
-    gfx::Vector2dF expectedTranslation = gfx::ScaleVector2d(expectedPanDelta, m_hostImpl->deviceScaleFactor());
-    expectedImplTransform.Translate(-expectedTranslation.x(), -expectedTranslation.y());
-
-    EXPECT_EQ(m_hostImpl->rootLayer()->implTransform(), expectedImplTransform);
-
-    // The scroll delta on the main thread should not have been affected by this.
-    scrollInfo = m_hostImpl->processScrollDeltas();
-    expectContains(*scrollInfo.get(), m_hostImpl->rootLayer()->id(), expectedScrollDelta);
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-
-    // Perform same test sequence in y-direction also.
-    // Document only scroll.
-    scrollDelta = gfx::Vector2d(0, 4);
-    expectedScrollDelta += scrollDelta;
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    // The scroll delta is not scaled because the main thread did not scale.
-    scrollInfo = m_hostImpl->processScrollDeltas();
-    expectContains(*scrollInfo.get(), m_hostImpl->rootLayer()->id(), expectedScrollDelta);
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-
-    // Verify we did not change the implTransform this time.
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-
-    // pinchZoomViewport scroll only.
-    scrollDelta = gfx::Vector2d(0, 1);
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    expectedPanDelta = scrollDelta;
-    expectedTranslation = gfx::ScaleVector2d(expectedPanDelta, m_hostImpl->deviceScaleFactor());
-    expectedImplTransform.Translate(-expectedTranslation.x(), -expectedTranslation.y());
-
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-
-    // The scroll delta on the main thread should not have been affected by this.
-    scrollInfo = m_hostImpl->processScrollDeltas();
-    expectContains(*scrollInfo.get(), m_hostImpl->rootLayer()->id(), expectedScrollDelta);
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportAndScrollWithDeviceScaleFactor)
-{
-    pinchZoomPanViewportAndScrollTest(1);
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportAndScrollWithDeviceScaleFactor2)
-{
-    pinchZoomPanViewportAndScrollTest(2);
-}
-
-// This test verifies the correct behaviour of the document-then-pinchZoomViewport
-// scrolling model, in both x- and y-directions, but this time using a single scroll
-// that crosses the 'boundary' of what will cause document-only scroll and what will
-// cause both document-scroll and zoomViewport panning.
-void LayerTreeHostImplTest::pinchZoomPanViewportAndScrollBoundaryTest(const float deviceScaleFactor)
-{
-    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-
-    gfx::Size layoutSurfaceSize(10, 20);
-    gfx::Size deviceSurfaceSize(layoutSurfaceSize.width() * static_cast<int>(deviceScaleFactor),
-                                layoutSurfaceSize.height() * static_cast<int>(deviceScaleFactor));
-    float pageScale = 2;
-    scoped_ptr<LayerImpl> root = createScrollableLayer(1, layoutSurfaceSize);
-    // For this test we want to scrolls to move both the document and the
-    // pinchZoomViewport so we can see some scroll component on the implTransform.
-    root->setMaxScrollOffset(gfx::Vector2d(3, 4));
-    m_hostImpl->setRootLayer(root.Pass());
-    m_hostImpl->setViewportSize(layoutSurfaceSize, deviceSurfaceSize);
-    m_hostImpl->setPageScaleFactorAndLimits(1, 1, pageScale);
-    initializeRendererAndDrawFrame();
-
-    // Set new page scale on impl thread by pinching.
-    m_hostImpl->pinchGestureBegin();
-    m_hostImpl->pinchGestureUpdate(pageScale, gfx::Point());
-    m_hostImpl->pinchGestureEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    gfx::Transform expectedImplTransform;
-    expectedImplTransform.Scale(pageScale, pageScale);
-
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-
-    // The implTransform ignores the scroll if !pageScalePinchZoomEnabled,
-    // so no point in continuing without it.
-    if (!m_hostImpl->settings().pageScalePinchZoomEnabled)
-        return;
-
-    // Scroll document and pann zoomViewport in one scroll-delta.
-    gfx::Vector2d scrollDelta(5, 0);
-    gfx::Vector2d expectedScrollDelta(gfx::Vector2d(3, 0)); // This component gets handled by document scroll.
-    gfx::Vector2d expectedMaxScroll(m_hostImpl->rootLayer()->maxScrollOffset());
-
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    // The scroll delta is not scaled because the main thread did not scale.
-    scoped_ptr<ScrollAndScaleSet> scrollInfo = m_hostImpl->processScrollDeltas();
-    expectContains(*scrollInfo.get(), m_hostImpl->rootLayer()->id(), expectedScrollDelta);
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-
-    gfx::Vector2d expectedPanDelta(2, 0); // This component gets handled by zoomViewport pan.
-    gfx::Vector2dF expectedTranslation = gfx::ScaleVector2d(expectedPanDelta, m_hostImpl->deviceScaleFactor());
-    expectedImplTransform.Translate(-expectedTranslation.x(), -expectedTranslation.y());
-
-    EXPECT_EQ(m_hostImpl->rootLayer()->implTransform(), expectedImplTransform);
-
-    // Perform same test sequence in y-direction also.
-    scrollDelta = gfx::Vector2d(0, 5);
-    expectedScrollDelta += gfx::Vector2d(0, 4); // This component gets handled by document scroll.
-    EXPECT_EQ(InputHandlerClient::ScrollStarted, m_hostImpl->scrollBegin(gfx::Point(0, 0), InputHandlerClient::Gesture));
-    m_hostImpl->scrollBy(gfx::Point(), scrollDelta);
-    m_hostImpl->scrollEnd();
-    m_hostImpl->updateRootScrollLayerImplTransform();
-
-    // The scroll delta is not scaled because the main thread did not scale.
-    scrollInfo = m_hostImpl->processScrollDeltas(); // This component gets handled by zoomViewport pan.
-    expectContains(*scrollInfo.get(), m_hostImpl->rootLayer()->id(), expectedScrollDelta);
-    EXPECT_EQ(expectedMaxScroll, m_hostImpl->rootLayer()->maxScrollOffset());
-
-    expectedPanDelta = gfx::Vector2d(0, 1);
-    expectedTranslation = gfx::ScaleVector2d(expectedPanDelta, m_hostImpl->deviceScaleFactor());
-    expectedImplTransform.Translate(-expectedTranslation.x(), -expectedTranslation.y());
-
-    EXPECT_EQ(expectedImplTransform, m_hostImpl->rootLayer()->implTransform());
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportAndScrollBoundaryWithDeviceScaleFactor)
-{
-    pinchZoomPanViewportAndScrollBoundaryTest(1);
-}
-
-TEST_P(LayerTreeHostImplTest, pinchZoomPanViewportAndScrollBoundaryWithDeviceScaleFactor2)
-{
-    pinchZoomPanViewportAndScrollBoundaryTest(2);
-}
-
 class LayerTreeHostImplTestWithDelegatingRenderer : public LayerTreeHostImplTest {
 protected:
     virtual scoped_ptr<OutputSurface> createOutputSurface()
     {
         // Creates an output surface with a parent to use a delegating renderer.
         WebKit::WebGraphicsContext3D::Attributes attrs;
-        return FakeOutputSurface::CreateDelegating3d(CompositorFakeWebGraphicsContext3D::create(attrs).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
+        return FakeOutputSurface::CreateDelegating3d(FakeWebGraphicsContext3D::Create(attrs).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
     }
 
     void drawFrameAndTestDamage(const gfx::RectF& expectedDamage) {
@@ -4928,8 +4141,8 @@
         ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
         ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        EXPECT_EQ(renderPassQuad->rect.ToString(), gfx::Rect(0, 0, 100, 100).ToString());
-        EXPECT_EQ(renderPassQuad->mask_uv_rect.ToString(), gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString());
+        EXPECT_EQ(gfx::Rect(0, 0, 100, 100).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
 
         m_hostImpl->drawLayers(frame);
         m_hostImpl->didDrawAllLayers(frame);
@@ -4942,7 +4155,7 @@
     gfx::Size deviceViewport(gfx::ToFlooredSize(gfx::ScaleSize(rootSize, deviceScaleFactor)));
     m_hostImpl->setViewportSize(rootSize, deviceViewport);
     m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
-    m_hostImpl->setNeedsUpdateDrawProperties();
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
     {
         LayerTreeHostImpl::FrameData frame;
         EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
@@ -4951,8 +4164,8 @@
         ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
         ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        EXPECT_EQ(renderPassQuad->rect.ToString(), gfx::Rect(0, 0, 200, 200).ToString());
-        EXPECT_EQ(renderPassQuad->mask_uv_rect.ToString(), gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString());
+        EXPECT_EQ(gfx::Rect(0, 0, 200, 200).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
 
         m_hostImpl->drawLayers(frame);
         m_hostImpl->didDrawAllLayers(frame);
@@ -4966,7 +4179,7 @@
     contentLayer->setContentsScale(deviceScaleFactor, deviceScaleFactor);
     maskLayer->setContentBounds(contentsBounds);
     maskLayer->setContentsScale(deviceScaleFactor, deviceScaleFactor);
-    m_hostImpl->setNeedsUpdateDrawProperties();
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
     {
         LayerTreeHostImpl::FrameData frame;
         EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
@@ -4975,14 +4188,139 @@
         ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
         ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
         const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
-        EXPECT_EQ(renderPassQuad->rect.ToString(), gfx::Rect(0, 0, 200, 200).ToString());
-        EXPECT_EQ(renderPassQuad->mask_uv_rect.ToString(), gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString());
+        EXPECT_EQ(gfx::Rect(0, 0, 200, 200).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
 
         m_hostImpl->drawLayers(frame);
         m_hostImpl->didDrawAllLayers(frame);
     }
 }
 
+TEST_P(LayerTreeHostImplTest, maskLayerWithDifferentBounds)
+{
+    // The mask layer has bounds 100x100 but is attached to a layer with bounds 50x50.
+
+    scoped_ptr<LayerImpl> scopedRoot = LayerImpl::create(m_hostImpl->activeTree(), 1);
+    LayerImpl* root = scopedRoot.get();
+    m_hostImpl->activeTree()->SetRootLayer(scopedRoot.Pass());
+
+    scoped_ptr<LayerImpl> scopedContentLayer = LayerImpl::create(m_hostImpl->activeTree(), 3);
+    LayerImpl* contentLayer = scopedContentLayer.get();
+    root->addChild(scopedContentLayer.Pass());
+
+    scoped_ptr<FakeMaskLayerImpl> scopedMaskLayer = FakeMaskLayerImpl::create(m_hostImpl->activeTree(), 4);
+    FakeMaskLayerImpl* maskLayer = scopedMaskLayer.get();
+    contentLayer->setMaskLayer(scopedMaskLayer.PassAs<LayerImpl>());
+
+    gfx::Size rootSize(100, 100);
+    root->setBounds(rootSize);
+    root->setContentBounds(rootSize);
+    root->setPosition(gfx::PointF());
+    root->setAnchorPoint(gfx::PointF());
+
+    gfx::Size layerSize(50, 50);
+    contentLayer->setBounds(layerSize);
+    contentLayer->setContentBounds(layerSize);
+    contentLayer->setPosition(gfx::PointF());
+    contentLayer->setAnchorPoint(gfx::PointF());
+    contentLayer->setDrawsContent(true);
+
+    gfx::Size maskSize(100, 100);
+    maskLayer->setBounds(maskSize);
+    maskLayer->setContentBounds(maskSize);
+    maskLayer->setPosition(gfx::PointF());
+    maskLayer->setAnchorPoint(gfx::PointF());
+    maskLayer->setDrawsContent(true);
+
+
+    // Check that the mask fills the surface.
+    float deviceScaleFactor = 1.f;
+    m_hostImpl->setViewportSize(rootSize, rootSize);
+    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
+    {
+        LayerTreeHostImpl::FrameData frame;
+        EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+
+        ASSERT_EQ(1u, frame.renderPasses.size());
+        ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
+        ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
+        const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
+        EXPECT_EQ(gfx::Rect(0, 0, 50, 50).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
+
+        m_hostImpl->drawLayers(frame);
+        m_hostImpl->didDrawAllLayers(frame);
+    }
+
+
+    // Applying a DSF should change the render surface size, but won't affect
+    // which part of the mask is used.
+    deviceScaleFactor = 2.f;
+    gfx::Size deviceViewport(gfx::ToFlooredSize(gfx::ScaleSize(rootSize, deviceScaleFactor)));
+    m_hostImpl->setViewportSize(rootSize, deviceViewport);
+    m_hostImpl->setDeviceScaleFactor(deviceScaleFactor);
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
+    {
+        LayerTreeHostImpl::FrameData frame;
+        EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+
+        ASSERT_EQ(1u, frame.renderPasses.size());
+        ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
+        ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
+        const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
+        EXPECT_EQ(gfx::Rect(0, 0, 100, 100).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
+
+        m_hostImpl->drawLayers(frame);
+        m_hostImpl->didDrawAllLayers(frame);
+    }
+
+
+    // Applying an equivalent content scale on the content layer and the mask
+    // should still result in the same part of the mask being used.
+    gfx::Size layerSizeLarge(gfx::ToRoundedSize(gfx::ScaleSize(layerSize, deviceScaleFactor)));
+    contentLayer->setContentBounds(layerSizeLarge);
+    contentLayer->setContentsScale(deviceScaleFactor, deviceScaleFactor);
+    gfx::Size maskSizeLarge(gfx::ToRoundedSize(gfx::ScaleSize(maskSize, deviceScaleFactor)));
+    maskLayer->setContentBounds(maskSizeLarge);
+    maskLayer->setContentsScale(deviceScaleFactor, deviceScaleFactor);
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
+    {
+        LayerTreeHostImpl::FrameData frame;
+        EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+
+        ASSERT_EQ(1u, frame.renderPasses.size());
+        ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
+        ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
+        const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
+        EXPECT_EQ(gfx::Rect(0, 0, 100, 100).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
+
+        m_hostImpl->drawLayers(frame);
+        m_hostImpl->didDrawAllLayers(frame);
+    }
+
+    // Applying a different contents scale to the mask layer will still result
+    // in the mask covering the owning layer.
+    maskLayer->setContentBounds(maskSize);
+    maskLayer->setContentsScale(deviceScaleFactor, deviceScaleFactor);
+    m_hostImpl->activeTree()->set_needs_update_draw_properties();
+    {
+        LayerTreeHostImpl::FrameData frame;
+        EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+
+        ASSERT_EQ(1u, frame.renderPasses.size());
+        ASSERT_EQ(1u, frame.renderPasses[0]->quad_list.size());
+        ASSERT_EQ(DrawQuad::RENDER_PASS, frame.renderPasses[0]->quad_list[0]->material);
+        const RenderPassDrawQuad* renderPassQuad = RenderPassDrawQuad::MaterialCast(frame.renderPasses[0]->quad_list[0]);
+        EXPECT_EQ(gfx::Rect(0, 0, 100, 100).ToString(), renderPassQuad->rect.ToString());
+        EXPECT_EQ(gfx::RectF(0.f, 0.f, 1.f, 1.f).ToString(), renderPassQuad->mask_uv_rect.ToString());
+
+        m_hostImpl->drawLayers(frame);
+        m_hostImpl->didDrawAllLayers(frame);
+    }
+}
+
 INSTANTIATE_TEST_CASE_P(LayerTreeHostImplTests,
                         LayerTreeHostImplTest,
                         ::testing::Values(false, true));
Index: src/cc/stream_video_draw_quad.cc
===================================================================
--- src/cc/stream_video_draw_quad.cc	(revision 184497)
+++ src/cc/stream_video_draw_quad.cc	(working copy)
@@ -40,6 +40,12 @@
   this->matrix = matrix;
 }
 
+void StreamVideoDrawQuad::AppendResources(
+    ResourceProvider::ResourceIdArray* resources) {
+  // TODO(danakj): Convert to TextureDrawQuad?
+  NOTIMPLEMENTED();
+}
+
 const StreamVideoDrawQuad* StreamVideoDrawQuad::MaterialCast(
     const DrawQuad* quad) {
   DCHECK(quad->material == DrawQuad::STREAM_VIDEO_CONTENT);
Index: src/cc/renderer.h
===================================================================
--- src/cc/renderer.h	(revision 184497)
+++ src/cc/renderer.h	(working copy)
@@ -52,8 +52,8 @@
     virtual bool haveCachedResourcesForRenderPassId(RenderPass::Id) const;
 
     // This passes ownership of the render passes to the renderer. It should
-    // consume them, and empty the list and hash map.
-    virtual void drawFrame(RenderPassList&, RenderPassIdHashMap&) = 0;
+    // consume them, and empty the list.
+    virtual void drawFrame(RenderPassList&) = 0;
 
     // waits for rendering to finish
     virtual void finish() = 0;
Index: src/cc/single_thread_proxy.cc
===================================================================
--- src/cc/single_thread_proxy.cc	(revision 184497)
+++ src/cc/single_thread_proxy.cc	(working copy)
@@ -4,10 +4,13 @@
 
 #include "cc/single_thread_proxy.h"
 
+#include "base/auto_reset.h"
 #include "base/debug/trace_event.h"
 #include "cc/draw_quad.h"
 #include "cc/layer_tree_host.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/output_surface.h"
+#include "cc/prioritized_resource_manager.h"
 #include "cc/resource_update_controller.h"
 #include "cc/thread.h"
 
@@ -24,10 +27,15 @@
     , m_outputSurfaceLost(false)
     , m_rendererInitialized(false)
     , m_nextFrameIsNewlyCommittedFrame(false)
+    , m_insideDraw(false)
     , m_totalCommitCount(0)
 {
     TRACE_EVENT0("cc", "SingleThreadProxy::SingleThreadProxy");
     DCHECK(Proxy::isMainThread());
+    DCHECK(layerTreeHost);
+
+    // Impl-side painting not supported without threaded compositing
+    DCHECK(!layerTreeHost->settings().implSidePainting);
 }
 
 void SingleThreadProxy::start()
@@ -51,12 +59,15 @@
     if (!commitAndComposite())
         return false;
 
-    m_layerTreeHostImpl->readback(pixels, rect);
+    {
+        DebugScopedSetImplThread impl(this);
+        m_layerTreeHostImpl->readback(pixels, rect);
 
-    if (m_layerTreeHostImpl->isContextLost())
-        return false;
+        if (m_layerTreeHostImpl->isContextLost())
+            return false;
 
-    m_layerTreeHostImpl->swapBuffers();
+        m_layerTreeHostImpl->swapBuffers();
+    }
     didSwapFrame();
 
     return true;
@@ -133,8 +144,7 @@
     {
         DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
         DebugScopedSetImplThread impl(this);
-        if (!m_layerTreeHostImpl->contentsTexturesPurged())
-            m_layerTreeHost->deleteContentsTexturesOnImplThread(m_layerTreeHostImpl->resourceProvider());
+        m_layerTreeHost->deleteContentsTexturesOnImplThread(m_layerTreeHostImpl->resourceProvider());
         initialized = m_layerTreeHostImpl->initializeRenderer(outputSurface.Pass());
         if (initialized) {
             m_RendererCapabilitiesForMainThread = m_layerTreeHostImpl->rendererCapabilities();
@@ -149,7 +159,7 @@
 
 void SingleThreadProxy::renderingStats(RenderingStats* stats)
 {
-    stats->totalCommitTimeInSeconds = m_totalCommitTime.InSecondsF();
+    stats->totalCommitTime = m_totalCommitTime;
     stats->totalCommitCount = m_totalCommitCount;
     m_layerTreeHostImpl->renderingStats(stats);
 }
@@ -161,13 +171,6 @@
     return m_RendererCapabilitiesForMainThread;
 }
 
-void SingleThreadProxy::loseOutputSurface()
-{
-    DCHECK(Proxy::isMainThread());
-    m_layerTreeHost->didLoseOutputSurface();
-    m_outputSurfaceLost = true;
-}
-
 void SingleThreadProxy::setNeedsAnimate()
 {
     // Thread-only feature
@@ -230,6 +233,12 @@
     setNeedsCommit();
 }
 
+void SingleThreadProxy::onHasPendingTreeStateChanged(bool havePendingTree)
+{
+    // Thread-only feature.
+    NOTREACHED();
+}
+
 void SingleThreadProxy::setDeferCommits(bool deferCommits)
 {
     // Thread-only feature.
@@ -241,10 +250,6 @@
     return false;
 }
 
-void SingleThreadProxy::didAddAnimation()
-{
-}
-
 size_t SingleThreadProxy::maxPartialTextureUpdates() const
 {
     return std::numeric_limits<size_t>::max();
@@ -258,7 +263,7 @@
         DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
         DebugScopedSetImplThread impl(this);
 
-        if (!m_layerTreeHostImpl->contentsTexturesPurged())
+        if (!m_layerTreeHostImpl->activeTree()->ContentsTexturesPurged())
             m_layerTreeHost->deleteContentsTexturesOnImplThread(m_layerTreeHostImpl->resourceProvider());
         m_layerTreeHostImpl.reset();
     }
@@ -270,6 +275,12 @@
     m_layerTreeHost->scheduleComposite();
 }
 
+void SingleThreadProxy::didUploadVisibleHighResolutionTileOnImplThread()
+{
+    // implSidePainting only.
+    NOTREACHED();
+}
+
 void SingleThreadProxy::setNeedsCommitOnImplThread()
 {
     m_layerTreeHost->scheduleComposite();
@@ -296,6 +307,12 @@
     return m_layerTreeHost->contentsTextureManager()->reduceMemoryOnImplThread(limitBytes, priorityCutoff, m_layerTreeHostImpl->resourceProvider());
 }
 
+void SingleThreadProxy::reduceWastedContentsTextureMemoryOnImplThread()
+{
+    // implSidePainting only.
+    NOTREACHED();
+}
+
 void SingleThreadProxy::sendManagedMemoryStats()
 {
     DCHECK(Proxy::isImplThread());
@@ -310,6 +327,17 @@
         m_layerTreeHost->contentsTextureManager()->memoryUseBytes());
 }
 
+bool SingleThreadProxy::isInsideDraw()
+{
+    return m_insideDraw;
+}
+
+void SingleThreadProxy::didLoseOutputSurfaceOnImplThread()
+{
+    // Cause a commit so we can notice the lost context.
+    setNeedsCommitOnImplThread();
+}
+
 // Called by the legacy scheduling path (e.g. where render_widget does the scheduling)
 void SingleThreadProxy::compositeImmediately()
 {
@@ -345,9 +373,6 @@
     scoped_ptr<ResourceUpdateQueue> queue = make_scoped_ptr(new ResourceUpdateQueue);
     m_layerTreeHost->updateLayers(*(queue.get()), m_layerTreeHostImpl->memoryAllocationLimitBytes());
 
-    if (m_layerTreeHostImpl->contentsTexturesPurged())
-        m_layerTreeHostImpl->resetContentsTexturesPurged();
-
     m_layerTreeHost->willCommit();
     doCommit(queue.Pass());
     bool result = doComposite();
@@ -360,15 +385,13 @@
     DCHECK(!m_outputSurfaceLost);
     {
         DebugScopedSetImplThread impl(this);
+        base::AutoReset<bool> markInside(&m_insideDraw, true);
 
         if (!m_layerTreeHostImpl->visible())
             return false;
 
         m_layerTreeHostImpl->animate(base::TimeTicks::Now(), base::Time::Now());
 
-        if (m_layerTreeHostImpl->settings().implSidePainting)
-          m_layerTreeHostImpl->manageTiles();
-
         // We guard prepareToDraw() with canDraw() because it always returns a valid frame, so can only
         // be used when such a frame is possible. Since drawLayers() depends on the result of
         // prepareToDraw(), it is guarded on canDraw() as well.
@@ -379,10 +402,12 @@
         m_layerTreeHostImpl->prepareToDraw(frame);
         m_layerTreeHostImpl->drawLayers(frame);
         m_layerTreeHostImpl->didDrawAllLayers(frame);
+        m_outputSurfaceLost = m_layerTreeHostImpl->isContextLost();
+
+        m_layerTreeHostImpl->beginNextFrame();
     }
 
-    if (m_layerTreeHostImpl->isContextLost()) {
-        m_outputSurfaceLost = true;
+    if (m_outputSurfaceLost) {
         m_layerTreeHost->didLoseOutputSurface();
         return false;
     }
@@ -403,4 +428,11 @@
     return false;
 }
 
+skia::RefPtr<SkPicture> SingleThreadProxy::capturePicture()
+{
+    // Requires impl-side painting, which is only supported in threaded compositing.
+    NOTREACHED();
+    return skia::RefPtr<SkPicture>();
+}
+
 }  // namespace cc
Index: src/cc/draw_quad.h
===================================================================
--- src/cc/draw_quad.h	(revision 184497)
+++ src/cc/draw_quad.h	(working copy)
@@ -6,6 +6,7 @@
 #define CC_DRAW_QUAD_H_
 
 #include "cc/cc_export.h"
+#include "cc/resource_provider.h"
 #include "cc/shared_quad_state.h"
 
 namespace cc {
@@ -37,7 +38,6 @@
   // TODO(danakj): Chromify or remove these SharedQuadState helpers.
   const gfx::Transform& quadTransform() const { return shared_quad_state->content_to_target_transform; }
   gfx::Rect visibleContentRect() const { return shared_quad_state->visible_content_rect; }
-  gfx::Rect clippedRectInTarget() const { return shared_quad_state->clipped_rect_in_target; }
   gfx::Rect clipRect() const { return shared_quad_state->clip_rect; }
   bool isClipped() const { return shared_quad_state->is_clipped; }
   float opacity() const { return shared_quad_state->opacity; }
@@ -71,6 +71,8 @@
         !opaque_rect.Contains(visible_rect);
   }
 
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources);
+
  protected:
   DrawQuad();
 
Index: src/cc/layer_animation_controller_unittest.cc
===================================================================
--- src/cc/layer_animation_controller_unittest.cc	(revision 184497)
+++ src/cc/layer_animation_controller_unittest.cc	(working copy)
@@ -4,7 +4,7 @@
 
 #include "cc/layer_animation_controller.h"
 
-#include "cc/active_animation.h"
+#include "cc/animation.h"
 #include "cc/animation_curve.h"
 #include "cc/test/animation_test_common.h"
 #include "testing/gmock/include/gmock/gmock.h"
@@ -19,45 +19,49 @@
     EXPECT_FLOAT_EQ(translateX, matrix.matrix().getDouble(0, 3));
 }
 
-scoped_ptr<ActiveAnimation> createActiveAnimation(scoped_ptr<AnimationCurve> curve, int id, ActiveAnimation::TargetProperty property)
+scoped_ptr<Animation> createAnimation(scoped_ptr<AnimationCurve> curve, int id, Animation::TargetProperty property)
 {
-    return ActiveAnimation::create(curve.Pass(), 0, id, property);
+    return Animation::create(curve.Pass(), 0, id, property);
 }
 
 TEST(LayerAnimationControllerTest, syncNewAnimation)
 {
-    FakeLayerAnimationControllerClient dummyImpl;
-    scoped_ptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(&dummyImpl));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummyImpl;
+    scoped_refptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(0));
+    controllerImpl->addObserver(&dummyImpl);
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    EXPECT_FALSE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
+    EXPECT_FALSE(controllerImpl->getAnimation(0, Animation::Opacity));
 
     addOpacityTransitionToController(*controller, 1, 0, 1, false);
 
     controller->pushAnimationUpdatesTo(controllerImpl.get());
 
-    EXPECT_TRUE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
-    EXPECT_EQ(ActiveAnimation::WaitingForTargetAvailability, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_TRUE(controllerImpl->getAnimation(0, Animation::Opacity));
+    EXPECT_EQ(Animation::WaitingForTargetAvailability, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
 }
 
 // If an animation is started on the impl thread before it is ticked on the main
 // thread, we must be sure to respect the synchronized start time.
 TEST(LayerAnimationControllerTest, doNotClobberStartTimes)
 {
-    FakeLayerAnimationControllerClient dummyImpl;
-    scoped_ptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(&dummyImpl));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummyImpl;
+    scoped_refptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(0));
+    controllerImpl->addObserver(&dummyImpl);
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    EXPECT_FALSE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
+    EXPECT_FALSE(controllerImpl->getAnimation(0, Animation::Opacity));
 
     addOpacityTransitionToController(*controller, 1, 0, 1, false);
 
     controller->pushAnimationUpdatesTo(controllerImpl.get());
 
-    EXPECT_TRUE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
-    EXPECT_EQ(ActiveAnimation::WaitingForTargetAvailability, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_TRUE(controllerImpl->getAnimation(0, Animation::Opacity));
+    EXPECT_EQ(Animation::WaitingForTargetAvailability, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
 
     AnimationEventsVector events;
     controllerImpl->animate(1, &events);
@@ -65,93 +69,97 @@
     // Synchronize the start times.
     EXPECT_EQ(1u, events.size());
     controller->OnAnimationStarted(events[0]);
-    EXPECT_EQ(controller->getActiveAnimation(0, ActiveAnimation::Opacity)->startTime(), controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->startTime());
+    EXPECT_EQ(controller->getAnimation(0, Animation::Opacity)->startTime(), controllerImpl->getAnimation(0, Animation::Opacity)->startTime());
 
     // Start the animation on the main thread. Should not affect the start time.
     controller->animate(1.5, 0);
-    EXPECT_EQ(controller->getActiveAnimation(0, ActiveAnimation::Opacity)->startTime(), controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->startTime());
+    EXPECT_EQ(controller->getAnimation(0, Animation::Opacity)->startTime(), controllerImpl->getAnimation(0, Animation::Opacity)->startTime());
 }
 
 TEST(LayerAnimationControllerTest, syncPauseAndResume)
 {
-    FakeLayerAnimationControllerClient dummyImpl;
-    scoped_ptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(&dummyImpl));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummyImpl;
+    scoped_refptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(0));
+    controllerImpl->addObserver(&dummyImpl);
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    EXPECT_FALSE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
+    EXPECT_FALSE(controllerImpl->getAnimation(0, Animation::Opacity));
 
     addOpacityTransitionToController(*controller, 1, 0, 1, false);
 
     controller->pushAnimationUpdatesTo(controllerImpl.get());
 
-    EXPECT_TRUE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
-    EXPECT_EQ(ActiveAnimation::WaitingForTargetAvailability, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_TRUE(controllerImpl->getAnimation(0, Animation::Opacity));
+    EXPECT_EQ(Animation::WaitingForTargetAvailability, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
 
     // Start the animations on each controller.
     AnimationEventsVector events;
     controllerImpl->animate(0, &events);
     controller->animate(0, 0);
-    EXPECT_EQ(ActiveAnimation::Running, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
-    EXPECT_EQ(ActiveAnimation::Running, controller->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_EQ(Animation::Running, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
+    EXPECT_EQ(Animation::Running, controller->getAnimation(0, Animation::Opacity)->runState());
 
     // Pause the main-thread animation.
     controller->suspendAnimations(1);
-    EXPECT_EQ(ActiveAnimation::Paused, controller->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_EQ(Animation::Paused, controller->getAnimation(0, Animation::Opacity)->runState());
 
     // The pause run state change should make it to the impl thread controller.
     controller->pushAnimationUpdatesTo(controllerImpl.get());
-    EXPECT_EQ(ActiveAnimation::Paused, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_EQ(Animation::Paused, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
 
     // Resume the main-thread animation.
     controller->resumeAnimations(2);
-    EXPECT_EQ(ActiveAnimation::Running, controller->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_EQ(Animation::Running, controller->getAnimation(0, Animation::Opacity)->runState());
 
     // The pause run state change should make it to the impl thread controller.
     controller->pushAnimationUpdatesTo(controllerImpl.get());
-    EXPECT_EQ(ActiveAnimation::Running, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_EQ(Animation::Running, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
 }
 
 TEST(LayerAnimationControllerTest, doNotSyncFinishedAnimation)
 {
-    FakeLayerAnimationControllerClient dummyImpl;
-    scoped_ptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(&dummyImpl));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummyImpl;
+    scoped_refptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(0));
+    controllerImpl->addObserver(&dummyImpl);
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    EXPECT_FALSE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
+    EXPECT_FALSE(controllerImpl->getAnimation(0, Animation::Opacity));
 
     int animationId = addOpacityTransitionToController(*controller, 1, 0, 1, false);
 
     controller->pushAnimationUpdatesTo(controllerImpl.get());
 
-    EXPECT_TRUE(controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity));
-    EXPECT_EQ(ActiveAnimation::WaitingForTargetAvailability, controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity)->runState());
+    EXPECT_TRUE(controllerImpl->getAnimation(0, Animation::Opacity));
+    EXPECT_EQ(Animation::WaitingForTargetAvailability, controllerImpl->getAnimation(0, Animation::Opacity)->runState());
 
     // Notify main thread controller that the animation has started.
-    AnimationEvent animationStartedEvent(AnimationEvent::Started, 0, 0, ActiveAnimation::Opacity, 0);
+    AnimationEvent animationStartedEvent(AnimationEvent::Started, 0, 0, Animation::Opacity, 0);
     controller->OnAnimationStarted(animationStartedEvent);
 
     // Force animation to complete on impl thread.
     controllerImpl->removeAnimation(animationId);
 
-    EXPECT_FALSE(controllerImpl->getActiveAnimation(animationId, ActiveAnimation::Opacity));
+    EXPECT_FALSE(controllerImpl->getAnimation(animationId, Animation::Opacity));
 
     controller->pushAnimationUpdatesTo(controllerImpl.get());
 
     // Even though the main thread has a 'new' animation, it should not be pushed because the animation has already completed on the impl thread.
-    EXPECT_FALSE(controllerImpl->getActiveAnimation(animationId, ActiveAnimation::Opacity));
+    EXPECT_FALSE(controllerImpl->getAnimation(animationId, Animation::Opacity));
 }
 
 // Tests that transitioning opacity from 0 to 1 works as expected.
 TEST(LayerAnimationControllerTest, TrivialTransition)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
 
     controller->addAnimation(toAdd.Pass());
     controller->animate(0, events.get());
@@ -166,11 +174,11 @@
 TEST(LayerAnimationControllerTest, AnimationsWaitingForStartTimeDoNotFinishIfTheyWaitLongerToStartThanTheirDuration)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
     toAdd->setNeedsSynchronizedStartTime(true);
 
     // We should pause at the first keyframe indefinitely waiting for that animation to start.
@@ -186,7 +194,7 @@
     EXPECT_EQ(0, dummy.opacity());
 
     // Send the synchronized start time.
-    controller->OnAnimationStarted(AnimationEvent(AnimationEvent::Started, 0, 1, ActiveAnimation::Opacity, 2));
+    controller->OnAnimationStarted(AnimationEvent(AnimationEvent::Started, 0, 1, Animation::Opacity, 2));
     controller->animate(5, events.get());
     EXPECT_EQ(1, dummy.opacity());
     EXPECT_FALSE(controller->hasActiveAnimation());
@@ -196,12 +204,12 @@
 TEST(LayerAnimationControllerTest, TrivialQueuing)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.5)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.5)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
 
     controller->animate(0, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
@@ -218,16 +226,16 @@
 TEST(LayerAnimationControllerTest, Interrupt)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
     controller->animate(0, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
     EXPECT_EQ(0, dummy.opacity());
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.5)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
-    toAdd->setRunState(ActiveAnimation::WaitingForNextTick, 0);
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.5)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
+    toAdd->setRunState(Animation::WaitingForNextTick, 0);
     controller->addAnimation(toAdd.Pass());
 
     // Since the animation was in the WaitingForNextTick state, it should start right in
@@ -244,13 +252,13 @@
 TEST(LayerAnimationControllerTest, ScheduleTogetherWhenAPropertyIsBlocked)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeTransformTransition(1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Transform));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeTransformTransition(1)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Transform));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeTransformTransition(1)).PassAs<AnimationCurve>(), 1, Animation::Transform));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeTransformTransition(1)).PassAs<AnimationCurve>(), 2, Animation::Transform));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
 
     controller->animate(0, events.get());
     EXPECT_EQ(0, dummy.opacity());
@@ -271,13 +279,13 @@
 TEST(LayerAnimationControllerTest, ScheduleTogetherWithAnAnimWaiting)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeTransformTransition(2)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Transform));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.5)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeTransformTransition(2)).PassAs<AnimationCurve>(), 1, Animation::Transform));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.5)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
 
     // Animations with id 1 should both start now.
     controller->animate(0, events.get());
@@ -301,12 +309,12 @@
 TEST(LayerAnimationControllerTest, ScheduleAnimation)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
-    toAdd->setRunState(ActiveAnimation::WaitingForStartTime, 0);
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
+    toAdd->setRunState(Animation::WaitingForStartTime, 0);
     toAdd->setStartTime(1);
     controller->addAnimation(toAdd.Pass());
 
@@ -325,14 +333,14 @@
 TEST(LayerAnimationControllerTest, ScheduledAnimationInterruptsRunningAnimation)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0.5, 0)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
-    toAdd->setRunState(ActiveAnimation::WaitingForStartTime, 0);
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0.5, 0)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
+    toAdd->setRunState(Animation::WaitingForStartTime, 0);
     toAdd->setStartTime(1);
     controller->addAnimation(toAdd.Pass());
 
@@ -356,18 +364,18 @@
 TEST(LayerAnimationControllerTest, ScheduledAnimationInterruptsRunningAnimationWithAnimInQueue)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0.5, 0)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
-    toAdd->setRunState(ActiveAnimation::WaitingForStartTime, 0);
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0.5, 0)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
+    toAdd->setRunState(Animation::WaitingForStartTime, 0);
     toAdd->setStartTime(1);
     controller->addAnimation(toAdd.Pass());
 
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 0.75)).PassAs<AnimationCurve>(), 3, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 0.75)).PassAs<AnimationCurve>(), 3, Animation::Opacity));
 
     // First 2s opacity transition should start immediately.
     controller->animate(0, events.get());
@@ -392,11 +400,11 @@
 TEST(LayerAnimationControllerTest, TrivialLooping)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), 1, Animation::Opacity));
     toAdd->setIterations(3);
     controller->addAnimation(toAdd.Pass());
 
@@ -428,12 +436,12 @@
 TEST(LayerAnimationControllerTest, InfiniteLooping)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
     const int id = 1;
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), id, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), id, Animation::Opacity));
     toAdd->setIterations(-1);
     controller->addAnimation(toAdd.Pass());
 
@@ -454,8 +462,8 @@
     EXPECT_TRUE(controller->hasActiveAnimation());
     EXPECT_EQ(0.75, dummy.opacity());
 
-    EXPECT_TRUE(controller->getActiveAnimation(id, ActiveAnimation::Opacity));
-    controller->getActiveAnimation(id, ActiveAnimation::Opacity)->setRunState(ActiveAnimation::Aborted, 0.75);
+    EXPECT_TRUE(controller->getAnimation(id, Animation::Opacity));
+    controller->getAnimation(id, Animation::Opacity)->setRunState(Animation::Aborted, 0.75);
     EXPECT_FALSE(controller->hasActiveAnimation());
     EXPECT_EQ(0.75, dummy.opacity());
 }
@@ -464,12 +472,12 @@
 TEST(LayerAnimationControllerTest, PauseResume)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
     const int id = 1;
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), id, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 0, 1)).PassAs<AnimationCurve>(), id, Animation::Opacity));
 
     controller->animate(0, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
@@ -478,15 +486,15 @@
     EXPECT_TRUE(controller->hasActiveAnimation());
     EXPECT_EQ(0.5, dummy.opacity());
 
-    EXPECT_TRUE(controller->getActiveAnimation(id, ActiveAnimation::Opacity));
-    controller->getActiveAnimation(id, ActiveAnimation::Opacity)->setRunState(ActiveAnimation::Paused, 0.5);
+    EXPECT_TRUE(controller->getAnimation(id, Animation::Opacity));
+    controller->getAnimation(id, Animation::Opacity)->setRunState(Animation::Paused, 0.5);
 
     controller->animate(1024, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
     EXPECT_EQ(0.5, dummy.opacity());
 
-    EXPECT_TRUE(controller->getActiveAnimation(id, ActiveAnimation::Opacity));
-    controller->getActiveAnimation(id, ActiveAnimation::Opacity)->setRunState(ActiveAnimation::Running, 1024);
+    EXPECT_TRUE(controller->getAnimation(id, Animation::Opacity));
+    controller->getAnimation(id, Animation::Opacity)->setRunState(Animation::Running, 1024);
 
     controller->animate(1024.25, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
@@ -499,14 +507,14 @@
 TEST(LayerAnimationControllerTest, AbortAGroupedAnimation)
 {
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
     const int id = 1;
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeTransformTransition(1)).PassAs<AnimationCurve>(), id, ActiveAnimation::Transform));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), id, ActiveAnimation::Opacity));
-    controller->addAnimation(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.75)).PassAs<AnimationCurve>(), 2, ActiveAnimation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeTransformTransition(1)).PassAs<AnimationCurve>(), id, Animation::Transform));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), id, Animation::Opacity));
+    controller->addAnimation(createAnimation(make_scoped_ptr(new FakeFloatTransition(1, 1, 0.75)).PassAs<AnimationCurve>(), 2, Animation::Opacity));
 
     controller->animate(0, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
@@ -515,8 +523,8 @@
     EXPECT_TRUE(controller->hasActiveAnimation());
     EXPECT_EQ(0.5, dummy.opacity());
 
-    EXPECT_TRUE(controller->getActiveAnimation(id, ActiveAnimation::Opacity));
-    controller->getActiveAnimation(id, ActiveAnimation::Opacity)->setRunState(ActiveAnimation::Aborted, 1);
+    EXPECT_TRUE(controller->getAnimation(id, Animation::Opacity));
+    controller->getAnimation(id, Animation::Opacity)->setRunState(Animation::Aborted, 1);
     controller->animate(1, events.get());
     EXPECT_TRUE(controller->hasActiveAnimation());
     EXPECT_EQ(1, dummy.opacity());
@@ -527,20 +535,21 @@
 
 TEST(LayerAnimationControllerTest, ForceSyncWhenSynchronizedStartTimeNeeded)
 {
-    FakeLayerAnimationControllerClient dummyImpl;
-    scoped_ptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(&dummyImpl));
+    FakeLayerAnimationValueObserver dummyImpl;
+    scoped_refptr<LayerAnimationController> controllerImpl(LayerAnimationController::create(0));
+    controllerImpl->addObserver(&dummyImpl);
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
-    FakeLayerAnimationControllerClient dummy;
-    scoped_ptr<LayerAnimationController> controller(
-        LayerAnimationController::create(&dummy));
+    FakeLayerAnimationValueObserver dummy;
+    scoped_refptr<LayerAnimationController> controller(LayerAnimationController::create(0));
+    controller->addObserver(&dummy);
 
-    scoped_ptr<ActiveAnimation> toAdd(createActiveAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), 0, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> toAdd(createAnimation(make_scoped_ptr(new FakeFloatTransition(2, 0, 1)).PassAs<AnimationCurve>(), 0, Animation::Opacity));
     toAdd->setNeedsSynchronizedStartTime(true);
     controller->addAnimation(toAdd.Pass());
 
     controller->animate(0, 0);
     EXPECT_TRUE(controller->hasActiveAnimation());
-    ActiveAnimation* activeAnimation = controller->getActiveAnimation(0, ActiveAnimation::Opacity);
+    Animation* activeAnimation = controller->getAnimation(0, Animation::Opacity);
     EXPECT_TRUE(activeAnimation);
     EXPECT_TRUE(activeAnimation->needsSynchronizedStartTime());
 
@@ -548,9 +557,9 @@
 
     controller->pushAnimationUpdatesTo(controllerImpl.get());
 
-    activeAnimation = controllerImpl->getActiveAnimation(0, ActiveAnimation::Opacity);
+    activeAnimation = controllerImpl->getAnimation(0, Animation::Opacity);
     EXPECT_TRUE(activeAnimation);
-    EXPECT_EQ(ActiveAnimation::WaitingForTargetAvailability, activeAnimation->runState());
+    EXPECT_EQ(Animation::WaitingForTargetAvailability, activeAnimation->runState());
 }
 
 }  // namespace
Index: src/cc/render_surface_filters.cc
===================================================================
--- src/cc/render_surface_filters.cc	(revision 184497)
+++ src/cc/render_surface_filters.cc	(working copy)
@@ -6,6 +6,9 @@
 
 #include "base/logging.h"
 #include "skia/ext/refptr.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperation.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/effects/SkBlurImageFilter.h"
 #include "third_party/skia/include/effects/SkColorMatrixFilter.h"
@@ -13,9 +16,6 @@
 #include "third_party/skia/include/gpu/SkGpuDevice.h"
 #include "third_party/skia/include/gpu/SkGrPixelRef.h"
 #include "ui/gfx/size_f.h"
-#include <public/WebFilterOperation.h>
-#include <public/WebFilterOperations.h>
-#include <public/WebGraphicsContext3D.h>
 
 namespace cc {
 
Index: src/cc/software_renderer.cc
===================================================================
--- src/cc/software_renderer.cc	(revision 184497)
+++ src/cc/software_renderer.cc	(working copy)
@@ -4,8 +4,6 @@
 
 #include "cc/software_renderer.h"
 
-#include <public/WebImage.h>
-
 #include "base/debug/trace_event.h"
 #include "cc/debug_border_draw_quad.h"
 #include "cc/math_util.h"
@@ -14,6 +12,7 @@
 #include "cc/solid_color_draw_quad.h"
 #include "cc/texture_draw_quad.h"
 #include "cc/tile_draw_quad.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebImage.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkMatrix.h"
@@ -184,7 +183,8 @@
     TRACE_EVENT0("cc", "SoftwareRenderer::drawQuad");
     gfx::Transform quadRectMatrix;
     quadRectTransform(&quadRectMatrix, quad->quadTransform(), quad->rect);
-    gfx::Transform contentsDeviceTransform = MathUtil::to2dTransform(frame.windowMatrix * frame.projectionMatrix * quadRectMatrix);
+    gfx::Transform contentsDeviceTransform = frame.windowMatrix * frame.projectionMatrix * quadRectMatrix;
+    contentsDeviceTransform.FlattenTo2d();
     SkMatrix skDeviceMatrix;
     toSkMatrix(&skDeviceMatrix, contentsDeviceTransform);
     m_skCurrentCanvas->setMatrix(skDeviceMatrix);
@@ -259,7 +259,9 @@
     // FIXME: Add support for non-premultiplied alpha.
     ResourceProvider::ScopedReadLockSoftware lock(m_resourceProvider, quad->resource_id);
     const SkBitmap* bitmap = lock.skBitmap();
-    gfx::RectF uvRect = gfx::ScaleRect(quad->uv_rect, bitmap->width(), bitmap->height());
+    gfx::RectF uvRect = gfx::ScaleRect(gfx::BoundingRect(quad->uv_top_left, quad->uv_bottom_right),
+                                       bitmap->width(),
+                                       bitmap->height());
     SkRect skUvRect = gfx::RectFToSkRect(uvRect);
     if (quad->flipped)
         m_skCurrentCanvas->scale(1, -1);
@@ -286,11 +288,6 @@
     if (!contentTexture || !contentTexture->id())
         return;
 
-    const RenderPass* renderPass = frame.renderPassesById->get(quad->render_pass_id);
-    DCHECK(renderPass);
-    if (!renderPass)
-        return;
-
     DCHECK(isSoftwareResource(contentTexture->id()));
     ResourceProvider::ScopedReadLockSoftware lock(m_resourceProvider, contentTexture->id());
 
@@ -311,7 +308,7 @@
     shader->setLocalMatrix(contentMat);
     m_skCurrentPaint.setShader(shader.get());
 
-    SkImageFilter* filter = renderPass->filter.get();
+    SkImageFilter* filter = quad->filter.get();
     if (filter)
         m_skCurrentPaint.setImageFilter(filter);
 
Index: src/cc/tiled_layer_impl.h
===================================================================
--- src/cc/tiled_layer_impl.h	(revision 184497)
+++ src/cc/tiled_layer_impl.h	(working copy)
@@ -21,6 +21,9 @@
     }
     virtual ~TiledLayerImpl();
 
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
 
     virtual ResourceProvider::ResourceId contentsResourceId() const OVERRIDE;
Index: src/cc/delegated_renderer_layer_impl.cc
===================================================================
--- src/cc/delegated_renderer_layer_impl.cc	(revision 184497)
+++ src/cc/delegated_renderer_layer_impl.cc	(working copy)
@@ -12,165 +12,220 @@
 
 namespace cc {
 
-DelegatedRendererLayerImpl::DelegatedRendererLayerImpl(LayerTreeImpl* treeImpl, int id)
-    : LayerImpl(treeImpl, id)
-{
+DelegatedRendererLayerImpl::DelegatedRendererLayerImpl(
+    LayerTreeImpl* tree_impl, int id)
+    : LayerImpl(tree_impl, id) {
 }
 
-DelegatedRendererLayerImpl::~DelegatedRendererLayerImpl()
-{
-    clearRenderPasses();
+DelegatedRendererLayerImpl::~DelegatedRendererLayerImpl() {
+  ClearRenderPasses();
 }
 
-bool DelegatedRendererLayerImpl::hasDelegatedContent() const
-{
-    return !m_renderPassesInDrawOrder.isEmpty();
+bool DelegatedRendererLayerImpl::hasDelegatedContent() const {
+  return !render_passes_in_draw_order_.empty();
 }
 
-bool DelegatedRendererLayerImpl::hasContributingDelegatedRenderPasses() const
-{
-    // The root RenderPass for the layer is merged with its target
-    // RenderPass in each frame. So we only have extra RenderPasses
-    // to merge when we have a non-root RenderPass present.
-    return m_renderPassesInDrawOrder.size() > 1;
+bool DelegatedRendererLayerImpl::hasContributingDelegatedRenderPasses() const {
+  // The root RenderPass for the layer is merged with its target
+  // RenderPass in each frame. So we only have extra RenderPasses
+  // to merge when we have a non-root RenderPass present.
+  return render_passes_in_draw_order_.size() > 1;
 }
 
-void DelegatedRendererLayerImpl::setRenderPasses(ScopedPtrVector<RenderPass>& renderPassesInDrawOrder)
-{
-    gfx::RectF oldRootDamage;
-    if (!m_renderPassesInDrawOrder.isEmpty())
-        oldRootDamage = m_renderPassesInDrawOrder.last()->damage_rect;
+void DelegatedRendererLayerImpl::SetRenderPasses(
+    ScopedPtrVector<RenderPass>& render_passes_in_draw_order) {
+  gfx::RectF old_root_damage;
+  if (!render_passes_in_draw_order_.empty())
+    old_root_damage = render_passes_in_draw_order_.back()->damage_rect;
 
-    clearRenderPasses();
+  ClearRenderPasses();
 
-    for (size_t i = 0; i < renderPassesInDrawOrder.size(); ++i) {
-        m_renderPassesIndexById.insert(std::pair<RenderPass::Id, int>(renderPassesInDrawOrder[i]->id, i));
-        m_renderPassesInDrawOrder.append(renderPassesInDrawOrder.take(i));
-    }
-    renderPassesInDrawOrder.clear();
+  for (size_t i = 0; i < render_passes_in_draw_order.size(); ++i) {
+    render_passes_index_by_id_.insert(
+        std::pair<RenderPass::Id, int>(render_passes_in_draw_order[i]->id, i));
+    scoped_ptr<RenderPass> passed_render_pass =
+        render_passes_in_draw_order.take(
+            render_passes_in_draw_order.begin() + i);
+    render_passes_in_draw_order_.push_back(passed_render_pass.Pass());
+  }
+  render_passes_in_draw_order.clear();
 
-    if (!m_renderPassesInDrawOrder.isEmpty())
-        m_renderPassesInDrawOrder.last()->damage_rect.Union(oldRootDamage);
+  if (!render_passes_in_draw_order_.empty())
+    render_passes_in_draw_order_.back()->damage_rect.Union(old_root_damage);
 }
 
-void DelegatedRendererLayerImpl::clearRenderPasses()
-{
-    // FIXME: Release the resources back to the nested compositor.
-    m_renderPassesIndexById.clear();
-    m_renderPassesInDrawOrder.clear();
+void DelegatedRendererLayerImpl::ClearRenderPasses() {
+  // FIXME: Release the resources back to the nested compositor.
+  render_passes_index_by_id_.clear();
+  render_passes_in_draw_order_.clear();
 }
 
-void DelegatedRendererLayerImpl::didLoseOutputSurface()
+scoped_ptr<LayerImpl> DelegatedRendererLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
 {
-    clearRenderPasses();
+    return DelegatedRendererLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
 }
 
-static inline int indexToId(int index) { return index + 1; }
-static inline int idToIndex(int id) { return id - 1; }
+void DelegatedRendererLayerImpl::didLoseOutputSurface() {
+  ClearRenderPasses();
+}
 
-RenderPass::Id DelegatedRendererLayerImpl::firstContributingRenderPassId() const
-{
-    return RenderPass::Id(id(), indexToId(0));
+static inline int IndexToId(int index) { return index + 1; }
+static inline int IdToIndex(int id) { return id - 1; }
+
+RenderPass::Id DelegatedRendererLayerImpl::firstContributingRenderPassId()
+    const {
+  return RenderPass::Id(id(), IndexToId(0));
 }
 
-RenderPass::Id DelegatedRendererLayerImpl::nextContributingRenderPassId(RenderPass::Id previous) const
-{
-    return RenderPass::Id(previous.layer_id, previous.index + 1);
+RenderPass::Id DelegatedRendererLayerImpl::nextContributingRenderPassId(
+    RenderPass::Id previous) const {
+  return RenderPass::Id(previous.layer_id, previous.index + 1);
 }
 
-RenderPass::Id DelegatedRendererLayerImpl::convertDelegatedRenderPassId(RenderPass::Id delegatedRenderPassId) const
-{
-    base::hash_map<RenderPass::Id, int>::const_iterator it = m_renderPassesIndexById.find(delegatedRenderPassId);
-    DCHECK(it != m_renderPassesIndexById.end());
-    unsigned delegatedRenderPassIndex = it->second;
-    return RenderPass::Id(id(), indexToId(delegatedRenderPassIndex));
+RenderPass::Id DelegatedRendererLayerImpl::ConvertDelegatedRenderPassId(
+    RenderPass::Id delegated_render_pass_id) const {
+  base::hash_map<RenderPass::Id, int>::const_iterator found =
+      render_passes_index_by_id_.find(delegated_render_pass_id);
+  DCHECK(found != render_passes_index_by_id_.end());
+  unsigned delegatedRenderPassIndex = found->second;
+  return RenderPass::Id(id(), IndexToId(delegatedRenderPassIndex));
 }
 
-void DelegatedRendererLayerImpl::appendContributingRenderPasses(RenderPassSink& renderPassSink)
-{
-    DCHECK(hasContributingDelegatedRenderPasses());
+void DelegatedRendererLayerImpl::AppendContributingRenderPasses(
+    RenderPassSink* render_pass_sink) {
+  DCHECK(hasContributingDelegatedRenderPasses());
 
-    for (size_t i = 0; i < m_renderPassesInDrawOrder.size() - 1; ++i) {
-        RenderPass::Id outputRenderPassId = convertDelegatedRenderPassId(m_renderPassesInDrawOrder[i]->id);
+  for (size_t i = 0; i < render_passes_in_draw_order_.size() - 1; ++i) {
+    RenderPass::Id output_render_pass_id =
+        ConvertDelegatedRenderPassId(render_passes_in_draw_order_[i]->id);
 
-        // Don't clash with the RenderPass we generate if we own a RenderSurfaceImpl.
-        DCHECK(outputRenderPassId.index > 0);
+    // Don't clash with the RenderPass we generate if we own a RenderSurface.
+    DCHECK(output_render_pass_id.index > 0);
 
-        renderPassSink.appendRenderPass(m_renderPassesInDrawOrder[i]->Copy(outputRenderPassId));
-    }
+    render_pass_sink->appendRenderPass(
+        render_passes_in_draw_order_[i]->Copy(output_render_pass_id));
+  }
 }
 
-void DelegatedRendererLayerImpl::appendQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData)
-{
-    if (m_renderPassesInDrawOrder.isEmpty())
-        return;
+void DelegatedRendererLayerImpl::appendQuads(
+    QuadSink& quad_sink, AppendQuadsData& append_quads_data) {
+  if (render_passes_in_draw_order_.empty())
+    return;
 
-    RenderPass::Id targetRenderPassId = appendQuadsData.renderPassId;
+  RenderPass::Id target_render_pass_id = append_quads_data.renderPassId;
 
-    // If the index of the renderPassId is 0, then it is a renderPass generated for a layer
-    // in this compositor, not the delegated renderer. Then we want to merge our root renderPass with
-    // the target renderPass. Otherwise, it is some renderPass which we added from the delegated
-    // renderer.
-    bool shouldMergeRootRenderPassWithTarget = !targetRenderPassId.index;
-    if (shouldMergeRootRenderPassWithTarget) {
-        // Verify that the renderPass we are appending to is created our renderTarget.
-        DCHECK(targetRenderPassId.layer_id == renderTarget()->id());
+  const RenderPass* root_delegated_render_pass =
+      render_passes_in_draw_order_.back();
 
-        const RenderPass* rootDelegatedRenderPass = m_renderPassesInDrawOrder.last();
-        appendRenderPassQuads(quadSink, appendQuadsData, rootDelegatedRenderPass);
-    } else {
-        // Verify that the renderPass we are appending to was created by us.
-        DCHECK(targetRenderPassId.layer_id == id());
+  DCHECK(root_delegated_render_pass->output_rect.origin().IsOrigin());
+  gfx::Size frame_size = root_delegated_render_pass->output_rect.size();
 
-        int renderPassIndex = idToIndex(targetRenderPassId.index);
-        const RenderPass* delegatedRenderPass = m_renderPassesInDrawOrder[renderPassIndex];
-        appendRenderPassQuads(quadSink, appendQuadsData, delegatedRenderPass);
-    }
+  // If the index of the renderPassId is 0, then it is a renderPass generated
+  // for a layer in this compositor, not the delegated renderer. Then we want to
+  // merge our root renderPass with the target renderPass. Otherwise, it is some
+  // renderPass which we added from the delegated renderer.
+  bool should_merge_root_render_pass_with_target = !target_render_pass_id.index;
+  if (should_merge_root_render_pass_with_target) {
+    // Verify that the renderPass we are appending to is created our
+    // renderTarget.
+    DCHECK(target_render_pass_id.layer_id == renderTarget()->id());
+
+    AppendRenderPassQuads(
+        &quad_sink, &append_quads_data, root_delegated_render_pass, frame_size);
+  } else {
+    // Verify that the renderPass we are appending to was created by us.
+    DCHECK(target_render_pass_id.layer_id == id());
+
+    int render_pass_index = IdToIndex(target_render_pass_id.index);
+    const RenderPass* delegated_render_pass =
+        render_passes_in_draw_order_[render_pass_index];
+    AppendRenderPassQuads(
+        &quad_sink, &append_quads_data, delegated_render_pass, frame_size);
+  }
 }
 
-void DelegatedRendererLayerImpl::appendRenderPassQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData, const RenderPass* delegatedRenderPass) const
-{
-    const SharedQuadState* currentSharedQuadState = 0;
-    SharedQuadState* copiedSharedQuadState = 0;
-    for (size_t i = 0; i < delegatedRenderPass->quad_list.size(); ++i) {
-        const DrawQuad* quad = delegatedRenderPass->quad_list[i];
+void DelegatedRendererLayerImpl::AppendRenderPassQuads(
+    QuadSink* quad_sink,
+    AppendQuadsData* append_quads_data,
+    const RenderPass* delegated_render_pass,
+    gfx::Size frame_size) const {
 
-        if (quad->shared_quad_state != currentSharedQuadState) {
-            currentSharedQuadState = quad->shared_quad_state;
-            copiedSharedQuadState = quadSink.useSharedQuadState(currentSharedQuadState->Copy());
-            bool targetIsFromDelegatedRendererLayer = appendQuadsData.renderPassId.layer_id == id();
-            if (!targetIsFromDelegatedRendererLayer) {
-              // Should be the root render pass.
-              DCHECK(delegatedRenderPass == m_renderPassesInDrawOrder.last());
-              // This layer must be drawing to a renderTarget other than itself.
-              DCHECK(renderTarget() != this);
+  const SharedQuadState* delegated_shared_quad_state = NULL;
+  SharedQuadState* output_shared_quad_state = NULL;
 
-              copiedSharedQuadState->content_to_target_transform = copiedSharedQuadState->content_to_target_transform * drawTransform();
-              copiedSharedQuadState->clipped_rect_in_target = MathUtil::mapClippedRect(drawTransform(), copiedSharedQuadState->clipped_rect_in_target);
-              copiedSharedQuadState->opacity *= drawOpacity();
-            }
-        }
-        DCHECK(copiedSharedQuadState);
+  for (size_t i = 0; i < delegated_render_pass->quad_list.size(); ++i) {
+    const DrawQuad* delegated_quad = delegated_render_pass->quad_list[i];
 
-        scoped_ptr<DrawQuad> copyQuad;
-        if (quad->material != DrawQuad::RENDER_PASS)
-            copyQuad = quad->Copy(copiedSharedQuadState);
-        else {
-            RenderPass::Id contributingDelegatedRenderPassId = RenderPassDrawQuad::MaterialCast(quad)->render_pass_id;
-            RenderPass::Id contributingRenderPassId = convertDelegatedRenderPassId(contributingDelegatedRenderPassId);
-            DCHECK(contributingRenderPassId != appendQuadsData.renderPassId);
+    if (delegated_quad->shared_quad_state != delegated_shared_quad_state) {
+      delegated_shared_quad_state = delegated_quad->shared_quad_state;
+      output_shared_quad_state = quad_sink->useSharedQuadState(
+          delegated_shared_quad_state->Copy());
 
-            copyQuad = RenderPassDrawQuad::MaterialCast(quad)->Copy(copiedSharedQuadState, contributingRenderPassId).PassAs<DrawQuad>();
+      bool is_root_delegated_render_pass =
+          delegated_render_pass == render_passes_in_draw_order_.back();
+      if (is_root_delegated_render_pass) {
+        // Don't allow areas inside the bounds that are empty.
+        DCHECK(display_size_.IsEmpty() ||
+               gfx::Rect(display_size_).Contains(gfx::Rect(bounds())));
+        gfx::Size display_size =
+            display_size_.IsEmpty() ? bounds() : display_size_;
+
+        gfx::Transform delegated_frame_to_layer_space_transform;
+        delegated_frame_to_layer_space_transform.Scale(
+            static_cast<double>(display_size.width()) / frame_size.width(),
+            static_cast<double>(display_size.height()) / frame_size.height());
+
+        gfx::Transform delegated_frame_to_target_transform =
+            drawTransform() * delegated_frame_to_layer_space_transform;
+
+        output_shared_quad_state->content_to_target_transform.ConcatTransform(
+            delegated_frame_to_target_transform);
+
+        if (renderTarget() == this) {
+          DCHECK(!isClipped());
+          DCHECK(renderSurface());
+          output_shared_quad_state->clip_rect = MathUtil::mapClippedRect(
+              delegated_frame_to_target_transform,
+              output_shared_quad_state->clip_rect);
+        } else {
+          gfx::Rect clip_rect = drawableContentRect();
+          if (output_shared_quad_state->is_clipped) {
+            clip_rect.Intersect(MathUtil::mapClippedRect(
+                delegated_frame_to_target_transform,
+                output_shared_quad_state->clip_rect));
+          }
+          output_shared_quad_state->clip_rect = clip_rect;
+          output_shared_quad_state->is_clipped = true;
         }
-        DCHECK(copyQuad.get());
 
-        quadSink.append(copyQuad.Pass(), appendQuadsData);
+        output_shared_quad_state->opacity *= drawOpacity();
+      }
     }
+    DCHECK(output_shared_quad_state);
+
+    scoped_ptr<DrawQuad> output_quad;
+    if (delegated_quad->material != DrawQuad::RENDER_PASS) {
+      output_quad = delegated_quad->Copy(output_shared_quad_state);
+    } else {
+      RenderPass::Id delegated_contributing_render_pass_id =
+          RenderPassDrawQuad::MaterialCast(delegated_quad)->render_pass_id;
+      RenderPass::Id output_contributing_render_pass_id =
+          ConvertDelegatedRenderPassId(delegated_contributing_render_pass_id);
+      DCHECK(output_contributing_render_pass_id !=
+             append_quads_data->renderPassId);
+
+      output_quad = RenderPassDrawQuad::MaterialCast(delegated_quad)->Copy(
+          output_shared_quad_state,
+          output_contributing_render_pass_id).PassAs<DrawQuad>();
+    }
+    DCHECK(output_quad.get());
+
+    quad_sink->append(output_quad.Pass(), *append_quads_data);
+  }
 }
 
-const char* DelegatedRendererLayerImpl::layerTypeAsString() const
-{
-    return "DelegatedRendererLayer";
+const char* DelegatedRendererLayerImpl::layerTypeAsString() const {
+  return "DelegatedRendererLayer";
 }
 
 }  // namespace cc
Index: src/cc/scrollbar_layer_impl_base.h
===================================================================
--- src/cc/scrollbar_layer_impl_base.h	(revision 184497)
+++ src/cc/scrollbar_layer_impl_base.h	(working copy)
@@ -7,7 +7,7 @@
 
 #include "cc/cc_export.h"
 #include "cc/layer_impl.h"
-#include <public/WebScrollbar.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbar.h"
 
 namespace cc {
 
Index: src/cc/texture_layer.cc
===================================================================
--- src/cc/texture_layer.cc	(revision 184497)
+++ src/cc/texture_layer.cc	(working copy)
@@ -7,21 +7,38 @@
 #include "cc/layer_tree_host.h"
 #include "cc/texture_layer_client.h"
 #include "cc/texture_layer_impl.h"
+#include "cc/thread.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
-#include "third_party/khronos/GLES2/gl2.h"
 
 namespace cc {
 
+static void runCallbackOnMainThread(const TextureMailbox::ReleaseCallback& callback, unsigned syncPoint)
+{
+    callback.Run(syncPoint);
+}
+
+static void postCallbackToMainThread(Thread *mainThread, const TextureMailbox::ReleaseCallback& callback, unsigned syncPoint)
+{
+    mainThread->postTask(base::Bind(&runCallbackOnMainThread, callback, syncPoint));
+}
+
 scoped_refptr<TextureLayer> TextureLayer::create(TextureLayerClient* client)
 {
-    return scoped_refptr<TextureLayer>(new TextureLayer(client));
+    return scoped_refptr<TextureLayer>(new TextureLayer(client, false));
 }
 
-TextureLayer::TextureLayer(TextureLayerClient* client)
+scoped_refptr<TextureLayer> TextureLayer::createForMailbox()
+{
+    return scoped_refptr<TextureLayer>(new TextureLayer(0, true));
+}
+
+TextureLayer::TextureLayer(TextureLayerClient* client, bool usesMailbox)
     : Layer()
     , m_client(client)
+    , m_usesMailbox(usesMailbox)
     , m_flipped(true)
-    , m_uvRect(0, 0, 1, 1)
+    , m_uvTopLeft(0.f, 0.f)
+    , m_uvBottomRight(1.f, 1.f)
     , m_premultipliedAlpha(true)
     , m_rateLimitContext(false)
     , m_contextLost(false)
@@ -42,11 +59,13 @@
         if (m_rateLimitContext && m_client)
             layerTreeHost()->stopRateLimiter(m_client->context());
     }
+    if (!m_contentCommitted)
+        m_textureMailbox.RunReleaseCallback(m_textureMailbox.sync_point());
 }
 
 scoped_ptr<LayerImpl> TextureLayer::createLayerImpl(LayerTreeImpl* treeImpl)
 {
-    return TextureLayerImpl::create(treeImpl, m_layerId).PassAs<LayerImpl>();
+    return TextureLayerImpl::create(treeImpl, m_layerId, m_usesMailbox).PassAs<LayerImpl>();
 }
 
 void TextureLayer::setFlipped(bool flipped)
@@ -55,9 +74,10 @@
     setNeedsCommit();
 }
 
-void TextureLayer::setUVRect(const gfx::RectF& rect)
+void TextureLayer::setUV(gfx::PointF topLeft, gfx::PointF bottomRight)
 {
-    m_uvRect = rect;
+    m_uvTopLeft = topLeft;
+    m_uvBottomRight = bottomRight;
     setNeedsCommit();
 }
 
@@ -92,6 +112,7 @@
 
 void TextureLayer::setTextureId(unsigned id)
 {
+    DCHECK(!m_usesMailbox);
     if (m_textureId == id)
         return;
     if (m_textureId && layerTreeHost())
@@ -100,6 +121,19 @@
     setNeedsCommit();
 }
 
+void TextureLayer::setTextureMailbox(const TextureMailbox& mailbox)
+{
+    DCHECK(m_usesMailbox);
+    if (m_textureMailbox.Equals(mailbox))
+        return;
+    // If we never commited the mailbox, we need to release it here
+    if (!m_contentCommitted)
+        m_textureMailbox.RunReleaseCallback(m_textureMailbox.sync_point());
+    m_textureMailbox = mailbox;
+
+    setNeedsCommit();
+}
+
 void TextureLayer::willModifyTexture()
 {
     if (layerTreeHost() && (drawsContent() || m_contentCommitted)) {
@@ -125,7 +159,7 @@
 
 bool TextureLayer::drawsContent() const
 {
-    return (m_client || m_textureId) && !m_contextLost && Layer::drawsContent();
+    return (m_client || m_textureId || !m_textureMailbox.IsEmpty()) && !m_contextLost && Layer::drawsContent();
 }
 
 void TextureLayer::update(ResourceUpdateQueue& queue, const OcclusionTracker*, RenderingStats&)
@@ -144,10 +178,19 @@
 
     TextureLayerImpl* textureLayer = static_cast<TextureLayerImpl*>(layer);
     textureLayer->setFlipped(m_flipped);
-    textureLayer->setUVRect(m_uvRect);
+    textureLayer->setUVTopLeft(m_uvTopLeft);
+    textureLayer->setUVBottomRight(m_uvBottomRight);
     textureLayer->setVertexOpacity(m_vertexOpacity);
     textureLayer->setPremultipliedAlpha(m_premultipliedAlpha);
-    textureLayer->setTextureId(m_textureId);
+    if (m_usesMailbox) {
+        Thread* mainThread = layerTreeHost()->proxy()->mainThread();
+        TextureMailbox::ReleaseCallback callback;
+        if (!m_textureMailbox.IsEmpty())
+          callback = base::Bind(&postCallbackToMainThread, mainThread, m_textureMailbox.callback());
+        textureLayer->setTextureMailbox(TextureMailbox(m_textureMailbox.name(), callback, m_textureMailbox.sync_point()));
+    } else {
+        textureLayer->setTextureId(m_textureId);
+    }
     m_contentCommitted = drawsContent();
 }
 
@@ -156,6 +199,11 @@
     // Double-buffered texture layers need to be blocked until they can be made
     // triple-buffered.  Single-buffered layers already prevent draws, so
     // can block too for simplicity.
+    return drawsContent();
+}
+
+bool TextureLayer::canClipSelf() const
+{
     return true;
 }
 
Index: src/cc/tile.h
===================================================================
--- src/cc/tile.h	(revision 184497)
+++ src/cc/tile.h	(working copy)
@@ -27,6 +27,7 @@
        gfx::Size tile_size,
        GLenum format,
        gfx::Rect content_rect,
+       gfx::Rect opaque_rect,
        float contents_scale);
 
   PicturePileImpl* picture_pile() {
@@ -42,24 +43,47 @@
                         priority_[PENDING_TREE]);
   }
 
-  void set_priority(WhichTree tree, const TilePriority& priority);
+  void set_priority(WhichTree tree, const TilePriority& priority) {
+    tile_manager_->WillModifyTilePriority(this, tree, priority);
+    priority_[tree] = priority;
+  }
 
   // Returns 0 if not drawable.
-  ResourceProvider::ResourceId GetResourceId() const;
+  ResourceProvider::ResourceId GetResourceId() const {
+    if (!managed_state_.resource)
+      return 0;
+    if (managed_state_.resource_is_being_initialized)
+      return 0;
 
+    return managed_state_.resource->id();
+  }
+
   const gfx::Rect& opaque_rect() const { return opaque_rect_; }
 
   bool contents_swizzled() const { return managed_state_.contents_swizzled; }
 
+  float contents_scale() const { return contents_scale_; }
+  gfx::Rect content_rect() const { return content_rect_; }
+
+  void set_picture_pile(scoped_refptr<PicturePileImpl> pile) {
+   picture_pile_ = pile;
+  }
+
+  ManagedTileState& ManagedStateForTesting() { return managed_state_; }
+
  private:
   // Methods called by by tile manager.
   friend class TileManager;
   friend class BinComparator;
   ManagedTileState& managed_state() { return managed_state_; }
   const ManagedTileState& managed_state() const { return managed_state_; }
-  size_t bytes_consumed_if_allocated() const;
-  float contents_scale() const { return contents_scale_; }
 
+  inline size_t bytes_consumed_if_allocated() const {
+    DCHECK(format_ == GL_RGBA);
+    return 4 * tile_size_.width() * tile_size_.height();
+  }
+
+
   // Normal private methods.
   friend class base::RefCounted<Tile>;
   ~Tile();
@@ -72,7 +96,7 @@
   float contents_scale_;
   gfx::Rect opaque_rect_;
 
-  TilePriority priority_[2];
+  TilePriority priority_[NUM_BIN_PRIORITIES];
   ManagedTileState managed_state_;
 };
 
Index: src/cc/layer_updater.cc
===================================================================
--- src/cc/layer_updater.cc	(revision 184497)
+++ src/cc/layer_updater.cc	(working copy)
@@ -4,15 +4,20 @@
 
 #include "cc/layer_updater.h"
 
+#include "cc/prioritized_resource.h"
+
 namespace cc {
 
 LayerUpdater::Resource::Resource(scoped_ptr<PrioritizedResource> texture)
-    : m_texture(texture.Pass())
-{
+    : m_texture(texture.Pass()) {
 }
 
-LayerUpdater::Resource::~Resource()
-{
+void LayerUpdater::Resource::swapTextureWith(
+    scoped_ptr<PrioritizedResource>& texture) {
+  m_texture.swap(texture);
 }
 
+LayerUpdater::Resource::~Resource() {
+}
+
 }  // namespace cc
Index: src/cc/yuv_video_draw_quad.h
===================================================================
--- src/cc/yuv_video_draw_quad.h	(revision 184497)
+++ src/cc/yuv_video_draw_quad.h	(working copy)
@@ -42,6 +42,9 @@
   VideoLayerImpl::FramePlane u_plane;
   VideoLayerImpl::FramePlane v_plane;
 
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources)
+      OVERRIDE;
+
   static const YUVVideoDrawQuad* MaterialCast(const DrawQuad*);
  private:
   YUVVideoDrawQuad();
Index: src/cc/prioritized_resource_manager.cc
===================================================================
--- src/cc/prioritized_resource_manager.cc	(revision 184497)
+++ src/cc/prioritized_resource_manager.cc	(working copy)
@@ -4,15 +4,14 @@
 
 #include "cc/prioritized_resource_manager.h"
 
+#include <algorithm>
+
 #include "base/debug/trace_event.h"
 #include "base/stl_util.h"
 #include "cc/prioritized_resource.h"
 #include "cc/priority_calculator.h"
 #include "cc/proxy.h"
-#include <algorithm>
 
-using namespace std;
-
 namespace cc {
 
 PrioritizedResourceManager::PrioritizedResourceManager(const Proxy* proxy)
@@ -279,16 +278,8 @@
     return true;
 }
 
-void PrioritizedResourceManager::reduceMemory(ResourceProvider* resourceProvider)
+void PrioritizedResourceManager::reduceWastedMemory(ResourceProvider* resourceProvider)
 {
-    DCHECK(m_proxy->isImplThread() && m_proxy->isMainThreadBlocked());
-    evictBackingsToReduceMemory(m_memoryAvailableBytes,
-                                PriorityCalculator::allowEverythingCutoff(),
-                                EvictAnything,
-                                UnlinkBackings,
-                                resourceProvider);
-    DCHECK(memoryUseBytes() <= m_memoryAvailableBytes);
-
     // We currently collect backings from deleted textures for later recycling.
     // However, if we do that forever we will always use the max limit even if
     // we really need very little memory. This should probably be solved by reducing the
@@ -305,14 +296,30 @@
         evictBackingsToReduceMemory(memoryUseBytes() - (wastedMemory - tenPercentOfMemory),
                                     PriorityCalculator::allowEverythingCutoff(),
                                     EvictOnlyRecyclable,
-                                    UnlinkBackings,
+                                    DoNotUnlinkBackings,
                                     resourceProvider);
 }
 
+void PrioritizedResourceManager::reduceMemory(ResourceProvider* resourceProvider)
+{
+    DCHECK(m_proxy->isImplThread() && m_proxy->isMainThreadBlocked());
+    evictBackingsToReduceMemory(m_memoryAvailableBytes,
+                                PriorityCalculator::allowEverythingCutoff(),
+                                EvictAnything,
+                                UnlinkBackings,
+                                resourceProvider);
+    DCHECK(memoryUseBytes() <= m_memoryAvailableBytes);
+
+    reduceWastedMemory(resourceProvider);
+}
+
 void PrioritizedResourceManager::clearAllMemory(ResourceProvider* resourceProvider)
 {
     DCHECK(m_proxy->isImplThread() && m_proxy->isMainThreadBlocked());
-    DCHECK(resourceProvider);
+    if (!resourceProvider) {
+        DCHECK(m_backings.empty());
+        return;
+    }
     evictBackingsToReduceMemory(0,
                                 PriorityCalculator::allowEverythingCutoff(),
                                 EvictAnything,
@@ -335,6 +342,17 @@
                                        resourceProvider);
 }
 
+void PrioritizedResourceManager::reduceWastedMemoryOnImplThread(ResourceProvider* resourceProvider)
+{
+    DCHECK(m_proxy->isImplThread());
+    DCHECK(resourceProvider);
+    // If we are in the process of uploading a new frame then the backings at the very end of
+    // the list are not sorted by priority. Sort them before doing the eviction.
+    if (m_backingsTailNotSorted)
+        sortBackings();
+    reduceWastedMemory(resourceProvider);
+}
+
 void PrioritizedResourceManager::unlinkAndClearEvictedBackings()
 {
     DCHECK(m_proxy->isMainThread());
Index: src/cc/io_surface_draw_quad.h
===================================================================
--- src/cc/io_surface_draw_quad.h	(revision 184497)
+++ src/cc/io_surface_draw_quad.h	(working copy)
@@ -41,6 +41,9 @@
   unsigned io_surface_texture_id;
   Orientation orientation;
 
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources)
+      OVERRIDE;
+
   static const IOSurfaceDrawQuad* MaterialCast(const DrawQuad*);
  private:
   IOSurfaceDrawQuad();
Index: src/cc/keyframed_animation_curve_unittest.cc
===================================================================
--- src/cc/keyframed_animation_curve_unittest.cc	(revision 184497)
+++ src/cc/keyframed_animation_curve_unittest.cc	(working copy)
@@ -4,19 +4,16 @@
 
 #include "cc/keyframed_animation_curve.h"
 
+#include "cc/transform_operations.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include <public/WebTransformOperations.h>
-#include <public/WebTransformationMatrix.h>
 
-using WebKit::WebTransformationMatrix;
-
 namespace cc {
 namespace {
 
-void expectTranslateX(double translateX, const WebTransformationMatrix& matrix)
+void expectTranslateX(double translateX, const gfx::Transform& transform)
 {
-    EXPECT_FLOAT_EQ(translateX, matrix.m41());
+    EXPECT_FLOAT_EQ(translateX, transform.matrix().getDouble(0, 3));
 }
 
 // Tests that a float animation with one keyframe works as expected.
@@ -87,8 +84,8 @@
 TEST(KeyframedAnimationCurveTest, OneTransformKeyframe)
 {
     scoped_ptr<KeyframedTransformAnimationCurve> curve(KeyframedTransformAnimationCurve::create());
-    WebKit::WebTransformOperations operations;
-    operations.appendTranslate(2, 0, 0);
+    TransformOperations operations;
+    operations.AppendTranslate(2, 0, 0);
     curve->addKeyframe(TransformKeyframe::create(0, operations, scoped_ptr<TimingFunction>()));
 
     expectTranslateX(2, curve->getValue(-1));
@@ -102,10 +99,10 @@
 TEST(KeyframedAnimationCurveTest, TwoTransformKeyframe)
 {
     scoped_ptr<KeyframedTransformAnimationCurve> curve(KeyframedTransformAnimationCurve::create());
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(2, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
+    TransformOperations operations1;
+    operations1.AppendTranslate(2, 0, 0);
+    TransformOperations operations2;
+    operations2.AppendTranslate(4, 0, 0);
 
     curve->addKeyframe(TransformKeyframe::create(0, operations1, scoped_ptr<TimingFunction>()));
     curve->addKeyframe(TransformKeyframe::create(1, operations2, scoped_ptr<TimingFunction>()));
@@ -120,12 +117,12 @@
 TEST(KeyframedAnimationCurveTest, ThreeTransformKeyframe)
 {
     scoped_ptr<KeyframedTransformAnimationCurve> curve(KeyframedTransformAnimationCurve::create());
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(2, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations3;
-    operations3.appendTranslate(8, 0, 0);
+    TransformOperations operations1;
+    operations1.AppendTranslate(2, 0, 0);
+    TransformOperations operations2;
+    operations2.AppendTranslate(4, 0, 0);
+    TransformOperations operations3;
+    operations3.AppendTranslate(8, 0, 0);
     curve->addKeyframe(TransformKeyframe::create(0, operations1, scoped_ptr<TimingFunction>()));
     curve->addKeyframe(TransformKeyframe::create(1, operations2, scoped_ptr<TimingFunction>()));
     curve->addKeyframe(TransformKeyframe::create(2, operations3, scoped_ptr<TimingFunction>()));
@@ -143,14 +140,14 @@
 {
     scoped_ptr<KeyframedTransformAnimationCurve> curve(KeyframedTransformAnimationCurve::create());
     // A step function.
-    WebKit::WebTransformOperations operations1;
-    operations1.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations2;
-    operations2.appendTranslate(4, 0, 0);
-    WebKit::WebTransformOperations operations3;
-    operations3.appendTranslate(6, 0, 0);
-    WebKit::WebTransformOperations operations4;
-    operations4.appendTranslate(6, 0, 0);
+    TransformOperations operations1;
+    operations1.AppendTranslate(4, 0, 0);
+    TransformOperations operations2;
+    operations2.AppendTranslate(4, 0, 0);
+    TransformOperations operations3;
+    operations3.AppendTranslate(6, 0, 0);
+    TransformOperations operations4;
+    operations4.AppendTranslate(6, 0, 0);
     curve->addKeyframe(TransformKeyframe::create(0, operations1, scoped_ptr<TimingFunction>()));
     curve->addKeyframe(TransformKeyframe::create(1, operations2, scoped_ptr<TimingFunction>()));
     curve->addKeyframe(TransformKeyframe::create(1, operations3, scoped_ptr<TimingFunction>()));
@@ -161,8 +158,8 @@
     expectTranslateX(4, curve->getValue(0.5));
 
     // There is a discontinuity at 1. Any value between 4 and 6 is valid.
-    WebTransformationMatrix value = curve->getValue(1);
-    EXPECT_TRUE(value.m41() >= 4 && value.m41() <= 6);
+    gfx::Transform value = curve->getValue(1);
+    EXPECT_TRUE(value.matrix().getDouble(0, 3) >= 4 && value.matrix().getDouble(0, 3) <= 6);
 
     expectTranslateX(6, curve->getValue(1.5));
     expectTranslateX(6, curve->getValue(2));
Index: src/cc/layer_tree_host_impl.cc
===================================================================
--- src/cc/layer_tree_host_impl.cc	(revision 184497)
+++ src/cc/layer_tree_host_impl.cc	(working copy)
@@ -9,6 +9,7 @@
 #include "base/basictypes.h"
 #include "base/debug/trace_event.h"
 #include "base/json/json_writer.h"
+#include "base/stl_util.h"
 #include "cc/append_quads_data.h"
 #include "cc/compositor_frame_metadata.h"
 #include "cc/damage_tracker.h"
@@ -23,8 +24,10 @@
 #include "cc/layer_tree_host_common.h"
 #include "cc/layer_tree_impl.h"
 #include "cc/math_util.h"
+#include "cc/memory_history.h"
 #include "cc/overdraw_metrics.h"
 #include "cc/page_scale_animation.h"
+#include "cc/paint_time_counter.h"
 #include "cc/prioritized_resource_manager.h"
 #include "cc/quad_culler.h"
 #include "cc/render_pass_draw_quad.h"
@@ -36,6 +39,8 @@
 #include "cc/software_renderer.h"
 #include "cc/solid_color_draw_quad.h"
 #include "cc/texture_uploader.h"
+#include "cc/top_controls_manager.h"
+#include "cc/tree_synchronizer.h"
 #include "cc/util.h"
 #include "ui/gfx/size_conversions.h"
 #include "ui/gfx/vector2d_conversions.h"
@@ -56,105 +61,6 @@
 
 namespace cc {
 
-PinchZoomViewport::PinchZoomViewport()
-    : m_pageScaleFactor(1)
-    , m_pageScaleDelta(1)
-    , m_sentPageScaleDelta(1)
-    , m_minPageScaleFactor(0)
-    , m_maxPageScaleFactor(0)
-    , m_deviceScaleFactor(1)
-{
-}
-
-float PinchZoomViewport::totalPageScaleFactor() const
-{
-    return m_pageScaleFactor * m_pageScaleDelta;
-}
-
-void PinchZoomViewport::setPageScaleDelta(float delta)
-{
-    // Clamp to the current min/max limits.
-    float totalPageScaleFactor = m_pageScaleFactor * delta;
-    if (m_minPageScaleFactor && totalPageScaleFactor < m_minPageScaleFactor)
-        delta = m_minPageScaleFactor / m_pageScaleFactor;
-    else if (m_maxPageScaleFactor && totalPageScaleFactor > m_maxPageScaleFactor)
-        delta = m_maxPageScaleFactor / m_pageScaleFactor;
-
-    if (delta == m_pageScaleDelta)
-        return;
-
-    m_pageScaleDelta = delta;
-}
-
-bool PinchZoomViewport::setPageScaleFactorAndLimits(float pageScaleFactor, float minPageScaleFactor, float maxPageScaleFactor)
-{
-    DCHECK(pageScaleFactor);
-
-    if (m_sentPageScaleDelta == 1 && pageScaleFactor == m_pageScaleFactor && minPageScaleFactor == m_minPageScaleFactor && maxPageScaleFactor == m_maxPageScaleFactor)
-        return false;
-
-    m_minPageScaleFactor = minPageScaleFactor;
-    m_maxPageScaleFactor = maxPageScaleFactor;
-
-    m_pageScaleFactor = pageScaleFactor;
-    return true;
-}
-
-gfx::RectF PinchZoomViewport::bounds() const
-{
-    gfx::RectF bounds(gfx::PointF(), m_layoutViewportSize);
-    bounds.Scale(1 / totalPageScaleFactor());
-    bounds += m_zoomedViewportOffset;
-    return bounds;
-}
-
-gfx::Vector2dF PinchZoomViewport::applyScroll(const gfx::Vector2dF& delta)
-{
-    gfx::Vector2dF overflow;
-    gfx::RectF pinchedBounds = bounds() + delta;
-
-    if (pinchedBounds.x() < 0) {
-        overflow.set_x(pinchedBounds.x());
-        pinchedBounds.set_x(0);
-    }
-
-    if (pinchedBounds.y() < 0) {
-        overflow.set_y(pinchedBounds.y());
-        pinchedBounds.set_y(0);
-    }
-
-    if (pinchedBounds.right() > m_layoutViewportSize.width()) {
-        overflow.set_x(pinchedBounds.right() - m_layoutViewportSize.width());
-        pinchedBounds += gfx::Vector2dF(m_layoutViewportSize.width() - pinchedBounds.right(), 0);
-    }
-
-    if (pinchedBounds.bottom() > m_layoutViewportSize.height()) {
-        overflow.set_y(pinchedBounds.bottom() - m_layoutViewportSize.height());
-        pinchedBounds += gfx::Vector2dF(0, m_layoutViewportSize.height() - pinchedBounds.bottom());
-    }
-    m_zoomedViewportOffset = pinchedBounds.OffsetFromOrigin();
-
-    return overflow;
-}
-
-gfx::Transform PinchZoomViewport::implTransform(bool pageScalePinchZoomEnabled) const
-{
-    gfx::Transform transform;
-    transform.Scale(m_pageScaleDelta, m_pageScaleDelta);
-
-    // If the pinch state is applied in the impl, then push it to the
-    // impl transform, otherwise the scale is handled by WebCore.
-    if (pageScalePinchZoomEnabled) {
-        transform.Scale(m_pageScaleFactor, m_pageScaleFactor);
-        // The offset needs to be scaled by deviceScaleFactor as this transform
-        // needs to work with physical pixels.
-        gfx::Vector2dF zoomedDeviceViewportOffset = gfx::ScaleVector2d(m_zoomedViewportOffset, m_deviceScaleFactor);
-        transform.Translate(-zoomedDeviceViewportOffset.x(), -zoomedDeviceViewportOffset.y());
-    }
-
-    return transform;
-}
-
 class LayerTreeHostImplTimeSourceAdapter : public TimeSourceClient {
 public:
     static scoped_ptr<LayerTreeHostImplTimeSourceAdapter> create(LayerTreeHostImpl* layerTreeHostImpl, scoped_refptr<DelayBasedTimeSource> timeSource)
@@ -169,7 +75,27 @@
 
     virtual void onTimerTick() OVERRIDE
     {
+        // In single threaded mode we attempt to simulate changing the current
+        // thread by maintaining a fake thread id. When we switch from one
+        // thread to another, we construct DebugScopedSetXXXThread objects that
+        // update the thread id. This lets DCHECKS that ensure we're on the
+        // right thread to work correctly in single threaded mode. The problem
+        // here is that the timer tasks are run via the message loop, and when
+        // they run, we've had no chance to construct a DebugScopedSetXXXThread
+        // object. The result is that we report that we're running on the main
+        // thread. In multi-threaded mode, this timer is run on the compositor
+        // thread, so to keep this consistent in single-threaded mode, we'll
+        // construct a DebugScopedSetImplThread object. There is no need to do
+        // this in multi-threaded mode since the real thread id's will be
+        // correct. In fact, setting fake thread id's interferes with the real
+        // thread id's and causes breakage.
+        scoped_ptr<DebugScopedSetImplThread> setImplThread;
+        if (!m_layerTreeHostImpl->proxy()->hasImplThread())
+            setImplThread.reset(new DebugScopedSetImplThread(m_layerTreeHostImpl->proxy()));
+
+        m_layerTreeHostImpl->activatePendingTreeIfNeeded();
         m_layerTreeHostImpl->animate(base::TimeTicks::Now(), base::Time::Now());
+        m_layerTreeHostImpl->beginNextFrame();
     }
 
     void setActive(bool active)
@@ -193,6 +119,7 @@
 };
 
 LayerTreeHostImpl::FrameData::FrameData()
+    : containsIncompleteTile(false)
 {
 }
 
@@ -208,22 +135,21 @@
 LayerTreeHostImpl::LayerTreeHostImpl(const LayerTreeSettings& settings, LayerTreeHostImplClient* client, Proxy* proxy)
     : m_client(client)
     , m_proxy(proxy)
-    , m_scrollDeltaIsInViewportSpace(false)
+    , m_didLockScrollingLayer(false)
+    , m_shouldBubbleScrolls(false)
+    , m_wheelScrolling(false)
     , m_settings(settings)
     , m_debugState(settings.initialDebugState)
     , m_deviceScaleFactor(1)
     , m_visible(true)
-    , m_contentsTexturesPurged(false)
     , m_managedMemoryPolicy(PrioritizedResourceManager::defaultMemoryAllocationLimit(),
-                            PriorityCalculator::allowEverythingCutoff(),
+                            ManagedMemoryPolicy::CUTOFF_ALLOW_EVERYTHING,
                             0,
-                            PriorityCalculator::allowNothingCutoff())
-    , m_backgroundColor(0)
-    , m_hasTransparentBackground(false)
-    , m_needsAnimateLayers(false)
-    , m_needsUpdateDrawProperties(false)
+                            ManagedMemoryPolicy::CUTOFF_ALLOW_NOTHING)
     , m_pinchGestureActive(false)
     , m_fpsCounter(FrameRateCounter::create(m_proxy->hasImplThread()))
+    , m_paintTimeCounter(PaintTimeCounter::create())
+    , m_memoryHistory(MemoryHistory::create())
     , m_debugRectHistory(DebugRectHistory::create())
     , m_numImplThreadScrolls(0)
     , m_numMainThreadScrolls(0)
@@ -232,12 +158,15 @@
     , m_lastSentMemoryVisibleBytes(0)
     , m_lastSentMemoryVisibleAndNearbyBytes(0)
     , m_lastSentMemoryUseBytes(0)
+    , m_animationRegistrar(AnimationRegistrar::create())
 {
     DCHECK(m_proxy->isImplThread());
     didVisibilityChange(this, m_visible);
 
-    // TODO(nduca): For now, assume we have an active tree. This will be removed
-    // in future patches.
+    if (settings.calculateTopControlsPosition)
+        m_topControlsManager = TopControlsManager::Create(this, settings.topControlsHeightPx);
+
+    // LTHI always has an active tree.
     m_activeTree = LayerTreeImpl::create(this);
 }
 
@@ -246,8 +175,15 @@
     DCHECK(m_proxy->isImplThread());
     TRACE_EVENT0("cc", "LayerTreeHostImpl::~LayerTreeHostImpl()");
 
-    if (rootLayer())
+    if (rootLayer()) {
         clearRenderSurfaces();
+        // The layer trees must be destroyed before the layer tree host. We've
+        // made a contract with our animation controllers that the registrar
+        // will outlive them, and we must make good.
+        m_recycleTree.reset();
+        m_pendingTree.reset();
+        m_activeTree.reset();
+    }
 }
 
 void LayerTreeHostImpl::beginCommit()
@@ -261,13 +197,13 @@
     // Impl-side painting needs an update immediately post-commit to have the
     // opportunity to create tilings.  Other paths can call updateDrawProperties
     // more lazily when needed prior to drawing.
-    setNeedsUpdateDrawProperties();
-    if (m_settings.implSidePainting)
-        updateDrawProperties();
+    if (m_settings.implSidePainting) {
+        pendingTree()->set_needs_update_draw_properties();
+        pendingTree()->UpdateDrawProperties(LayerTreeImpl::UPDATE_PENDING_TREE);
+    } else {
+        activeTree()->set_needs_update_draw_properties();
+    }
 
-    // Recompute max scroll position; must be after layer content bounds are
-    // updated.
-    updateMaxScrollOffset();
     m_client->sendManagedMemoryStats();
 }
 
@@ -285,11 +221,15 @@
         TRACE_EVENT_INSTANT0("cc", "LayerTreeHostImpl::canDraw empty viewport");
         return false;
     }
+    if (m_activeTree->ViewportSizeInvalid()) {
+        TRACE_EVENT_INSTANT0("cc", "LayerTreeHostImpl::canDraw viewport size recently changed");
+        return false;
+    }
     if (!m_renderer) {
         TRACE_EVENT_INSTANT0("cc", "LayerTreeHostImpl::canDraw no renderer");
         return false;
     }
-    if (m_contentsTexturesPurged) {
+    if (m_activeTree->ContentsTexturesPurged()) {
         TRACE_EVENT_INSTANT0("cc", "LayerTreeHostImpl::canDraw contents textures purged");
         return false;
     }
@@ -306,12 +246,24 @@
     animatePageScale(monotonicTime);
     animateLayers(monotonicTime, wallClockTime);
     animateScrollbars(monotonicTime);
+    if (m_topControlsManager)
+        m_topControlsManager->Animate(monotonicTime);
 }
 
 void LayerTreeHostImpl::manageTiles()
 {
     DCHECK(m_tileManager);
     m_tileManager->ManageTiles();
+
+    size_t memoryRequiredBytes;
+    size_t memoryNiceToHaveBytes;
+    size_t memoryUsedBytes;
+    m_tileManager->GetMemoryStats(&memoryRequiredBytes,
+                                  &memoryNiceToHaveBytes,
+                                  &memoryUsedBytes);
+    sendManagedMemoryStats(memoryRequiredBytes,
+                           memoryNiceToHaveBytes,
+                           memoryUsedBytes);
 }
 
 void LayerTreeHostImpl::startPageScaleAnimation(gfx::Vector2d targetOffset, bool anchorPoint, float pageScale, base::TimeTicks startTime, base::TimeDelta duration)
@@ -320,15 +272,15 @@
         return;
 
     gfx::Vector2dF scrollTotal = rootScrollLayer()->scrollOffset() + rootScrollLayer()->scrollDelta();
-    gfx::SizeF scaledContentSize = contentSize();
+    gfx::SizeF scaledScrollableSize = activeTree()->ScrollableSize();
     if (!m_settings.pageScalePinchZoomEnabled) {
-        scrollTotal.Scale(1 / m_pinchZoomViewport.pageScaleFactor());
-        scaledContentSize.Scale(1 / m_pinchZoomViewport.pageScaleFactor());
+        scrollTotal.Scale(1 / activeTree()->page_scale_factor());
+        scaledScrollableSize.Scale(1 / activeTree()->page_scale_factor());
     }
     gfx::SizeF viewportSize = gfx::ScaleSize(m_deviceViewportSize, 1 / m_deviceScaleFactor);
 
     double startTimeSeconds = (startTime - base::TimeTicks()).InSecondsF();
-    m_pageScaleAnimation = PageScaleAnimation::create(scrollTotal, m_pinchZoomViewport.totalPageScaleFactor(), viewportSize, scaledContentSize, startTimeSeconds);
+    m_pageScaleAnimation = PageScaleAnimation::create(scrollTotal, activeTree()->total_page_scale_factor(), viewportSize, scaledScrollableSize, startTimeSeconds);
 
     if (anchorPoint) {
         gfx::Vector2dF anchor(targetOffset);
@@ -342,7 +294,6 @@
         m_pageScaleAnimation->zoomTo(scaledTargetOffset, pageScale, duration.InSecondsF());
     }
 
-    setNeedsUpdateDrawProperties();
     m_client->setNeedsRedrawOnImplThread();
     m_client->setNeedsCommitOnImplThread();
 }
@@ -361,7 +312,7 @@
 
     // First find out which layer was hit from the saved list of visible layers
     // in the most recent frame.
-    LayerImpl* layerImpl = LayerTreeHostCommon::findLayerThatIsHitByPoint(deviceViewportPoint, m_renderSurfaceLayerList);
+    LayerImpl* layerImpl = LayerTreeHostCommon::findLayerThatIsHitByPoint(deviceViewportPoint, activeTree()->RenderSurfaceLayerList());
 
     // Walk up the hierarchy and look for a layer with a touch event handler region that the given point hits.
     for (; layerImpl; layerImpl = layerImpl->parent()) {
@@ -386,46 +337,10 @@
     }
 }
 
-void LayerTreeHostImpl::updateRootScrollLayerImplTransform()
-{
-    if (rootScrollLayer()) {
-        rootScrollLayer()->setImplTransform(implTransform());
-    }
-}
-
-void LayerTreeHostImpl::updateDrawProperties()
-{
-    if (!needsUpdateDrawProperties())
-        return;
-
-    m_renderSurfaceLayerList.clear();
-    m_needsUpdateDrawProperties = false;
-
-    if (!rootLayer())
-        return;
-
-    calculateRenderSurfaceLayerList(m_renderSurfaceLayerList);
-}
-
-void LayerTreeHostImpl::calculateRenderSurfaceLayerList(LayerList& renderSurfaceLayerList)
-{
-    DCHECK(renderSurfaceLayerList.empty());
-    DCHECK(rootLayer());
-    DCHECK(m_renderer); // For maxTextureSize.
-    {
-        updateRootScrollLayerImplTransform();
-
-        TRACE_EVENT0("cc", "LayerTreeHostImpl::calcDrawEtc");
-        float pageScaleFactor = m_pinchZoomViewport.pageScaleFactor();
-        LayerTreeHostCommon::calculateDrawProperties(rootLayer(), deviceViewportSize(), m_deviceScaleFactor, pageScaleFactor, rendererCapabilities().maxTextureSize, m_settings.canUseLCDText, renderSurfaceLayerList);
-    }
-}
-
 void LayerTreeHostImpl::FrameData::appendRenderPass(scoped_ptr<RenderPass> renderPass)
 {
-    RenderPass* pass = renderPass.get();
-    renderPasses.push_back(pass);
-    renderPassesById.set(pass->id, renderPass.Pass());
+    renderPassesById[renderPass->id] = renderPass.get();
+    renderPasses.push_back(renderPass.Pass());
 }
 
 static void appendQuadsForLayer(RenderPass* targetRenderPass, LayerImpl* layer, OcclusionTrackerImpl& occlusionTracker, AppendQuadsData& appendQuadsData)
@@ -493,7 +408,6 @@
     sharedQuadState->SetAll(rootLayer->drawTransform(),
                             rootTargetRect,
                             rootTargetRect,
-                            rootTargetRect,
                             false,
                             opacity);
 
@@ -518,7 +432,9 @@
 {
     DCHECK(frame.renderPasses.empty());
 
-    updateDrawProperties();
+    if (!canDraw() || !rootLayer())
+      return false;
+
     trackDamageForAllSurfaces(rootLayer(), *frame.renderSurfaceLayerList);
 
     TRACE_EVENT1("cc", "LayerTreeHostImpl::calculateRenderPasses", "renderSurfaceLayerList.size()", static_cast<long long unsigned>(frame.renderSurfaceLayerList->size()));
@@ -549,7 +465,7 @@
     LayerIteratorType end = LayerIteratorType::end(frame.renderSurfaceLayerList);
     for (LayerIteratorType it = LayerIteratorType::begin(frame.renderSurfaceLayerList); it != end; ++it) {
         RenderPass::Id targetRenderPassId = it.targetRenderSurfaceLayer()->renderSurface()->renderPassId();
-        RenderPass* targetRenderPass = frame.renderPassesById.get(targetRenderPassId);
+        RenderPass* targetRenderPass = frame.renderPassesById[targetRenderPassId];
 
         occlusionTracker.enterLayer(it);
 
@@ -557,22 +473,22 @@
 
         if (it.representsContributingRenderSurface()) {
             RenderPass::Id contributingRenderPassId = it->renderSurface()->renderPassId();
-            RenderPass* contributingRenderPass = frame.renderPassesById.get(contributingRenderPassId);
+            RenderPass* contributingRenderPass = frame.renderPassesById[contributingRenderPassId];
             appendQuadsForRenderSurfaceLayer(targetRenderPass, *it, contributingRenderPass, occlusionTracker, appendQuadsData);
         } else if (it.representsItself() && !it->visibleContentRect().IsEmpty()) {
             bool hasOcclusionFromOutsideTargetSurface;
             bool implDrawTransformIsUnknown = false;
-            if (occlusionTracker.occluded(it->renderTarget(), it->visibleContentRect(), it->drawTransform(), implDrawTransformIsUnknown, it->drawableContentRect(), &hasOcclusionFromOutsideTargetSurface))
+            if (occlusionTracker.occluded(it->renderTarget(), it->visibleContentRect(), it->drawTransform(), implDrawTransformIsUnknown, it->isClipped(), it->clipRect(), &hasOcclusionFromOutsideTargetSurface))
                 appendQuadsData.hadOcclusionFromOutsideTargetSurface |= hasOcclusionFromOutsideTargetSurface;
             else {
-                DCHECK_EQ(this->activeTree(), it->layerTreeImpl());
+                DCHECK_EQ(activeTree(), it->layerTreeImpl());
                 it->willDraw(m_resourceProvider.get());
                 frame.willDrawLayers.push_back(*it);
 
                 if (it->hasContributingDelegatedRenderPasses()) {
                     RenderPass::Id contributingRenderPassId = it->firstContributingRenderPassId();
-                    while (frame.renderPassesById.contains(contributingRenderPassId)) {
-                        RenderPass* renderPass = frame.renderPassesById.get(contributingRenderPassId);
+                    while (frame.renderPassesById.find(contributingRenderPassId) != frame.renderPassesById.end()) {
+                        RenderPass* renderPass = frame.renderPassesById[contributingRenderPassId];
   
                         AppendQuadsData appendQuadsData(renderPass->id);
                         appendQuadsForLayer(renderPass, *it, occlusionTracker, appendQuadsData);
@@ -597,6 +513,9 @@
                 drawFrame = false;
         }
 
+        if (appendQuadsData.hadIncompleteTile) 
+            frame.containsIncompleteTile = true;
+
         occlusionTracker.leaveLayer(it);
     }
 
@@ -604,13 +523,15 @@
     for (size_t i = 0; i < frame.renderPasses.size(); ++i) {
         for (size_t j = 0; j < frame.renderPasses[i]->quad_list.size(); ++j)
             DCHECK(frame.renderPasses[i]->quad_list[j]->shared_quad_state);
-        DCHECK(frame.renderPassesById.contains(frame.renderPasses[i]->id));
+        DCHECK(frame.renderPassesById.find(frame.renderPasses[i]->id)
+               != frame.renderPassesById.end());
     }
 #endif
+    DCHECK(frame.renderPasses.back()->output_rect.origin().IsOrigin());
 
-    if (!m_hasTransparentBackground) {
+    if (!activeTree()->has_transparent_background()) {
         frame.renderPasses.back()->has_transparent_background = false;
-        appendQuadsToFillScreen(frame.renderPasses.back(), rootLayer(), m_backgroundColor, occlusionTracker);
+        appendQuadsToFillScreen(frame.renderPasses.back(), rootLayer(), activeTree()->background_color(), occlusionTracker);
     }
 
     if (drawFrame)
@@ -623,35 +544,6 @@
     return drawFrame;
 }
 
-void LayerTreeHostImpl::animateLayersRecursive(LayerImpl* current, base::TimeTicks monotonicTime, base::Time wallClockTime, AnimationEventsVector* events, bool& didAnimate, bool& needsAnimateLayers)
-{
-    bool subtreeNeedsAnimateLayers = false;
-
-    LayerAnimationController* currentController = current->layerAnimationController();
-
-    bool hadActiveAnimation = currentController->hasActiveAnimation();
-    double monotonicTimeSeconds = (monotonicTime - base::TimeTicks()).InSecondsF();
-    currentController->animate(monotonicTimeSeconds, events);
-    bool startedAnimation = events->size() > 0;
-
-    // We animated if we either ticked a running animation, or started a new animation.
-    if (hadActiveAnimation || startedAnimation)
-        didAnimate = true;
-
-    // If the current controller still has an active animation, we must continue animating layers.
-    if (currentController->hasActiveAnimation())
-         subtreeNeedsAnimateLayers = true;
-
-    for (size_t i = 0; i < current->children().size(); ++i) {
-        bool childNeedsAnimateLayers = false;
-        animateLayersRecursive(current->children()[i], monotonicTime, wallClockTime, events, didAnimate, childNeedsAnimateLayers);
-        if (childNeedsAnimateLayers)
-            subtreeNeedsAnimateLayers = true;
-    }
-
-    needsAnimateLayers = subtreeNeedsAnimateLayers;
-}
-
 void LayerTreeHostImpl::setBackgroundTickingEnabled(bool enabled)
 {
     // Lazily create the timeSource adapter so that we can vary the interval for testing.
@@ -661,34 +553,26 @@
     m_timeSourceClientAdapter->setActive(enabled);
 }
 
-gfx::Size LayerTreeHostImpl::contentSize() const
-{
-    // TODO(aelias): Hardcoding the first child here is weird. Think of
-    // a cleaner way to get the contentBounds on the Impl side.
-    if (!rootScrollLayer() || rootScrollLayer()->children().isEmpty())
-        return gfx::Size();
-    return rootScrollLayer()->children()[0]->contentBounds();
-}
-
 static inline RenderPass* findRenderPassById(RenderPass::Id renderPassId, const LayerTreeHostImpl::FrameData& frame)
 {
     RenderPassIdHashMap::const_iterator it = frame.renderPassesById.find(renderPassId);
-    DCHECK(it != frame.renderPassesById.end());
-    return it->second;
+    return it != frame.renderPassesById.end() ? it->second : NULL;
 }
 
 static void removeRenderPassesRecursive(RenderPass::Id removeRenderPassId, LayerTreeHostImpl::FrameData& frame)
 {
     RenderPass* removeRenderPass = findRenderPassById(removeRenderPassId, frame);
+    // The pass was already removed by another quad - probably the original, and we are the replica.
+    if (!removeRenderPass)
+        return;
     RenderPassList& renderPasses = frame.renderPasses;
     RenderPassList::iterator toRemove = std::find(renderPasses.begin(), renderPasses.end(), removeRenderPass);
 
-    // The pass was already removed by another quad - probably the original, and we are the replica.
-    if (toRemove == renderPasses.end())
-        return;
+    DCHECK(toRemove != renderPasses.end());
 
-    const RenderPass* removedPass = *toRemove;
+    scoped_ptr<RenderPass> removedPass = renderPasses.take(toRemove);
     frame.renderPasses.erase(toRemove);
+    frame.renderPassesById.erase(removeRenderPassId);
 
     // Now follow up for all RenderPass quads and remove their RenderPasses recursively.
     const QuadList& quadList = removedPass->quad_list;
@@ -719,15 +603,11 @@
 bool LayerTreeHostImpl::CullRenderPassesWithNoQuads::shouldRemoveRenderPass(const RenderPassDrawQuad& quad, const FrameData& frame) const
 {
     const RenderPass* renderPass = findRenderPassById(quad.render_pass_id, frame);
-    const RenderPassList& renderPasses = frame.renderPasses;
-    RenderPassList::const_iterator foundPass = std::find(renderPasses.begin(), renderPasses.end(), renderPass);
-
-    bool renderPassAlreadyRemoved = foundPass == renderPasses.end();
-    if (renderPassAlreadyRemoved)
+    if (!renderPass)
         return false;
 
     // If any quad or RenderPass draws into this RenderPass, then keep it.
-    const QuadList& quadList = (*foundPass)->quad_list;
+    const QuadList& quadList = renderPass->quad_list;
     for (QuadList::constBackToFrontIterator quadListIterator = quadList.backToFrontBegin(); quadListIterator != quadList.backToFrontEnd(); ++quadListIterator) {
         DrawQuad* currentQuad = *quadListIterator;
 
@@ -735,8 +615,7 @@
             return false;
 
         const RenderPass* contributingPass = findRenderPassById(RenderPassDrawQuad::MaterialCast(currentQuad)->render_pass_id, frame);
-        RenderPassList::const_iterator foundContributingPass = std::find(renderPasses.begin(), renderPasses.end(), contributingPass);
-        if (foundContributingPass != renderPasses.end())
+        if (contributingPass)
             return false;
     }
     return true;
@@ -781,12 +660,12 @@
 bool LayerTreeHostImpl::prepareToDraw(FrameData& frame)
 {
     TRACE_EVENT0("cc", "LayerTreeHostImpl::prepareToDraw");
-    DCHECK(canDraw());
 
-    if (m_tileManager)
-        m_tileManager->CheckForCompletedSetPixels();
+    if (m_topControlsManager)
+        m_topControlsManager->UpdateDrawPositions();
+    activeTree()->UpdateDrawProperties(LayerTreeImpl::UPDATE_ACTIVE_TREE_FOR_DRAW);
 
-    frame.renderSurfaceLayerList = &m_renderSurfaceLayerList;
+    frame.renderSurfaceLayerList = &activeTree()->RenderSurfaceLayerList();
     frame.renderPasses.clear();
     frame.renderPassesById.clear();
     frame.willDrawLayers.clear();
@@ -802,20 +681,23 @@
 {
     bool evictedResources = m_client->reduceContentsTextureMemoryOnImplThread(
         m_visible ? policy.bytesLimitWhenVisible : policy.bytesLimitWhenNotVisible,
-        m_visible ? policy.priorityCutoffWhenVisible : policy.priorityCutoffWhenNotVisible);
+        ManagedMemoryPolicy::priorityCutoffToValue(
+            m_visible ? policy.priorityCutoffWhenVisible : policy.priorityCutoffWhenNotVisible));
     if (evictedResources) {
-        setContentsTexturesPurged();
+        activeTree()->SetContentsTexturesPurged();
+        if (pendingTree())
+            pendingTree()->SetContentsTexturesPurged();
         m_client->setNeedsCommitOnImplThread();
         m_client->onCanDrawStateChanged(canDraw());
+        m_client->renewTreePriority();
     }
     m_client->sendManagedMemoryStats();
 
     if (m_tileManager) {
-      // TODO(nduca): Pass something useful into the memory manager.
-      LOG(INFO) << "Setting up initial tile manager policy";
       GlobalStateThatImpactsTilePriority new_state(m_tileManager->GlobalState());
-      new_state.memory_limit_in_bytes = PrioritizedResourceManager::defaultMemoryAllocationLimit();
-      new_state.memory_limit_policy = ALLOW_ANYTHING;
+      new_state.memory_limit_in_bytes = m_visible ? policy.bytesLimitWhenVisible : policy.bytesLimitWhenNotVisible;
+      new_state.memory_limit_policy = ManagedMemoryPolicy::priorityCutoffToTileMemoryLimitPolicy(
+          m_visible ? policy.priorityCutoffWhenVisible : policy.priorityCutoffWhenNotVisible);
       m_tileManager->SetGlobalState(new_state);
     }
 }
@@ -831,14 +713,10 @@
       m_client->setNeedsManageTilesOnImplThread();
 }
 
-void LayerTreeHostImpl::ScheduleCheckForCompletedSetPixels()
+void LayerTreeHostImpl::DidUploadVisibleHighResolutionTile()
 {
-    // CheckForCompletedSetPixels() should be called before we draw and
-    // preferably only once per vsync interval. For now just make sure
-    // a redraw is scheduled and call CheckForCompletedSetPixels() in
-    // prepareToDraw().
     if (m_client)
-      m_client->setNeedsRedrawOnImplThread();
+        m_client->didUploadVisibleHighResolutionTileOnImplThread();
 }
 
 bool LayerTreeHostImpl::shouldClearRootRenderPass() const
@@ -887,20 +765,23 @@
 
 CompositorFrameMetadata LayerTreeHostImpl::makeCompositorFrameMetadata() const
 {
+    CompositorFrameMetadata metadata;
+    metadata.page_scale_factor = activeTree()->total_page_scale_factor();
+    metadata.viewport_size = activeTree()->ScrollableViewportSize();
+    metadata.root_layer_size = activeTree()->ScrollableSize();
+    metadata.min_page_scale_factor = activeTree()->min_page_scale_factor();
+    metadata.max_page_scale_factor = activeTree()->max_page_scale_factor();
+    if (m_topControlsManager) {
+        metadata.location_bar_offset = gfx::Vector2dF(0.f, m_topControlsManager->controls_top_offset());
+        metadata.location_bar_content_translation = gfx::Vector2dF(0.f, m_topControlsManager->content_top_offset());
+    }
+
     if (!rootScrollLayer())
-        return CompositorFrameMetadata();
+      return metadata;
 
-    CompositorFrameMetadata metadata;
     metadata.root_scroll_offset = rootScrollLayer()->scrollOffset() + rootScrollLayer()->scrollDelta();
-    metadata.page_scale_factor = m_pinchZoomViewport.totalPageScaleFactor();
-    metadata.viewport_size = m_pinchZoomViewport.bounds().size();
-    metadata.root_layer_size = rootScrollLayer()->bounds();
-    metadata.min_page_scale_factor = m_pinchZoomViewport.minPageScaleFactor();
-    metadata.max_page_scale_factor = m_pinchZoomViewport.maxPageScaleFactor();
-    if (!m_settings.pageScalePinchZoomEnabled) {
-        metadata.root_scroll_offset.Scale(1 / m_pinchZoomViewport.pageScaleFactor());
-        metadata.root_layer_size.Scale(1 / m_pinchZoomViewport.pageScaleFactor());
-    }
+    if (!m_settings.pageScalePinchZoomEnabled)
+        metadata.root_scroll_offset.Scale(1 / activeTree()->page_scale_factor());
 
     return metadata;
 }
@@ -914,8 +795,13 @@
     // FIXME: use the frame begin time from the overall compositor scheduler.
     // This value is currently inaccessible because it is up in Chromium's
     // RenderWidget.
-    m_fpsCounter->markBeginningOfFrame(base::TimeTicks::Now());
+    m_fpsCounter->saveTimeStamp(base::TimeTicks::Now());
 
+    if (m_tileManager) {
+        m_memoryHistory->SaveEntry(
+            m_tileManager->memory_stats_from_last_assign());
+    }
+
     if (m_debugState.showHudRects())
         m_debugRectHistory->saveDebugRectsForCurrentFrame(rootLayer(), *frame.renderSurfaceLayerList, frame.occludingScreenSpaceRects, frame.nonOccludingScreenSpaceRects, m_debugState);
 
@@ -924,11 +810,10 @@
     if (m_activeTree->hud_layer())
         m_activeTree->hud_layer()->updateHudTexture(m_resourceProvider.get());
 
-    m_renderer->drawFrame(frame.renderPasses, frame.renderPassesById);
-
+    m_renderer->drawFrame(frame.renderPasses);
     // The render passes should be consumed by the renderer.
     DCHECK(frame.renderPasses.empty());
-    DCHECK(frame.renderPassesById.empty());
+    frame.renderPassesById.clear();
 
     // The next frame should start by assuming nothing has changed, and changes are noted as they occur.
     for (unsigned int i = 0; i < frame.renderSurfaceLayerList->size(); i++)
@@ -954,6 +839,7 @@
 
 bool LayerTreeHostImpl::isContextLost()
 {
+    DCHECK(m_proxy->isImplThread());
     return m_renderer && m_renderer->isContextLost();
 }
 
@@ -964,9 +850,6 @@
 
 bool LayerTreeHostImpl::swapBuffers()
 {
-    DCHECK(m_renderer);
-
-    m_fpsCounter->markEndOfFrame();
     return m_renderer->swapBuffers();
 }
 
@@ -996,6 +879,16 @@
     m_renderer->getFramebufferPixels(pixels, rect);
 }
 
+bool LayerTreeHostImpl::haveRootScrollLayer() const {
+  return rootScrollLayer();
+}
+
+float LayerTreeHostImpl::rootScrollLayerTotalScrollY() const {
+  if (LayerImpl* layer = rootScrollLayer())
+    return layer->scrollOffset().y() + layer->scrollDelta().y();
+  return 0.0f;
+}
+
 LayerImpl* LayerTreeHostImpl::rootLayer() const
 {
   return m_activeTree->RootLayer();
@@ -1003,12 +896,12 @@
 
 LayerImpl* LayerTreeHostImpl::rootScrollLayer() const
 {
-  return m_activeTree->root_scroll_layer();
+  return m_activeTree->RootScrollLayer();
 }
 
 LayerImpl* LayerTreeHostImpl::currentlyScrollingLayer() const
 {
-  return m_activeTree->currently_scrolling_layer();
+  return m_activeTree->CurrentlyScrollingLayer();
 }
 
 // Content layers can be either directly scrollable or contained in an outer
@@ -1028,20 +921,106 @@
     return 0;
 }
 
-void LayerTreeHostImpl::setRootLayer(scoped_ptr<LayerImpl> layer)
+void LayerTreeHostImpl::createPendingTree()
 {
-    m_activeTree->SetRootLayer(layer.Pass());
-    setNeedsUpdateDrawProperties();
+    CHECK(!m_pendingTree);
+    if (m_recycleTree)
+        m_recycleTree.swap(m_pendingTree);
+    else
+        m_pendingTree = LayerTreeImpl::create(this);
+    m_client->onCanDrawStateChanged(canDraw());
+    m_client->onHasPendingTreeStateChanged(pendingTree());
+    TRACE_EVENT_ASYNC_BEGIN0("cc", "PendingTree", m_pendingTree.get());
 }
 
-scoped_ptr<LayerImpl> LayerTreeHostImpl::detachLayerTree()
+void LayerTreeHostImpl::checkForCompletedTileUploads()
 {
-    scoped_ptr<LayerImpl> layer = m_activeTree->DetachLayerTree();
-    m_renderSurfaceLayerList.clear();
-    setNeedsUpdateDrawProperties();
-    return layer.Pass();
+    DCHECK(!m_client->isInsideDraw()) << "Checking for completed uploads within a draw may trigger spurious redraws.";
+    if (m_tileManager)
+        m_tileManager->CheckForCompletedTileUploads();
 }
 
+scoped_ptr<base::Value> LayerTreeHostImpl::activationStateAsValue() const
+{
+    scoped_ptr<base::DictionaryValue> state(new base::DictionaryValue());
+    state->SetBoolean("visible_resources_ready", pendingTree()->AreVisibleResourcesReady());
+    state->Set("tile_manager", m_tileManager->AsValue().release());
+    return state.PassAs<base::Value>();
+}
+
+namespace {
+
+std::string ValueToString(scoped_ptr<base::Value> value)
+{
+    std::string str;
+    base::JSONWriter::Write(value.get(), &str);
+    return str;
+}
+
+}
+
+void LayerTreeHostImpl::activatePendingTreeIfNeeded()
+{
+    if (!pendingTree())
+        return;
+
+    CHECK(m_tileManager);
+
+    pendingTree()->UpdateDrawProperties(LayerTreeImpl::UPDATE_PENDING_TREE);
+
+    TRACE_EVENT_ASYNC_STEP1("cc",
+                            "PendingTree", m_pendingTree.get(), "activate",
+                            "state", ValueToString(activationStateAsValue()));
+
+    // It's always fine to activate to an empty tree.  Otherwise, only
+    // activate once all visible resources in pending tree are ready
+    // or tile manager has no work scheduled for pending tree.
+    if (activeTree()->RootLayer() &&
+        !pendingTree()->AreVisibleResourcesReady()) {
+        // In smoothness takes priority mode, the pending tree's priorities are
+        // ignored, so the tile manager may not have work for it even though it
+        // is simultaneously not ready to be activated.
+        if (m_tileManager->GlobalState().tree_priority ==
+            SMOOTHNESS_TAKES_PRIORITY ||
+            m_tileManager->HasPendingWorkScheduled(PENDING_TREE)) {
+            return;
+        }
+    }
+
+    activatePendingTree();
+}
+
+void LayerTreeHostImpl::activatePendingTree()
+{
+    CHECK(m_pendingTree);
+    TRACE_EVENT_ASYNC_END0("cc", "PendingTree", m_pendingTree.get());
+
+    m_activeTree->PushPersistedState(m_pendingTree.get());
+    if (m_pendingTree->needs_full_tree_sync())
+        m_activeTree->SetRootLayer(TreeSynchronizer::synchronizeTrees(m_pendingTree->RootLayer(), m_activeTree->DetachLayerTree(), m_activeTree.get()));
+    TreeSynchronizer::pushProperties(m_pendingTree->RootLayer(), m_activeTree->RootLayer());
+    DCHECK(!m_recycleTree);
+
+    m_pendingTree->pushPropertiesTo(m_activeTree.get());
+
+    // Now that we've synced everything from the pending tree to the active
+    // tree, rename the pending tree the recycle tree so we can reuse it on the
+    // next sync.
+    m_pendingTree.swap(m_recycleTree);
+    m_recycleTree->ClearRenderSurfaces();
+
+    m_activeTree->DidBecomeActive();
+
+    // Reduce wasted memory now that unlinked resources are guaranteed not
+    // to be used.
+    m_client->reduceWastedContentsTextureMemoryOnImplThread();
+
+    m_client->onCanDrawStateChanged(canDraw());
+    m_client->onHasPendingTreeStateChanged(pendingTree());
+    m_client->setNeedsRedrawOnImplThread();
+    m_client->renewTreePriority();
+}
+
 void LayerTreeHostImpl::setVisible(bool visible)
 {
     DCHECK(m_proxy->isImplThread());
@@ -1057,7 +1036,7 @@
 
     m_renderer->setVisible(visible);
 
-    setBackgroundTickingEnabled(!m_visible && m_needsAnimateLayers);
+    setBackgroundTickingEnabled(!m_visible && !m_animationRegistrar->active_animation_controllers().empty());
 }
 
 bool LayerTreeHostImpl::initializeRenderer(scoped_ptr<OutputSurface> outputSurface)
@@ -1065,10 +1044,15 @@
     // Since we will create a new resource provider, we cannot continue to use
     // the old resources (i.e. renderSurfaces and texture IDs). Clear them
     // before we destroy the old resource provider.
-    if (rootLayer()) {
+    if (rootLayer())
         clearRenderSurfaces();
-        sendDidLoseOutputSurfaceRecursive(rootLayer());
-    }
+    if (activeTree()->RootLayer())
+        sendDidLoseOutputSurfaceRecursive(activeTree()->RootLayer());
+    if (pendingTree() && pendingTree()->RootLayer())
+        sendDidLoseOutputSurfaceRecursive(pendingTree()->RootLayer());
+    if (m_recycleTree && m_recycleTree->RootLayer())
+        sendDidLoseOutputSurfaceRecursive(m_recycleTree->RootLayer());
+
     // Note: order is important here.
     m_renderer.reset();
     m_tileManager.reset();
@@ -1086,7 +1070,7 @@
       m_tileManager.reset(new TileManager(this, resourceProvider.get(), m_settings.numRasterThreads));
 
     if (outputSurface->Capabilities().has_parent_compositor)
-        m_renderer = DelegatingRenderer::Create(this, resourceProvider.get());
+        m_renderer = DelegatingRenderer::Create(this, outputSurface.get(), resourceProvider.get());
     else if (outputSurface->Context3D())
         m_renderer = GLRenderer::create(this, outputSurface.get(), resourceProvider.get());
     else if (outputSurface->SoftwareDevice())
@@ -1102,31 +1086,26 @@
 
     m_client->onCanDrawStateChanged(canDraw());
 
+    // See note in LayerTreeImpl::UpdateDrawProperties.  Renderer needs
+    // to be initialized to get max texture size.
+    activeTree()->set_needs_update_draw_properties();
+    if (pendingTree())
+        pendingTree()->set_needs_update_draw_properties();
+
     return true;
 }
 
-void LayerTreeHostImpl::setContentsTexturesPurged()
-{
-    m_contentsTexturesPurged = true;
-    m_client->onCanDrawStateChanged(canDraw());
-}
-
-void LayerTreeHostImpl::resetContentsTexturesPurged()
-{
-    m_contentsTexturesPurged = false;
-    m_client->onCanDrawStateChanged(canDraw());
-}
-
 void LayerTreeHostImpl::setViewportSize(const gfx::Size& layoutViewportSize, const gfx::Size& deviceViewportSize)
 {
     if (layoutViewportSize == m_layoutViewportSize && deviceViewportSize == m_deviceViewportSize)
         return;
 
+    if (pendingTree() && m_deviceViewportSize != deviceViewportSize)
+        activeTree()->SetViewportSizeInvalid();
+
     m_layoutViewportSize = layoutViewportSize;
     m_deviceViewportSize = deviceViewportSize;
 
-    m_pinchZoomViewport.setLayoutViewportSize(layoutViewportSize);
-
     updateMaxScrollOffset();
 
     if (m_renderer)
@@ -1156,73 +1135,20 @@
     if (deviceScaleFactor == m_deviceScaleFactor)
         return;
     m_deviceScaleFactor = deviceScaleFactor;
-    m_pinchZoomViewport.setDeviceScaleFactor(m_deviceScaleFactor);
 
     updateMaxScrollOffset();
 }
 
-float LayerTreeHostImpl::pageScaleFactor() const
+void LayerTreeHostImpl::updateMaxScrollOffset()
 {
-    return m_pinchZoomViewport.pageScaleFactor();
+    activeTree()->UpdateMaxScrollOffset();
 }
 
-void LayerTreeHostImpl::setPageScaleFactorAndLimits(float pageScaleFactor, float minPageScaleFactor, float maxPageScaleFactor)
+void LayerTreeHostImpl::setActiveTreeNeedsUpdateDrawProperties()
 {
-    if (!pageScaleFactor)
-      return;
-
-    float pageScaleChange = pageScaleFactor / m_pinchZoomViewport.pageScaleFactor();
-    m_pinchZoomViewport.setPageScaleFactorAndLimits(pageScaleFactor, minPageScaleFactor, maxPageScaleFactor);
-
-    if (!m_settings.pageScalePinchZoomEnabled && pageScaleChange != 1)
-        adjustScrollsForPageScaleChange(rootScrollLayer(), pageScaleChange);
-
-    // Clamp delta to limits and refresh display matrix.
-    setPageScaleDelta(m_pinchZoomViewport.pageScaleDelta() / m_pinchZoomViewport.sentPageScaleDelta());
-    m_pinchZoomViewport.setSentPageScaleDelta(1);
+    activeTree()->set_needs_update_draw_properties();
 }
 
-void LayerTreeHostImpl::setPageScaleDelta(float delta)
-{
-    m_pinchZoomViewport.setPageScaleDelta(delta);
-
-    updateMaxScrollOffset();
-}
-
-void LayerTreeHostImpl::updateMaxScrollOffset()
-{
-    if (!rootScrollLayer() || !rootScrollLayer()->children().size())
-        return;
-
-    gfx::SizeF viewBounds = m_deviceViewportSize;
-    if (LayerImpl* clipLayer = rootScrollLayer()->parent()) {
-        // Compensate for non-overlay scrollbars.
-        if (clipLayer->masksToBounds())
-            viewBounds = gfx::ScaleSize(clipLayer->bounds(), m_deviceScaleFactor);
-    }
-
-    gfx::Size contentBounds = contentSize();
-    if (m_settings.pageScalePinchZoomEnabled) {
-        // Pinch with pageScale scrolls entirely in layout space.  contentSize
-        // returns the bounds including the page scale factor, so calculate the
-        // pre page-scale layout size here.
-        float pageScaleFactor = m_pinchZoomViewport.pageScaleFactor();
-        contentBounds.set_width(contentBounds.width() / pageScaleFactor);
-        contentBounds.set_height(contentBounds.height() / pageScaleFactor);
-    } else {
-        viewBounds.Scale(1 / m_pinchZoomViewport.pageScaleDelta());
-    }
-
-    gfx::Vector2dF maxScroll = gfx::Rect(contentBounds).bottom_right() - gfx::RectF(viewBounds).bottom_right();
-    maxScroll.Scale(1 / m_deviceScaleFactor);
-
-    // The viewport may be larger than the contents in some cases, such as
-    // having a vertical scrollbar but no horizontal overflow.
-    maxScroll.ClampToMin(gfx::Vector2dF());
-
-    rootScrollLayer()->setMaxScrollOffset(gfx::ToFlooredVector2d(maxScroll));
-}
-
 void LayerTreeHostImpl::setNeedsRedraw()
 {
     m_client->setNeedsRedrawOnImplThread();
@@ -1230,32 +1156,17 @@
 
 bool LayerTreeHostImpl::ensureRenderSurfaceLayerList()
 {
-    // TODO(enne): See http://crbug.com/164949.  This function should really
-    // just call updateDrawProperties(), but that breaks a number of
-    // impl transform tests that don't expect the tree to be updated.
-    if (!rootLayer())
-        return false;
-    if (!m_renderer)
-        return false;
-
-    // We need both a non-empty render surface layer list and a root render
-    // surface to be able to iterate over the visible layers.
-    if (m_renderSurfaceLayerList.size() && rootLayer()->renderSurface())
-        return true;
-
-    // If we are called after setRootLayer() but before prepareToDraw(), we need
-    // to recalculate the visible layers. This prevents being unable to scroll
-    // during part of a commit.
-    setNeedsUpdateDrawProperties();
-    updateDrawProperties();
-
-    return m_renderSurfaceLayerList.size();
+    activeTree()->UpdateDrawProperties(LayerTreeImpl::UPDATE_ACTIVE_TREE);
+    return activeTree()->RenderSurfaceLayerList().size();
 }
 
 InputHandlerClient::ScrollStatus LayerTreeHostImpl::scrollBegin(gfx::Point viewportPoint, InputHandlerClient::ScrollInputType type)
 {
     TRACE_EVENT0("cc", "LayerTreeHostImpl::scrollBegin");
 
+    if (m_topControlsManager)
+        m_topControlsManager->ScrollBegin();
+
     DCHECK(!currentlyScrollingLayer());
     clearCurrentlyScrollingLayer();
 
@@ -1266,7 +1177,7 @@
 
     // First find out which layer was hit from the saved list of visible layers
     // in the most recent frame.
-    LayerImpl* layerImpl = LayerTreeHostCommon::findLayerThatIsHitByPoint(deviceViewportPoint, m_renderSurfaceLayerList);
+    LayerImpl* layerImpl = LayerTreeHostCommon::findLayerThatIsHitByPoint(deviceViewportPoint, activeTree()->RenderSurfaceLayerList());
 
     // Walk up the hierarchy and look for a scrollable layer.
     LayerImpl* potentiallyScrollingLayerImpl = 0;
@@ -1295,24 +1206,22 @@
 
     if (potentiallyScrollingLayerImpl) {
         m_activeTree->set_currently_scrolling_layer(potentiallyScrollingLayerImpl);
-        // Gesture events need to be transformed from viewport coordinates to local layer coordinates
-        // so that the scrolling contents exactly follow the user's finger. In contrast, wheel
-        // events are already in local layer coordinates so we can just apply them directly.
-        m_scrollDeltaIsInViewportSpace = (type == Gesture);
+        m_shouldBubbleScrolls = (type != NonBubblingGesture);
+        m_wheelScrolling = (type == Wheel);
         m_numImplThreadScrolls++;
-        setNeedsUpdateDrawProperties();
+        m_client->renewTreePriority();
         return ScrollStarted;
     }
     return ScrollIgnored;
 }
 
-static gfx::Vector2dF scrollLayerWithViewportSpaceDelta(PinchZoomViewport* viewport, LayerImpl& layerImpl, float scaleFromViewportToScreenSpace, gfx::PointF viewportPoint, gfx::Vector2dF viewportDelta)
+gfx::Vector2dF LayerTreeHostImpl::scrollLayerWithViewportSpaceDelta(LayerImpl* layerImpl, float scaleFromViewportToScreenSpace, gfx::PointF viewportPoint, gfx::Vector2dF viewportDelta)
 {
     // Layers with non-invertible screen space transforms should not have passed the scroll hit
     // test in the first place.
-    DCHECK(layerImpl.screenSpaceTransform().IsInvertible());
+    DCHECK(layerImpl->screenSpaceTransform().IsInvertible());
     gfx::Transform inverseScreenSpaceTransform(gfx::Transform::kSkipInitialization);
-    bool didInvert = layerImpl.screenSpaceTransform().GetInverse(&inverseScreenSpaceTransform);
+    bool didInvert = layerImpl->screenSpaceTransform().GetInverse(&inverseScreenSpaceTransform);
     // TODO: With the advent of impl-side crolling for non-root layers, we may
     // need to explicitly handle uninvertible transforms here.
     DCHECK(didInvert);
@@ -1336,25 +1245,21 @@
         return gfx::Vector2dF();
 
     // localStartPoint and localEndPoint are in content space but we want to move them to layer space for scrolling.
-    float widthScale = 1 / layerImpl.contentsScaleX();
-    float heightScale = 1 / layerImpl.contentsScaleY();
+    float widthScale = 1 / layerImpl->contentsScaleX();
+    float heightScale = 1 / layerImpl->contentsScaleY();
     localStartPoint.Scale(widthScale, heightScale);
     localEndPoint.Scale(widthScale, heightScale);
 
     // Apply the scroll delta.
-    gfx::Vector2dF previousDelta = layerImpl.scrollDelta();
-    gfx::Vector2dF unscrolled = layerImpl.scrollBy(localEndPoint - localStartPoint);
+    gfx::Vector2dF previousDelta = layerImpl->scrollDelta();
+    layerImpl->scrollBy(localEndPoint - localStartPoint);
 
-    gfx::Vector2dF viewportAppliedPan;
-    if (viewport)
-        viewportAppliedPan = unscrolled - viewport->applyScroll(unscrolled);
-
     // Get the end point in the layer's content space so we can apply its screenSpaceTransform.
-    gfx::PointF actualLocalEndPoint = localStartPoint + layerImpl.scrollDelta() + viewportAppliedPan - previousDelta;
+    gfx::PointF actualLocalEndPoint = localStartPoint + layerImpl->scrollDelta() - previousDelta;
     gfx::PointF actualLocalContentEndPoint = gfx::ScalePoint(actualLocalEndPoint, 1 / widthScale, 1 / heightScale);
 
     // Calculate the applied scroll delta in viewport space coordinates.
-    gfx::PointF actualScreenSpaceEndPoint = MathUtil::mapPoint(layerImpl.screenSpaceTransform(), actualLocalContentEndPoint, endClipped);
+    gfx::PointF actualScreenSpaceEndPoint = MathUtil::mapPoint(layerImpl->screenSpaceTransform(), actualLocalContentEndPoint, endClipped);
     DCHECK(!endClipped);
     if (endClipped)
         return gfx::Vector2dF();
@@ -1383,21 +1288,33 @@
         if (!layerImpl->scrollable())
             continue;
 
-        PinchZoomViewport* viewport = NULL;
-        if (m_settings.pageScalePinchZoomEnabled && layerImpl == rootScrollLayer())
-            viewport = &m_pinchZoomViewport;
         gfx::Vector2dF appliedDelta;
-        if (m_scrollDeltaIsInViewportSpace) {
+        if (m_topControlsManager && layerImpl == rootScrollLayer())
+            pendingDelta = m_topControlsManager->ScrollBy(pendingDelta);
+
+        // Gesture events need to be transformed from viewport coordinates to local layer coordinates
+        // so that the scrolling contents exactly follow the user's finger. In contrast, wheel
+        // events represent a fixed amount of scrolling so we can just apply them directly.
+        if (!m_wheelScrolling) {
             float scaleFromViewportToScreenSpace = m_deviceScaleFactor;
-            appliedDelta = scrollLayerWithViewportSpaceDelta(viewport, *layerImpl, scaleFromViewportToScreenSpace, viewportPoint, pendingDelta);
+            appliedDelta = scrollLayerWithViewportSpaceDelta(layerImpl, scaleFromViewportToScreenSpace, viewportPoint, pendingDelta);
         } else
             appliedDelta = scrollLayerWithLocalDelta(*layerImpl, pendingDelta);
 
         // If the layer wasn't able to move, try the next one in the hierarchy.
         float moveThresholdSquared = 0.1f * 0.1f;
-        if (appliedDelta.LengthSquared() < moveThresholdSquared)
-            continue;
+        if (appliedDelta.LengthSquared() < moveThresholdSquared) {
+            if (m_shouldBubbleScrolls || !m_didLockScrollingLayer)
+                continue;
+            else
+                break;
+        }
         didScroll = true;
+        m_didLockScrollingLayer = true;
+        if (!m_shouldBubbleScrolls) {
+            m_activeTree->set_currently_scrolling_layer(layerImpl);
+            break;
+        }
 
         // If the applied delta is within 45 degrees of the input delta, bail out to make it easier
         // to scroll just one layer in one direction without affecting any of its parents.
@@ -1419,7 +1336,7 @@
     if (didScroll) {
         m_client->setNeedsCommitOnImplThread();
         m_client->setNeedsRedrawOnImplThread();
-        setNeedsUpdateDrawProperties();
+        m_client->renewTreePriority();
     }
     return didScroll;
 }
@@ -1427,10 +1344,13 @@
 void LayerTreeHostImpl::clearCurrentlyScrollingLayer()
 {
     m_activeTree->ClearCurrentlyScrollingLayer();
+    m_didLockScrollingLayer = false;
 }
 
 void LayerTreeHostImpl::scrollEnd()
 {
+    if (m_topControlsManager)
+        m_topControlsManager->ScrollEnd();
     clearCurrentlyScrollingLayer();
 }
 
@@ -1438,9 +1358,7 @@
 {
     m_pinchGestureActive = true;
     m_previousPinchAnchor = gfx::Point();
-
-    if (rootScrollLayer() && rootScrollLayer()->scrollbarAnimationController())
-        rootScrollLayer()->scrollbarAnimationController()->didPinchGestureBegin();
+    m_client->renewTreePriority();
 }
 
 void LayerTreeHostImpl::pinchGestureUpdate(float magnifyDelta, gfx::Point anchor)
@@ -1452,29 +1370,26 @@
 
     // Keep the center-of-pinch anchor specified by (x, y) in a stable
     // position over the course of the magnify.
-    float pageScaleDelta = m_pinchZoomViewport.pageScaleDelta();
+    float pageScaleDelta = activeTree()->page_scale_delta();
     gfx::PointF previousScaleAnchor = gfx::ScalePoint(anchor, 1 / pageScaleDelta);
-    setPageScaleDelta(pageScaleDelta * magnifyDelta);
-    pageScaleDelta = m_pinchZoomViewport.pageScaleDelta();
+    activeTree()->SetPageScaleDelta(pageScaleDelta * magnifyDelta);
+    pageScaleDelta = activeTree()->page_scale_delta();
     gfx::PointF newScaleAnchor = gfx::ScalePoint(anchor, 1 / pageScaleDelta);
     gfx::Vector2dF move = previousScaleAnchor - newScaleAnchor;
 
     m_previousPinchAnchor = anchor;
 
-    if (m_settings.pageScalePinchZoomEnabled) {
-        // Compute the application of the delta with respect to the current page zoom of the page.
-        move.Scale(1 / m_pinchZoomViewport.pageScaleFactor());
-    }
+    if (m_settings.pageScalePinchZoomEnabled)
+        move.Scale(1 / activeTree()->page_scale_factor());
 
-    gfx::Vector2dF scrollOverflow = m_settings.pageScalePinchZoomEnabled ? m_pinchZoomViewport.applyScroll(move) : move;
-    rootScrollLayer()->scrollBy(scrollOverflow);
+    rootScrollLayer()->scrollBy(move);
 
     if (rootScrollLayer()->scrollbarAnimationController())
-        rootScrollLayer()->scrollbarAnimationController()->didPinchGestureUpdate();
+        rootScrollLayer()->scrollbarAnimationController()->didPinchGestureUpdate(base::TimeTicks::Now());
 
     m_client->setNeedsCommitOnImplThread();
     m_client->setNeedsRedrawOnImplThread();
-    setNeedsUpdateDrawProperties();
+    m_client->renewTreePriority();
 }
 
 void LayerTreeHostImpl::pinchGestureEnd()
@@ -1482,7 +1397,7 @@
     m_pinchGestureActive = false;
 
     if (rootScrollLayer() && rootScrollLayer()->scrollbarAnimationController())
-        rootScrollLayer()->scrollbarAnimationController()->didPinchGestureEnd();
+        rootScrollLayer()->scrollbarAnimationController()->didPinchGestureEnd(base::TimeTicks::Now());
 
     m_client->setNeedsCommitOnImplThread();
 }
@@ -1491,7 +1406,7 @@
 {
     gfx::Vector2dF scaledScrollOffset = m_pageScaleAnimation->targetScrollOffset();
     if (!m_settings.pageScalePinchZoomEnabled)
-        scaledScrollOffset.Scale(m_pinchZoomViewport.pageScaleFactor());
+        scaledScrollOffset.Scale(activeTree()->page_scale_factor());
     makeScrollAndScaleSet(scrollInfo, ToFlooredVector2d(scaledScrollOffset), m_pageScaleAnimation->targetPageScaleFactor());
 }
 
@@ -1504,50 +1419,36 @@
     // significant amount. This also ensures only one fake delta set will be
     // sent.
     const float pinchZoomOutSensitivity = 0.95f;
-    if (m_pinchZoomViewport.pageScaleDelta() > pinchZoomOutSensitivity)
+    if (activeTree()->page_scale_delta() > pinchZoomOutSensitivity)
         return;
 
     // Compute where the scroll offset/page scale would be if fully pinch-zoomed
     // out from the anchor point.
     gfx::Vector2dF scrollBegin = rootScrollLayer()->scrollOffset() + rootScrollLayer()->scrollDelta();
-    scrollBegin.Scale(m_pinchZoomViewport.pageScaleDelta());
-    float scaleBegin = m_pinchZoomViewport.totalPageScaleFactor();
-    float pageScaleDeltaToSend = m_pinchZoomViewport.minPageScaleFactor() / m_pinchZoomViewport.pageScaleFactor();
-    gfx::SizeF scaledContentsSize = gfx::ScaleSize(contentSize(), pageScaleDeltaToSend);
+    scrollBegin.Scale(activeTree()->page_scale_delta());
+    float scaleBegin = activeTree()->total_page_scale_factor();
+    float pageScaleDeltaToSend = activeTree()->min_page_scale_factor() / activeTree()->page_scale_factor();
+    gfx::SizeF scaledScrollableSize = gfx::ScaleSize(activeTree()->ScrollableSize(), pageScaleDeltaToSend);
 
     gfx::Vector2d anchorOffset = m_previousPinchAnchor.OffsetFromOrigin();
     gfx::Vector2dF scrollEnd = scrollBegin + anchorOffset;
-    scrollEnd.Scale(m_pinchZoomViewport.minPageScaleFactor() / scaleBegin);
+    scrollEnd.Scale(activeTree()->min_page_scale_factor() / scaleBegin);
     scrollEnd -= anchorOffset;
-    scrollEnd.ClampToMax(gfx::RectF(scaledContentsSize).bottom_right() - gfx::Rect(m_deviceViewportSize).bottom_right());
+    scrollEnd.ClampToMax(gfx::RectF(scaledScrollableSize).bottom_right() - gfx::Rect(m_deviceViewportSize).bottom_right());
     scrollEnd.ClampToMin(gfx::Vector2d());
     scrollEnd.Scale(1 / pageScaleDeltaToSend);
     scrollEnd.Scale(m_deviceScaleFactor);
 
-    makeScrollAndScaleSet(scrollInfo, gfx::ToRoundedVector2d(scrollEnd), m_pinchZoomViewport.minPageScaleFactor());
+    makeScrollAndScaleSet(scrollInfo, gfx::ToRoundedVector2d(scrollEnd), activeTree()->min_page_scale_factor());
 }
 
-void LayerTreeHostImpl::makeScrollAndScaleSet(ScrollAndScaleSet* scrollInfo, gfx::Vector2d scrollOffset, float pageScale)
-{
-    if (!rootScrollLayer())
-        return;
-
-    LayerTreeHostCommon::ScrollUpdateInfo scroll;
-    scroll.layerId = rootScrollLayer()->id();
-    scroll.scrollDelta = scrollOffset - rootScrollLayer()->scrollOffset();
-    scrollInfo->scrolls.push_back(scroll);
-    rootScrollLayer()->setSentScrollDelta(scroll.scrollDelta);
-    scrollInfo->pageScaleDelta = pageScale / m_pinchZoomViewport.pageScaleFactor();
-    m_pinchZoomViewport.setSentPageScaleDelta(scrollInfo->pageScaleDelta);
-}
-
 static void collectScrollDeltas(ScrollAndScaleSet* scrollInfo, LayerImpl* layerImpl)
 {
     if (!layerImpl)
         return;
 
-    if (!layerImpl->scrollDelta().IsZero()) {
-        gfx::Vector2d scrollDelta = gfx::ToFlooredVector2d(layerImpl->scrollDelta());
+    gfx::Vector2d scrollDelta = gfx::ToFlooredVector2d(layerImpl->scrollDelta());
+    if (!scrollDelta.IsZero()) {
         LayerTreeHostCommon::ScrollUpdateInfo scroll;
         scroll.layerId = layerImpl->id();
         scroll.scrollDelta = scrollDelta;
@@ -1559,16 +1460,28 @@
         collectScrollDeltas(scrollInfo, layerImpl->children()[i]);
 }
 
+void LayerTreeHostImpl::makeScrollAndScaleSet(ScrollAndScaleSet* scrollInfo, gfx::Vector2d scrollOffset, float pageScale)
+{
+    if (!rootScrollLayer())
+        return;
+
+    LayerTreeHostCommon::ScrollUpdateInfo scroll;
+    scroll.layerId = rootScrollLayer()->id();
+    scroll.scrollDelta = scrollOffset - rootScrollLayer()->scrollOffset();
+    scrollInfo->scrolls.push_back(scroll);
+    activeTree()->RootScrollLayer()->setSentScrollDelta(scroll.scrollDelta);
+    scrollInfo->pageScaleDelta = pageScale / activeTree()->page_scale_factor();
+    activeTree()->set_sent_page_scale_delta(scrollInfo->pageScaleDelta);
+}
+
 scoped_ptr<ScrollAndScaleSet> LayerTreeHostImpl::processScrollDeltas()
 {
     scoped_ptr<ScrollAndScaleSet> scrollInfo(new ScrollAndScaleSet());
 
-    if (m_pinchGestureActive || m_pageScaleAnimation) {
+    if (!m_settings.pageScalePinchZoomEnabled && (m_pinchGestureActive || m_pageScaleAnimation)) {
         scrollInfo->pageScaleDelta = 1;
-        m_pinchZoomViewport.setSentPageScaleDelta(1);
-        // FIXME(aelias): Make pinch-zoom painting optimization compatible with
-        // compositor-side scaling.
-        if (!m_settings.pageScalePinchZoomEnabled && m_pinchGestureActive)
+        activeTree()->set_sent_page_scale_delta(1);
+        if (m_pinchGestureActive)
             computePinchZoomDeltas(scrollInfo.get());
         else if (m_pageScaleAnimation.get())
             computeDoubleTapZoomDeltas(scrollInfo.get());
@@ -1576,17 +1489,12 @@
     }
 
     collectScrollDeltas(scrollInfo.get(), rootLayer());
-    scrollInfo->pageScaleDelta = m_pinchZoomViewport.pageScaleDelta();
-    m_pinchZoomViewport.setSentPageScaleDelta(scrollInfo->pageScaleDelta);
+    scrollInfo->pageScaleDelta = activeTree()->page_scale_delta();
+    activeTree()->set_sent_page_scale_delta(scrollInfo->pageScaleDelta);
 
     return scrollInfo.Pass();
 }
 
-gfx::Transform LayerTreeHostImpl::implTransform() const
-{
-    return m_pinchZoomViewport.implTransform(m_settings.pageScalePinchZoomEnabled);
-}
-
 void LayerTreeHostImpl::setFullRootLayerDamage()
 {
     if (rootLayer()) {
@@ -1604,14 +1512,13 @@
     double monotonicTime = (time - base::TimeTicks()).InSecondsF();
     gfx::Vector2dF scrollTotal = rootScrollLayer()->scrollOffset() + rootScrollLayer()->scrollDelta();
 
-    setPageScaleDelta(m_pageScaleAnimation->pageScaleFactorAtTime(monotonicTime) / m_pinchZoomViewport.pageScaleFactor());
+    activeTree()->SetPageScaleDelta(m_pageScaleAnimation->pageScaleFactorAtTime(monotonicTime) / activeTree()->page_scale_factor());
     gfx::Vector2dF nextScroll = m_pageScaleAnimation->scrollOffsetAtTime(monotonicTime);
 
     if (!m_settings.pageScalePinchZoomEnabled)
-        nextScroll.Scale(m_pinchZoomViewport.pageScaleFactor());
+        nextScroll.Scale(activeTree()->page_scale_factor());
     rootScrollLayer()->scrollBy(nextScroll - scrollTotal);
     m_client->setNeedsRedrawOnImplThread();
-    setNeedsUpdateDrawProperties();
 
     if (m_pageScaleAnimation->isAnimationCompleteAtTime(monotonicTime)) {
         m_pageScaleAnimation.reset();
@@ -1621,25 +1528,23 @@
 
 void LayerTreeHostImpl::animateLayers(base::TimeTicks monotonicTime, base::Time wallClockTime)
 {
-    if (!m_settings.acceleratedAnimationEnabled || !m_needsAnimateLayers || !rootLayer())
+    if (!m_settings.acceleratedAnimationEnabled || m_animationRegistrar->active_animation_controllers().empty() || !rootLayer())
         return;
 
     TRACE_EVENT0("cc", "LayerTreeHostImpl::animateLayers");
 
+    double monotonicSeconds = (monotonicTime - base::TimeTicks()).InSecondsF();
+
     scoped_ptr<AnimationEventsVector> events(make_scoped_ptr(new AnimationEventsVector));
+    AnimationRegistrar::AnimationControllerMap copy = m_animationRegistrar->active_animation_controllers();
+    for (AnimationRegistrar::AnimationControllerMap::iterator iter = copy.begin(); iter != copy.end(); ++iter)
+        (*iter).second->animate(monotonicSeconds, events.get());
 
-    bool didAnimate = false;
-    animateLayersRecursive(rootLayer(), monotonicTime, wallClockTime, events.get(), didAnimate, m_needsAnimateLayers);
-
     if (!events->empty())
         m_client->postAnimationEventsToMainThreadOnImplThread(events.Pass(), wallClockTime);
 
-    if (didAnimate) {
-        m_client->setNeedsRedrawOnImplThread();
-        setNeedsUpdateDrawProperties();
-    }
-
-    setBackgroundTickingEnabled(!m_visible && m_needsAnimateLayers);
+    m_client->setNeedsRedrawOnImplThread();
+    setBackgroundTickingEnabled(!m_visible && !m_animationRegistrar->active_animation_controllers().empty());
 }
 
 base::TimeDelta LayerTreeHostImpl::lowFrequencyAnimationInterval() const
@@ -1659,19 +1564,11 @@
         sendDidLoseOutputSurfaceRecursive(current->children()[i]);
 }
 
-static void clearRenderSurfacesOnLayerImplRecursive(LayerImpl* current)
-{
-    DCHECK(current);
-    for (size_t i = 0; i < current->children().size(); ++i)
-        clearRenderSurfacesOnLayerImplRecursive(current->children()[i]);
-    current->clearRenderSurface();
-}
-
 void LayerTreeHostImpl::clearRenderSurfaces()
 {
-    clearRenderSurfacesOnLayerImplRecursive(rootLayer());
-    m_renderSurfaceLayerList.clear();
-    setNeedsUpdateDrawProperties();
+    activeTree()->ClearRenderSurfaces();
+    if (pendingTree())
+        pendingTree()->ClearRenderSurfaces();
 }
 
 std::string LayerTreeHostImpl::layerTreeAsText() const
@@ -1762,12 +1659,67 @@
         return;
 
     ScrollbarAnimationController* scrollbarController = layer->scrollbarAnimationController();
-    double monotonicTime = (time - base::TimeTicks()).InSecondsF();
-    if (scrollbarController && scrollbarController->animate(monotonicTime))
+    if (scrollbarController && scrollbarController->animate(time))
         m_client->setNeedsRedrawOnImplThread();
 
     for (size_t i = 0; i < layer->children().size(); ++i)
         animateScrollbarsRecursive(layer->children()[i], time);
 }
 
+void LayerTreeHostImpl::setTreePriority(TreePriority priority)
+{
+    if (!m_tileManager)
+        return;
+
+    GlobalStateThatImpactsTilePriority new_state(m_tileManager->GlobalState());
+    if (new_state.tree_priority == priority)
+        return;
+
+    new_state.tree_priority = priority;
+    m_tileManager->SetGlobalState(new_state);
+}
+
+void LayerTreeHostImpl::beginNextFrame()
+{
+    m_currentFrameTime = base::TimeTicks();
+}
+
+base::TimeTicks LayerTreeHostImpl::currentFrameTime()
+{
+    if (m_currentFrameTime.is_null())
+        m_currentFrameTime = base::TimeTicks::Now();
+    return m_currentFrameTime;
+}
+
+// static
+LayerImpl* LayerTreeHostImpl::getNonCompositedContentLayerRecursive(LayerImpl* layer)
+{
+    if (!layer)
+        return NULL;
+
+    if (layer->drawsContent())
+        return layer;
+
+    for (LayerImpl::LayerList::const_iterator it = layer->children().begin();
+            it != layer->children().end(); ++it) {
+        LayerImpl* nccr = getNonCompositedContentLayerRecursive(*it);
+        if (nccr)
+            return nccr;
+    }
+
+    return NULL;
+}
+
+skia::RefPtr<SkPicture> LayerTreeHostImpl::capturePicture()
+{
+    LayerTreeImpl* tree = pendingTree() ? pendingTree() : activeTree();
+    LayerImpl* layer = getNonCompositedContentLayerRecursive(tree->RootLayer());
+    return layer ? layer->getPicture() : skia::RefPtr<SkPicture>();
+}
+
+void LayerTreeHostImpl::savePaintTime(const base::TimeDelta& totalPaintTime)
+{
+    m_paintTimeCounter->SavePaintTime(totalPaintTime);
+}
+
 }  // namespace cc
Index: src/cc/frame_rate_controller.h
===================================================================
--- src/cc/frame_rate_controller.h	(revision 184497)
+++ src/cc/frame_rate_controller.h	(working copy)
@@ -29,6 +29,10 @@
 
 class CC_EXPORT FrameRateController {
 public:
+    enum {
+        kDefaultMaxFramesPending = 2
+    };
+
     explicit FrameRateController(scoped_refptr<TimeSource>);
     // Alternate form of FrameRateController with unthrottled frame-rate.
     explicit FrameRateController(Thread*);
@@ -48,6 +52,7 @@
     void didFinishFrame();
     void didAbortAllPendingFrames();
     void setMaxFramesPending(int); // 0 for unlimited.
+    int maxFramesPending() const { return m_maxFramesPending; }
 
     // This returns null for unthrottled frame-rate.
     base::TimeTicks nextTickTime();
Index: src/cc/active_animation.cc
===================================================================
--- src/cc/active_animation.cc	(revision 184497)
+++ src/cc/active_animation.cc	(working copy)
@@ -1,208 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "cc/active_animation.h"
-
-#include <cmath>
-
-#include "base/debug/trace_event.h"
-#include "base/string_util.h"
-#include "cc/animation_curve.h"
-
-namespace {
-
-// This should match the RunState enum.
-static const char* const s_runStateNames[] = {
-    "WaitingForNextTick",
-    "WaitingForTargetAvailability",
-    "WaitingForStartTime",
-    "WaitingForDeletion",
-    "Running",
-    "Paused",
-    "Finished",
-    "Aborted"
-};
-
-COMPILE_ASSERT(static_cast<int>(cc::ActiveAnimation::RunStateEnumSize) == arraysize(s_runStateNames), RunState_names_match_enum);
-
-// This should match the TargetProperty enum.
-static const char* const s_targetPropertyNames[] = {
-    "Transform",
-    "Opacity"
-};
-
-COMPILE_ASSERT(static_cast<int>(cc::ActiveAnimation::TargetPropertyEnumSize) == arraysize(s_targetPropertyNames), TargetProperty_names_match_enum);
-
-} // namespace
-
-namespace cc {
-
-scoped_ptr<ActiveAnimation> ActiveAnimation::create(scoped_ptr<AnimationCurve> curve, int animationId, int groupId, TargetProperty targetProperty)
-{
-    return make_scoped_ptr(new ActiveAnimation(curve.Pass(), animationId, groupId, targetProperty));
-}
-
-ActiveAnimation::ActiveAnimation(scoped_ptr<AnimationCurve> curve, int animationId, int groupId, TargetProperty targetProperty)
-    : m_curve(curve.Pass())
-    , m_id(animationId)
-    , m_group(groupId)
-    , m_targetProperty(targetProperty)
-    , m_runState(WaitingForTargetAvailability)
-    , m_iterations(1)
-    , m_startTime(0)
-    , m_alternatesDirection(false)
-    , m_timeOffset(0)
-    , m_needsSynchronizedStartTime(false)
-    , m_suspended(false)
-    , m_pauseTime(0)
-    , m_totalPausedTime(0)
-    , m_isControllingInstance(false)
-{
-}
-
-ActiveAnimation::~ActiveAnimation()
-{
-    if (m_runState == Running || m_runState == Paused)
-        setRunState(Aborted, 0);
-}
-
-void ActiveAnimation::setRunState(RunState runState, double monotonicTime)
-{
-    if (m_suspended)
-        return;
-
-    char nameBuffer[256];
-    base::snprintf(nameBuffer, sizeof(nameBuffer), "%s-%d%s", s_targetPropertyNames[m_targetProperty], m_group, m_isControllingInstance ? "(impl)" : "");
-
-    bool isWaitingToStart = m_runState == WaitingForNextTick
-        || m_runState == WaitingForTargetAvailability
-        || m_runState == WaitingForStartTime;
-
-    if (isWaitingToStart && runState == Running)
-        TRACE_EVENT_ASYNC_BEGIN1("cc", "ActiveAnimation", this, "Name", TRACE_STR_COPY(nameBuffer));
-
-    bool wasFinished = isFinished();
-
-    const char* oldRunStateName = s_runStateNames[m_runState];
-
-    if (runState == Running && m_runState == Paused)
-        m_totalPausedTime += monotonicTime - m_pauseTime;
-    else if (runState == Paused)
-        m_pauseTime = monotonicTime;
-    m_runState = runState;
-
-    const char* newRunStateName = s_runStateNames[runState];
-
-    if (!wasFinished && isFinished())
-        TRACE_EVENT_ASYNC_END0("cc", "ActiveAnimation", this);
-
-    char stateBuffer[256];
-    base::snprintf(stateBuffer, sizeof(stateBuffer), "%s->%s", oldRunStateName, newRunStateName);
-
-    TRACE_EVENT_INSTANT2("cc", "LayerAnimationController::setRunState", "Name", TRACE_STR_COPY(nameBuffer), "State", TRACE_STR_COPY(stateBuffer));
-}
-
-void ActiveAnimation::suspend(double monotonicTime)
-{
-    setRunState(Paused, monotonicTime);
-    m_suspended = true;
-}
-
-void ActiveAnimation::resume(double monotonicTime)
-{
-    m_suspended = false;
-    setRunState(Running, monotonicTime);
-}
-
-bool ActiveAnimation::isFinishedAt(double monotonicTime) const
-{
-    if (isFinished())
-        return true;
-
-    if (m_needsSynchronizedStartTime)
-        return false;
-
-    return m_runState == Running
-        && m_iterations >= 0
-        && m_iterations * m_curve->duration() <= monotonicTime - startTime() - m_totalPausedTime;
-}
-
-double ActiveAnimation::trimTimeToCurrentIteration(double monotonicTime) const
-{
-    double trimmed = monotonicTime + m_timeOffset;
-
-    // If we're paused, time is 'stuck' at the pause time.
-    if (m_runState == Paused)
-        trimmed = m_pauseTime;
-
-    // Returned time should always be relative to the start time and should subtract
-    // all time spent paused.
-    trimmed -= m_startTime + m_totalPausedTime;
-
-    // Zero is always the start of the animation.
-    if (trimmed <= 0)
-        return 0;
-
-    // Always return zero if we have no iterations.
-    if (!m_iterations)
-        return 0;
-
-    // Don't attempt to trim if we have no duration.
-    if (m_curve->duration() <= 0)
-        return 0;
-
-    // If less than an iteration duration, just return trimmed.
-    if (trimmed < m_curve->duration())
-        return trimmed;
-
-    // If greater than or equal to the total duration, return iteration duration.
-    if (m_iterations >= 0 && trimmed >= m_curve->duration() * m_iterations) {
-        if (m_alternatesDirection && !(m_iterations % 2))
-            return 0;
-        return m_curve->duration();
-    }
-
-    // We need to know the current iteration if we're alternating.
-    int iteration = static_cast<int>(trimmed / m_curve->duration());
-
-    // Calculate x where trimmed = x + n * m_curve->duration() for some positive integer n.
-    trimmed = fmod(trimmed, m_curve->duration());
-
-    // If we're alternating and on an odd iteration, reverse the direction.
-    if (m_alternatesDirection && iteration % 2 == 1)
-        return m_curve->duration() - trimmed;
-
-    return trimmed;
-}
-
-scoped_ptr<ActiveAnimation> ActiveAnimation::clone(InstanceType instanceType) const
-{
-    return cloneAndInitialize(instanceType, m_runState, m_startTime);
-}
-
-scoped_ptr<ActiveAnimation> ActiveAnimation::cloneAndInitialize(InstanceType instanceType, RunState initialRunState, double startTime) const
-{
-    scoped_ptr<ActiveAnimation> toReturn(new ActiveAnimation(m_curve->clone(), m_id, m_group, m_targetProperty));
-    toReturn->m_runState = initialRunState;
-    toReturn->m_iterations = m_iterations;
-    toReturn->m_startTime = startTime;
-    toReturn->m_pauseTime = m_pauseTime;
-    toReturn->m_totalPausedTime = m_totalPausedTime;
-    toReturn->m_timeOffset = m_timeOffset;
-    toReturn->m_alternatesDirection = m_alternatesDirection;
-    toReturn->m_isControllingInstance = instanceType == ControllingInstance;
-    return toReturn.Pass();
-}
-
-void ActiveAnimation::pushPropertiesTo(ActiveAnimation* other) const
-{
-    // Currently, we only push changes due to pausing and resuming animations on the main thread.
-    if (m_runState == ActiveAnimation::Paused || other->m_runState == ActiveAnimation::Paused) {
-        other->m_runState = m_runState;
-        other->m_pauseTime = m_pauseTime;
-        other->m_totalPausedTime = m_totalPausedTime;
-    }
-}
-
-}  // namespace cc
Index: src/cc/picture_layer_tiling_unittest.cc
===================================================================
--- src/cc/picture_layer_tiling_unittest.cc	(revision 184497)
+++ src/cc/picture_layer_tiling_unittest.cc	(working copy)
@@ -6,6 +6,7 @@
 
 #include "cc/test/fake_picture_layer_tiling_client.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/rect_conversions.h"
 #include "ui/gfx/size_conversions.h"
 
 namespace cc {
@@ -20,12 +21,17 @@
                   float contents_scale,
                   gfx::Size layer_bounds) {
     client_.SetTileSize(tile_size);
-    tiling_ = PictureLayerTiling::Create(contents_scale, tile_size);
+    tiling_ = PictureLayerTiling::Create(contents_scale);
     tiling_->SetClient(&client_);
     tiling_->SetLayerBounds(layer_bounds);
   }
 
-  void VerifyTilesExactlyCoverRect(float rect_scale, gfx::Rect rect) {
+  void VerifyTilesExactlyCoverRect(
+      float rect_scale,
+      gfx::Rect request_rect,
+      gfx::Rect expect_rect) {
+    EXPECT_TRUE(request_rect.Contains(expect_rect));
+
     // Iterators are not valid if this ratio is too large (i.e. the
     // tiling is too high-res for a low-res destination rect.)  This is an
     // artifact of snapping geometry to integer coordinates and then mapping
@@ -33,14 +39,17 @@
     float dest_to_contents_scale = tiling_->contents_scale() / rect_scale;
     ASSERT_LE(dest_to_contents_scale, 2.0);
 
-    Region remaining = rect;
-    for (PictureLayerTiling::Iterator iter(tiling_.get(), rect_scale, rect);
+    Region remaining = expect_rect;
+    for (PictureLayerTiling::Iterator iter(tiling_.get(),
+                                           rect_scale,
+                                           request_rect,
+                                           PictureLayerTiling::LayerDeviceAlignmentUnknown);
          iter;
          ++iter) {
 
       // Geometry cannot overlap previous geometry at all
       gfx::Rect geometry = iter.geometry_rect();
-      EXPECT_TRUE(rect.Contains(geometry));
+      EXPECT_TRUE(expect_rect.Contains(geometry));
       EXPECT_TRUE(remaining.Contains(geometry));
       remaining.Subtract(geometry);
 
@@ -58,6 +67,18 @@
     EXPECT_TRUE(remaining.IsEmpty());
   }
 
+  void VerifyTilesExactlyCoverRect(float rect_scale, gfx::Rect rect) {
+    VerifyTilesExactlyCoverRect(rect_scale, rect, rect);
+  }
+
+  void VerifyTilesCoverNonContainedRect(float rect_scale, gfx::Rect dest_rect) {
+    float dest_to_contents_scale = tiling_->contents_scale() / rect_scale;
+    gfx::Rect clamped_rect(gfx::ToEnclosingRect(gfx::ScaleRect(
+        tiling_->ContentRect(), 1 / dest_to_contents_scale)));
+    clamped_rect.Intersect(dest_rect);
+    VerifyTilesExactlyCoverRect(rect_scale, dest_rect, clamped_rect);
+  }
+
  protected:
   FakePictureLayerTilingClient client_;
   scoped_ptr<PictureLayerTiling> tiling_;
@@ -119,5 +140,219 @@
   VerifyTilesExactlyCoverRect(scale, gfx::Rect(2014, 1579, 867, 1033));
 }
 
+TEST_F(PictureLayerTilingIteratorTest, IteratorEmptyRect) {
+  Initialize(gfx::Size(100, 100), 1.0f, gfx::Size(800, 600));
+
+  gfx::Rect empty;
+  PictureLayerTiling::Iterator iter(tiling_.get(), 1.0f, empty,
+                                    PictureLayerTiling::LayerDeviceAlignmentUnknown);
+  EXPECT_FALSE(iter);
+}
+
+TEST_F(PictureLayerTilingIteratorTest, NonIntersectingRect) {
+  Initialize(gfx::Size(100, 100), 1.0f, gfx::Size(800, 600));
+  gfx::Rect non_intersecting(1000, 1000, 50, 50);
+  PictureLayerTiling::Iterator iter(tiling_.get(), 1, non_intersecting,
+                                    PictureLayerTiling::LayerDeviceAlignmentUnknown);
+  EXPECT_FALSE(iter);
+}
+
+TEST_F(PictureLayerTilingIteratorTest, LayerEdgeTextureCoordinates) {
+  Initialize(gfx::Size(300, 300), 1.0f, gfx::Size(256, 256));
+  // All of these sizes are 256x256, scaled and ceiled.
+  VerifyTilesExactlyCoverRect(1.0f, gfx::Rect(gfx::Size(256, 256)));
+  VerifyTilesExactlyCoverRect(0.8f, gfx::Rect(gfx::Size(205, 205)));
+  VerifyTilesExactlyCoverRect(1.2f, gfx::Rect(gfx::Size(308, 308)));
+}
+
+TEST_F(PictureLayerTilingIteratorTest, NonContainedDestRect) {
+  Initialize(gfx::Size(100, 100), 1.0f, gfx::Size(400, 400));
+
+  // Too large in all dimensions
+  VerifyTilesCoverNonContainedRect(1.0f, gfx::Rect(-1000, -1000, 2000, 2000));
+  VerifyTilesCoverNonContainedRect(1.5f, gfx::Rect(-1000, -1000, 2000, 2000));
+  VerifyTilesCoverNonContainedRect(0.5f, gfx::Rect(-1000, -1000, 2000, 2000));
+
+  // Partially covering content, but too large
+  VerifyTilesCoverNonContainedRect(1.0f, gfx::Rect(-1000, 100, 2000, 100));
+  VerifyTilesCoverNonContainedRect(1.5f, gfx::Rect(-1000, 100, 2000, 100));
+  VerifyTilesCoverNonContainedRect(0.5f, gfx::Rect(-1000, 100, 2000, 100));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectEqual) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-1000, -1000, 10000, 10000);
+  int64 target_area = 100 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(in.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectSmaller) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-1000, -1000, 10000, 10000);
+  int64 target_area = 100 * 100;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(out.bottom() - in.bottom(), in.y() - out.y());
+  EXPECT_EQ(out.right() - in.right(), in.x() - out.x());
+  EXPECT_EQ(out.width() - in.width(), out.height() - in.height());
+  EXPECT_NEAR(100 * 100, out.width() * out.height(), 50);
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectUnbounded) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-1000, -1000, 10000, 10000);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(out.bottom() - in.bottom(), in.y() - out.y());
+  EXPECT_EQ(out.right() - in.right(), in.x() - out.x());
+  EXPECT_EQ(out.width() - in.width(), out.height() - in.height());
+  EXPECT_NEAR(200 * 200, out.width() * out.height(), 100);
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedSmaller) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(50, 60, 40, 30);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(bounds.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedEqual) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds = in;
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(bounds.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedSmallerStretchVertical) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(45, 0, 90, 300);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(bounds.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedEqualStretchVertical) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(40, 0, 100, 300);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(bounds.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedSmallerStretchHorizontal) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(0, 55, 180, 190);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(bounds.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedEqualStretchHorizontal) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(0, 50, 180, 200);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(bounds.ToString(), out.ToString());
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedLeft) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(20, -1000, 10000, 10000);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(out.bottom() - in.bottom(), in.y() - out.y());
+  EXPECT_EQ(out.bottom() - in.bottom(), out.right() - in.right());
+  EXPECT_LE(out.width() * out.height(), target_area);
+  EXPECT_GT(out.width() * out.height(),
+            target_area - out.width() - out.height() * 2);
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedRight) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-1000, -1000, 1000+120, 10000);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(out.bottom() - in.bottom(), in.y() - out.y());
+  EXPECT_EQ(out.bottom() - in.bottom(), in.x() - out.x());
+  EXPECT_LE(out.width() * out.height(), target_area);
+  EXPECT_GT(out.width() * out.height(),
+            target_area - out.width() - out.height() * 2);
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedTop) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-1000, 30, 10000, 10000);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(out.right() - in.right(), in.x() - out.x());
+  EXPECT_EQ(out.right() - in.right(), out.bottom() - in.bottom());
+  EXPECT_LE(out.width() * out.height(), target_area);
+  EXPECT_GT(out.width() * out.height(),
+            target_area - out.width() * 2 - out.height());
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectBoundedBottom) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-1000, -1000, 10000, 1000 + 220);
+  int64 target_area = 200 * 200;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(out.right() - in.right(), in.x() - out.x());
+  EXPECT_EQ(out.right() - in.right(), in.y() - out.y());
+  EXPECT_LE(out.width() * out.height(), target_area);
+  EXPECT_GT(out.width() * out.height(),
+            target_area - out.width() * 2 - out.height());
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectSquishedHorizontally) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(0, -4000, 100+40+20, 100000);
+  int64 target_area = 400 * 400;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(20, out.right() - in.right());
+  EXPECT_EQ(40, in.x() - out.x());
+  EXPECT_EQ(out.bottom() - in.bottom(), in.y() - out.y());
+  EXPECT_LE(out.width() * out.height(), target_area);
+  EXPECT_GT(out.width() * out.height(),
+            target_area - out.width() * 2);
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
+TEST(PictureLayerTilingTest, ExpandRectSquishedVertically) {
+  gfx::Rect in(40, 50, 100, 200);
+  gfx::Rect bounds(-4000, 0, 100000, 200+50+30);
+  int64 target_area = 400 * 400;
+  gfx::Rect out = PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+      in, target_area, bounds);
+  EXPECT_EQ(30, out.bottom() - in.bottom());
+  EXPECT_EQ(50, in.y() - out.y());
+  EXPECT_EQ(out.right() - in.right(), in.x() - out.x());
+  EXPECT_LE(out.width() * out.height(), target_area);
+  EXPECT_GT(out.width() * out.height(),
+            target_area - out.height() * 2);
+  EXPECT_TRUE(bounds.Contains(out));
+}
+
 }  // namespace
 }  // namespace cc
Index: src/cc/skpicture_content_layer_updater.cc
===================================================================
--- src/cc/skpicture_content_layer_updater.cc	(revision 184497)
+++ src/cc/skpicture_content_layer_updater.cc	(working copy)
@@ -6,6 +6,7 @@
 
 #include "base/debug/trace_event.h"
 #include "cc/layer_painter.h"
+#include "cc/prioritized_resource.h"
 #include "cc/resource_update_queue.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 
Index: src/cc/layer_tree_host_unittest.cc
===================================================================
--- src/cc/layer_tree_host_unittest.cc	(revision 184497)
+++ src/cc/layer_tree_host_unittest.cc	(working copy)
@@ -7,28 +7,35 @@
 #include "base/synchronization/lock.h"
 #include "cc/content_layer.h"
 #include "cc/content_layer_client.h"
+#include "cc/frame_rate_controller.h"
 #include "cc/layer_impl.h"
 #include "cc/layer_tree_host_impl.h"
 #include "cc/layer_tree_impl.h"
 #include "cc/output_surface.h"
+#include "cc/picture_layer.h"
+#include "cc/prioritized_resource.h"
+#include "cc/resource_update_queue.h"
 #include "cc/single_thread_proxy.h"
+#include "cc/test/fake_content_layer.h"
 #include "cc/test/fake_content_layer_client.h"
 #include "cc/test/fake_layer_tree_host_client.h"
 #include "cc/test/fake_output_surface.h"
 #include "cc/test/fake_proxy.h"
+#include "cc/test/fake_scrollbar_layer.h"
 #include "cc/test/geometry_test_utils.h"
 #include "cc/test/layer_tree_test_common.h"
 #include "cc/test/occlusion_tracker_test_common.h"
-#include "cc/resource_update_queue.h"
+#include "cc/thread_proxy.h"
 #include "cc/timing_function.h"
+#include "skia/ext/refptr.h"
 #include "testing/gmock/include/gmock/gmock.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/khronos/GLES2/gl2ext.h"
+#include "third_party/skia/include/core/SkPicture.h"
 #include "ui/gfx/point_conversions.h"
 #include "ui/gfx/size_conversions.h"
 #include "ui/gfx/vector2d_conversions.h"
-#include <public/WebLayerScrollClient.h>
-#include <public/WebSize.h>
 
 namespace cc {
 namespace {
@@ -442,7 +449,7 @@
             m_layerTreeHost->setViewportSize(gfx::Size(0, 0), gfx::Size(0, 0));
         } else if (m_numCommits == 2) {
             char pixels[4];
-            m_layerTreeHost->compositeAndReadback(static_cast<void*>(&pixels), gfx::Rect(0, 0, 1, 1));
+            m_layerTreeHost->compositeAndReadback(&pixels, gfx::Rect(0, 0, 1, 1));
         } else if (m_numCommits == 3) {
             // Let it draw so we go idle and end the test.
             m_layerTreeHost->setViewportSize(gfx::Size(1, 1), gfx::Size(1, 1));
@@ -622,514 +629,6 @@
     runTest(true);
 }
 
-// Makes sure that setNedsAnimate does not cause the commitRequested() state to be set.
-class LayerTreeHostTestSetNeedsAnimateShouldNotSetCommitRequested : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestSetNeedsAnimateShouldNotSetCommitRequested()
-        : m_numCommits(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void animate(base::TimeTicks monotonicTime) OVERRIDE
-    {
-        // We skip the first commit becasue its the commit that populates the
-        // impl thread with a tree. After the second commit, the test is done.
-        if (m_numCommits != 1)
-            return;
-
-        m_layerTreeHost->setNeedsAnimate();
-        // Right now, commitRequested is going to be true, because during
-        // beginFrame, we force commitRequested to true to prevent requests from
-        // hitting the impl thread. But, when the next didCommit happens, we should
-        // verify that commitRequested has gone back to false.
-    }
-
-    virtual void didCommit() OVERRIDE
-    {
-        if (!m_numCommits) {
-            EXPECT_FALSE(m_layerTreeHost->commitRequested());
-            m_layerTreeHost->setNeedsAnimate();
-            EXPECT_FALSE(m_layerTreeHost->commitRequested());
-        }
-
-        // Verifies that the setNeedsAnimate we made in ::animate did not
-        // trigger commitRequested.
-        EXPECT_FALSE(m_layerTreeHost->commitRequested());
-        endTest();
-        m_numCommits++;
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-    int m_numCommits;
-};
-
-TEST_F(LayerTreeHostTestSetNeedsAnimateShouldNotSetCommitRequested, runMultiThread)
-{
-    runTest(true);
-}
-
-
-
-// Trigger a frame with setNeedsCommit. Then, inside the resulting animate
-// callback, requet another frame using setNeedsAnimate. End the test when
-// animate gets called yet-again, indicating that the proxy is correctly
-// handling the case where setNeedsAnimate() is called inside the begin frame
-// flow.
-class LayerTreeHostTestSetNeedsAnimateInsideAnimationCallback : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestSetNeedsAnimateInsideAnimationCallback()
-        : m_numAnimates(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postSetNeedsAnimateToMainThread();
-    }
-
-    virtual void animate(base::TimeTicks) OVERRIDE
-    {
-        if (!m_numAnimates) {
-            m_layerTreeHost->setNeedsAnimate();
-            m_numAnimates++;
-            return;
-        }
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-    int m_numAnimates;
-};
-
-TEST_F(LayerTreeHostTestSetNeedsAnimateInsideAnimationCallback, runMultiThread)
-{
-    runTest(true);
-}
-
-// Add a layer animation and confirm that LayerTreeHostImpl::animateLayers does get
-// called and continues to get called.
-class LayerTreeHostTestAddAnimation : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestAddAnimation()
-        : m_numAnimates(0)
-        , m_receivedAnimationStartedNotification(false)
-        , m_startTime(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postAddInstantAnimationToMainThread();
-    }
-
-    virtual void animateLayers(LayerTreeHostImpl* layerTreeHostImpl, base::TimeTicks monotonicTime) OVERRIDE
-    {
-        if (!m_numAnimates) {
-            // The animation had zero duration so layerTreeHostImpl should no
-            // longer need to animate its layers.
-            EXPECT_FALSE(layerTreeHostImpl->needsAnimateLayers());
-            m_numAnimates++;
-            m_firstMonotonicTime = monotonicTime;
-            return;
-        }
-        EXPECT_LT(0, m_startTime);
-        EXPECT_TRUE(m_receivedAnimationStartedNotification);
-        endTest();
-    }
-
-    virtual void notifyAnimationStarted(double wallClockTime) OVERRIDE
-    {
-        m_receivedAnimationStartedNotification = true;
-        m_startTime = wallClockTime;
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-    int m_numAnimates;
-    bool m_receivedAnimationStartedNotification;
-    double m_startTime;
-    base::TimeTicks m_firstMonotonicTime;
-};
-
-TEST_F(LayerTreeHostTestAddAnimation, runMultiThread)
-{
-    runTest(true);
-}
-
-// Add a layer animation to a layer, but continually fail to draw. Confirm that after
-// a while, we do eventually force a draw.
-class LayerTreeHostTestCheckerboardDoesNotStarveDraws : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestCheckerboardDoesNotStarveDraws()
-        : m_startedAnimating(false)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-    virtual void animateLayers(LayerTreeHostImpl* layerTreeHostImpl, base::TimeTicks monotonicTime) OVERRIDE
-    {
-        m_startedAnimating = true;
-    }
-
-    virtual void drawLayersOnThread(LayerTreeHostImpl*) OVERRIDE
-    {
-        if (m_startedAnimating)
-            endTest();
-    }
-
-    virtual bool prepareToDrawOnThread(LayerTreeHostImpl*) OVERRIDE
-    {
-        return false;
-    }
-
-private:
-    bool m_startedAnimating;
-};
-
-// Starvation can only be an issue with the MT compositor.
-TEST_F(LayerTreeHostTestCheckerboardDoesNotStarveDraws, runMultiThread)
-{
-    runTest(true);
-}
-
-// Ensures that animations continue to be ticked when we are backgrounded.
-class LayerTreeHostTestTickAnimationWhileBackgrounded : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestTickAnimationWhileBackgrounded()
-        : m_numAnimates(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
-    }
-
-    // Use willAnimateLayers to set visible false before the animation runs and
-    // causes a commit, so we block the second visible animate in single-thread
-    // mode.
-    virtual void willAnimateLayers(LayerTreeHostImpl* layerTreeHostImpl, base::TimeTicks monotonicTime) OVERRIDE
-    {
-        if (m_numAnimates < 2) {
-            if (!m_numAnimates) {
-                // We have a long animation running. It should continue to tick even if we are not visible.
-                postSetVisibleToMainThread(false);
-            }
-            m_numAnimates++;
-            return;
-        }
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-    int m_numAnimates;
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestTickAnimationWhileBackgrounded)
-
-// Ensures that animations continue to be ticked when we are backgrounded.
-class LayerTreeHostTestAddAnimationWithTimingFunction : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestAddAnimationWithTimingFunction()
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
-    }
-
-    virtual void animateLayers(LayerTreeHostImpl* layerTreeHostImpl, base::TimeTicks monotonicTime) OVERRIDE
-    {
-        const ActiveAnimation* animation = m_layerTreeHost->rootLayer()->layerAnimationController()->getActiveAnimation(0, ActiveAnimation::Opacity);
-        if (!animation)
-            return;
-        const FloatAnimationCurve* curve = animation->curve()->toFloatAnimationCurve();
-        float startOpacity = curve->getValue(0);
-        float endOpacity = curve->getValue(curve->duration());
-        float linearlyInterpolatedOpacity = 0.25 * endOpacity + 0.75 * startOpacity;
-        double time = curve->duration() * 0.25;
-        // If the linear timing function associated with this animation was not picked up,
-        // then the linearly interpolated opacity would be different because of the
-        // default ease timing function.
-        EXPECT_FLOAT_EQ(linearlyInterpolatedOpacity, curve->getValue(time));
-
-        const ActiveAnimation* animationImpl = layerTreeHostImpl->rootLayer()->layerAnimationController()->getActiveAnimation(0, ActiveAnimation::Opacity);
-
-        m_layerTreeHost->rootLayer()->layerAnimationController()->removeAnimation(animation->id());
-        layerTreeHostImpl->rootLayer()->layerAnimationController()->removeAnimation(animationImpl->id());
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestAddAnimationWithTimingFunction)
-
-// Ensures that main thread animations have their start times synchronized with impl thread animations.
-class LayerTreeHostTestSynchronizeAnimationStartTimes : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestSynchronizeAnimationStartTimes()
-        : m_mainStartTime(-1)
-        , m_implStartTime(-1)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
-    }
-
-    virtual void notifyAnimationStarted(double time) OVERRIDE
-    {
-        LayerAnimationController* controller = m_layerTreeHost->rootLayer()->layerAnimationController();
-        ActiveAnimation* animation = controller->getActiveAnimation(0, ActiveAnimation::Opacity);
-        m_mainStartTime = animation->startTime();
-        controller->removeAnimation(animation->id());
-
-        if (m_implStartTime > 0)
-            endTest();
-    }
-
-    virtual void animateLayers(LayerTreeHostImpl* impl, base::TimeTicks monotonicTime)
-    {
-        LayerAnimationController* controller = impl->rootLayer()->layerAnimationController();
-        ActiveAnimation* animation = controller->getActiveAnimation(0, ActiveAnimation::Opacity);
-        if (!animation)
-            return;
-
-        m_implStartTime = animation->startTime();
-        controller->removeAnimation(animation->id());
-
-        if (m_mainStartTime > 0)
-            endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        EXPECT_FLOAT_EQ(m_implStartTime, m_mainStartTime);
-    }
-
-private:
-    double m_mainStartTime;
-    double m_implStartTime;
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestSynchronizeAnimationStartTimes)
-
-// Ensures that main thread animations have their start times synchronized with impl thread animations.
-class LayerTreeHostTestAnimationFinishedEvents : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestAnimationFinishedEvents()
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postAddInstantAnimationToMainThread();
-    }
-
-    virtual void notifyAnimationFinished(double time) OVERRIDE
-    {
-        const ActiveAnimation* animation = m_layerTreeHost->rootLayer()->layerAnimationController()->getActiveAnimation(0, ActiveAnimation::Opacity);
-        m_layerTreeHost->rootLayer()->layerAnimationController()->removeAnimation(animation->id());
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestAnimationFinishedEvents)
-
-class LayerTreeHostTestScrollSimple : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestScrollSimple()
-        : m_initialScroll(10, 20)
-        , m_secondScroll(40, 5)
-        , m_scrollAmount(2, -1)
-        , m_scrolls(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->rootLayer()->setScrollable(true);
-        m_layerTreeHost->rootLayer()->setScrollOffset(m_initialScroll);
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void layout() OVERRIDE
-    {
-        Layer* root = m_layerTreeHost->rootLayer();
-        if (!m_layerTreeHost->commitNumber())
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll);
-        else {
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll + m_scrollAmount);
-
-            // Pretend like Javascript updated the scroll position itself.
-            root->setScrollOffset(m_secondScroll);
-        }
-    }
-
-    virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        LayerImpl* root = impl->rootLayer();
-        EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
-
-        root->setScrollable(true);
-        root->setMaxScrollOffset(gfx::Vector2d(100, 100));
-        root->scrollBy(m_scrollAmount);
-
-        if (!impl->activeTree()->source_frame_number()) {
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll);
-            EXPECT_VECTOR_EQ(root->scrollDelta(), m_scrollAmount);
-            postSetNeedsCommitToMainThread();
-        } else if (impl->activeTree()->source_frame_number() == 1) {
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_secondScroll);
-            EXPECT_VECTOR_EQ(root->scrollDelta(), m_scrollAmount);
-            endTest();
-        }
-    }
-
-    virtual void applyScrollAndScale(gfx::Vector2d scrollDelta, float scale) OVERRIDE
-    {
-        gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
-        m_layerTreeHost->rootLayer()->setScrollOffset(offset + scrollDelta);
-        m_scrolls++;
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        EXPECT_EQ(1, m_scrolls);
-    }
-private:
-    gfx::Vector2d m_initialScroll;
-    gfx::Vector2d m_secondScroll;
-    gfx::Vector2d m_scrollAmount;
-    int m_scrolls;
-};
-
-TEST_F(LayerTreeHostTestScrollSimple, runMultiThread)
-{
-    runTest(true);
-}
-
-class LayerTreeHostTestScrollMultipleRedraw : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestScrollMultipleRedraw()
-        : m_initialScroll(40, 10)
-        , m_scrollAmount(-3, 17)
-        , m_scrolls(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->rootLayer()->setScrollable(true);
-        m_layerTreeHost->rootLayer()->setScrollOffset(m_initialScroll);
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void beginCommitOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        Layer* root = m_layerTreeHost->rootLayer();
-        if (!m_layerTreeHost->commitNumber())
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll);
-        else if (m_layerTreeHost->commitNumber() == 1)
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll + m_scrollAmount + m_scrollAmount);
-        else if (m_layerTreeHost->commitNumber() == 2)
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll + m_scrollAmount + m_scrollAmount);
-    }
-
-    virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        LayerImpl* root = impl->rootLayer();
-        root->setScrollable(true);
-        root->setMaxScrollOffset(gfx::Vector2d(100, 100));
-
-        if (!impl->activeTree()->source_frame_number() && impl->sourceAnimationFrameNumber() == 1) {
-            // First draw after first commit.
-            EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
-            root->scrollBy(m_scrollAmount);
-            EXPECT_VECTOR_EQ(root->scrollDelta(), m_scrollAmount);
-
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll);
-            postSetNeedsRedrawToMainThread();
-        } else if (!impl->activeTree()->source_frame_number() && impl->sourceAnimationFrameNumber() == 2) {
-            // Second draw after first commit.
-            EXPECT_EQ(root->scrollDelta(), m_scrollAmount);
-            root->scrollBy(m_scrollAmount);
-            EXPECT_VECTOR_EQ(root->scrollDelta(), m_scrollAmount + m_scrollAmount);
-
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll);
-            postSetNeedsCommitToMainThread();
-        } else if (impl->activeTree()->source_frame_number() == 1) {
-            // Third or later draw after second commit.
-            EXPECT_GE(impl->sourceAnimationFrameNumber(), 3);
-            EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
-            EXPECT_VECTOR_EQ(root->scrollOffset(), m_initialScroll + m_scrollAmount + m_scrollAmount);
-            endTest();
-        }
-    }
-
-    virtual void applyScrollAndScale(gfx::Vector2d scrollDelta, float scale) OVERRIDE
-    {
-        gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
-        m_layerTreeHost->rootLayer()->setScrollOffset(offset + scrollDelta);
-        m_scrolls++;
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        EXPECT_EQ(1, m_scrolls);
-    }
-private:
-    gfx::Vector2d m_initialScroll;
-    gfx::Vector2d m_scrollAmount;
-    int m_scrolls;
-};
-
-TEST_F(LayerTreeHostTestScrollMultipleRedraw, runMultiThread)
-{
-    runTest(true);
-}
-
 // This test verifies that properties on the layer tree host are commited to the impl side.
 class LayerTreeHostTestCommit : public LayerTreeHostTest {
 public:
@@ -1148,8 +647,8 @@
     virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
     {
         EXPECT_EQ(gfx::Size(20, 20), impl->layoutViewportSize());
-        EXPECT_EQ(SK_ColorGRAY, impl->backgroundColor());
-        EXPECT_EQ(5, impl->pageScaleFactor());
+        EXPECT_EQ(SK_ColorGRAY, impl->activeTree()->background_color());
+        EXPECT_EQ(5, impl->activeTree()->page_scale_factor());
 
         endTest();
     }
@@ -1189,11 +688,11 @@
     {
         impl->rootLayer()->setScrollable(true);
         impl->rootLayer()->setScrollOffset(gfx::Vector2d());
-        impl->setPageScaleFactorAndLimits(impl->pageScaleFactor(), 0.5, 2);
+        impl->activeTree()->SetPageScaleFactorAndLimits(impl->activeTree()->page_scale_factor(), 0.5, 2);
 
         // We request animation only once.
         if (!m_animationRequested) {
-            m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&LayerTreeHostTestStartPageScaleAnimation::requestStartPageScaleAnimation, base::Unretained(this)));
+            impl->proxy()->mainThread()->postTask(base::Bind(&LayerTreeHostTestStartPageScaleAnimation::requestStartPageScaleAnimation, base::Unretained(this)));
             m_animationRequested = true;
         }
     }
@@ -1210,7 +709,7 @@
         impl->processScrollDeltas();
         // We get one commit before the first draw, and the animation doesn't happen until the second draw.
         if (impl->activeTree()->source_frame_number() == 1) {
-            EXPECT_EQ(1.25, impl->pageScaleFactor());
+            EXPECT_EQ(1.25, impl->activeTree()->page_scale_factor());
             endTest();
         } else
             postSetNeedsRedrawToMainThread();
@@ -1366,12 +865,15 @@
 
     virtual void calculateContentsScale(
         float idealContentsScale,
+        bool animatingTransformToScreen,
         float* contentsScaleX,
         float* contentsScaleY,
         gfx::Size* contentBounds) OVERRIDE
     {
+        // Skip over the ContentLayer's method to the base Layer class.
         Layer::calculateContentsScale(
              idealContentsScale,
+             animatingTransformToScreen,
              contentsScaleX,
              contentsScaleY,
              contentBounds);
@@ -1383,48 +885,6 @@
     virtual ~NoScaleContentLayer() { }
 };
 
-// Ensures that when opacity is being animated, this value does not cause the subtree to be skipped.
-class LayerTreeHostTestDoNotSkipLayersWithAnimatedOpacity : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestDoNotSkipLayersWithAnimatedOpacity()
-        : m_updateCheckLayer(ContentLayerWithUpdateTracking::create(&m_client))
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
-        m_layerTreeHost->rootLayer()->addChild(m_updateCheckLayer);
-        m_updateCheckLayer->setOpacity(0);
-        m_updateCheckLayer->drawProperties().opacity = 0;
-        postAddAnimationToMainThread(m_updateCheckLayer.get());
-    }
-
-    virtual void commitCompleteOnThread(LayerTreeHostImpl*) OVERRIDE
-    {
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        // update() should have been called once, proving that the layer was not skipped.
-        EXPECT_EQ(1, m_updateCheckLayer->paintContentsCount());
-
-        // clear m_updateCheckLayer so LayerTreeHost dies.
-        m_updateCheckLayer = NULL;
-    }
-
-private:
-    FakeContentLayerClient m_client;
-    scoped_refptr<ContentLayerWithUpdateTracking> m_updateCheckLayer;
-};
-
-TEST_F(LayerTreeHostTestDoNotSkipLayersWithAnimatedOpacity, runMultiThread)
-{
-    runTest(true);
-}
-
-
 class LayerTreeHostTestDeviceScaleFactorScalesViewportAndLayers : public LayerTreeHostTest {
 public:
 
@@ -1485,9 +945,13 @@
         EXPECT_EQ(gfx::Point(2, 2), child->position());
 
         // Compute all the layer transforms for the frame.
-        MockLayerTreeHostImpl::LayerList renderSurfaceLayerList;
-        mockImpl->calculateRenderSurfaceLayerList(renderSurfaceLayerList);
+        LayerTreeHostImpl::FrameData frameData;
+        mockImpl->prepareToDraw(frameData);
+        mockImpl->didDrawAllLayers(frameData);
 
+        const MockLayerTreeHostImpl::LayerList& renderSurfaceLayerList =
+          *frameData.renderSurfaceLayerList;
+
         // Both layers should be drawing into the root render surface.
         ASSERT_EQ(1u, renderSurfaceLayerList.size());
         ASSERT_EQ(root->renderSurface(), renderSurfaceLayerList[0]->renderSurface());
@@ -1542,51 +1006,69 @@
 class LayerTreeHostTestAtomicCommit : public LayerTreeHostTest {
 public:
     LayerTreeHostTestAtomicCommit()
-        : m_layer(ContentLayerWithUpdateTracking::create(&m_client))
     {
         // Make sure partial texture updates are turned off.
         m_settings.maxPartialTextureUpdates = 0;
+        // Linear fade animator prevents scrollbars from drawing immediately.
+        m_settings.useLinearFadeScrollbarAnimator = false;
     }
 
-    virtual void beginTest() OVERRIDE
+    virtual void setupTree() OVERRIDE
     {
+        m_layer = FakeContentLayer::Create(&m_client);
+        m_layer->setBounds(gfx::Size(10, 20));
+
+        bool paint_scrollbar = true;
+        bool has_thumb = false;
+        m_scrollbar = FakeScrollbarLayer::Create(
+            paint_scrollbar, has_thumb, m_layer->id());
+        m_scrollbar->setPosition(gfx::Point(0, 10));
+        m_scrollbar->setBounds(gfx::Size(10, 10));
+
+        m_layer->addChild(m_scrollbar);
+
         m_layerTreeHost->setRootLayer(m_layer);
-        m_layerTreeHost->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
+        LayerTreeHostTest::setupTree();
+    }
 
-        ASSERT_TRUE(m_layerTreeHost->initializeRendererIfNeeded());
-        ResourceUpdateQueue queue;
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
+    virtual void beginTest() OVERRIDE
+    {
         postSetNeedsCommitToMainThread();
     }
 
     virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
     {
-        CompositorFakeWebGraphicsContext3DWithTextureTracking* context = static_cast<CompositorFakeWebGraphicsContext3DWithTextureTracking*>(impl->outputSurface()->Context3D());
+        ASSERT_EQ(0u, m_layerTreeHost->settings().maxPartialTextureUpdates);
 
+        FakeWebGraphicsContext3D* context = static_cast<FakeWebGraphicsContext3D*>(impl->outputSurface()->Context3D());
+
         switch (impl->activeTree()->source_frame_number()) {
         case 0:
-            // Number of textures should be one.
-            ASSERT_EQ(1, context->numTextures());
-            // Number of textures used for commit should be one.
-            EXPECT_EQ(1, context->numUsedTextures());
+            // Number of textures should be one for each layer
+            ASSERT_EQ(2, context->NumTextures());
+            // Number of textures used for commit should be one for each layer.
+            EXPECT_EQ(2, context->NumUsedTextures());
             // Verify that used texture is correct.
-            EXPECT_TRUE(context->usedTexture(context->texture(0)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(0)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(1)));
 
-            context->resetUsedTextures();
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 1:
-            // Number of textures should be two as the first texture
-            // is used by impl thread and cannot by used for update.
-            ASSERT_EQ(2, context->numTextures());
-            // Number of textures used for commit should still be one.
-            EXPECT_EQ(1, context->numUsedTextures());
-            // First texture should not have been used.
-            EXPECT_FALSE(context->usedTexture(context->texture(0)));
-            // New texture should have been used.
-            EXPECT_TRUE(context->usedTexture(context->texture(1)));
+            // Number of textures should be doubled as the first textures
+            // are used by impl thread and cannot by used for update.
+            ASSERT_EQ(4, context->NumTextures());
+            // Number of textures used for commit should still be one for each layer.
+            EXPECT_EQ(2, context->NumUsedTextures());
+            // First textures should not have been used.
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(0)));
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(1)));
+            // New textures should have been used.
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(2)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(3)));
 
-            context->resetUsedTextures();
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 2:
@@ -1600,16 +1082,17 @@
 
     virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE
     {
-        CompositorFakeWebGraphicsContext3DWithTextureTracking* context = static_cast<CompositorFakeWebGraphicsContext3DWithTextureTracking*>(impl->outputSurface()->Context3D());
+        FakeWebGraphicsContext3D* context = static_cast<FakeWebGraphicsContext3D*>(impl->outputSurface()->Context3D());
 
-        // Number of textures used for draw should always be one.
-        EXPECT_EQ(1, context->numUsedTextures());
-        context->resetUsedTextures();
+        // Number of textures used for draw should always be one for each layer.
+        EXPECT_EQ(2, context->NumUsedTextures());
+        context->ResetUsedTextures();
     }
 
     virtual void layout() OVERRIDE
     {
         m_layer->setNeedsDisplay();
+        m_scrollbar->setNeedsDisplay();
     }
 
     virtual void afterTest() OVERRIDE
@@ -1618,7 +1101,8 @@
 
 private:
     FakeContentLayerClient m_client;
-    scoped_refptr<ContentLayerWithUpdateTracking> m_layer;
+    scoped_refptr<FakeContentLayer> m_layer;
+    scoped_refptr<FakeScrollbarLayer> m_scrollbar;
 };
 
 TEST_F(LayerTreeHostTestAtomicCommit, runMultiThread)
@@ -1641,78 +1125,125 @@
 class LayerTreeHostTestAtomicCommitWithPartialUpdate : public LayerTreeHostTest {
 public:
     LayerTreeHostTestAtomicCommitWithPartialUpdate()
-        : m_parent(ContentLayerWithUpdateTracking::create(&m_client))
-        , m_child(ContentLayerWithUpdateTracking::create(&m_client))
-        , m_numCommits(0)
+        : m_numCommits(0)
     {
         // Allow one partial texture update.
         m_settings.maxPartialTextureUpdates = 1;
+        // Linear fade animator prevents scrollbars from drawing immediately.
+        m_settings.useLinearFadeScrollbarAnimator = false;
     }
 
-    virtual void beginTest() OVERRIDE
+    virtual void setupTree() OVERRIDE
     {
-        m_layerTreeHost->setRootLayer(m_parent);
-        m_layerTreeHost->setViewportSize(gfx::Size(10, 20), gfx::Size(10, 20));
+        m_parent = FakeContentLayer::Create(&m_client);
+        m_parent->setBounds(gfx::Size(10, 20));
 
-        gfx::Transform identityMatrix;
-        setLayerPropertiesForTesting(m_parent.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(10, 20), true);
-        setLayerPropertiesForTesting(m_child.get(), m_parent.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 10), gfx::Size(10, 10), false);
+        m_child = FakeContentLayer::Create(&m_client);
+        m_child->setPosition(gfx::Point(0, 10));
+        m_child->setBounds(gfx::Size(3, 10));
 
-        ASSERT_TRUE(m_layerTreeHost->initializeRendererIfNeeded());
-        ResourceUpdateQueue queue;
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
+        bool paint_scrollbar = true;
+        bool has_thumb = false;
+        m_scrollbarWithPaints = FakeScrollbarLayer::Create(
+            paint_scrollbar, has_thumb, m_parent->id());
+        m_scrollbarWithPaints->setPosition(gfx::Point(3, 10));
+        m_scrollbarWithPaints->setBounds(gfx::Size(3, 10));
+
+        paint_scrollbar = false;
+        m_scrollbarWithoutPaints = FakeScrollbarLayer::Create(
+            paint_scrollbar, has_thumb, m_parent->id());
+        m_scrollbarWithoutPaints->setPosition(gfx::Point(6, 10));
+        m_scrollbarWithoutPaints->setBounds(gfx::Size(3, 10));
+
+        m_parent->addChild(m_child);
+        m_parent->addChild(m_scrollbarWithPaints);
+        m_parent->addChild(m_scrollbarWithoutPaints);
+
+        m_layerTreeHost->setRootLayer(m_parent);
+        LayerTreeHostTest::setupTree();
+    }
+
+    virtual void beginTest() OVERRIDE
+    {
         postSetNeedsCommitToMainThread();
     }
 
     virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
     {
-        CompositorFakeWebGraphicsContext3DWithTextureTracking* context = static_cast<CompositorFakeWebGraphicsContext3DWithTextureTracking*>(impl->outputSurface()->Context3D());
+        ASSERT_EQ(1u, m_layerTreeHost->settings().maxPartialTextureUpdates);
 
+        FakeWebGraphicsContext3D* context = static_cast<FakeWebGraphicsContext3D*>(impl->outputSurface()->Context3D());
+
         switch (impl->activeTree()->source_frame_number()) {
         case 0:
-            // Number of textures should be two.
-            ASSERT_EQ(2, context->numTextures());
-            // Number of textures used for commit should be two.
-            EXPECT_EQ(2, context->numUsedTextures());
+            // Number of textures should be one for each layer.
+            ASSERT_EQ(4, context->NumTextures());
+            // Number of textures used for commit should be one for each layer.
+            EXPECT_EQ(4, context->NumUsedTextures());
             // Verify that used textures are correct.
-            EXPECT_TRUE(context->usedTexture(context->texture(0)));
-            EXPECT_TRUE(context->usedTexture(context->texture(1)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(0)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(1)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(2)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(3)));
 
-            context->resetUsedTextures();
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 1:
-            // Number of textures used for commit should still be two.
-            EXPECT_EQ(2, context->numUsedTextures());
-            // First two textures should not have been used.
-            EXPECT_FALSE(context->usedTexture(context->texture(0)));
-            EXPECT_FALSE(context->usedTexture(context->texture(1)));
+            // Number of textures should be two for each content layer and one
+            // for each scrollbar, since they always do a partial update.
+            ASSERT_EQ(6, context->NumTextures());
+            // Number of textures used for commit should be one for each content
+            // layer, and one for the scrollbar layer that paints.
+            EXPECT_EQ(3, context->NumUsedTextures());
+
+            // First content textures should not have been used.
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(0)));
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(1)));
+            // The non-painting scrollbar's texture wasn't updated.
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(2)));
+            // The painting scrollbar's partial update texture was used.
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(3)));
             // New textures should have been used.
-            EXPECT_TRUE(context->usedTexture(context->texture(2)));
-            EXPECT_TRUE(context->usedTexture(context->texture(3)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(4)));
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(5)));
 
-            context->resetUsedTextures();
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 2:
-            // Number of textures used for commit should still be two.
-            EXPECT_EQ(2, context->numUsedTextures());
+            // Number of textures should be two for each content layer and one
+            // for each scrollbar, since they always do a partial update.
+            ASSERT_EQ(6, context->NumTextures());
+            // Number of textures used for commit should be one for each content
+            // layer, and one for the scrollbar layer that paints.
+            EXPECT_EQ(3, context->NumUsedTextures());
 
-            context->resetUsedTextures();
+            // The non-painting scrollbar's texture wasn't updated.
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(2)));
+            // The painting scrollbar does a partial update.
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(3)));
+            // One content layer does a partial update also.
+            EXPECT_TRUE(context->UsedTexture(context->TextureAt(4)));
+            EXPECT_FALSE(context->UsedTexture(context->TextureAt(5)));
+
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 3:
             // No textures should be used for commit.
-            EXPECT_EQ(0, context->numUsedTextures());
+            EXPECT_EQ(0, context->NumUsedTextures());
 
-            context->resetUsedTextures();
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 4:
-            // Number of textures used for commit should be one.
-            EXPECT_EQ(1, context->numUsedTextures());
+            // Number of textures used for commit should be two. One for the
+            // content layer, and one for the painting scrollbar. The
+            // non-painting scrollbar doesn't update its texture.
+            EXPECT_EQ(2, context->NumUsedTextures());
 
-            context->resetUsedTextures();
+            context->ResetUsedTextures();
             postSetNeedsCommitToMainThread();
             break;
         case 5:
@@ -1726,16 +1257,16 @@
 
     virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE
     {
-        CompositorFakeWebGraphicsContext3DWithTextureTracking* context = static_cast<CompositorFakeWebGraphicsContext3DWithTextureTracking*>(impl->outputSurface()->Context3D());
+        FakeWebGraphicsContext3D* context = static_cast<FakeWebGraphicsContext3D*>(impl->outputSurface()->Context3D());
 
-        // Number of textures used for drawing should two except for frame 4
-        // where the viewport only contains one layer.
+        // Number of textures used for drawing should one per layer except for
+        // frame 3 where the viewport only contains one layer.
         if (impl->activeTree()->source_frame_number() == 3)
-            EXPECT_EQ(1, context->numUsedTextures());
+            EXPECT_EQ(1, context->NumUsedTextures());
         else
-            EXPECT_EQ(2, context->numUsedTextures());
+            EXPECT_EQ(4, context->NumUsedTextures());
 
-        context->resetUsedTextures();
+        context->ResetUsedTextures();
     }
 
     virtual void layout() OVERRIDE
@@ -1745,14 +1276,20 @@
         case 1:
             m_parent->setNeedsDisplay();
             m_child->setNeedsDisplay();
+            m_scrollbarWithPaints->setNeedsDisplay();
+            m_scrollbarWithoutPaints->setNeedsDisplay();
             break;
         case 2:
             // Damage part of layers.
             m_parent->setNeedsDisplayRect(gfx::RectF(0, 0, 5, 5));
             m_child->setNeedsDisplayRect(gfx::RectF(0, 0, 5, 5));
+            m_scrollbarWithPaints->setNeedsDisplayRect(gfx::RectF(0, 0, 5, 5));
+            m_scrollbarWithoutPaints->setNeedsDisplayRect(gfx::RectF(0, 0, 5, 5));
             break;
         case 3:
             m_child->setNeedsDisplay();
+            m_scrollbarWithPaints->setNeedsDisplay();
+            m_scrollbarWithoutPaints->setNeedsDisplay();
             m_layerTreeHost->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
             break;
         case 4:
@@ -1772,8 +1309,10 @@
 
 private:
     FakeContentLayerClient m_client;
-    scoped_refptr<ContentLayerWithUpdateTracking> m_parent;
-    scoped_refptr<ContentLayerWithUpdateTracking> m_child;
+    scoped_refptr<FakeContentLayer> m_parent;
+    scoped_refptr<FakeContentLayer> m_child;
+    scoped_refptr<FakeScrollbarLayer> m_scrollbarWithPaints;
+    scoped_refptr<FakeScrollbarLayer> m_scrollbarWithoutPaints;
     int m_numCommits;
 };
 
@@ -1782,454 +1321,6 @@
     runTest(true);
 }
 
-class TestLayer : public Layer {
-public:
-    static scoped_refptr<TestLayer> create() { return make_scoped_refptr(new TestLayer()); }
-
-    virtual void update(ResourceUpdateQueue&, const OcclusionTracker* occlusion, RenderingStats&) OVERRIDE
-    {
-        // Gain access to internals of the OcclusionTracker.
-        const TestOcclusionTracker* testOcclusion = static_cast<const TestOcclusionTracker*>(occlusion);
-        if (!testOcclusion) {
-            m_occlusion.Clear();
-            return;
-        }
-        m_occlusion = UnionRegions(testOcclusion->occlusionFromInsideTarget(), testOcclusion->occlusionFromOutsideTarget());
-    }
-
-    virtual bool drawsContent() const OVERRIDE { return true; }
-
-    const Region& occlusion() const { return m_occlusion; }
-    void clearOcclusion() { m_occlusion.Clear(); }
-
-private:
-    TestLayer() : Layer() { }
-    virtual ~TestLayer() { }
-
-    Region m_occlusion;
-};
-
-static void setTestLayerPropertiesForTesting(TestLayer* layer, Layer* parent, const gfx::Transform& transform, const gfx::PointF& anchor, const gfx::PointF& position, const gfx::Size& bounds, bool opaque)
-{
-    setLayerPropertiesForTesting(layer, parent, transform, anchor, position, bounds, opaque);
-    layer->clearOcclusion();
-}
-
-class LayerTreeHostTestLayerOcclusion : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestLayerOcclusion() { }
-
-    virtual void beginTest() OVERRIDE
-    {
-        scoped_refptr<TestLayer> rootLayer = TestLayer::create();
-        scoped_refptr<TestLayer> child = TestLayer::create();
-        scoped_refptr<TestLayer> child2 = TestLayer::create();
-        scoped_refptr<TestLayer> grandChild = TestLayer::create();
-        scoped_refptr<TestLayer> mask = TestLayer::create();
-
-        gfx::Transform identityMatrix;
-
-        child->setMasksToBounds(true);
-        child->setForceRenderSurface(true);
-
-        // See LayerTreeHostCommonTest.layerAddsSelfToOccludedRegionWithRotatedSurface for a nice visual of these layers and how they end up
-        // positioned on the screen.
-
-        // The child layer is a surface and the grandChild is opaque, but clipped to the child and rootLayer
-        setTestLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setTestLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), false);
-        setTestLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(20, 500), true);
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        ASSERT_TRUE(m_layerTreeHost->initializeRendererIfNeeded());
-        ResourceUpdateQueue queue;
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 10, 190).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 10, 10, 190).ToString(), rootLayer->occlusion().ToString());
-
-        // If the child layer is opaque, then it adds to the occlusion seen by the rootLayer.
-        setLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(20, 500), true);
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 10, 190).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 10, 190, 190).ToString(), rootLayer->occlusion().ToString());
-
-        // Add a second child to the root layer and the regions should merge
-        setTestLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setTestLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), false);
-        setTestLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(20, 500), true);
-        setTestLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(20, 10), gfx::Size(10, 500), true);
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 0, 10, 190).ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 20, 190).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 10, 20, 190).ToString(), rootLayer->occlusion().ToString());
-
-        // If the child layer has a mask on it, then it shouldn't contribute to occlusion on stuff below it
-        setLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(20, 20), gfx::Size(500, 500), true);
-        setLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(500, 500), true);
-
-        child->setMaskLayer(mask.get());
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 180, 180).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 10, 190, 190).ToString(), rootLayer->occlusion().ToString());
-
-        // If the child layer with a mask is below child2, then child2 should contribute to occlusion on everything, and child shouldn't contribute to the rootLayer
-        setLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(20, 500), true);
-        setLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(20, 10), gfx::Size(10, 500), true);
-
-        child->setMaskLayer(mask.get());
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 0, 10, 190).ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 20, 190).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(20, 10, 10, 190), rootLayer->occlusion());
-
-        // If the child layer has a non-opaque drawOpacity, then it shouldn't contribute to occlusion on stuff below it
-        setTestLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setTestLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(20, 10), gfx::Size(10, 500), true);
-        setTestLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setTestLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(20, 500), true);
-
-        child->setMaskLayer(0);
-        child->setOpacity(0.5);
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 10, 190).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(20, 10, 10, 190).ToString(), rootLayer->occlusion().ToString());
-
-        // If the child layer with non-opaque drawOpacity is below child2, then child2 should contribute to occlusion on everything, and child shouldn't contribute to the rootLayer
-        setTestLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setTestLayerPropertiesForTesting(child.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setTestLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(-10, -10), gfx::Size(20, 500), true);
-        setTestLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(20, 10), gfx::Size(10, 500), true);
-
-        child->setMaskLayer(0);
-        child->setOpacity(0.5);
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 0, 10, 190).ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(0, 0, 20, 190).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(20, 10, 10, 190).ToString(), rootLayer->occlusion().ToString());
-
-        // Kill the layerTreeHost immediately.
-        m_layerTreeHost->setRootLayer(0);
-        m_layerTreeHost.reset();
-
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestLayerOcclusion)
-
-class LayerTreeHostTestLayerOcclusionWithFilters : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestLayerOcclusionWithFilters() { }
-
-    virtual void beginTest() OVERRIDE
-    {
-        scoped_refptr<TestLayer> rootLayer = TestLayer::create();
-        scoped_refptr<TestLayer> child = TestLayer::create();
-        scoped_refptr<TestLayer> child2 = TestLayer::create();
-        scoped_refptr<TestLayer> grandChild = TestLayer::create();
-        scoped_refptr<TestLayer> mask = TestLayer::create();
-
-        gfx::Transform identityMatrix;
-        gfx::Transform childTransform;
-        childTransform.Translate(250, 250);
-        childTransform.Rotate(90);
-        childTransform.Translate(-250, -250);
-
-        child->setMasksToBounds(true);
-
-        // If the child layer has a filter that changes alpha values, and is below child2, then child2 should contribute to occlusion on everything,
-        // and child shouldn't contribute to the rootLayer
-        setTestLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setTestLayerPropertiesForTesting(child.get(), rootLayer.get(), childTransform, gfx::PointF(0, 0), gfx::PointF(30, 30), gfx::Size(500, 500), true);
-        setTestLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setTestLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 70), gfx::Size(500, 500), true);
-
-        {
-            WebKit::WebFilterOperations filters;
-            filters.append(WebKit::WebFilterOperation::createOpacityFilter(0.5));
-            child->setFilters(filters);
-        }
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        ASSERT_TRUE(m_layerTreeHost->initializeRendererIfNeeded());
-        ResourceUpdateQueue queue;
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(40, 330, 130, 190).ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(UnionRegions(gfx::Rect(10, 330, 160, 170), gfx::Rect(40, 500, 130, 20)).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 70, 190, 130).ToString(), rootLayer->occlusion().ToString());
-
-        // If the child layer has a filter that moves pixels/changes alpha, and is below child2, then child should not inherit occlusion from outside its subtree,
-        // and should not contribute to the rootLayer
-        setTestLayerPropertiesForTesting(rootLayer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        setTestLayerPropertiesForTesting(child.get(), rootLayer.get(), childTransform, gfx::PointF(0, 0), gfx::PointF(30, 30), gfx::Size(500, 500), true);
-        setTestLayerPropertiesForTesting(grandChild.get(), child.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 10), gfx::Size(500, 500), true);
-        setTestLayerPropertiesForTesting(child2.get(), rootLayer.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(10, 70), gfx::Size(500, 500), true);
-
-        {
-            WebKit::WebFilterOperations filters;
-            filters.append(WebKit::WebFilterOperation::createBlurFilter(10));
-            child->setFilters(filters);
-        }
-
-        m_layerTreeHost->setRootLayer(rootLayer);
-        m_layerTreeHost->setViewportSize(rootLayer->bounds(), rootLayer->bounds());
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        EXPECT_EQ(gfx::Rect().ToString(), child2->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect().ToString(), grandChild->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 330, 160, 170).ToString(), child->occlusion().ToString());
-        EXPECT_EQ(gfx::Rect(10, 70, 190, 130).ToString(), rootLayer->occlusion().ToString());
-
-        // Kill the layerTreeHost immediately.
-        m_layerTreeHost->setRootLayer(0);
-        m_layerTreeHost.reset();
-
-        LayerTreeHost::setNeedsFilterContext(false);
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestLayerOcclusionWithFilters)
-
-class LayerTreeHostTestManySurfaces : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestManySurfaces() { }
-
-    virtual void beginTest() OVERRIDE
-    {
-        // We create enough RenderSurfaces that it will trigger Vector reallocation while computing occlusion.
-        Region occluded;
-        const gfx::Transform identityMatrix;
-        std::vector<scoped_refptr<TestLayer> > layers;
-        std::vector<scoped_refptr<TestLayer> > children;
-        int numSurfaces = 20;
-        scoped_refptr<TestLayer> replica = TestLayer::create();
-
-        for (int i = 0; i < numSurfaces; ++i) {
-            layers.push_back(TestLayer::create());
-            if (!i) {
-                setTestLayerPropertiesForTesting(layers.back().get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(200, 200), true);
-                layers.back()->createRenderSurface();
-            } else {
-                setTestLayerPropertiesForTesting(layers.back().get(), layers[layers.size()-2].get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(1, 1), gfx::Size(200-i, 200-i), true);
-                layers.back()->setMasksToBounds(true);
-                layers.back()->setReplicaLayer(replica.get()); // Make it have a RenderSurfaceImpl
-            }
-        }
-
-        for (int i = 1; i < numSurfaces; ++i) {
-            children.push_back(TestLayer::create());
-            setTestLayerPropertiesForTesting(children.back().get(), layers[i].get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(500, 500), false);
-        }
-
-        m_layerTreeHost->setRootLayer(layers[0].get());
-        m_layerTreeHost->setViewportSize(layers[0]->bounds(), layers[0]->bounds());
-        ASSERT_TRUE(m_layerTreeHost->initializeRendererIfNeeded());
-        ResourceUpdateQueue queue;
-        m_layerTreeHost->updateLayers(queue, std::numeric_limits<size_t>::max());
-        m_layerTreeHost->commitComplete();
-
-        for (int i = 0; i < numSurfaces-1; ++i) {
-            gfx::Rect expectedOcclusion(1, 1, 200-i-1, 200-i-1);
-            EXPECT_EQ(expectedOcclusion.ToString(), layers[i]->occlusion().ToString());
-        }
-
-        // Kill the layerTreeHost immediately.
-        m_layerTreeHost->setRootLayer(0);
-        m_layerTreeHost.reset();
-
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestManySurfaces)
-
-// A loseOutputSurface(1) should lead to a didRecreateOutputSurface(true)
-class LayerTreeHostTestSetSingleLostContext : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestSetSingleLostContext()
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void didCommitAndDrawFrame() OVERRIDE
-    {
-        m_layerTreeHost->loseOutputSurface(1);
-    }
-
-    virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE
-    {
-        EXPECT_TRUE(succeeded);
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-};
-
-TEST_F(LayerTreeHostTestSetSingleLostContext, runMultiThread)
-{
-    runTest(true);
-}
-
-// A loseOutputSurface(10) should lead to a didRecreateOutputSurface(false), and
-// a finishAllRendering() should not hang.
-class LayerTreeHostTestSetRepeatedLostContext : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestSetRepeatedLostContext()
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void didCommitAndDrawFrame() OVERRIDE
-    {
-        m_layerTreeHost->loseOutputSurface(10);
-    }
-
-    virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE
-    {
-        EXPECT_FALSE(succeeded);
-        m_layerTreeHost->finishAllRendering();
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-};
-
-TEST_F(LayerTreeHostTestSetRepeatedLostContext, runMultiThread)
-{
-    runTest(true);
-}
-
-class LayerTreeHostTestFractionalScroll : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestFractionalScroll()
-        : m_scrollAmount(1.75, 0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->rootLayer()->setScrollable(true);
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        LayerImpl* root = impl->rootLayer();
-        root->setMaxScrollOffset(gfx::Vector2d(100, 100));
-
-        // Check that a fractional scroll delta is correctly accumulated over multiple commits.
-        if (!impl->activeTree()->source_frame_number()) {
-            EXPECT_VECTOR_EQ(root->scrollOffset(), gfx::Vector2d(0, 0));
-            EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d(0, 0));
-            postSetNeedsCommitToMainThread();
-        } else if (impl->activeTree()->source_frame_number() == 1) {
-            EXPECT_VECTOR_EQ(root->scrollOffset(), gfx::ToFlooredVector2d(m_scrollAmount));
-            EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2dF(fmod(m_scrollAmount.x(), 1), 0));
-            postSetNeedsCommitToMainThread();
-        } else if (impl->activeTree()->source_frame_number() == 2) {
-            EXPECT_VECTOR_EQ(root->scrollOffset(), gfx::ToFlooredVector2d(m_scrollAmount + m_scrollAmount));
-            EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2dF(fmod(2 * m_scrollAmount.x(), 1), 0));
-            endTest();
-        }
-        root->scrollBy(m_scrollAmount);
-    }
-
-    virtual void applyScrollAndScale(gfx::Vector2d scrollDelta, float scale) OVERRIDE
-    {
-        gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
-        m_layerTreeHost->rootLayer()->setScrollOffset(offset + scrollDelta);
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-private:
-    gfx::Vector2dF m_scrollAmount;
-};
-
-TEST_F(LayerTreeHostTestFractionalScroll, runMultiThread)
-{
-    runTest(true);
-}
-
 class LayerTreeHostTestFinishAllRendering : public LayerTreeHostTest {
 public:
     LayerTreeHostTestFinishAllRendering()
@@ -2281,339 +1372,6 @@
 
 SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestFinishAllRendering)
 
-// Layers added to tree with existing active animations should have the animation
-// correctly recognized.
-class LayerTreeHostTestLayerAddedWithAnimation : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestLayerAddedWithAnimation()
-        : m_addedAnimation(false)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        EXPECT_FALSE(m_addedAnimation);
-
-        scoped_refptr<Layer> layer = Layer::create();
-        layer->setLayerAnimationDelegate(this);
-
-        // Any valid AnimationCurve will do here.
-        scoped_ptr<AnimationCurve> curve(EaseTimingFunction::create());
-        scoped_ptr<ActiveAnimation> animation(ActiveAnimation::create(curve.Pass(), 1, 1, ActiveAnimation::Opacity));
-        layer->layerAnimationController()->addAnimation(animation.Pass());
-
-        // We add the animation *before* attaching the layer to the tree.
-        m_layerTreeHost->rootLayer()->addChild(layer);
-        EXPECT_TRUE(m_addedAnimation);
-
-        endTest();
-    }
-
-    virtual void didAddAnimation() OVERRIDE
-    {
-        m_addedAnimation = true;
-    }
-
-    virtual void afterTest() OVERRIDE { }
-
-private:
-    bool m_addedAnimation;
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestLayerAddedWithAnimation)
-
-class LayerTreeHostTestScrollChildLayer : public LayerTreeHostTest, public WebKit::WebLayerScrollClient {
-public:
-    LayerTreeHostTestScrollChildLayer(float deviceScaleFactor)
-        : m_deviceScaleFactor(deviceScaleFactor)
-        , m_initialScroll(10, 20)
-        , m_secondScroll(40, 5)
-        , m_scrollAmount(2, -1)
-        , m_rootScrolls(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        gfx::Size viewportSize(10, 10);
-        gfx::Size deviceViewportSize = gfx::ToCeiledSize(gfx::ScaleSize(viewportSize, m_deviceScaleFactor));
-        m_layerTreeHost->setViewportSize(viewportSize, deviceViewportSize);
-
-        m_layerTreeHost->setDeviceScaleFactor(m_deviceScaleFactor);
-
-        m_rootScrollLayer = ContentLayer::create(&m_fakeDelegate);
-        m_rootScrollLayer->setBounds(gfx::Size(110, 110));
-
-        m_rootScrollLayer->setPosition(gfx::PointF(0, 0));
-        m_rootScrollLayer->setAnchorPoint(gfx::PointF(0, 0));
-
-        m_rootScrollLayer->setIsDrawable(true);
-        m_rootScrollLayer->setScrollable(true);
-        m_rootScrollLayer->setMaxScrollOffset(gfx::Vector2d(100, 100));
-        m_layerTreeHost->rootLayer()->addChild(m_rootScrollLayer);
-
-        m_childLayer = ContentLayer::create(&m_fakeDelegate);
-        m_childLayer->setLayerScrollClient(this);
-        m_childLayer->setBounds(gfx::Size(110, 110));
-
-        // The scrolls will happen at 5, 5. If they are treated like device pixels, then
-        // they will be at 2.5, 2.5 in logical pixels, and will miss this layer.
-        m_childLayer->setPosition(gfx::PointF(5, 5));
-        m_childLayer->setAnchorPoint(gfx::PointF(0, 0));
-
-        m_childLayer->setIsDrawable(true);
-        m_childLayer->setScrollable(true);
-        m_childLayer->setMaxScrollOffset(gfx::Vector2d(100, 100));
-        m_rootScrollLayer->addChild(m_childLayer);
-
-        m_childLayer->setScrollOffset(m_initialScroll);
-
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void didScroll() OVERRIDE
-    {
-        m_finalScrollOffset = m_childLayer->scrollOffset();
-    }
-
-    virtual void applyScrollAndScale(gfx::Vector2d scrollDelta, float scale) OVERRIDE
-    {
-        gfx::Vector2d offset = m_rootScrollLayer->scrollOffset();
-        m_rootScrollLayer->setScrollOffset(offset + scrollDelta);
-        m_rootScrolls++;
-    }
-
-    virtual void layout() OVERRIDE
-    {
-        EXPECT_VECTOR_EQ(gfx::Vector2d(), m_rootScrollLayer->scrollOffset());
-
-        switch (m_layerTreeHost->commitNumber()) {
-        case 0:
-            EXPECT_VECTOR_EQ(m_initialScroll, m_childLayer->scrollOffset());
-            break;
-        case 1:
-            EXPECT_VECTOR_EQ(m_initialScroll + m_scrollAmount, m_childLayer->scrollOffset());
-
-            // Pretend like Javascript updated the scroll position itself.
-            m_childLayer->setScrollOffset(m_secondScroll);
-            break;
-        case 2:
-            EXPECT_VECTOR_EQ(m_secondScroll + m_scrollAmount, m_childLayer->scrollOffset());
-            break;
-        }
-    }
-
-    virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        LayerImpl* root = impl->rootLayer();
-        LayerImpl* rootScrollLayer = root->children()[0];
-        LayerImpl* childLayer = rootScrollLayer->children()[0];
-
-        EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
-        EXPECT_VECTOR_EQ(rootScrollLayer->scrollDelta(), gfx::Vector2d());
-        EXPECT_EQ(rootScrollLayer->bounds().width() * m_deviceScaleFactor, rootScrollLayer->contentBounds().width());
-        EXPECT_EQ(rootScrollLayer->bounds().height() * m_deviceScaleFactor, rootScrollLayer->contentBounds().height());
-        EXPECT_EQ(childLayer->bounds().width() * m_deviceScaleFactor, childLayer->contentBounds().width());
-        EXPECT_EQ(childLayer->bounds().height() * m_deviceScaleFactor, childLayer->contentBounds().height());
-
-        switch (impl->activeTree()->source_frame_number()) {
-        case 0:
-            // Gesture scroll on impl thread.
-            EXPECT_EQ(impl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::Gesture), InputHandlerClient::ScrollStarted);
-            impl->scrollBy(gfx::Point(), m_scrollAmount);
-            impl->scrollEnd();
-
-            EXPECT_VECTOR_EQ(m_initialScroll, childLayer->scrollOffset());
-            EXPECT_VECTOR_EQ(m_scrollAmount, childLayer->scrollDelta());
-            break;
-        case 1:
-            // Wheel scroll on impl thread.
-            EXPECT_EQ(impl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
-            impl->scrollBy(gfx::Point(), m_scrollAmount);
-            impl->scrollEnd();
-
-            EXPECT_VECTOR_EQ(m_secondScroll, childLayer->scrollOffset());
-            EXPECT_VECTOR_EQ(m_scrollAmount, childLayer->scrollDelta());
-            break;
-        case 2:
-            EXPECT_VECTOR_EQ(m_secondScroll + m_scrollAmount, childLayer->scrollOffset());
-            EXPECT_VECTOR_EQ(gfx::Vector2d(0, 0), childLayer->scrollDelta());
-
-            endTest();
-        }
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        EXPECT_EQ(0, m_rootScrolls);
-        EXPECT_VECTOR_EQ(m_secondScroll + m_scrollAmount, m_finalScrollOffset);
-    }
-
-private:
-    float m_deviceScaleFactor;
-    gfx::Vector2d m_initialScroll;
-    gfx::Vector2d m_secondScroll;
-    gfx::Vector2d m_scrollAmount;
-    int m_rootScrolls;
-    gfx::Vector2d m_finalScrollOffset;
-
-    FakeContentLayerClient m_fakeDelegate;
-    scoped_refptr<Layer> m_rootScrollLayer;
-    scoped_refptr<Layer> m_childLayer;
-};
-
-class LayerTreeHostTestScrollChildLayerNormalDpi : public LayerTreeHostTestScrollChildLayer {
-public:
-    LayerTreeHostTestScrollChildLayerNormalDpi() : LayerTreeHostTestScrollChildLayer(1) { }
-};
-
-TEST_F(LayerTreeHostTestScrollChildLayerNormalDpi, runMultiThread)
-{
-    runTest(true);
-}
-
-class LayerTreeHostTestScrollChildLayerHighDpi : public LayerTreeHostTestScrollChildLayer {
-public:
-    LayerTreeHostTestScrollChildLayerHighDpi() : LayerTreeHostTestScrollChildLayer(2) { }
-};
-
-TEST_F(LayerTreeHostTestScrollChildLayerHighDpi, runMultiThread)
-{
-    runTest(true);
-}
-
-class LayerTreeHostTestScrollRootScrollLayer : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestScrollRootScrollLayer(float deviceScaleFactor)
-        : m_deviceScaleFactor(deviceScaleFactor)
-        , m_initialScroll(10, 20)
-        , m_secondScroll(40, 5)
-        , m_scrollAmount(2, -1)
-        , m_rootScrolls(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        gfx::Size viewportSize(10, 10);
-        gfx::Size deviceViewportSize = gfx::ToCeiledSize(gfx::ScaleSize(viewportSize, m_deviceScaleFactor));
-        m_layerTreeHost->setViewportSize(viewportSize, deviceViewportSize);
-
-        m_layerTreeHost->setDeviceScaleFactor(m_deviceScaleFactor);
-
-        m_rootScrollLayer = ContentLayer::create(&m_fakeDelegate);
-        m_rootScrollLayer->setBounds(gfx::Size(110, 110));
-
-        m_rootScrollLayer->setPosition(gfx::PointF(0, 0));
-        m_rootScrollLayer->setAnchorPoint(gfx::PointF(0, 0));
-
-        m_rootScrollLayer->setIsDrawable(true);
-        m_rootScrollLayer->setScrollable(true);
-        m_rootScrollLayer->setMaxScrollOffset(gfx::Vector2d(100, 100));
-        m_layerTreeHost->rootLayer()->addChild(m_rootScrollLayer);
-
-        m_rootScrollLayer->setScrollOffset(m_initialScroll);
-
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void applyScrollAndScale(gfx::Vector2d scrollDelta, float scale) OVERRIDE
-    {
-        gfx::Vector2d offset = m_rootScrollLayer->scrollOffset();
-        m_rootScrollLayer->setScrollOffset(offset + scrollDelta);
-        m_rootScrolls++;
-    }
-
-    virtual void layout() OVERRIDE
-    {
-        switch (m_layerTreeHost->commitNumber()) {
-        case 0:
-            EXPECT_VECTOR_EQ(m_initialScroll, m_rootScrollLayer->scrollOffset());
-            break;
-        case 1:
-            EXPECT_VECTOR_EQ(m_initialScroll + m_scrollAmount, m_rootScrollLayer->scrollOffset());
-
-            // Pretend like Javascript updated the scroll position itself.
-            m_rootScrollLayer->setScrollOffset(m_secondScroll);
-            break;
-        case 2:
-            EXPECT_VECTOR_EQ(m_secondScroll + m_scrollAmount, m_rootScrollLayer->scrollOffset());
-            break;
-        }
-    }
-
-    virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        LayerImpl* root = impl->rootLayer();
-        LayerImpl* rootScrollLayer = root->children()[0];
-
-        EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
-        EXPECT_EQ(rootScrollLayer->bounds().width() * m_deviceScaleFactor, rootScrollLayer->contentBounds().width());
-        EXPECT_EQ(rootScrollLayer->bounds().height() * m_deviceScaleFactor, rootScrollLayer->contentBounds().height());
-
-        switch (impl->activeTree()->source_frame_number()) {
-        case 0:
-            // Gesture scroll on impl thread.
-            EXPECT_EQ(impl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::Gesture), InputHandlerClient::ScrollStarted);
-            impl->scrollBy(gfx::Point(), m_scrollAmount);
-            impl->scrollEnd();
-
-            EXPECT_VECTOR_EQ(m_initialScroll, rootScrollLayer->scrollOffset());
-            EXPECT_VECTOR_EQ(m_scrollAmount, rootScrollLayer->scrollDelta());
-            break;
-        case 1:
-            // Wheel scroll on impl thread.
-            EXPECT_EQ(impl->scrollBegin(gfx::Point(5, 5), InputHandlerClient::Wheel), InputHandlerClient::ScrollStarted);
-            impl->scrollBy(gfx::Point(), m_scrollAmount);
-            impl->scrollEnd();
-
-            EXPECT_VECTOR_EQ(m_secondScroll, rootScrollLayer->scrollOffset());
-            EXPECT_VECTOR_EQ(m_scrollAmount, rootScrollLayer->scrollDelta());
-            break;
-        case 2:
-            EXPECT_VECTOR_EQ(m_secondScroll + m_scrollAmount, rootScrollLayer->scrollOffset());
-            EXPECT_VECTOR_EQ(gfx::Vector2d(0, 0), rootScrollLayer->scrollDelta());
-
-            endTest();
-        }
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        EXPECT_EQ(2, m_rootScrolls);
-    }
-
-private:
-    float m_deviceScaleFactor;
-    gfx::Vector2d m_initialScroll;
-    gfx::Vector2d m_secondScroll;
-    gfx::Vector2d m_scrollAmount;
-    int m_rootScrolls;
-
-    FakeContentLayerClient m_fakeDelegate;
-    scoped_refptr<Layer> m_rootScrollLayer;
-};
-
-class LayerTreeHostTestScrollRootScrollLayerNormalDpi : public LayerTreeHostTestScrollRootScrollLayer {
-public:
-    LayerTreeHostTestScrollRootScrollLayerNormalDpi() : LayerTreeHostTestScrollRootScrollLayer(1) { }
-};
-
-TEST_F(LayerTreeHostTestScrollRootScrollLayerNormalDpi, runMultiThread)
-{
-    runTest(true);
-}
-
-class LayerTreeHostTestScrollRootScrollLayerHighDpi : public LayerTreeHostTestScrollRootScrollLayer {
-public:
-    LayerTreeHostTestScrollRootScrollLayerHighDpi() : LayerTreeHostTestScrollRootScrollLayer(2) { }
-};
-
-TEST_F(LayerTreeHostTestScrollRootScrollLayerHighDpi, runMultiThread)
-{
-    runTest(true);
-}
-
 class LayerTreeHostTestCompositeAndReadbackCleanup : public LayerTreeHostTest {
 public:
     LayerTreeHostTestCompositeAndReadbackCleanup() { }
@@ -2636,48 +1394,6 @@
 
 SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestCompositeAndReadbackCleanup)
 
-class LayerTreeHostTestCompositeAndReadbackAnimateCount : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestCompositeAndReadbackAnimateCount()
-        : m_layoutCount(0)
-    {
-    }
-
-    virtual void animate(base::TimeTicks) OVERRIDE
-    {
-        // We shouldn't animate on the compositeAndReadback-forced commit, but we should
-        // for the setNeedsCommit-triggered commit.
-        EXPECT_EQ(1, m_layoutCount);
-    }
-
-    virtual void layout() OVERRIDE
-    {
-        m_layoutCount++;
-        if (m_layoutCount == 2)
-            endTest();
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->setNeedsCommit();
-
-        char pixels[4];
-        m_layerTreeHost->compositeAndReadback(&pixels, gfx::Rect(0, 0, 1, 1));
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-    int m_layoutCount;
-};
-
-TEST_F(LayerTreeHostTestCompositeAndReadbackAnimateCount, runMultiThread)
-{
-    runTest(true);
-}
-
 class LayerTreeHostTestSurfaceNotAllocatedForLayersOutsideMemoryLimit : public LayerTreeHostTest {
 public:
     LayerTreeHostTestSurfaceNotAllocatedForLayersOutsideMemoryLimit()
@@ -2985,176 +1701,6 @@
     runTest(true);
 }
 
-class LayerTreeHostTestLostContextAfterEvictTextures : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestLostContextAfterEvictTextures()
-        : m_layer(EvictionTestLayer::create())
-        , m_implForEvictTextures(0)
-        , m_numCommits(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->setRootLayer(m_layer);
-        m_layerTreeHost->setViewportSize(gfx::Size(10, 20), gfx::Size(10, 20));
-
-        gfx::Transform identityMatrix;
-        setLayerPropertiesForTesting(m_layer.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(10, 20), true);
-
-        postSetNeedsCommitToMainThread();
-    }
-
-    void postEvictTextures()
-    {
-        if (implThread()) {
-            implThread()->postTask(base::Bind(&LayerTreeHostTestLostContextAfterEvictTextures::evictTexturesOnImplThread,
-                                              base::Unretained(this)));
-        } else {
-            DebugScopedSetImplThread impl(proxy());
-            evictTexturesOnImplThread();
-        }
-    }
-
-    void evictTexturesOnImplThread()
-    {
-        DCHECK(m_implForEvictTextures);
-        m_implForEvictTextures->enforceManagedMemoryPolicy(ManagedMemoryPolicy(0));
-    }
-
-    // Commit 1: Just commit and draw normally, then at the end, set ourselves
-    // invisible (to prevent a commit that would recreate textures after
-    // eviction, before the context recovery), and post a task that will evict
-    // textures, then cause the context to be lost, and then set ourselves
-    // visible again (to allow commits, since that's what causes context
-    // recovery in single thread).
-    virtual void didCommitAndDrawFrame() OVERRIDE
-    {
-        ++m_numCommits;
-        switch (m_numCommits) {
-        case 1:
-            EXPECT_TRUE(m_layer->haveBackingTexture());
-            m_layerTreeHost->setVisible(false);
-            postEvictTextures();
-            m_layerTreeHost->loseOutputSurface(1);
-            m_layerTreeHost->setVisible(true);
-            break;
-        default:
-            break;
-        }
-    }
-
-    virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        m_implForEvictTextures = impl;
-    }
-
-    virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE
-    {
-        EXPECT_TRUE(succeeded);
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-
-private:
-    FakeContentLayerClient m_client;
-    scoped_refptr<EvictionTestLayer> m_layer;
-    LayerTreeHostImpl* m_implForEvictTextures;
-    int m_numCommits;
-};
-
-SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostTestLostContextAfterEvictTextures)
-
-class CompositorFakeWebGraphicsContext3DWithEndQueryCausingLostContext : public CompositorFakeWebGraphicsContext3D {
-public:
-    static scoped_ptr<CompositorFakeWebGraphicsContext3DWithEndQueryCausingLostContext> create(Attributes attrs)
-    {
-        return make_scoped_ptr(new CompositorFakeWebGraphicsContext3DWithEndQueryCausingLostContext(attrs));
-    }
-
-    virtual void setContextLostCallback(WebGraphicsContextLostCallback* callback) { m_contextLostCallback = callback; }
-    virtual bool isContextLost() { return m_isContextLost; }
-
-    virtual void beginQueryEXT(WebKit::WGC3Denum, WebKit::WebGLId) { }
-    virtual void endQueryEXT(WebKit::WGC3Denum)
-    {
-        // Lose context.
-        if (!m_isContextLost) {
-            m_contextLostCallback->onContextLost();
-            m_isContextLost = true;
-        }
-    }
-    virtual void getQueryObjectuivEXT(WebKit::WebGLId, WebKit::WGC3Denum pname, WebKit::WGC3Duint* params)
-    {
-        // Context is lost. We need to behave as if result is available.
-        if (pname == GL_QUERY_RESULT_AVAILABLE_EXT)
-            *params = 1;
-    }
-
-private:
-    explicit CompositorFakeWebGraphicsContext3DWithEndQueryCausingLostContext(Attributes attrs)
-        : CompositorFakeWebGraphicsContext3D(attrs)
-        , m_contextLostCallback(0)
-        , m_isContextLost(false) { }
-
-    WebGraphicsContextLostCallback* m_contextLostCallback;
-    bool m_isContextLost;
-};
-
-class LayerTreeHostTestLostContextWhileUpdatingResources : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestLostContextWhileUpdatingResources()
-        : m_parent(ContentLayerWithUpdateTracking::create(&m_client))
-        , m_numChildren(50)
-    {
-        for (int i = 0; i < m_numChildren; i++)
-            m_children.push_back(ContentLayerWithUpdateTracking::create(&m_client));
-    }
-
-    virtual void beginTest()
-    {
-        m_layerTreeHost->setRootLayer(m_parent);
-        m_layerTreeHost->setViewportSize(gfx::Size(m_numChildren, 1), gfx::Size(m_numChildren, 1));
-
-        gfx::Transform identityMatrix;
-        setLayerPropertiesForTesting(m_parent.get(), 0, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(m_numChildren, 1), true);
-        for (int i = 0; i < m_numChildren; i++)
-            setLayerPropertiesForTesting(m_children[i].get(), m_parent.get(), identityMatrix, gfx::PointF(0, 0), gfx::PointF(i, 0), gfx::Size(1, 1), false);
-
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void commitCompleteOnThread(LayerTreeHostImpl* impl)
-    {
-        endTest();
-    }
-
-    virtual void layout()
-    {
-        m_parent->setNeedsDisplay();
-        for (int i = 0; i < m_numChildren; i++)
-            m_children[i]->setNeedsDisplay();
-    }
-
-    virtual void afterTest()
-    {
-    }
-
-private:
-    FakeContentLayerClient m_client;
-    scoped_refptr<ContentLayerWithUpdateTracking> m_parent;
-    int m_numChildren;
-    std::vector<scoped_refptr<ContentLayerWithUpdateTracking> > m_children;
-};
-
-TEST_F(LayerTreeHostTestLostContextWhileUpdatingResources, runMultiThread)
-{
-    runTest(true);
-}
-
 class LayerTreeHostTestContinuousCommit : public LayerTreeHostTest {
 public:
     LayerTreeHostTestContinuousCommit()
@@ -3271,103 +1817,6 @@
     runTest(true);
 }
 
-class LayerTreeHostTestAdjustPointForZoom : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestAdjustPointForZoom()
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        gfx::Transform m;
-        m.Translate(250, 360);
-        m.Scale(2, 2);
-
-        gfx::Point point(400, 550);
-        gfx::Point transformedPoint;
-
-        // Unit transform, no change expected.
-        m_layerTreeHost->setImplTransform(gfx::Transform());
-        transformedPoint = gfx::ToRoundedPoint(m_layerTreeHost->adjustEventPointForPinchZoom(point));
-        EXPECT_EQ(point.x(), transformedPoint.x());
-        EXPECT_EQ(point.y(), transformedPoint.y());
-
-        m_layerTreeHost->setImplTransform(m);
-
-        // Apply m^(-1): 75 = (400 - 250) / 2; 95 = (550 - 360) / 2.
-        transformedPoint = gfx::ToRoundedPoint(m_layerTreeHost->adjustEventPointForPinchZoom(point));
-        EXPECT_EQ(75, transformedPoint.x());
-        EXPECT_EQ(95, transformedPoint.y());
-        endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-    }
-};
-
-TEST_F(LayerTreeHostTestAdjustPointForZoom, runMultiThread)
-{
-    runTest(true);
-}
-
-class LayerTreeHostTestContinuousAnimate : public LayerTreeHostTest {
-public:
-    LayerTreeHostTestContinuousAnimate()
-        : m_numCommitComplete(0)
-        , m_numDrawLayers(0)
-    {
-    }
-
-    virtual void beginTest() OVERRIDE
-    {
-        m_layerTreeHost->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
-        m_layerTreeHost->rootLayer()->setBounds(gfx::Size(10, 10));
-
-        postSetNeedsCommitToMainThread();
-    }
-
-    virtual void animate(base::TimeTicks) OVERRIDE
-    {
-        if (m_numDrawLayers == 2)
-            return;
-        m_layerTreeHost->setNeedsAnimate();
-    }
-
-    virtual void layout() OVERRIDE
-    {
-        m_layerTreeHost->rootLayer()->setNeedsDisplay();
-    }
-
-    virtual void commitCompleteOnThread(LayerTreeHostImpl*) OVERRIDE
-    {
-        if (m_numDrawLayers == 1)
-            m_numCommitComplete++;
-    }
-
-    virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE
-    {
-        m_numDrawLayers++;
-        if (m_numDrawLayers == 2)
-            endTest();
-    }
-
-    virtual void afterTest() OVERRIDE
-    {
-        // Check that we didn't commit twice between first and second draw.
-        EXPECT_EQ(1, m_numCommitComplete);
-    }
-
-private:
-    int m_numCommitComplete;
-    int m_numDrawLayers;
-};
-
-TEST_F(LayerTreeHostTestContinuousAnimate, runMultiThread)
-{
-    runTest(true);
-}
-
 class LayerTreeHostTestDeferCommits : public LayerTreeHostTest {
 public:
     LayerTreeHostTestDeferCommits()
@@ -3543,5 +1992,122 @@
     EXPECT_EQ(0u, host->settings().maxPartialTextureUpdates);
 }
 
+class LayerTreeHostTestCapturePicture : public LayerTreeHostTest {
+public:
+    LayerTreeHostTestCapturePicture()
+        : m_bounds(gfx::Size(100, 100))
+        , m_layer(PictureLayer::create(&m_contentClient))
+    {
+        m_settings.implSidePainting = true;
+    }
+
+    class FillRectContentLayerClient : public ContentLayerClient {
+    public:
+        virtual void paintContents(SkCanvas* canvas, const gfx::Rect& clip, gfx::RectF& opaque) OVERRIDE
+        {
+            SkPaint paint;
+            paint.setColor(SK_ColorGREEN);
+
+            SkRect rect = SkRect::MakeWH(canvas->getDeviceSize().width(), canvas->getDeviceSize().height());
+            opaque = gfx::RectF(rect.width(), rect.height());
+            canvas->drawRect(rect, paint);
+        }
+    };
+
+    virtual void beginTest() OVERRIDE
+    {
+        m_layer->setIsDrawable(true);
+        m_layer->setBounds(m_bounds);
+        m_layerTreeHost->setViewportSize(m_bounds, m_bounds);
+        m_layerTreeHost->setRootLayer(m_layer);
+
+        EXPECT_TRUE(m_layerTreeHost->initializeRendererIfNeeded());
+        postSetNeedsCommitToMainThread();
+    }
+
+    virtual void didCommitAndDrawFrame() OVERRIDE
+    {
+        m_picture = m_layerTreeHost->capturePicture();
+        endTest();
+    }
+
+    virtual void afterTest() OVERRIDE
+    {
+        EXPECT_EQ(m_bounds, gfx::Size(m_picture->width(), m_picture->height()));
+
+        SkBitmap bitmap;
+        bitmap.setConfig(SkBitmap::kARGB_8888_Config, m_bounds.width(), m_bounds.height());
+        bitmap.allocPixels();
+        bitmap.eraseARGB(0, 0, 0, 0);
+        SkCanvas canvas(bitmap);
+
+        m_picture->draw(&canvas);
+
+        bitmap.lockPixels();
+        SkColor* pixels = reinterpret_cast<SkColor*>(bitmap.getPixels());
+        EXPECT_EQ(SK_ColorGREEN, pixels[0]);
+        bitmap.unlockPixels();
+    }
+
+private:
+    gfx::Size m_bounds;
+    FillRectContentLayerClient m_contentClient;
+    scoped_refptr<PictureLayer> m_layer;
+    skia::RefPtr<SkPicture> m_picture;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostTestCapturePicture);
+
+class LayerTreeHostTestMaxPendingFrames : public LayerTreeHostTest {
+public:
+    LayerTreeHostTestMaxPendingFrames()
+        : LayerTreeHostTest()
+    {
+    }
+
+    virtual scoped_ptr<OutputSurface> createOutputSurface() OVERRIDE
+    {
+        if (m_delegatingRenderer)
+            return FakeOutputSurface::CreateDelegating3d().PassAs<OutputSurface>();
+        return FakeOutputSurface::Create3d().PassAs<OutputSurface>();
+    }
+
+    virtual void beginTest() OVERRIDE
+    {
+        postSetNeedsCommitToMainThread();
+    }
+
+    virtual void drawLayersOnThread(LayerTreeHostImpl* hostImpl) OVERRIDE
+    {
+        DCHECK(hostImpl->proxy()->hasImplThread());
+
+        const ThreadProxy* proxy = static_cast<ThreadProxy*>(hostImpl->proxy());
+        if (m_delegatingRenderer)
+            EXPECT_EQ(1, proxy->maxFramesPendingForTesting());
+        else
+            EXPECT_EQ(FrameRateController::kDefaultMaxFramesPending, proxy->maxFramesPendingForTesting());
+        endTest();
+    }
+
+    virtual void afterTest() OVERRIDE
+    {
+    }
+
+protected:
+    bool m_delegatingRenderer;
+};
+
+TEST_F(LayerTreeHostTestMaxPendingFrames, DelegatingRenderer)
+{
+    m_delegatingRenderer = true;
+    runTest(true);
+}
+
+TEST_F(LayerTreeHostTestMaxPendingFrames, GLRenderer)
+{
+    m_delegatingRenderer = false;
+    runTest(true);
+}
+
 }  // namespace
 }  // namespace cc
Index: src/cc/contents_scaling_layer.h
===================================================================
--- src/cc/contents_scaling_layer.h	(revision 184497)
+++ src/cc/contents_scaling_layer.h	(working copy)
@@ -16,6 +16,7 @@
  public:
   virtual void calculateContentsScale(
       float ideal_contents_scale,
+      bool animating_transform_to_screen,
       float* contents_scale_x,
       float* contents_scale_y,
       gfx::Size* content_bounds) OVERRIDE;
Index: src/cc/quad_culler.cc
===================================================================
--- src/cc/quad_culler.cc	(revision 184497)
+++ src/cc/quad_culler.cc	(working copy)
@@ -14,8 +14,6 @@
 #include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/transform.h"
 
-using namespace std;
-
 namespace cc {
 
 QuadCuller::QuadCuller(QuadList& quadList, SharedQuadStateList& sharedQuadStateList, const LayerImpl* layer, const OcclusionTrackerImpl& occlusionTracker, bool showCullingWithDebugBorderQuads, bool forSurface)
@@ -33,7 +31,7 @@
 {
     // FIXME: If all quads are culled for the sharedQuadState, we can drop it from the list.
     m_currentSharedQuadState = sharedQuadState.get();
-    m_sharedQuadStateList.append(sharedQuadState.Pass());
+    m_sharedQuadStateList.push_back(sharedQuadState.Pass());
     return m_currentSharedQuadState;
 }
 
@@ -53,11 +51,11 @@
             float width = DebugColors::CulledTileBorderWidth(layer ? layer->layerTreeImpl() : NULL);
             scoped_ptr<DebugBorderDrawQuad> debugBorderQuad = DebugBorderDrawQuad::Create();
             debugBorderQuad->SetNew(drawQuad->shared_quad_state, drawQuad->visible_rect, color, width);
-            quadList.append(debugBorderQuad.PassAs<DrawQuad>());
+            quadList.push_back(debugBorderQuad.PassAs<DrawQuad>());
         }
 
         // Pass the quad after we're done using it.
-        quadList.append(drawQuad.Pass());
+        quadList.push_back(drawQuad.Pass());
     }
     return keepQuad;
 }
@@ -65,8 +63,8 @@
 bool QuadCuller::append(scoped_ptr<DrawQuad> drawQuad, AppendQuadsData& appendQuadsData)
 {
     DCHECK(drawQuad->shared_quad_state == m_currentSharedQuadState);
-    DCHECK(!m_sharedQuadStateList.isEmpty());
-    DCHECK(m_sharedQuadStateList.last() == m_currentSharedQuadState);
+    DCHECK(!m_sharedQuadStateList.empty());
+    DCHECK(m_sharedQuadStateList.back() == m_currentSharedQuadState);
 
     gfx::Rect culledRect;
     bool hasOcclusionFromOutsideTargetSurface;
@@ -75,7 +73,7 @@
     if (m_forSurface)
         culledRect = m_occlusionTracker.unoccludedContributingSurfaceContentRect(m_layer, false, drawQuad->rect, &hasOcclusionFromOutsideTargetSurface);
     else
-        culledRect = m_occlusionTracker.unoccludedContentRect(m_layer->renderTarget(), drawQuad->rect, drawQuad->quadTransform(), implDrawTransformIsUnknown, drawQuad->clippedRectInTarget(), &hasOcclusionFromOutsideTargetSurface);
+        culledRect = m_occlusionTracker.unoccludedContentRect(m_layer->renderTarget(), drawQuad->rect, drawQuad->quadTransform(), implDrawTransformIsUnknown, drawQuad->isClipped(), drawQuad->clipRect(), &hasOcclusionFromOutsideTargetSurface);
 
     appendQuadsData.hadOcclusionFromOutsideTargetSurface |= hasOcclusionFromOutsideTargetSurface;
 
Index: src/cc/layer_tree_host_common.h
===================================================================
--- src/cc/layer_tree_host_common.h	(revision 184497)
+++ src/cc/layer_tree_host_common.h	(working copy)
@@ -22,17 +22,19 @@
     static gfx::Rect calculateVisibleRect(const gfx::Rect& targetSurfaceRect, const gfx::Rect& layerBoundRect, const gfx::Transform&);
 
     static void calculateDrawProperties(Layer* rootLayer, const gfx::Size& deviceViewportSize, float deviceScaleFactor, float pageScaleFactor, int maxTextureSize, bool canUseLCDText, std::vector<scoped_refptr<Layer> >& renderSurfaceLayerList);
-    static void calculateDrawProperties(LayerImpl* rootLayer, const gfx::Size& deviceViewportSize, float deviceScaleFactor, float pageScaleFactor, int maxTextureSize, bool canUseLCDText, std::vector<LayerImpl*>& renderSurfaceLayerList);
+    static void calculateDrawProperties(LayerImpl* rootLayer, const gfx::Size& deviceViewportSize, float deviceScaleFactor, float pageScaleFactor, int maxTextureSize, bool canUseLCDText, std::vector<LayerImpl*>& renderSurfaceLayerList, bool updateTilePriorities);
 
     // Performs hit testing for a given renderSurfaceLayerList.
-    static LayerImpl* findLayerThatIsHitByPoint(const gfx::PointF& screenSpacePoint, std::vector<LayerImpl*>& renderSurfaceLayerList);
+    static LayerImpl* findLayerThatIsHitByPoint(const gfx::PointF& screenSpacePoint, const std::vector<LayerImpl*>& renderSurfaceLayerList);
 
-    static LayerImpl* findLayerThatIsHitByPointInTouchHandlerRegion(const gfx::PointF& screenSpacePoint, std::vector<LayerImpl*>& renderSurfaceLayerList);
+    static LayerImpl* findLayerThatIsHitByPointInTouchHandlerRegion(const gfx::PointF& screenSpacePoint, const std::vector<LayerImpl*>& renderSurfaceLayerList);
 
     static bool layerHasTouchEventHandlersAt(const gfx::PointF& screenSpacePoint, LayerImpl* layerImpl);
 
     template<typename LayerType> static bool renderSurfaceContributesToTarget(LayerType*, int targetSurfaceLayerID);
 
+    template<class Function, typename LayerType> static void callFunctionForSubtree(LayerType* rootLayer);
+
     // Returns a layer with the given id if one exists in the subtree starting
     // from the given root layer (including mask and replica layers).
     template<typename LayerType> static LayerType* findLayerInSubtree(LayerType* rootLayer, int layerId);
@@ -94,6 +96,23 @@
     return 0;
 }
 
+template<class Function, typename LayerType>
+void LayerTreeHostCommon::callFunctionForSubtree(LayerType* rootLayer)
+{
+    Function()(rootLayer);
+   
+    if (LayerType* maskLayer = rootLayer->maskLayer())
+        Function()(maskLayer);
+    if (LayerType* replicaLayer = rootLayer->replicaLayer()) {
+        Function()(replicaLayer);
+        if (LayerType* maskLayer = replicaLayer->maskLayer())
+            Function()(maskLayer);
+    }
+
+    for (size_t i = 0; i < rootLayer->children().size(); ++i)
+        callFunctionForSubtree<Function>(getChildAsRawPtr(rootLayer->children(), i));
+}
+
 }  // namespace cc
 
 #endif  // CC_LAYER_TREE_HOST_COMMON_H_
Index: src/cc/DEPS
===================================================================
--- src/cc/DEPS	(revision 184497)
+++ src/cc/DEPS	(working copy)
@@ -7,8 +7,5 @@
   "+ui/gfx",
   "+ui/gl",
   # TODO(danakj): Drop dependencies on WebKit Platform API from cc.
-  "+third_party/WebKit/Source/Platform/chromium/public/WebCompositorOutputSurface.h",
-  "+third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h",
-  "+third_party/WebKit/Source/Platform/chromium/public/WebGraphicsMemoryAllocation.h",
-  "+third_party/WebKit/Source/Platform/chromium/public/WebImage.h",
+  "+third_party/WebKit/Source/Platform/chromium/public",
 ]
Index: src/cc/frame_rate_controller.cc
===================================================================
--- src/cc/frame_rate_controller.cc	(revision 184497)
+++ src/cc/frame_rate_controller.cc	(working copy)
@@ -10,14 +10,6 @@
 #include "cc/time_source.h"
 #include "cc/thread.h"
 
-namespace {
-
-// This will be the maximum number of pending frames unless
-// FrameRateController::setMaxFramesPending is called.
-const int defaultMaxFramesPending = 2;
-
-}  // namespace
-
 namespace cc {
 
 class FrameRateControllerTimeSourceAdapter : public TimeSourceClient {
@@ -41,7 +33,7 @@
 FrameRateController::FrameRateController(scoped_refptr<TimeSource> timer)
     : m_client(0)
     , m_numFramesPending(0)
-    , m_maxFramesPending(defaultMaxFramesPending)
+    , m_maxFramesPending(0)
     , m_timeSource(timer)
     , m_active(false)
     , m_swapBuffersCompleteSupported(true)
@@ -56,7 +48,7 @@
 FrameRateController::FrameRateController(Thread* thread)
     : m_client(0)
     , m_numFramesPending(0)
-    , m_maxFramesPending(defaultMaxFramesPending)
+    , m_maxFramesPending(0)
     , m_active(false)
     , m_swapBuffersCompleteSupported(true)
     , m_isTimeSourceThrottling(false)
@@ -90,7 +82,7 @@
 
 void FrameRateController::setMaxFramesPending(int maxFramesPending)
 {
-    DCHECK(maxFramesPending > 0);
+    DCHECK_GE(maxFramesPending, 0);
     m_maxFramesPending = maxFramesPending;
 }
 
@@ -110,13 +102,13 @@
     DCHECK(m_active);
 
     // Check if we have too many frames in flight.
-    bool throttled = m_numFramesPending >= m_maxFramesPending;
+    bool throttled = m_maxFramesPending && m_numFramesPending >= m_maxFramesPending;
     TRACE_COUNTER_ID1("cc", "ThrottledVSyncInterval", m_thread, throttled);
 
     if (m_client)
         m_client->vsyncTick(throttled);
 
-    if (m_swapBuffersCompleteSupported && !m_isTimeSourceThrottling && m_numFramesPending < m_maxFramesPending)
+    if (m_swapBuffersCompleteSupported && !m_isTimeSourceThrottling && !throttled)
         postManualTick();
 }
 
Index: src/cc/output_surface.h
===================================================================
--- src/cc/output_surface.h	(revision 184497)
+++ src/cc/output_surface.h	(working copy)
@@ -54,8 +54,13 @@
   virtual SoftwareOutputDevice* SoftwareDevice() const = 0;
 
   // Sends frame data to the parent compositor. This should only be called when
-  // capabilities().has_parent_compositor.
-  virtual void SendFrameToParentCompositor(const CompositorFrame&) {}
+  // capabilities().has_parent_compositor. The implementation may destroy or
+  // steal the contents of the CompositorFrame passed in.
+  virtual void SendFrameToParentCompositor(CompositorFrame*) = 0;
+
+  // Notifies frame-rate smoothness preference. If true, all non-critical
+  // processing should be stopped, or lowered in priority.
+  virtual void UpdateSmoothnessTakesPriority(bool prefer_smoothness) {}
 };
 
 }  // namespace cc
Index: src/cc/occlusion_tracker.h
===================================================================
--- src/cc/occlusion_tracker.h	(revision 184497)
+++ src/cc/occlusion_tracker.h	(working copy)
@@ -35,9 +35,9 @@
     void leaveLayer(const LayerIteratorPosition<LayerType>&);
 
     // Returns true if the given rect in content space for a layer is fully occluded in either screen space or the layer's target surface.  |renderTarget| is the contributing layer's render target, and |drawTransform|, |transformsToTargetKnown| and |clippedRectInTarget| are relative to that.
-    bool occluded(const LayerType* renderTarget, const gfx::Rect& contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, const gfx::Rect& clippedRectInTarget, bool* hasOcclusionFromOutsideTargetSurface = 0) const;
+    bool occluded(const LayerType* renderTarget, gfx::Rect contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, bool isClipped, gfx::Rect clipRectInTarget, bool* hasOcclusionFromOutsideTargetSurface = 0) const;
     // Gives an unoccluded sub-rect of |contentRect| in the content space of a layer. Used when considering occlusion for a layer that paints/draws something. |renderTarget| is the contributing layer's render target, and |drawTransform|, |transformsToTargetKnown| and |clippedRectInTarget| are relative to that.
-    gfx::Rect unoccludedContentRect(const LayerType* renderTarget, const gfx::Rect& contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, const gfx::Rect& clippedRectInTarget, bool* hasOcclusionFromOutsideTargetSurface = 0) const;
+    gfx::Rect unoccludedContentRect(const LayerType* renderTarget, gfx::Rect contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, bool isClipped, gfx::Rect clipRectInTarget, bool* hasOcclusionFromOutsideTargetSurface = 0) const;
 
     // Gives an unoccluded sub-rect of |contentRect| in the content space of the renderTarget owned by the layer.
     // Used when considering occlusion for a contributing surface that is rendering into another target.
@@ -76,9 +76,6 @@
     // We merge the occlusion at the top of the stack with the new current subtree. This new target is pushed onto the stack if not already there.
     std::vector<StackObject> m_stack;
 
-    // Allow tests to override this.
-    virtual gfx::Rect layerClipRectInTarget(const LayerType*) const;
-
 private:
     // Called when visiting a layer representing itself. If the target was not already current, then this indicates we have entered a new surface subtree.
     void enterRenderTarget(const LayerType* newTarget);
Index: src/cc/scheduler_unittest.cc
===================================================================
--- src/cc/scheduler_unittest.cc	(revision 184497)
+++ src/cc/scheduler_unittest.cc	(working copy)
@@ -50,6 +50,8 @@
     }
 
     virtual void scheduledActionCommit() OVERRIDE { m_actions.push_back("scheduledActionCommit"); }
+    virtual void scheduledActionCheckForCompletedTileUploads() OVERRIDE { m_actions.push_back("scheduledActionCheckForCompletedTileUploads"); }
+    virtual void scheduledActionActivatePendingTreeIfNeeded() OVERRIDE { m_actions.push_back("scheduledActionActivatePendingTreeIfNeeded"); }
     virtual void scheduledActionBeginContextRecreation() OVERRIDE { m_actions.push_back("scheduledActionBeginContextRecreation"); }
     virtual void scheduledActionAcquireLayerTexturesForMainThread() OVERRIDE { m_actions.push_back("scheduledActionAcquireLayerTexturesForMainThread"); }
     virtual void didAnticipatedDrawTimeChange(base::TimeTicks) OVERRIDE { }
@@ -68,7 +70,8 @@
 {
     FakeSchedulerClient client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
     scheduler->setCanDraw(true);
@@ -102,7 +105,8 @@
 {
     FakeSchedulerClient client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
     scheduler->setCanDraw(true);
@@ -136,7 +140,8 @@
 {
     FakeSchedulerClient client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
     scheduler->setCanDraw(true);
@@ -175,7 +180,8 @@
 {
     FakeSchedulerClient client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
     scheduler->setCanDraw(true);
@@ -238,7 +244,8 @@
 {
     SchedulerClientThatSetNeedsDrawInsideDraw client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     client.setScheduler(scheduler.get());
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
@@ -265,7 +272,8 @@
 {
     SchedulerClientThatSetNeedsDrawInsideDraw client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     client.setScheduler(scheduler.get());
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
@@ -338,7 +346,8 @@
 {
     SchedulerClientThatSetNeedsCommitInsideDraw client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     client.setScheduler(scheduler.get());
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
@@ -366,7 +375,8 @@
 {
     SchedulerClientThatSetNeedsDrawInsideDraw client;
     scoped_refptr<FakeTimeSource> timeSource(new FakeTimeSource());
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)));
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, make_scoped_ptr(new FrameRateController(timeSource)), defaultSchedulerSettings);
     client.setScheduler(scheduler.get());
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
@@ -409,7 +419,8 @@
     SchedulerClientThatSetNeedsCommitInsideDraw client;
     scoped_ptr<FakeFrameRateController> controller(new FakeFrameRateController(timeSource));
     FakeFrameRateController* controllerPtr = controller.get();
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, controller.PassAs<FrameRateController>());
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, controller.PassAs<FrameRateController>(), defaultSchedulerSettings);
     client.setScheduler(scheduler.get());
     scheduler->setCanBeginFrame(true);
     scheduler->setVisible(true);
@@ -446,7 +457,8 @@
     FakeSchedulerClient client;
     scoped_ptr<FakeFrameRateController> controller(new FakeFrameRateController(timeSource));
     FakeFrameRateController* controllerPtr = controller.get();
-    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, controller.PassAs<FrameRateController>());
+    SchedulerSettings defaultSchedulerSettings;
+    scoped_ptr<Scheduler> scheduler = Scheduler::create(&client, controller.PassAs<FrameRateController>(), defaultSchedulerSettings);
 
     EXPECT_EQ(0, controllerPtr->numFramesPending());
 
Index: src/cc/scrollbar_layer_unittest.cc
===================================================================
--- src/cc/scrollbar_layer_unittest.cc	(revision 184497)
+++ src/cc/scrollbar_layer_unittest.cc	(working copy)
@@ -4,104 +4,121 @@
 
 #include "cc/scrollbar_layer.h"
 
+#include "cc/append_quads_data.h"
+#include "cc/prioritized_resource_manager.h"
+#include "cc/priority_calculator.h"
+#include "cc/resource_update_queue.h"
 #include "cc/scrollbar_animation_controller.h"
 #include "cc/scrollbar_layer_impl.h"
 #include "cc/single_thread_proxy.h"
+#include "cc/solid_color_draw_quad.h"
 #include "cc/test/fake_impl_proxy.h"
+#include "cc/test/fake_layer_tree_host_client.h"
 #include "cc/test/fake_layer_tree_host_impl.h"
+#include "cc/test/fake_scrollbar_theme_painter.h"
+#include "cc/test/fake_web_graphics_context_3d.h"
+#include "cc/test/fake_web_scrollbar.h"
 #include "cc/test/fake_web_scrollbar_theme_geometry.h"
+#include "cc/test/geometry_test_utils.h"
 #include "cc/test/layer_tree_test_common.h"
+#include "cc/test/mock_quad_culler.h"
 #include "cc/tree_synchronizer.h"
+#include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include <public/WebScrollbar.h>
-#include <public/WebScrollbarThemeGeometry.h>
-#include <public/WebScrollbarThemePainter.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbar.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbarThemeGeometry.h"
 
 namespace cc {
 namespace {
 
-class FakeWebScrollbar : public WebKit::WebScrollbar {
-public:
-    static scoped_ptr<FakeWebScrollbar> create() { return make_scoped_ptr(new FakeWebScrollbar()); }
+scoped_ptr<LayerImpl> layerImplForScrollAreaAndScrollbar(
+    FakeLayerTreeHostImpl* host_impl,
+    scoped_ptr<WebKit::WebScrollbar> scrollbar,
+    bool reverse_order)
+{
+    scoped_refptr<Layer> layerTreeRoot = Layer::create();
+    scoped_refptr<Layer> child1 = Layer::create();
+    scoped_refptr<Layer> child2 = ScrollbarLayer::create(scrollbar.Pass(), FakeScrollbarThemePainter::Create(false).PassAs<ScrollbarThemePainter>(), FakeWebScrollbarThemeGeometry::create(true), child1->id());
+    layerTreeRoot->addChild(child1);
+    layerTreeRoot->insertChild(child2, reverse_order ? 0 : 1);
+    scoped_ptr<LayerImpl> layerImpl = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), host_impl->activeTree());
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImpl.get());
+    return layerImpl.Pass();
+}
 
-    // WebScrollbar implementation
-    virtual bool isOverlay() const OVERRIDE { return false; }
-    virtual int value() const OVERRIDE { return 0; }
-    virtual WebKit::WebPoint location() const OVERRIDE { return WebKit::WebPoint(); }
-    virtual WebKit::WebSize size() const OVERRIDE { return WebKit::WebSize(); }
-    virtual bool enabled() const OVERRIDE { return true; }
-    virtual int maximum() const OVERRIDE { return 0; }
-    virtual int totalSize() const OVERRIDE { return 0; }
-    virtual bool isScrollViewScrollbar() const OVERRIDE { return false; }
-    virtual bool isScrollableAreaActive() const OVERRIDE { return true; }
-    virtual void getTickmarks(WebKit::WebVector<WebKit::WebRect>&) const OVERRIDE { }
-    virtual ScrollbarControlSize controlSize() const OVERRIDE { return WebScrollbar::RegularScrollbar; }
-    virtual ScrollbarPart pressedPart() const OVERRIDE { return WebScrollbar::NoPart; }
-    virtual ScrollbarPart hoveredPart() const OVERRIDE { return WebScrollbar::NoPart; }
-    virtual ScrollbarOverlayStyle scrollbarOverlayStyle() const OVERRIDE { return WebScrollbar::ScrollbarOverlayStyleDefault; }
-    virtual bool isCustomScrollbar() const OVERRIDE { return false; }
-    virtual Orientation orientation() const OVERRIDE { return WebScrollbar::Horizontal; }
-};
-
 TEST(ScrollbarLayerTest, resolveScrollLayerPointer)
 {
     FakeImplProxy proxy;
     FakeLayerTreeHostImpl hostImpl(&proxy);
-    WebKit::WebScrollbarThemePainter painter;
 
     {
         scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
-        scoped_refptr<Layer> layerTreeRoot = Layer::create();
-        scoped_refptr<Layer> child1 = Layer::create();
-        scoped_refptr<Layer> child2 = ScrollbarLayer::create(scrollbar.Pass(), painter, FakeWebScrollbarThemeGeometry::create(), child1->id());
-        layerTreeRoot->addChild(child1);
-        layerTreeRoot->addChild(child2);
+        scoped_ptr<LayerImpl> layerImplTreeRoot = layerImplForScrollAreaAndScrollbar(&hostImpl, scrollbar.Pass(), false);
 
-        scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), hostImpl.activeTree());
-
         LayerImpl* ccChild1 = layerImplTreeRoot->children()[0];
         ScrollbarLayerImpl* ccChild2 = static_cast<ScrollbarLayerImpl*>(layerImplTreeRoot->children()[1]);
 
-        EXPECT_TRUE(ccChild1->scrollbarAnimationController());
         EXPECT_EQ(ccChild1->horizontalScrollbarLayer(), ccChild2);
     }
 
     { // another traverse order
         scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
-        scoped_refptr<Layer> layerTreeRoot = Layer::create();
-        scoped_refptr<Layer> child2 = Layer::create();
-        scoped_refptr<Layer> child1 = ScrollbarLayer::create(scrollbar.Pass(), painter, FakeWebScrollbarThemeGeometry::create(), child2->id());
-        layerTreeRoot->addChild(child1);
-        layerTreeRoot->addChild(child2);
+        scoped_ptr<LayerImpl> layerImplTreeRoot = layerImplForScrollAreaAndScrollbar(&hostImpl, scrollbar.Pass(), true);
 
-        scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), hostImpl.activeTree());
-
         ScrollbarLayerImpl* ccChild1 = static_cast<ScrollbarLayerImpl*>(layerImplTreeRoot->children()[0]);
         LayerImpl* ccChild2 = layerImplTreeRoot->children()[1];
 
-        EXPECT_TRUE(ccChild2->scrollbarAnimationController());
         EXPECT_EQ(ccChild2->horizontalScrollbarLayer(), ccChild1);
     }
 }
 
+TEST(ScrollbarLayerTest, shouldScrollNonOverlayOnMainThread)
+{
+    FakeImplProxy proxy;
+    FakeLayerTreeHostImpl hostImpl(&proxy);
+
+    // Create and attach a non-overlay scrollbar.
+    scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
+    static_cast<FakeWebScrollbar*>(scrollbar.get())->setOverlay(false);
+    scoped_ptr<LayerImpl> layerImplTreeRoot = layerImplForScrollAreaAndScrollbar(&hostImpl, scrollbar.Pass(), false);
+    ScrollbarLayerImpl* scrollbarLayerImpl = static_cast<ScrollbarLayerImpl*>(layerImplTreeRoot->children()[1]);
+
+    // When the scrollbar is not an overlay scrollbar, the scroll should be
+    // responded to on the main thread as the compositor does not yet implement
+    // scrollbar scrolling.
+    EXPECT_EQ(InputHandlerClient::ScrollOnMainThread, scrollbarLayerImpl->tryScroll(gfx::Point(0, 0), InputHandlerClient::Gesture));
+
+    // Create and attach an overlay scrollbar.
+    scrollbar = FakeWebScrollbar::create();
+    static_cast<FakeWebScrollbar*>(scrollbar.get())->setOverlay(true);
+
+    layerImplTreeRoot = layerImplForScrollAreaAndScrollbar(&hostImpl, scrollbar.Pass(), false);
+    scrollbarLayerImpl = static_cast<ScrollbarLayerImpl*>(layerImplTreeRoot->children()[1]);
+
+    // The user shouldn't be able to drag an overlay scrollbar and the scroll
+    // may be handled in the compositor.
+    EXPECT_EQ(InputHandlerClient::ScrollIgnored, scrollbarLayerImpl->tryScroll(gfx::Point(0, 0), InputHandlerClient::Gesture));
+}
+
 TEST(ScrollbarLayerTest, scrollOffsetSynchronization)
 {
     FakeImplProxy proxy;
     FakeLayerTreeHostImpl hostImpl(&proxy);
-    WebKit::WebScrollbarThemePainter painter;
 
     scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
     scoped_refptr<Layer> layerTreeRoot = Layer::create();
     scoped_refptr<Layer> contentLayer = Layer::create();
-    scoped_refptr<Layer> scrollbarLayer = ScrollbarLayer::create(scrollbar.Pass(), painter, FakeWebScrollbarThemeGeometry::create(), layerTreeRoot->id());
+    scoped_refptr<Layer> scrollbarLayer = ScrollbarLayer::create(scrollbar.Pass(), FakeScrollbarThemePainter::Create(false).PassAs<ScrollbarThemePainter>(), FakeWebScrollbarThemeGeometry::create(true), layerTreeRoot->id());
     layerTreeRoot->addChild(contentLayer);
     layerTreeRoot->addChild(scrollbarLayer);
 
     layerTreeRoot->setScrollOffset(gfx::Vector2d(10, 20));
     layerTreeRoot->setMaxScrollOffset(gfx::Vector2d(30, 50));
+    layerTreeRoot->setBounds(gfx::Size(100, 200));
     contentLayer->setBounds(gfx::Size(100, 200));
 
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), hostImpl.activeTree());
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
 
     ScrollbarLayerImpl* ccScrollbarLayer = static_cast<ScrollbarLayerImpl*>(layerImplTreeRoot->children()[1]);
 
@@ -111,10 +128,12 @@
 
     layerTreeRoot->setScrollOffset(gfx::Vector2d(100, 200));
     layerTreeRoot->setMaxScrollOffset(gfx::Vector2d(300, 500));
+    layerTreeRoot->setBounds(gfx::Size(1000, 2000));
     contentLayer->setBounds(gfx::Size(1000, 2000));
 
     ScrollbarAnimationController* scrollbarController = layerImplTreeRoot->scrollbarAnimationController();
     layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), layerImplTreeRoot.Pass(), hostImpl.activeTree());
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
     EXPECT_EQ(scrollbarController, layerImplTreeRoot->scrollbarAnimationController());
 
     EXPECT_EQ(100, ccScrollbarLayer->currentPos());
@@ -128,6 +147,48 @@
     EXPECT_EQ(300, ccScrollbarLayer->maximum());
 }
 
+TEST(ScrollbarLayerTest, solidColorThicknessOverride)
+{
+    LayerTreeSettings layerTreeSettings;
+    layerTreeSettings.solidColorScrollbars = true;
+    layerTreeSettings.solidColorScrollbarThicknessDIP = 3;
+    FakeImplProxy proxy;
+    FakeLayerTreeHostImpl hostImpl(layerTreeSettings, &proxy);
+
+    scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
+    static_cast<FakeWebScrollbar*>(scrollbar.get())->setOverlay(true);
+    scoped_ptr<LayerImpl> layerImplTreeRoot = layerImplForScrollAreaAndScrollbar(&hostImpl, scrollbar.Pass(), false);
+    ScrollbarLayerImpl* scrollbarLayerImpl = static_cast<ScrollbarLayerImpl*>(layerImplTreeRoot->children()[1]);
+    scrollbarLayerImpl->setThumbSize(gfx::Size(4, 4));
+
+    // Thickness should be overridden to 3.
+    {
+        MockQuadCuller quadCuller;
+        AppendQuadsData data;
+        scrollbarLayerImpl->appendQuads(quadCuller, data);
+
+        const QuadList& quads = quadCuller.quadList();
+        ASSERT_EQ(1, quads.size());
+        EXPECT_EQ(DrawQuad::SOLID_COLOR, quads[0]->material);
+        EXPECT_RECT_EQ(gfx::Rect(1, 0, 4, 3), quads[0]->rect);
+    }
+
+    // Contents scale should scale the draw quad.
+    scrollbarLayerImpl->drawProperties().contents_scale_x = 2;
+    scrollbarLayerImpl->drawProperties().contents_scale_y = 2;
+    {
+        MockQuadCuller quadCuller;
+        AppendQuadsData data;
+        scrollbarLayerImpl->appendQuads(quadCuller, data);
+
+        const QuadList& quads = quadCuller.quadList();
+        ASSERT_EQ(1, quads.size());
+        EXPECT_EQ(DrawQuad::SOLID_COLOR, quads[0]->material);
+        EXPECT_RECT_EQ(gfx::Rect(2, 0, 8, 6), quads[0]->rect);
+    }
+
+}
+
 class ScrollbarLayerTestMaxTextureSize : public ThreadedTest {
 public:
     ScrollbarLayerTestMaxTextureSize() {}
@@ -141,7 +202,7 @@
         m_layerTreeHost->initializeRendererIfNeeded();
 
         scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
-        m_scrollbarLayer = ScrollbarLayer::create(scrollbar.Pass(), m_painter, FakeWebScrollbarThemeGeometry::create(), 1);
+        m_scrollbarLayer = ScrollbarLayer::create(scrollbar.Pass(), FakeScrollbarThemePainter::Create(false).PassAs<ScrollbarThemePainter>(), FakeWebScrollbarThemeGeometry::create(true), 1);
         m_scrollbarLayer->setLayerTreeHost(m_layerTreeHost.get());
         m_scrollbarLayer->setBounds(m_bounds);
         m_layerTreeHost->rootLayer()->addChild(m_scrollbarLayer);
@@ -155,7 +216,7 @@
 
     virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE
     {
-        const int kMaxTextureSize = m_layerTreeHost->rendererCapabilities().maxTextureSize;
+        const int kMaxTextureSize = impl->rendererCapabilities().maxTextureSize;
 
         // Check first that we're actually testing something.
         EXPECT_GT(m_scrollbarLayer->bounds().width(), kMaxTextureSize);
@@ -173,17 +234,95 @@
 private:
     scoped_refptr<ScrollbarLayer> m_scrollbarLayer;
     scoped_refptr<Layer> m_scrollLayer;
-    WebKit::WebScrollbarThemePainter m_painter;
     gfx::Size m_bounds;
 };
 
 TEST_F(ScrollbarLayerTestMaxTextureSize, runTest) {
-    FakeWebGraphicsContext3D context;
+    scoped_ptr<FakeWebGraphicsContext3D> context = FakeWebGraphicsContext3D::Create();
     int max_size = 0;
-    context.getIntegerv(GL_MAX_TEXTURE_SIZE, &max_size);
+    context->getIntegerv(GL_MAX_TEXTURE_SIZE, &max_size);
     setScrollbarBounds(gfx::Size(max_size + 100, max_size + 100));
     runTest(true);
 }
 
+class MockLayerTreeHost : public LayerTreeHost {
+public:
+    MockLayerTreeHost(const LayerTreeSettings& settings)
+        : LayerTreeHost(&m_fakeClient, settings)
+    {
+        initialize(scoped_ptr<Thread>(NULL));
+    }
+
+private:
+    FakeLayerImplTreeHostClient m_fakeClient;
+};
+
+
+class ScrollbarLayerTestResourceCreation : public testing::Test {
+public:
+    ScrollbarLayerTestResourceCreation()
+    {
+    }
+
+    void testResourceUpload(int expectedResources)
+    {
+        m_layerTreeHost.reset(new MockLayerTreeHost(m_layerTreeSettings));
+
+        scoped_ptr<WebKit::WebScrollbar> scrollbar(FakeWebScrollbar::create());
+        scoped_refptr<Layer> layerTreeRoot = Layer::create();
+        scoped_refptr<Layer> contentLayer = Layer::create();
+        scoped_refptr<Layer> scrollbarLayer = ScrollbarLayer::create(scrollbar.Pass(), FakeScrollbarThemePainter::Create(false).PassAs<ScrollbarThemePainter>(), FakeWebScrollbarThemeGeometry::create(true), layerTreeRoot->id());
+        layerTreeRoot->addChild(contentLayer);
+        layerTreeRoot->addChild(scrollbarLayer);
+
+        m_layerTreeHost->initializeRendererIfNeeded();
+        m_layerTreeHost->contentsTextureManager()->setMaxMemoryLimitBytes(1024 * 1024);
+        m_layerTreeHost->setRootLayer(layerTreeRoot);
+
+        scrollbarLayer->setIsDrawable(true);
+        scrollbarLayer->setBounds(gfx::Size(100, 100));
+        layerTreeRoot->setScrollOffset(gfx::Vector2d(10, 20));
+        layerTreeRoot->setMaxScrollOffset(gfx::Vector2d(30, 50));
+        layerTreeRoot->setBounds(gfx::Size(100, 200));
+        contentLayer->setBounds(gfx::Size(100, 200));
+        scrollbarLayer->drawProperties().content_bounds = gfx::Size(100, 200);
+        scrollbarLayer->drawProperties().visible_content_rect = gfx::Rect(0, 0, 100, 200);
+        scrollbarLayer->createRenderSurface();
+        scrollbarLayer->drawProperties().render_target = scrollbarLayer;
+
+        testing::Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
+        EXPECT_EQ(scrollbarLayer->layerTreeHost(), m_layerTreeHost.get());
+
+        PriorityCalculator calculator;
+        ResourceUpdateQueue queue;
+        OcclusionTracker occlusionTracker(gfx::Rect(), false);
+        RenderingStats stats;
+        scrollbarLayer->setTexturePriorities(calculator);
+        m_layerTreeHost->contentsTextureManager()->prioritizeTextures();
+        scrollbarLayer->update(queue, &occlusionTracker, stats);
+        EXPECT_EQ(0, queue.fullUploadSize());
+        EXPECT_EQ(expectedResources, queue.partialUploadSize());
+
+        testing::Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
+    }
+
+protected:
+    scoped_ptr<MockLayerTreeHost> m_layerTreeHost;
+    LayerTreeSettings m_layerTreeSettings;
+};
+
+TEST_F(ScrollbarLayerTestResourceCreation, resourceUpload)
+{
+    m_layerTreeSettings.solidColorScrollbars = false;
+    m_layerTreeSettings.maxPartialTextureUpdates = 2; // Android in M25 overrides this to 0 in cc/
+    testResourceUpload(2);
+}
+
+TEST_F(ScrollbarLayerTestResourceCreation, solidColorNoResourceUpload)
+{
+    m_layerTreeSettings.solidColorScrollbars = true;
+    testResourceUpload(0);
+}
+
 }  // namespace
 }  // namespace cc
Index: src/cc/tiling_data.cc
===================================================================
--- src/cc/tiling_data.cc	(revision 184497)
+++ src/cc/tiling_data.cc	(working copy)
@@ -19,14 +19,29 @@
   return total_size > 0 ? num_tiles : 0;
 }
 
-TilingData::TilingData(gfx::Size max_texture_size, gfx::Size total_size, bool hasBorderTexels)
+TilingData::TilingData()
+    : border_texels_(0) {
+  RecomputeNumTiles();
+}
+
+TilingData::TilingData(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool hasBorderTexels)
     : max_texture_size_(max_texture_size),
       total_size_(total_size),
       border_texels_(hasBorderTexels ? 1 : 0) {
   RecomputeNumTiles();
 }
 
-TilingData::~TilingData() {
+TilingData::TilingData(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    int border_texels)
+    : max_texture_size_(max_texture_size),
+      total_size_(total_size),
+      border_texels_(border_texels) {
+  RecomputeNumTiles();
 }
 
 void TilingData::SetTotalSize(gfx::Size total_size) {
@@ -44,12 +59,18 @@
   RecomputeNumTiles();
 }
 
+void TilingData::SetBorderTexels(int border_texels) {
+  border_texels_ = border_texels;
+  RecomputeNumTiles();
+}
+
 int TilingData::TileXIndexFromSrcCoord(int src_position) const {
   if (num_tiles_x_ <= 1)
     return 0;
 
-  DCHECK(max_texture_size_.width() - 2 * border_texels_);
-  int x = (src_position - border_texels_) / (max_texture_size_.width() - 2 * border_texels_);
+  DCHECK_GT(max_texture_size_.width() - 2 * border_texels_, 0);
+  int x = (src_position - border_texels_) /
+      (max_texture_size_.width() - 2 * border_texels_);
   return std::min(std::max(x, 0), num_tiles_x_ - 1);
 }
 
@@ -57,17 +78,83 @@
   if (num_tiles_y_ <= 1)
     return 0;
 
-  DCHECK(max_texture_size_.height() - 2 * border_texels_);
-  int y = (src_position - border_texels_) / (max_texture_size_.height() - 2 * border_texels_);
+  DCHECK_GT(max_texture_size_.height() - 2 * border_texels_, 0);
+  int y = (src_position - border_texels_) /
+      (max_texture_size_.height() - 2 * border_texels_);
   return std::min(std::max(y, 0), num_tiles_y_ - 1);
 }
 
+int TilingData::FirstBorderTileXIndexFromSrcCoord(int src_position) const {
+  if (num_tiles_x_ <= 1)
+    return 0;
+
+  DCHECK_GT(max_texture_size_.width() - 2 * border_texels_, 0);
+  int inner_tile_size = max_texture_size_.width() - 2 * border_texels_;
+  int x = (src_position - 2 * border_texels_) / inner_tile_size;
+  return std::min(std::max(x, 0), num_tiles_x_ - 1);
+}
+
+int TilingData::FirstBorderTileYIndexFromSrcCoord(int src_position) const {
+  if (num_tiles_y_ <= 1)
+    return 0;
+
+  DCHECK_GT(max_texture_size_.height() - 2 * border_texels_, 0);
+  int inner_tile_size = max_texture_size_.height() - 2 * border_texels_;
+  int y = (src_position - 2 * border_texels_) / inner_tile_size;
+  return std::min(std::max(y, 0), num_tiles_y_ - 1);
+}
+
+int TilingData::LastBorderTileXIndexFromSrcCoord(int src_position) const {
+  if (num_tiles_x_ <= 1)
+    return 0;
+
+  DCHECK_GT(max_texture_size_.width() - 2 * border_texels_, 0);
+  int inner_tile_size = max_texture_size_.width() - 2 * border_texels_;
+  int x = src_position / inner_tile_size;
+  return std::min(std::max(x, 0), num_tiles_x_ - 1);
+}
+
+int TilingData::LastBorderTileYIndexFromSrcCoord(int src_position) const {
+  if (num_tiles_y_ <= 1)
+    return 0;
+
+  DCHECK_GT(max_texture_size_.height() - 2 * border_texels_, 0);
+  int inner_tile_size = max_texture_size_.height() - 2 * border_texels_;
+  int y = src_position / inner_tile_size;
+  return std::min(std::max(y, 0), num_tiles_y_ - 1);
+}
+
 gfx::Rect TilingData::TileBounds(int i, int j) const {
   AssertTile(i, j);
-  int x = TilePositionX(i);
-  int y = TilePositionY(j);
-  int width = TileSizeX(i);
-  int height = TileSizeY(j);
+  int max_texture_size_x = max_texture_size_.width() - 2 * border_texels_;
+  int max_texture_size_y = max_texture_size_.height() - 2 * border_texels_;
+  int total_size_x = total_size_.width();
+  int total_size_y = total_size_.height();
+
+  int lo_x = max_texture_size_x * i;
+  if (i != 0)
+    lo_x += border_texels_;
+
+  int lo_y = max_texture_size_y * j;
+  if (j != 0)
+    lo_y += border_texels_;
+
+  int hi_x = max_texture_size_x * (i + 1) + border_texels_;
+  if (i + 1 == num_tiles_x_)
+    hi_x += border_texels_;
+  if (hi_x > total_size_x)
+    hi_x = total_size_x;
+
+  int hi_y = max_texture_size_y * (j + 1) + border_texels_;
+  if (j + 1 == num_tiles_y_)
+    hi_y += border_texels_;
+  if (hi_y > total_size_y)
+    hi_y = total_size_y;
+
+  int x = lo_x;
+  int y = lo_y;
+  int width = hi_x - lo_x;
+  int height = hi_y - lo_y;
   DCHECK_GE(x, 0);
   DCHECK_GE(y, 0);
   DCHECK_GE(width, 0);
@@ -87,13 +174,13 @@
     int y2 = bounds.bottom();
 
     if (i > 0)
-      x1--;
+      x1-= border_texels_;
     if (i < (num_tiles_x_ - 1))
-      x2++;
+      x2+= border_texels_;
     if (j > 0)
-      y1--;
+      y1-= border_texels_;
     if (j < (num_tiles_y_ - 1))
-      y2++;
+      y2+= border_texels_;
 
     bounds = gfx::Rect(x1, y1, x2 - x1, y2 - y1);
   }
@@ -105,9 +192,9 @@
   DCHECK_GE(x_index, 0);
   DCHECK_LT(x_index, num_tiles_x_);
 
-  int pos = 0;
-  for (int i = 0; i < x_index; i++)
-    pos += TileSizeX(i);
+  int pos = (max_texture_size_.width() - 2 * border_texels_) * x_index;
+  if (x_index != 0)
+    pos += border_texels_;
 
   return pos;
 }
@@ -116,9 +203,9 @@
   DCHECK_GE(y_index, 0);
   DCHECK_LT(y_index, num_tiles_y_);
 
-  int pos = 0;
-  for (int i = 0; i < y_index; i++)
-    pos += TileSizeY(i);
+  int pos = (max_texture_size_.height() - 2 * border_texels_) * y_index;
+  if (y_index != 0)
+    pos += border_texels_;
 
   return pos;
 }
@@ -169,4 +256,143 @@
   num_tiles_y_ = ComputeNumTiles(max_texture_size_.height(), total_size_.height(), border_texels_);
 }
 
+TilingData::BaseIterator::BaseIterator(const TilingData* tiling_data)
+    : tiling_data_(tiling_data),
+      index_x_(-1),
+      index_y_(-1) {
+}
+
+TilingData::Iterator::Iterator(const TilingData* tiling_data, gfx::Rect rect)
+    : BaseIterator(tiling_data),
+      left_(-1),
+      right_(-1),
+      bottom_(-1) {
+  if (tiling_data_->num_tiles_x() <= 0 || tiling_data_->num_tiles_y() <= 0) {
+    done();
+    return;
+  }
+
+  rect.Intersect(gfx::Rect(tiling_data_->total_size()));
+  index_x_ = tiling_data_->FirstBorderTileXIndexFromSrcCoord(rect.x());
+  index_y_ = tiling_data_->FirstBorderTileYIndexFromSrcCoord(rect.y());
+  left_ = index_x_;
+  right_ = tiling_data_->LastBorderTileXIndexFromSrcCoord(rect.right() - 1);
+  bottom_ = tiling_data_->LastBorderTileYIndexFromSrcCoord(rect.bottom() - 1);
+
+  // Index functions always return valid indices, so explicitly check
+  // for non-intersecting rects.
+  gfx::Rect new_rect = tiling_data_->TileBoundsWithBorder(index_x_, index_y_);
+  if (!new_rect.Intersects(rect))
+    done();
+}
+
+TilingData::Iterator& TilingData::Iterator::operator++() {
+  if (!*this)
+    return *this;
+
+  index_x_++;
+  if (index_x_ > right_) {
+    index_x_ = left_;
+    index_y_++;
+    if (index_y_ > bottom_)
+      done();
+  }
+
+  return *this;
+}
+
+TilingData::DifferenceIterator::DifferenceIterator(
+    const TilingData* tiling_data,
+    gfx::Rect consider,
+    gfx::Rect ignore)
+    : BaseIterator(tiling_data),
+      consider_left_(-1),
+      consider_top_(-1),
+      consider_right_(-1),
+      consider_bottom_(-1),
+      ignore_left_(-1),
+      ignore_top_(-1),
+      ignore_right_(-1),
+      ignore_bottom_(-1) {
+  if (tiling_data_->num_tiles_x() <= 0 || tiling_data_->num_tiles_y() <= 0) {
+    done();
+    return;
+  }
+
+  gfx::Rect bounds(tiling_data_->total_size());
+  consider.Intersect(bounds);
+  ignore.Intersect(bounds);
+  if (consider.IsEmpty()) {
+    done();
+    return;
+  }
+
+  consider_left_ =
+      tiling_data_->FirstBorderTileXIndexFromSrcCoord(consider.x());
+  consider_top_ =
+      tiling_data_->FirstBorderTileYIndexFromSrcCoord(consider.y());
+  consider_right_ =
+      tiling_data_->LastBorderTileXIndexFromSrcCoord(consider.right() - 1);
+  consider_bottom_ =
+      tiling_data_->LastBorderTileYIndexFromSrcCoord(consider.bottom() - 1);
+
+  if (!ignore.IsEmpty()) {
+    ignore_left_ =
+        tiling_data_->FirstBorderTileXIndexFromSrcCoord(ignore.x());
+    ignore_top_ =
+        tiling_data_->FirstBorderTileYIndexFromSrcCoord(ignore.y());
+    ignore_right_ =
+        tiling_data_->LastBorderTileXIndexFromSrcCoord(ignore.right() - 1);
+    ignore_bottom_ =
+        tiling_data_->LastBorderTileYIndexFromSrcCoord(ignore.bottom() - 1);
+
+    // Clamp ignore indices to consider indices.
+    ignore_left_ = std::max(ignore_left_, consider_left_);
+    ignore_top_ = std::max(ignore_top_, consider_top_);
+    ignore_right_ = std::min(ignore_right_, consider_right_);
+    ignore_bottom_ = std::min(ignore_bottom_, consider_bottom_);
+  }
+
+  if (ignore_left_ == consider_left_ && ignore_right_ == consider_right_ &&
+      ignore_top_ == consider_top_ && ignore_bottom_ == consider_bottom_) {
+    done();
+    return;
+  }
+
+  index_x_ = consider_left_;
+  index_y_ = consider_top_;
+
+  if (in_ignore_rect())
+    ++(*this);
+}
+
+TilingData::DifferenceIterator& TilingData::DifferenceIterator::operator++() {
+  if (!*this)
+    return *this;
+
+  index_x_++;
+  if (in_ignore_rect())
+    index_x_ = ignore_right_ + 1;
+
+  if (index_x_ > consider_right_) {
+    index_x_ = consider_left_;
+    index_y_++;
+
+    if (in_ignore_rect()) {
+      index_x_ = ignore_right_ + 1;
+      // If the ignore rect spans the whole consider rect horizontally, then
+      // ignore_right + 1 will be out of bounds.
+      if (in_ignore_rect() || index_x_ > consider_right_) {
+        index_y_ = ignore_bottom_ + 1;
+        index_x_ = consider_left_;
+      }
+    }
+
+    if (index_y_ > consider_bottom_)
+      done();
+  }
+
+  return *this;
+}
+
 }  // namespace cc
Index: src/cc/shared_quad_state.h
===================================================================
--- src/cc/shared_quad_state.h	(revision 184497)
+++ src/cc/shared_quad_state.h	(working copy)
@@ -21,7 +21,6 @@
 
   void SetAll(const gfx::Transform& content_to_target_transform,
               const gfx::Rect& visible_content_rect,
-              const gfx::Rect& clipped_rect_in_target,
               const gfx::Rect& clip_rect,
               bool is_clipped,
               float opacity);
@@ -30,7 +29,6 @@
   gfx::Transform content_to_target_transform;
   // This rect lives in the content space for the quad's originating layer.
   gfx::Rect visible_content_rect;
-  gfx::Rect clipped_rect_in_target;
   gfx::Rect clip_rect;
   bool is_clipped;
   float opacity;
Index: src/cc/platform_color.h
===================================================================
--- src/cc/platform_color.h	(revision 184497)
+++ src/cc/platform_color.h	(working copy)
@@ -5,10 +5,10 @@
 #ifndef CC_PLATFORM_COLOR_H_
 #define CC_PLATFORM_COLOR_H_
 
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/khronos/GLES2/gl2ext.h"
 #include "third_party/skia/include/core/SkTypes.h"
-#include <public/WebGraphicsContext3D.h>
 
 namespace cc {
 
Index: src/cc/picture_layer_tiling_set_unittest.cc
===================================================================
--- src/cc/picture_layer_tiling_set_unittest.cc	(revision 184497)
+++ src/cc/picture_layer_tiling_set_unittest.cc	(working copy)
@@ -4,7 +4,11 @@
 
 #include "cc/picture_layer_tiling_set.h"
 
+#include "cc/resource_pool.h"
+#include "cc/resource_provider.h"
+#include "cc/test/fake_output_surface.h"
 #include "cc/test/fake_picture_layer_tiling_client.h"
+#include "cc/test/fake_tile_manager_client.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/size_conversions.h"
 
@@ -14,14 +18,14 @@
 TEST(PictureLayerTilingSetTest, NoResources) {
   FakePictureLayerTilingClient client;
   PictureLayerTilingSet set(&client);
-  gfx::Size default_tile_size(256, 256);
+  client.SetTileSize(gfx::Size(256, 256));
 
   gfx::Size layer_bounds(1000, 800);
   set.SetLayerBounds(layer_bounds);
 
-  set.AddTiling(1.0, default_tile_size);
-  set.AddTiling(1.5, default_tile_size);
-  set.AddTiling(2.0, default_tile_size);
+  set.AddTiling(1.0);
+  set.AddTiling(1.5);
+  set.AddTiling(2.0);
 
   float contents_scale = 2.0;
   gfx::Size content_bounds(
@@ -29,7 +33,12 @@
   gfx::Rect content_rect(gfx::Point(), content_bounds);
 
   Region remaining(content_rect);
-  PictureLayerTilingSet::Iterator iter(&set, contents_scale, content_rect);
+  PictureLayerTilingSet::Iterator iter(
+      &set,
+      contents_scale,
+      content_rect,
+      contents_scale,
+      PictureLayerTiling::LayerDeviceAlignmentUnknown);
   for (; iter; ++iter) {
     gfx::Rect geometry_rect = iter.geometry_rect();
     EXPECT_TRUE(content_rect.Contains(geometry_rect));
@@ -42,5 +51,103 @@
   EXPECT_TRUE(remaining.IsEmpty());
 }
 
+class PictureLayerTilingSetTestWithResources : public testing::Test {
+ public:
+  void runTest(
+      int num_tilings,
+      float min_scale,
+      float scale_increment,
+      float ideal_contents_scale,
+      float expected_scale) {
+    scoped_ptr<FakeOutputSurface> output_surface =
+        FakeOutputSurface::Create3d();
+    scoped_ptr<ResourceProvider> resource_provider =
+        ResourceProvider::create(output_surface.get());
+
+    FakePictureLayerTilingClient client;
+    client.SetTileSize(gfx::Size(256, 256));
+    PictureLayerTilingSet set(&client);
+
+    gfx::Size layer_bounds(1000, 800);
+    set.SetLayerBounds(layer_bounds);
+
+    float scale = min_scale;
+    for (int i = 0; i < num_tilings; ++i, scale += scale_increment) {
+      PictureLayerTiling* tiling = set.AddTiling(scale);
+      std::vector<Tile*> tiles = tiling->AllTilesForTesting();
+      for (size_t i = 0; i < tiles.size(); ++i) {
+        EXPECT_FALSE(tiles[i]->ManagedStateForTesting().resource);
+
+        tiles[i]->ManagedStateForTesting().resource =
+            make_scoped_ptr(new ResourcePool::Resource(
+                resource_provider.get(),
+                gfx::Size(1, 1),
+                resource_provider->bestTextureFormat()));
+      }
+    }
+
+    float max_contents_scale = scale;
+    gfx::Size content_bounds(
+        gfx::ToCeiledSize(gfx::ScaleSize(layer_bounds, max_contents_scale)));
+    gfx::Rect content_rect(gfx::Point(), content_bounds);
+
+    Region remaining(content_rect);
+    PictureLayerTilingSet::Iterator iter(
+        &set,
+        max_contents_scale,
+        content_rect,
+        ideal_contents_scale,
+        PictureLayerTiling::LayerDeviceAlignmentUnknown);
+    for (; iter; ++iter) {
+      gfx::Rect geometry_rect = iter.geometry_rect();
+      EXPECT_TRUE(content_rect.Contains(geometry_rect));
+      ASSERT_TRUE(remaining.Contains(geometry_rect));
+      remaining.Subtract(geometry_rect);
+
+      float scale = iter.CurrentTiling()->contents_scale();
+      EXPECT_EQ(expected_scale, scale);
+
+      if (num_tilings)
+        EXPECT_TRUE(*iter);
+      else
+        EXPECT_FALSE(*iter);
+    }
+    EXPECT_TRUE(remaining.IsEmpty());
+  }
+};
+
+TEST_F(PictureLayerTilingSetTestWithResources, NoTilings) {
+  runTest(0, 0.f, 0.f, 2.f, 0.f);
+}
+TEST_F(PictureLayerTilingSetTestWithResources, OneTiling_Smaller) {
+  runTest(1, 1.f, 0.f, 2.f, 1.f);
+}
+TEST_F(PictureLayerTilingSetTestWithResources, OneTiling_Larger) {
+  runTest(1, 3.f, 0.f, 2.f, 3.f);
+}
+TEST_F(PictureLayerTilingSetTestWithResources, TwoTilings_Smaller) {
+  runTest(2, 1.f, 1.f, 3.f, 2.f);
+}
+
+TEST_F(PictureLayerTilingSetTestWithResources, TwoTilings_SmallerEqual) {
+  runTest(2, 1.f, 1.f, 2.f, 2.f);
+}
+
+TEST_F(PictureLayerTilingSetTestWithResources, TwoTilings_LargerEqual) {
+  runTest(2, 1.f, 1.f, 1.f, 1.f);
+}
+
+TEST_F(PictureLayerTilingSetTestWithResources, TwoTilings_Larger) {
+  runTest(2, 2.f, 8.f, 1.f, 2.f);
+}
+
+TEST_F(PictureLayerTilingSetTestWithResources, ManyTilings_Equal) {
+  runTest(10, 1.f, 1.f, 5.f, 5.f);
+}
+
+TEST_F(PictureLayerTilingSetTestWithResources, ManyTilings_NotEqual) {
+  runTest(10, 1.f, 1.f, 4.5f, 5.f);
+}
+
 }  // namespace
 }  // namespace cc
Index: src/cc/contents_scaling_layer_unittest.cc
===================================================================
--- src/cc/contents_scaling_layer_unittest.cc	(revision 184497)
+++ src/cc/contents_scaling_layer_unittest.cc	(working copy)
@@ -33,6 +33,7 @@
       // Simulate calcDrawProperties.
       calculateContentsScale(
           contentsScale,
+          false,  // animating_transform_to_screen
           &drawProperties().contents_scale_x,
           &drawProperties().contents_scale_y,
           &drawProperties().content_bounds);
Index: src/cc/delegating_renderer.h
===================================================================
--- src/cc/delegating_renderer.h	(revision 184497)
+++ src/cc/delegating_renderer.h	(working copy)
@@ -12,6 +12,7 @@
 
 namespace cc {
 
+class OutputSurface;
 class ResourceProvider;
 
 class CC_EXPORT DelegatingRenderer :
@@ -21,13 +22,14 @@
 {
  public:
   static scoped_ptr<DelegatingRenderer> Create(
-      RendererClient* client, ResourceProvider* resource_provider);
+      RendererClient* client,
+      OutputSurface* output_surface,
+      ResourceProvider* resource_provider);
   virtual ~DelegatingRenderer();
 
   virtual const RendererCapabilities& capabilities() const OVERRIDE;
 
-  virtual void drawFrame(RenderPassList& render_passes_in_draw_order,
-                         RenderPassIdHashMap& render_passes_by_id) OVERRIDE;
+  virtual void drawFrame(RenderPassList& render_passes_in_draw_order) OVERRIDE;
 
   virtual void finish() OVERRIDE {}
 
@@ -51,9 +53,11 @@
 
 private:
   DelegatingRenderer(RendererClient* client,
+                     OutputSurface* output_surface,
                      ResourceProvider* resource_provider);
   bool Initialize();
 
+  OutputSurface* output_surface_;
   ResourceProvider* resource_provider_;
   RendererCapabilities capabilities_;
   bool visible_;
Index: src/cc/tiled_layer.h
===================================================================
--- src/cc/tiled_layer.h	(revision 184497)
+++ src/cc/tiled_layer.h	(working copy)
@@ -8,9 +8,11 @@
 #include "cc/cc_export.h"
 #include "cc/contents_scaling_layer.h"
 #include "cc/layer_tiling_data.h"
-#include "cc/layer_updater.h"
 
 namespace cc {
+class LayerUpdater;
+class PrioritizedResourceManager;
+class PrioritizedResource;
 class UpdatableTile;
 
 class CC_EXPORT TiledLayer : public ContentsScalingLayer {
@@ -44,7 +46,7 @@
 
     // Exposed to subclasses for testing.
     void setTileSize(const gfx::Size&);
-    void setTextureFormat(GLenum textureFormat) { m_textureFormat = textureFormat; }
+    void setTextureFormat(unsigned textureFormat) { m_textureFormat = textureFormat; }
     void setBorderTexelOption(LayerTilingData::BorderTexelOption);
     size_t numPaintedTiles() { return m_tiler->tiles().size(); }
 
@@ -65,6 +67,8 @@
 
     // Virtual for testing
     virtual PrioritizedResourceManager* resourceManager() const;
+    const LayerTilingData* tilerForTesting() const { return m_tiler.get(); }
+    const PrioritizedResource* resourceAtForTesting(int, int) const;
 
 private:
     virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
@@ -88,7 +92,7 @@
 
     bool isSmallAnimatedLayer() const;
 
-    GLenum m_textureFormat;
+    unsigned m_textureFormat;
     bool m_skipsDraw;
     bool m_failedUpdate;
 
Index: src/cc/delegated_renderer_layer.cc
===================================================================
--- src/cc/delegated_renderer_layer.cc	(revision 184497)
+++ src/cc/delegated_renderer_layer.cc	(working copy)
@@ -8,25 +8,21 @@
 
 namespace cc {
 
-scoped_refptr<DelegatedRendererLayer> DelegatedRendererLayer::create()
-{
-    return scoped_refptr<DelegatedRendererLayer>(new DelegatedRendererLayer());
+scoped_refptr<DelegatedRendererLayer> DelegatedRendererLayer::Create() {
+  return scoped_refptr<DelegatedRendererLayer>(new DelegatedRendererLayer());
 }
 
 DelegatedRendererLayer::DelegatedRendererLayer()
-    : Layer()
-{
-    setIsDrawable(true);
-    setMasksToBounds(true);
+    : Layer() {
+  setIsDrawable(true);
 }
 
-DelegatedRendererLayer::~DelegatedRendererLayer()
-{
-}
+DelegatedRendererLayer::~DelegatedRendererLayer() {}
 
-scoped_ptr<LayerImpl> DelegatedRendererLayer::createLayerImpl(LayerTreeImpl* treeImpl)
-{
-    return DelegatedRendererLayerImpl::create(treeImpl, m_layerId).PassAs<LayerImpl>();
+scoped_ptr<LayerImpl> DelegatedRendererLayer::createLayerImpl(
+    LayerTreeImpl* tree_impl) {
+  return DelegatedRendererLayerImpl::Create(
+      tree_impl, m_layerId).PassAs<LayerImpl>();
 }
 
 }  // namespace cc
Index: src/cc/scheduler_state_machine_unittest.cc
===================================================================
--- src/cc/scheduler_state_machine_unittest.cc	(revision 184497)
+++ src/cc/scheduler_state_machine_unittest.cc	(working copy)
@@ -4,9 +4,11 @@
 
 #include "cc/scheduler_state_machine.h"
 
+#include "cc/scheduler.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace cc {
+
 namespace {
 
 const SchedulerStateMachine::CommitState allCommitStates[] = {
@@ -19,6 +21,8 @@
 // Exposes the protected state fields of the SchedulerStateMachine for testing
 class StateMachine : public SchedulerStateMachine {
 public:
+    StateMachine(const SchedulerSettings& schedulerSettings)
+      : SchedulerStateMachine(schedulerSettings) { }
     void setCommitState(CommitState cs) { m_commitState = cs; }
     CommitState commitState() const { return  m_commitState; }
 
@@ -37,9 +41,11 @@
 
 TEST(SchedulerStateMachineTest, TestNextActionBeginsFrameIfNeeded)
 {
+    SchedulerSettings defaultSchedulerSettings;
+
     // If no commit needed, do nothing
-    {
-        StateMachine state;
+    {    
+        StateMachine state(defaultSchedulerSettings);
         state.setCommitState(SchedulerStateMachine::COMMIT_STATE_IDLE);
         state.setCanBeginFrame(true);
         state.setNeedsRedraw(false);
@@ -56,7 +62,7 @@
 
     // If commit requested but canBeginFrame is still false, do nothing.
     {
-        StateMachine state;
+        StateMachine state(defaultSchedulerSettings);
         state.setCommitState(SchedulerStateMachine::COMMIT_STATE_IDLE);
         state.setNeedsRedraw(false);
         state.setVisible(true);
@@ -73,7 +79,7 @@
 
     // If commit requested, begin a frame
     {
-        StateMachine state;
+        StateMachine state(defaultSchedulerSettings);
         state.setCommitState(SchedulerStateMachine::COMMIT_STATE_IDLE);
         state.setCanBeginFrame(true);
         state.setNeedsRedraw(false);
@@ -83,7 +89,7 @@
 
     // Begin the frame, make sure needsCommit and commitState update correctly.
     {
-        StateMachine state;
+        StateMachine state(defaultSchedulerSettings);
         state.setCanBeginFrame(true);
         state.setVisible(true);
         state.updateState(SchedulerStateMachine::ACTION_BEGIN_FRAME);
@@ -95,7 +101,8 @@
 
 TEST(SchedulerStateMachineTest, TestSetForcedRedrawDoesNotSetsNormalRedraw)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanDraw(true);
     state.setNeedsForcedRedraw();
     EXPECT_FALSE(state.redrawPending());
@@ -104,7 +111,8 @@
 
 TEST(SchedulerStateMachineTest, TestFailedDrawSetsNeedsCommitAndDoesNotDrawAgain)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -130,7 +138,8 @@
 
 TEST(SchedulerStateMachineTest, TestSetNeedsRedrawDuringFailedDrawDoesNotRemoveNeedsRedraw)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -159,7 +168,8 @@
 
 TEST(SchedulerStateMachineTest, TestCommitAfterFailedDrawAllowsDrawInSameFrame)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -197,7 +207,8 @@
 
 TEST(SchedulerStateMachineTest, TestCommitAfterFailedAndSuccessfulDrawDoesNotAllowDrawInSameFrame)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -246,7 +257,8 @@
 
 TEST(SchedulerStateMachineTest, TestFailedDrawsWillEventuallyForceADrawAfterTheNextCommit)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -286,7 +298,8 @@
 
 TEST(SchedulerStateMachineTest, TestFailedDrawIsRetriedNextVSync)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -317,7 +330,8 @@
 
 TEST(SchedulerStateMachineTest, TestDoestDrawTwiceInSameFrame)
 {
-    SchedulerStateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    SchedulerStateMachine state(defaultSchedulerSettings);
     state.setVisible(true);
     state.setCanDraw(true);
     state.setNeedsRedraw();
@@ -345,11 +359,13 @@
 
 TEST(SchedulerStateMachineTest, TestNextActionDrawsOnVSync)
 {
+    SchedulerSettings defaultSchedulerSettings;
+
     // When not on vsync, or on vsync but not visible, don't draw.
     size_t numCommitStates = sizeof(allCommitStates) / sizeof(SchedulerStateMachine::CommitState);
     for (size_t i = 0; i < numCommitStates; ++i) {
         for (unsigned j = 0; j < 2; ++j) {
-            StateMachine state;
+            StateMachine state(defaultSchedulerSettings);
             state.setCommitState(allCommitStates[i]);
             bool visible = j;
             if (!visible) {
@@ -370,7 +386,7 @@
     // When on vsync, or not on vsync but needsForcedRedraw set, should always draw except if you're ready to commit, in which case commit.
     for (size_t i = 0; i < numCommitStates; ++i) {
         for (unsigned j = 0; j < 2; ++j) {
-            StateMachine state;
+            StateMachine state(defaultSchedulerSettings);
             state.setCanDraw(true);
             state.setCommitState(allCommitStates[i]);
             bool forcedDraw = j;
@@ -401,11 +417,13 @@
 
 TEST(SchedulerStateMachineTest, TestNoCommitStatesRedrawWhenInvisible)
 {
+    SchedulerSettings defaultSchedulerSettings;
+
     size_t numCommitStates = sizeof(allCommitStates) / sizeof(SchedulerStateMachine::CommitState);
     for (size_t i = 0; i < numCommitStates; ++i) {
         // There shouldn't be any drawing regardless of vsync.
         for (unsigned j = 0; j < 2; ++j) {
-            StateMachine state;
+            StateMachine state(defaultSchedulerSettings);
             state.setCommitState(allCommitStates[i]);
             state.setVisible(false);
             state.setNeedsRedraw(true);
@@ -425,11 +443,13 @@
 
 TEST(SchedulerStateMachineTest, TestCanRedraw_StopsDraw)
 {
+    SchedulerSettings defaultSchedulerSettings;
+
     size_t numCommitStates = sizeof(allCommitStates) / sizeof(SchedulerStateMachine::CommitState);
     for (size_t i = 0; i < numCommitStates; ++i) {
         // There shouldn't be any drawing regardless of vsync.
         for (unsigned j = 0; j < 2; ++j) {
-            StateMachine state;
+            StateMachine state(defaultSchedulerSettings);
             state.setCommitState(allCommitStates[i]);
             state.setVisible(false);
             state.setNeedsRedraw(true);
@@ -445,7 +465,8 @@
 
 TEST(SchedulerStateMachineTest, TestCanRedrawWithWaitingForFirstDrawMakesProgress)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCommitState(SchedulerStateMachine::COMMIT_STATE_WAITING_FOR_FIRST_DRAW);
     state.setCanBeginFrame(true);
     state.setNeedsCommit();
@@ -457,7 +478,8 @@
 
 TEST(SchedulerStateMachineTest, TestSetNeedsCommitIsNotLost)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setNeedsCommit();
     state.setVisible(true);
@@ -496,7 +518,8 @@
 
 TEST(SchedulerStateMachineTest, TestFullCycle)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -539,7 +562,8 @@
 
 TEST(SchedulerStateMachineTest, TestFullCycleWithCommitRequestInbetween)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -586,14 +610,16 @@
 
 TEST(SchedulerStateMachineTest, TestRequestCommitInvisible)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setNeedsCommit();
     EXPECT_EQ(SchedulerStateMachine::ACTION_NONE, state.nextAction());
 }
 
 TEST(SchedulerStateMachineTest, TestGoesInvisibleBeforeBeginFrameCompletes)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -632,7 +658,8 @@
 
 TEST(SchedulerStateMachineTest, TestContextLostWhenCompletelyIdle)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -655,7 +682,8 @@
 
 TEST(SchedulerStateMachineTest, TestContextLostWhenIdleAndCommitRequestedWhileRecreating)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -692,7 +720,8 @@
 
 TEST(SchedulerStateMachineTest, TestContextLostWhileCommitInProgress)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -735,7 +764,8 @@
 
 TEST(SchedulerStateMachineTest, TestContextLostWhileCommitInProgressAndAnotherCommitRequested)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -780,7 +810,8 @@
 
 TEST(SchedulerStateMachineTest, TestFinishAllRenderingWhileContextLost)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setVisible(true);
     state.setCanDraw(true);
 
@@ -809,7 +840,8 @@
 
 TEST(SchedulerStateMachineTest, TestBeginFrameWhenInvisibleAndForceCommit)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(false);
     state.setNeedsCommit();
@@ -819,7 +851,8 @@
 
 TEST(SchedulerStateMachineTest, TestBeginFrameWhenCanBeginFrameFalseAndForceCommit)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setVisible(true);
     state.setCanDraw(true);
     state.setNeedsCommit();
@@ -829,7 +862,8 @@
 
 TEST(SchedulerStateMachineTest, TestBeginFrameWhenCommitInProgress)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(false);
     state.setCommitState(SchedulerStateMachine::COMMIT_STATE_FRAME_IN_PROGRESS);
@@ -846,7 +880,8 @@
 
 TEST(SchedulerStateMachineTest, TestBeginFrameWhenForcedCommitInProgress)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(false);
     state.setCommitState(SchedulerStateMachine::COMMIT_STATE_FRAME_IN_PROGRESS);
@@ -865,7 +900,8 @@
 
 TEST(SchedulerStateMachineTest, TestBeginFrameWhenContextLost)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -877,7 +913,8 @@
 
 TEST(SchedulerStateMachineTest, TestImmediateBeginFrame)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -907,7 +944,8 @@
 
 TEST(SchedulerStateMachineTest, TestImmediateBeginFrameDuringCommit)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -941,7 +979,8 @@
 
 TEST(SchedulerStateMachineTest, ImmediateBeginFrameWhileInvisible)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(true);
@@ -983,7 +1022,8 @@
 
 TEST(SchedulerStateMachineTest, ImmediateBeginFrameWhileCantDraw)
 {
-    StateMachine state;
+    SchedulerSettings defaultSchedulerSettings;
+    StateMachine state(defaultSchedulerSettings);
     state.setCanBeginFrame(true);
     state.setVisible(true);
     state.setCanDraw(false);
Index: src/cc/image_layer_updater.cc
===================================================================
--- src/cc/image_layer_updater.cc	(revision 184497)
+++ src/cc/image_layer_updater.cc	(working copy)
@@ -3,10 +3,21 @@
 // found in the LICENSE file.
 
 #include "cc/image_layer_updater.h"
+#include "cc/prioritized_resource.h"
 #include "cc/resource_update_queue.h"
 
 namespace cc {
 
+ImageLayerUpdater::Resource::Resource(ImageLayerUpdater* updater, scoped_ptr<PrioritizedResource> texture)
+    : LayerUpdater::Resource(texture.Pass())
+    , m_updater(updater)
+{
+}
+
+ImageLayerUpdater::Resource::~Resource()
+{
+}
+
 void ImageLayerUpdater::Resource::update(ResourceUpdateQueue& queue, const gfx::Rect& sourceRect, const gfx::Vector2d& destOffset, bool partialUpdate, RenderingStats&)
 {
     m_updater->updateTexture(queue, texture(), sourceRect, destOffset, partialUpdate);
Index: src/cc/scheduler_state_machine.cc
===================================================================
--- src/cc/scheduler_state_machine.cc	(revision 184497)
+++ src/cc/scheduler_state_machine.cc	(working copy)
@@ -9,13 +9,17 @@
 
 namespace cc {
 
-SchedulerStateMachine::SchedulerStateMachine()
-    : m_commitState(COMMIT_STATE_IDLE)
+SchedulerStateMachine::SchedulerStateMachine(const SchedulerSettings& settings)
+    : m_settings(settings)
+    , m_commitState(COMMIT_STATE_IDLE)
     , m_currentFrameNumber(0)
     , m_lastFrameNumberWhereDrawWasCalled(-1)
+    , m_lastFrameNumberWhereTreeActivationAttempted(-1)
+    , m_lastFrameNumberWhereCheckForCompletedTileUploadsCalled(-1)
     , m_consecutiveFailedDraws(0)
     , m_maximumNumberOfFailedDrawsBeforeDrawIsForced(3)
     , m_needsRedraw(false)
+    , m_swapUsedIncompleteTile(false)
     , m_needsForcedRedraw(false)
     , m_needsForcedRedrawAfterNextCommit(false)
     , m_needsCommit(false)
@@ -26,6 +30,7 @@
     , m_visible(false)
     , m_canBeginFrame(false)
     , m_canDraw(false)
+    , m_hasPendingTree(false)
     , m_drawIfPossibleFailed(false)
     , m_textureState(LAYER_TEXTURE_STATE_UNLOCKED)
     , m_outputSurfaceState(OUTPUT_SURFACE_ACTIVE)
@@ -35,12 +40,16 @@
 std::string SchedulerStateMachine::toString()
 {
     std::string str;
+    base::StringAppendF(&str, "m_settings.implSidePainting = %d; ", m_settings.implSidePainting);
     base::StringAppendF(&str, "m_commitState = %d; ", m_commitState);
     base::StringAppendF(&str, "m_currentFrameNumber = %d; ", m_currentFrameNumber);
     base::StringAppendF(&str, "m_lastFrameNumberWhereDrawWasCalled = %d; ", m_lastFrameNumberWhereDrawWasCalled);
+    base::StringAppendF(&str, "m_lastFrameNumberWhereTreeActivationAttempted = %d; ", m_lastFrameNumberWhereTreeActivationAttempted);
+    base::StringAppendF(&str, "m_lastFrameNumberWhereCheckForCompletedTileUploadsCalled = %d; ", m_lastFrameNumberWhereCheckForCompletedTileUploadsCalled);
     base::StringAppendF(&str, "m_consecutiveFailedDraws = %d; ", m_consecutiveFailedDraws);
     base::StringAppendF(&str, "m_maximumNumberOfFailedDrawsBeforeDrawIsForced = %d; ", m_maximumNumberOfFailedDrawsBeforeDrawIsForced);
     base::StringAppendF(&str, "m_needsRedraw = %d; ", m_needsRedraw);
+    base::StringAppendF(&str, "m_swapUsedIncompleteTile = %d; ", m_swapUsedIncompleteTile);
     base::StringAppendF(&str, "m_needsForcedRedraw = %d; ", m_needsForcedRedraw);
     base::StringAppendF(&str, "m_needsForcedRedrawAfterNextCommit = %d; ", m_needsForcedRedrawAfterNextCommit);
     base::StringAppendF(&str, "m_needsCommit = %d; ", m_needsCommit);
@@ -52,6 +61,7 @@
     base::StringAppendF(&str, "m_canBeginFrame = %d; ", m_canBeginFrame);
     base::StringAppendF(&str, "m_canDraw = %d; ", m_canDraw);
     base::StringAppendF(&str, "m_drawIfPossibleFailed = %d; ", m_drawIfPossibleFailed);
+    base::StringAppendF(&str, "m_hasPendingTree = %d; ", m_hasPendingTree);
     base::StringAppendF(&str, "m_textureState = %d; ", m_textureState);
     base::StringAppendF(&str, "m_outputSurfaceState = %d; ", m_outputSurfaceState);
     return str;
@@ -62,6 +72,17 @@
     return m_currentFrameNumber == m_lastFrameNumberWhereDrawWasCalled;
 }
 
+bool SchedulerStateMachine::hasAttemptedTreeActivationThisFrame() const
+{
+    return m_currentFrameNumber == m_lastFrameNumberWhereTreeActivationAttempted;
+}
+
+bool SchedulerStateMachine::hasCheckedForCompletedTileUploadsThisFrame() const
+{
+    return m_currentFrameNumber ==
+           m_lastFrameNumberWhereCheckForCompletedTileUploadsCalled;
+}
+
 bool SchedulerStateMachine::drawSuspendedUntilCommit() const
 {
     if (!m_canDraw)
@@ -98,6 +119,23 @@
     return true;
 }
 
+bool SchedulerStateMachine::shouldAttemptTreeActivation() const
+{
+    return m_hasPendingTree && m_insideVSync && !hasAttemptedTreeActivationThisFrame();
+}
+
+bool SchedulerStateMachine::shouldCheckForCompletedTileUploads() const
+{
+    if (!m_settings.implSidePainting)
+        return false;
+    if (hasCheckedForCompletedTileUploadsThisFrame())
+        return false;
+
+    return shouldAttemptTreeActivation() ||
+           shouldDraw() ||
+           m_swapUsedIncompleteTile;
+}
+
 bool SchedulerStateMachine::shouldAcquireLayerTexturesForMainThread() const
 {
     if (!m_mainThreadNeedsLayerTextures)
@@ -118,23 +156,34 @@
 {
     if (shouldAcquireLayerTexturesForMainThread())
         return ACTION_ACQUIRE_LAYER_TEXTURES_FOR_MAIN_THREAD;
+
     switch (m_commitState) {
     case COMMIT_STATE_IDLE:
         if (m_outputSurfaceState != OUTPUT_SURFACE_ACTIVE && m_needsForcedRedraw)
             return ACTION_DRAW_FORCED;
         if (m_outputSurfaceState != OUTPUT_SURFACE_ACTIVE && m_needsForcedCommit)
-            return ACTION_BEGIN_FRAME;
+            // TODO(enne): Should probably drop the active tree on force commit
+            return m_hasPendingTree ? ACTION_NONE : ACTION_BEGIN_FRAME;
         if (m_outputSurfaceState == OUTPUT_SURFACE_LOST)
             return ACTION_BEGIN_OUTPUT_SURFACE_RECREATION;
         if (m_outputSurfaceState == OUTPUT_SURFACE_RECREATING)
             return ACTION_NONE;
+        if (shouldCheckForCompletedTileUploads())
+            return ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS;
+        if (shouldAttemptTreeActivation())
+            return ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED;
         if (shouldDraw())
             return m_needsForcedRedraw ? ACTION_DRAW_FORCED : ACTION_DRAW_IF_POSSIBLE;
         if (m_needsCommit && ((m_visible && m_canBeginFrame) || m_needsForcedCommit))
-            return ACTION_BEGIN_FRAME;
+            // TODO(enne): Should probably drop the active tree on force commit
+            return m_hasPendingTree ? ACTION_NONE : ACTION_BEGIN_FRAME;
         return ACTION_NONE;
 
     case COMMIT_STATE_FRAME_IN_PROGRESS:
+        if (shouldCheckForCompletedTileUploads())
+            return ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS;
+        if (shouldAttemptTreeActivation())
+            return ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED;
         if (shouldDraw())
             return m_needsForcedRedraw ? ACTION_DRAW_FORCED : ACTION_DRAW_IF_POSSIBLE;
         return ACTION_NONE;
@@ -143,17 +192,25 @@
         return ACTION_COMMIT;
 
     case COMMIT_STATE_WAITING_FOR_FIRST_DRAW: {
+        if (shouldCheckForCompletedTileUploads())
+            return ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS;
+        if (shouldAttemptTreeActivation())
+            return ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED;
         if (shouldDraw() || m_outputSurfaceState == OUTPUT_SURFACE_LOST)
             return m_needsForcedRedraw ? ACTION_DRAW_FORCED : ACTION_DRAW_IF_POSSIBLE;
         // COMMIT_STATE_WAITING_FOR_FIRST_DRAW wants to enforce a draw. If m_canDraw is false
         // or textures are not available, proceed to the next step (similar as in COMMIT_STATE_IDLE).
         bool canCommit = m_visible || m_needsForcedCommit;
         if (m_needsCommit && canCommit && drawSuspendedUntilCommit())
-            return ACTION_BEGIN_FRAME;
+            return m_hasPendingTree ? ACTION_NONE : ACTION_BEGIN_FRAME;
         return ACTION_NONE;
     }
 
     case COMMIT_STATE_WAITING_FOR_FIRST_FORCED_DRAW:
+        if (shouldCheckForCompletedTileUploads())
+            return ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS;
+        if (shouldAttemptTreeActivation())
+            return ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED;
         if (m_needsForcedRedraw)
             return ACTION_DRAW_FORCED;
         return ACTION_NONE;
@@ -168,7 +225,16 @@
     case ACTION_NONE:
         return;
 
+    case ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS:
+        m_lastFrameNumberWhereCheckForCompletedTileUploadsCalled = m_currentFrameNumber;
+        return;
+
+    case ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED:
+        m_lastFrameNumberWhereTreeActivationAttempted = m_currentFrameNumber;
+        return;
+
     case ACTION_BEGIN_FRAME:
+        DCHECK(!m_hasPendingTree);
         DCHECK(m_visible || m_needsForcedCommit);
         m_commitState = COMMIT_STATE_FRAME_IN_PROGRESS;
         m_needsCommit = false;
@@ -180,7 +246,9 @@
             m_commitState = COMMIT_STATE_WAITING_FOR_FIRST_FORCED_DRAW;
         else
             m_commitState = COMMIT_STATE_WAITING_FOR_FIRST_DRAW;
-        m_needsRedraw = true;
+        // When impl-side painting, we draw on activation instead of on commit.
+        if (!m_settings.implSidePainting)
+            m_needsRedraw = true;
         if (m_drawIfPossibleFailed)
             m_lastFrameNumberWhereDrawWasCalled = -1;
 
@@ -197,6 +265,7 @@
         m_needsRedraw = false;
         m_needsForcedRedraw = false;
         m_drawIfPossibleFailed = false;
+        m_swapUsedIncompleteTile = false;
         if (m_insideVSync)
             m_lastFrameNumberWhereDrawWasCalled = m_currentFrameNumber;
         if (m_commitState == COMMIT_STATE_WAITING_FOR_FIRST_FORCED_DRAW) {
@@ -233,6 +302,11 @@
 
 bool SchedulerStateMachine::vsyncCallbackNeeded() const
 {
+    // If we have a pending tree, need to keep getting notifications until
+    // the tree is ready to be swapped.
+    if (m_hasPendingTree)
+        return true;
+
     // If we can't draw, don't tick until we are notified that we can draw again.
     if (!m_canDraw)
         return false;
@@ -240,6 +314,9 @@
     if (m_needsForcedRedraw)
         return true;
 
+    if (m_visible && m_swapUsedIncompleteTile)
+        return true;
+
     return m_needsRedraw && m_visible && m_outputSurfaceState == OUTPUT_SURFACE_ACTIVE;
 }
 
@@ -264,6 +341,11 @@
     m_needsRedraw = true;
 }
 
+void SchedulerStateMachine::didSwapUseIncompleteTile()
+{
+    m_swapUsedIncompleteTile = true;
+}
+
 void SchedulerStateMachine::setNeedsForcedRedraw()
 {
     m_needsForcedRedraw = true;
@@ -322,6 +404,16 @@
     m_outputSurfaceState = OUTPUT_SURFACE_LOST;
 }
 
+void SchedulerStateMachine::setHasPendingTree(bool hasPendingTree)
+{
+    m_hasPendingTree = hasPendingTree;
+}
+
+void SchedulerStateMachine::setCanDraw(bool can)
+{
+    m_canDraw = can;
+}
+
 void SchedulerStateMachine::didRecreateOutputSurface()
 {
     DCHECK(m_outputSurfaceState == OUTPUT_SURFACE_RECREATING);
Index: src/cc/resource_provider.h
===================================================================
--- src/cc/resource_provider.h	(revision 184497)
+++ src/cc/resource_provider.h	(working copy)
@@ -5,20 +5,24 @@
 #ifndef CC_RESOURCE_PROVIDER_H_
 #define CC_RESOURCE_PROVIDER_H_
 
+#include <deque>
+#include <string>
+#include <vector>
+
 #include "base/basictypes.h"
+#include "base/callback.h"
 #include "base/hash_tables.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/threading/thread_checker.h"
 #include "cc/cc_export.h"
 #include "cc/output_surface.h"
 #include "cc/texture_copier.h"
+#include "cc/texture_mailbox.h"
 #include "cc/transferable_resource.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "ui/gfx/size.h"
-#include <deque>
-#include <vector>
 
 namespace WebKit {
 class WebGraphicsContext3D;
@@ -82,6 +86,9 @@
     // Wraps an external texture into a GL resource.
     ResourceId createResourceFromExternalTexture(unsigned textureId);
 
+    // Wraps an external texture mailbox into a GL resource.
+    ResourceId createResourceFromTextureMailbox(const TextureMailbox&);
+
     void deleteResource(ResourceId);
 
     // Update pixels from image, copying sourceRect (in image) into destRect (in the resource).
@@ -214,6 +221,14 @@
         DISALLOW_COPY_AND_ASSIGN(ScopedWriteLockSoftware);
     };
 
+    class Fence : public base::RefCounted<Fence> {
+    public:
+        virtual bool hasPassed() = 0;
+    protected:
+        friend class base::RefCounted<Fence>;
+        virtual ~Fence() {}
+    };
+
     // Acquire pixel buffer for resource. The pixel buffer can be used to
     // set resource pixels without performing unnecessary copying.
     void acquirePixelBuffer(ResourceId id);
@@ -229,10 +244,28 @@
     // Asynchronously update pixels from acquired pixel buffer.
     void beginSetPixels(ResourceId id);
     bool didSetPixelsComplete(ResourceId id);
+    void abortSetPixels(ResourceId id);
 
+    // For tests only! This prevents detecting uninitialized reads.
+    // Use setPixels or lockForWrite to allocate implicitly.
+    void allocateForTesting(ResourceId id);
+
+    // Sets the current read fence. If a resource is locked for read
+    // and has read fences enabled, the resource will not allow writes
+    // until this fence has passed.
+    void setReadLockFence(scoped_refptr<Fence> fence) { m_currentReadLockFence = fence; }
+    Fence* getReadLockFence() { return m_currentReadLockFence; }
+
+    // Enable read lock fences for a specific resource.
+    void enableReadLockFences(ResourceProvider::ResourceId, bool enable);
+
+    // Indicates if we can currently lock this resource for write.
+    bool canLockForWrite(ResourceId);
+
 private:
     struct Resource {
         Resource();
+        ~Resource();
         Resource(unsigned textureId, const gfx::Size& size, GLenum format, GLenum filter);
         Resource(uint8_t* pixels, const gfx::Size& size, GLenum format, GLenum filter);
 
@@ -241,7 +274,7 @@
         unsigned glPixelBufferId;
         // Query used to determine when asynchronous set pixels complete.
         unsigned glUploadQueryId;
-        Mailbox mailbox;
+        TextureMailbox mailbox;
         uint8_t* pixels;
         uint8_t* pixelBuffer;
         int lockForReadCount;
@@ -250,6 +283,9 @@
         bool exported;
         bool markedForDeletion;
         bool pendingSetPixels;
+        bool allocated;
+        bool enableReadLockFences;
+        scoped_refptr<Fence> readLockFence;
         gfx::Size size;
         GLenum format;
         // TODO(skyostil): Use a separate sampler object for filter state.
@@ -266,6 +302,9 @@
     };
     typedef base::hash_map<int, Child> ChildMap;
 
+    bool readLockFenceHasPassed(Resource* resource) { return !resource->readLockFence ||
+                                                              resource->readLockFence->hasPassed(); }
+
     explicit ResourceProvider(OutputSurface*);
     bool initialize();
 
@@ -277,6 +316,7 @@
 
     bool transferResource(WebKit::WebGraphicsContext3D*, ResourceId, TransferableResource*);
     void deleteResourceInternal(ResourceMap::iterator it);
+    void lazyAllocate(Resource*);
 
     OutputSurface* m_outputSurface;
     ResourceId m_nextId;
@@ -295,6 +335,8 @@
 
     base::ThreadChecker m_threadChecker;
 
+    scoped_refptr<Fence> m_currentReadLockFence;
+
     DISALLOW_COPY_AND_ASSIGN(ResourceProvider);
 };
 
Index: src/cc/video_layer.h
===================================================================
--- src/cc/video_layer.h	(revision 184497)
+++ src/cc/video_layer.h	(working copy)
@@ -9,36 +9,28 @@
 #include "cc/cc_export.h"
 #include "cc/layer.h"
 
-namespace WebKit {
-class WebVideoFrame;
-class WebVideoFrameProvider;
-}
-
 namespace media {
 class VideoFrame;
 }
 
 namespace cc {
 
+class VideoFrameProvider;
 class VideoLayerImpl;
 
 // A Layer that contains a Video element.
 class CC_EXPORT VideoLayer : public Layer {
 public:
-    typedef base::Callback<media::VideoFrame* (WebKit::WebVideoFrame*)> FrameUnwrapper;
+    static scoped_refptr<VideoLayer> create(VideoFrameProvider*);
 
-    static scoped_refptr<VideoLayer> create(WebKit::WebVideoFrameProvider*,
-                                            const FrameUnwrapper&);
-
     virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
 
 private:
-    VideoLayer(WebKit::WebVideoFrameProvider*, const FrameUnwrapper&);
+    explicit VideoLayer(VideoFrameProvider*);
     virtual ~VideoLayer();
 
     // This pointer is only for passing to VideoLayerImpl's constructor. It should never be dereferenced by this class.
-    WebKit::WebVideoFrameProvider* m_provider;
-    FrameUnwrapper m_unwrapper;
+    VideoFrameProvider* m_provider;
 };
 
 }  // namespace cc
Index: src/cc/nine_patch_layer.cc
===================================================================
--- src/cc/nine_patch_layer.cc	(revision 184497)
+++ src/cc/nine_patch_layer.cc	(working copy)
@@ -6,6 +6,7 @@
 
 #include "cc/layer_tree_host.h"
 #include "cc/nine_patch_layer_impl.h"
+#include "cc/prioritized_resource.h"
 #include "cc/resource_update.h"
 #include "cc/resource_update_queue.h"
 
Index: src/cc/managed_memory_policy.h
===================================================================
--- src/cc/managed_memory_policy.h	(revision 184497)
+++ src/cc/managed_memory_policy.h	(working copy)
@@ -7,22 +7,33 @@
 
 #include "base/basictypes.h"
 #include "cc/cc_export.h"
+#include "cc/tile_priority.h"
 
 namespace cc {
 
 struct CC_EXPORT ManagedMemoryPolicy {
+     enum PriorityCutoff {
+        CUTOFF_ALLOW_NOTHING,
+        CUTOFF_ALLOW_REQUIRED_ONLY,
+        CUTOFF_ALLOW_NICE_TO_HAVE,
+        CUTOFF_ALLOW_EVERYTHING,
+    };
+
     ManagedMemoryPolicy(size_t bytesLimitWhenVisible);
     ManagedMemoryPolicy(size_t bytesLimitWhenVisible,
-                        int priorityCutoffWhenVisible,
+                        PriorityCutoff priorityCutoffWhenVisible,
                         size_t bytesLimitWhenNotVisible,
-                        int priorityCutoffWhenNotVisible);
+                        PriorityCutoff priorityCutoffWhenNotVisible);
     bool operator==(const ManagedMemoryPolicy&) const;
     bool operator!=(const ManagedMemoryPolicy&) const;
 
     size_t bytesLimitWhenVisible;
-    int priorityCutoffWhenVisible;
+    PriorityCutoff priorityCutoffWhenVisible;
     size_t bytesLimitWhenNotVisible;
-    int priorityCutoffWhenNotVisible;
+    PriorityCutoff priorityCutoffWhenNotVisible;
+
+    static int priorityCutoffToValue(PriorityCutoff priorityCutoff);
+    static TileMemoryLimitPolicy priorityCutoffToTileMemoryLimitPolicy(PriorityCutoff priorityCutoff);
 };
 
 }  // namespace cc
Index: src/cc/prioritized_resource_manager.h
===================================================================
--- src/cc/prioritized_resource_manager.h	(revision 184497)
+++ src/cc/prioritized_resource_manager.h	(working copy)
@@ -84,6 +84,10 @@
     // indeed evicted as a result of this call.
     bool reduceMemoryOnImplThread(size_t limitBytes, int priorityCutoff, ResourceProvider*);
 
+    // Delete contents textures' backing resources that can be recycled. This
+    // may be called on the impl thread while the main thread is running.
+    void reduceWastedMemoryOnImplThread(ResourceProvider*);
+
     // Returns true if there exist any textures that are linked to backings that have had their
     // resources evicted. Only when we commit a tree that has no textures linked to evicted backings
     // may we allow drawing. After an eviction, this will not become true until
@@ -97,6 +101,7 @@
 
     bool requestLate(PrioritizedResource*);
 
+    void reduceWastedMemory(ResourceProvider*);
     void reduceMemory(ResourceProvider*);
     void clearAllMemory(ResourceProvider*);
 
Index: src/cc/occlusion_tracker_unittest.cc
===================================================================
--- src/cc/occlusion_tracker_unittest.cc	(revision 184497)
+++ src/cc/occlusion_tracker_unittest.cc	(working copy)
@@ -4,9 +4,6 @@
 
 #include "cc/occlusion_tracker.h"
 
-#include <public/WebFilterOperation.h>
-#include <public/WebFilterOperations.h>
-
 #include "cc/layer.h"
 #include "cc/layer_animation_controller.h"
 #include "cc/layer_impl.h"
@@ -21,6 +18,8 @@
 #include "cc/test/occlusion_tracker_test_common.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperation.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "ui/gfx/transform.h"
 
 namespace cc {
@@ -90,30 +89,18 @@
 public:
     TestOcclusionTrackerWithClip(gfx::Rect viewportRect, bool recordMetricsForFrame = false)
         : TestOcclusionTrackerBase<LayerType, RenderSurfaceType>(viewportRect, recordMetricsForFrame)
-        , m_overrideLayerClipRect(false)
     {
     }
 
-    void setLayerClipRect(const gfx::Rect& rect) { m_overrideLayerClipRect = true; m_layerClipRect = rect;}
-    void useDefaultLayerClipRect() { m_overrideLayerClipRect = false; }
-    // Returns true if the given rect in content space for the layer is fully occluded in either screen space or the layer's target surface.
     bool occludedLayer(const LayerType* layer, const gfx::Rect& contentRect, bool* hasOcclusionFromOutsideTargetSurface = 0) const
     {
-        return this->occluded(layer->renderTarget(), contentRect, layer->drawTransform(), layerImplDrawTransformIsUnknown(layer), layerClipRectInTarget(layer), hasOcclusionFromOutsideTargetSurface);
+        return this->occluded(layer->renderTarget(), contentRect, layer->drawTransform(), layerImplDrawTransformIsUnknown(layer), layer->isClipped(), layer->clipRect(), hasOcclusionFromOutsideTargetSurface);
     }
     // Gives an unoccluded sub-rect of |contentRect| in the content space of the layer. Simple wrapper around unoccludedContentRect.
     gfx::Rect unoccludedLayerContentRect(const LayerType* layer, const gfx::Rect& contentRect, bool* hasOcclusionFromOutsideTargetSurface = 0) const
     {
-        return this->unoccludedContentRect(layer->renderTarget(), contentRect, layer->drawTransform(), layerImplDrawTransformIsUnknown(layer), layerClipRectInTarget(layer), hasOcclusionFromOutsideTargetSurface);
+        return this->unoccludedContentRect(layer->renderTarget(), contentRect, layer->drawTransform(), layerImplDrawTransformIsUnknown(layer), layer->isClipped(), layer->clipRect(), hasOcclusionFromOutsideTargetSurface);
     }
-
-
-protected:
-    virtual gfx::Rect layerClipRectInTarget(const LayerType* layer) const { return m_overrideLayerClipRect ? m_layerClipRect : OcclusionTrackerBase<LayerType, RenderSurfaceType>::layerClipRectInTarget(layer); }
-
-private:
-    bool m_overrideLayerClipRect;
-    gfx::Rect m_layerClipRect;
 };
 
 struct OcclusionTrackerTestMainThreadTypes {
@@ -290,7 +277,7 @@
 
         DCHECK(!root->renderSurface());
 
-        LayerTreeHostCommon::calculateDrawProperties(root, root->bounds(), 1, 1, dummyMaxTextureSize, false, m_renderSurfaceLayerListImpl);
+        LayerTreeHostCommon::calculateDrawProperties(root, root->bounds(), 1, 1, dummyMaxTextureSize, false, m_renderSurfaceLayerListImpl, false);
 
         m_layerIterator = m_layerIteratorBegin = Types::TestLayerIterator::begin(&m_renderSurfaceLayerListImpl);
     }
@@ -479,12 +466,13 @@
 
     void runMyTest()
     {
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100));
+        typename Types::ContentLayerType* root = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200));
+        typename Types::ContentLayerType* parent = this->createDrawingLayer(root, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100), true);
         typename Types::ContentLayerType* layer = this->createDrawingLayer(parent, this->identityMatrix, gfx::PointF(30, 30), gfx::Size(500, 500), true);
-        this->calcDrawEtc(parent);
+        parent->setMasksToBounds(true);
+        this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(layer, occlusion);
         this->enterLayer(parent, occlusion);
@@ -495,26 +483,18 @@
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 30, 70, 70)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(29, 30, 70, 70)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 29, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(31, 30, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 31, 70, 70)));
-
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 30, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(29, 30, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 29, 70, 70)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(31, 30, 70, 70)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 31, 70, 70)));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 30, 70, 70)).IsEmpty());
         EXPECT_RECT_EQ(gfx::Rect(29, 30, 1, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 30, 70, 70)));
         EXPECT_RECT_EQ(gfx::Rect(29, 29, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 29, 70, 70)));
         EXPECT_RECT_EQ(gfx::Rect(30, 29, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 29, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(31, 29, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 29, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(100, 30, 1, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 30, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(31, 31, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 31, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(30, 100, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 31, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(29, 31, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 31, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(31, 29, 69, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 29, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 30, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 31, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 31, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(29, 31, 1, 69), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 31, 70, 70)));
     }
 };
 
@@ -550,11 +530,11 @@
         quadTransform.Translate(30, 30);
         gfx::Rect clipRectInTarget(0, 0, 100, 100);
 
-        EXPECT_TRUE(occlusion.unoccludedContentRect(parent, gfx::Rect(0, 0, 10, 10), quadTransform, false, clipRectInTarget).IsEmpty());
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 10, 10), occlusion.unoccludedContentRect(parent, gfx::Rect(0, 0, 10, 10), quadTransform, true, clipRectInTarget));
-        EXPECT_RECT_EQ(gfx::Rect(40, 40, 10, 10), occlusion.unoccludedContentRect(parent, gfx::Rect(40, 40, 10, 10), quadTransform, false, clipRectInTarget));
-        EXPECT_RECT_EQ(gfx::Rect(40, 30, 5, 10), occlusion.unoccludedContentRect(parent, gfx::Rect(35, 30, 10, 10), quadTransform, false, clipRectInTarget));
-        EXPECT_RECT_EQ(gfx::Rect(40, 40, 5, 5), occlusion.unoccludedContentRect(parent, gfx::Rect(40, 40, 10, 10), quadTransform, false, gfx::Rect(0, 0, 75, 75)));
+        EXPECT_TRUE(occlusion.unoccludedContentRect(parent, gfx::Rect(0, 0, 10, 10), quadTransform, false, true, clipRectInTarget).IsEmpty());
+        EXPECT_RECT_EQ(gfx::Rect(0, 0, 10, 10), occlusion.unoccludedContentRect(parent, gfx::Rect(0, 0, 10, 10), quadTransform, true, true, clipRectInTarget));
+        EXPECT_RECT_EQ(gfx::Rect(40, 40, 10, 10), occlusion.unoccludedContentRect(parent, gfx::Rect(40, 40, 10, 10), quadTransform, false, true, clipRectInTarget));
+        EXPECT_RECT_EQ(gfx::Rect(40, 30, 5, 10), occlusion.unoccludedContentRect(parent, gfx::Rect(35, 30, 10, 10), quadTransform, false, true, clipRectInTarget));
+        EXPECT_RECT_EQ(gfx::Rect(40, 40, 5, 5), occlusion.unoccludedContentRect(parent, gfx::Rect(40, 40, 10, 10), quadTransform, false, true, gfx::Rect(0, 0, 75, 75)));
     }
 };
 
@@ -571,12 +551,13 @@
         layerTransform.Rotate(90);
         layerTransform.Translate(-250, -250);
 
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100));
+        typename Types::ContentLayerType* root = this->createRoot(this->identityMatrix, gfx::Point(0, 0), gfx::Size(200, 200));
+        typename Types::ContentLayerType* parent = this->createDrawingLayer(root, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100), true);
         typename Types::ContentLayerType* layer = this->createDrawingLayer(parent, layerTransform, gfx::PointF(30, 30), gfx::Size(500, 500), true);
-        this->calcDrawEtc(parent);
+        parent->setMasksToBounds(true);
+        this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(layer, occlusion);
         this->enterLayer(parent, occlusion);
@@ -587,26 +568,18 @@
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 30, 70, 70)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(29, 30, 70, 70)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 29, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(31, 30, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 31, 70, 70)));
-
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 30, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(29, 30, 70, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 29, 70, 70)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(31, 30, 70, 70)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 31, 70, 70)));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 30, 70, 70)).IsEmpty());
         EXPECT_RECT_EQ(gfx::Rect(29, 30, 1, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 30, 70, 70)));
         EXPECT_RECT_EQ(gfx::Rect(29, 29, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 29, 70, 70)));
         EXPECT_RECT_EQ(gfx::Rect(30, 29, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 29, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(31, 29, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 29, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(100, 30, 1, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 30, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(31, 31, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 31, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(30, 100, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 31, 70, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(29, 31, 70, 70), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 31, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(31, 29, 69, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 29, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 30, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 31, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 31, 70, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(29, 31, 1, 69), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 31, 70, 70)));
     }
 };
 
@@ -621,12 +594,13 @@
         gfx::Transform layerTransform;
         layerTransform.Translate(20, 20);
 
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100));
+        typename Types::ContentLayerType* root = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200));
+        typename Types::ContentLayerType* parent = this->createDrawingLayer(root, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100), true);
         typename Types::ContentLayerType* layer = this->createDrawingLayer(parent, layerTransform, gfx::PointF(30, 30), gfx::Size(500, 500), true);
-        this->calcDrawEtc(parent);
+        parent->setMasksToBounds(true);
+        this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(layer, occlusion);
         this->enterLayer(parent, occlusion);
@@ -637,38 +611,18 @@
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(50, 50, 50, 50)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(49, 50, 50, 50)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(50, 49, 50, 50)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(51, 50, 50, 50)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(50, 51, 50, 50)));
-
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(50, 50, 50, 50)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(49, 50, 50, 50)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(50, 49, 50, 50)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(51, 50, 50, 50)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(50, 51, 50, 50)));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(50, 50, 50, 50)).IsEmpty());
         EXPECT_RECT_EQ(gfx::Rect(49, 50, 1, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(49, 50, 50, 50)));
         EXPECT_RECT_EQ(gfx::Rect(49, 49, 50, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(49, 49, 50, 50)));
         EXPECT_RECT_EQ(gfx::Rect(50, 49, 50, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(50, 49, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(51, 49, 50, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(51, 49, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(100, 50, 1, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(51, 50, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(51, 51, 50, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(51, 51, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(50, 100, 50, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(50, 51, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(49, 51, 50, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(49, 51, 50, 50)));
-
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(50, 50, 50, 50)).IsEmpty());
-        EXPECT_RECT_EQ(gfx::Rect(49, 50, 1, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(49, 50, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(49, 49, 50, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(49, 49, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(50, 49, 50, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(50, 49, 50, 50)));
         EXPECT_RECT_EQ(gfx::Rect(51, 49, 49, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(51, 49, 50, 50)));
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(51, 50, 50, 50)).IsEmpty());
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(51, 51, 50, 50)).IsEmpty());
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(50, 51, 50, 50)).IsEmpty());
         EXPECT_RECT_EQ(gfx::Rect(49, 51, 1, 49), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(49, 51, 50, 50)));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
     }
 };
 
@@ -693,7 +647,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(layer, occlusion);
         this->enterContributingSurface(child, occlusion);
@@ -710,18 +663,9 @@
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 40, 70, 60)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(29, 40, 70, 60)));
         EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 39, 70, 60)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(31, 40, 70, 60)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 41, 70, 60)));
-
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 40, 70, 60)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(29, 40, 70, 60)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(30, 39, 70, 60)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(31, 40, 70, 60)));
         EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(30, 41, 70, 60)));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
-
         /* Justification for the above occlusion from |layer|:
                    100
           +---------------------+                                      +---------------------+
@@ -799,7 +743,8 @@
         childTransform.Rotate(90);
         childTransform.Translate(-250, -250);
 
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100));
+        typename Types::ContentLayerType* root = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200));
+        typename Types::ContentLayerType* parent = this->createDrawingLayer(root, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100), true);
         parent->setMasksToBounds(true);
         typename Types::LayerType* child = this->createLayer(parent, childTransform, gfx::PointF(30, 30), gfx::Size(500, 500));
         child->setMasksToBounds(true);
@@ -807,10 +752,9 @@
         // |child2| makes |parent|'s surface get considered by OcclusionTracker first, instead of |child|'s. This exercises different code in
         // leaveToTargetRenderSurface, as the target surface has already been seen.
         typename Types::ContentLayerType* child2 = this->createDrawingLayer(parent, this->identityMatrix, gfx::PointF(30, 30), gfx::Size(60, 20), true);
-        this->calcDrawEtc(parent);
+        this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(-10, -10, 1000, 1000));
 
         this->visitLayer(child2, occlusion);
 
@@ -861,8 +805,8 @@
         EXPECT_RECT_EQ(gfx::Rect(30, 29, 70, 11), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 29, 70, 70)));
         // This rect extends past left/right ends of |child2|.
         EXPECT_RECT_EQ(gfx::Rect(20, 39, 80, 60), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(20, 39, 80, 60)));
-        EXPECT_RECT_EQ(gfx::Rect(100, 40, 1, 60), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 40, 70, 60)));
-        EXPECT_RECT_EQ(gfx::Rect(30, 100, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 41, 70, 60)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 40, 70, 60)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 41, 70, 60)));
 
         /* Justification for the above occlusion from |layer|:
                    100
@@ -907,14 +851,14 @@
         gfx::Transform layerTransform;
         layerTransform.Translate(10, 10);
 
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100));
+        typename Types::ContentLayerType* root = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(1000, 1000));
+        typename Types::ContentLayerType* parent = this->createDrawingLayer(root, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100), true);
         typename Types::LayerType* child = this->createLayer(parent, childTransform, gfx::PointF(30, 30), gfx::Size(500, 500));
         child->setMasksToBounds(true);
         typename Types::ContentLayerType* layer = this->createDrawingLayer(child, layerTransform, gfx::PointF(0, 0), gfx::Size(500, 500), true);
-        this->calcDrawEtc(parent);
+        this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         gfx::Rect clippedLayerInChild = MathUtil::mapClippedRect(layerTransform, layer->visibleContentRect());
 
@@ -924,25 +868,6 @@
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_EQ(clippedLayerInChild.ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
-        EXPECT_TRUE(occlusion.occludedLayer(child, clippedLayerInChild));
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(child, clippedLayerInChild).IsEmpty());
-        clippedLayerInChild += gfx::Vector2d(-1, 0);
-        EXPECT_FALSE(occlusion.occludedLayer(child, clippedLayerInChild));
-        EXPECT_FALSE(occlusion.unoccludedLayerContentRect(child, clippedLayerInChild).IsEmpty());
-        clippedLayerInChild += gfx::Vector2d(1, 0);
-        clippedLayerInChild += gfx::Vector2d(1, 0);
-        EXPECT_FALSE(occlusion.occludedLayer(child, clippedLayerInChild));
-        EXPECT_FALSE(occlusion.unoccludedLayerContentRect(child, clippedLayerInChild).IsEmpty());
-        clippedLayerInChild += gfx::Vector2d(-1, 0);
-        clippedLayerInChild += gfx::Vector2d(0, -1);
-        EXPECT_FALSE(occlusion.occludedLayer(child, clippedLayerInChild));
-        EXPECT_FALSE(occlusion.unoccludedLayerContentRect(child, clippedLayerInChild).IsEmpty());
-        clippedLayerInChild += gfx::Vector2d(0, 1);
-        clippedLayerInChild += gfx::Vector2d(0, 1);
-        EXPECT_FALSE(occlusion.occludedLayer(child, clippedLayerInChild));
-        EXPECT_FALSE(occlusion.unoccludedLayerContentRect(child, clippedLayerInChild).IsEmpty());
-        clippedLayerInChild += gfx::Vector2d(0, -1);
-
         this->leaveContributingSurface(child, occlusion);
         this->enterLayer(parent, occlusion);
 
@@ -967,19 +892,20 @@
         childTransform.Rotate(90);
         childTransform.Translate(-250, -250);
 
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100));
+        typename Types::ContentLayerType* root = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(1000, 1000));
+        typename Types::ContentLayerType* parent = this->createDrawingLayer(root, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(100, 100), true);
         parent->setMasksToBounds(true);
-        typename Types::LayerType* child = this->createLayer(parent, childTransform, gfx::PointF(30, 30), gfx::Size(500, 500));
+        typename Types::ContentLayerType* child = this->createDrawingLayer(parent, childTransform, gfx::PointF(30, 30), gfx::Size(500, 500), false);
         child->setMasksToBounds(true);
         typename Types::ContentLayerType* layer1 = this->createDrawingLayer(child, this->identityMatrix, gfx::PointF(10, 10), gfx::Size(500, 500), true);
         typename Types::ContentLayerType* layer2 = this->createDrawingLayer(child, this->identityMatrix, gfx::PointF(10, 450), gfx::Size(500, 60), true);
-        this->calcDrawEtc(parent);
+        this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(layer2, occlusion);
         this->visitLayer(layer1, occlusion);
+        this->visitLayer(child, occlusion);
         this->enterContributingSurface(child, occlusion);
 
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
@@ -987,15 +913,17 @@
 
         EXPECT_TRUE(occlusion.occludedLayer(child, gfx::Rect(10, 430, 60, 70)));
         EXPECT_FALSE(occlusion.occludedLayer(child, gfx::Rect(9, 430, 60, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child, gfx::Rect(10, 429, 60, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child, gfx::Rect(11, 430, 60, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child, gfx::Rect(10, 431, 60, 70)));
+        // These rects are occluded except for the part outside the bounds of the target surface.
+        EXPECT_TRUE(occlusion.occludedLayer(child, gfx::Rect(10, 429, 60, 70)));
+        EXPECT_TRUE(occlusion.occludedLayer(child, gfx::Rect(11, 430, 60, 70)));
+        EXPECT_TRUE(occlusion.occludedLayer(child, gfx::Rect(10, 431, 60, 70)));
 
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(child, gfx::Rect(10, 430, 60, 70)).IsEmpty());
         EXPECT_RECT_EQ(gfx::Rect(9, 430, 1, 70), occlusion.unoccludedLayerContentRect(child, gfx::Rect(9, 430, 60, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(10, 429, 60, 1), occlusion.unoccludedLayerContentRect(child, gfx::Rect(10, 429, 60, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(70, 430, 1, 70), occlusion.unoccludedLayerContentRect(child, gfx::Rect(11, 430, 60, 70)));
-        EXPECT_RECT_EQ(gfx::Rect(10, 500, 60, 1), occlusion.unoccludedLayerContentRect(child, gfx::Rect(10, 431, 60, 70)));
+        // These rects are occluded except for the part outside the bounds of the target surface.
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(child, gfx::Rect(10, 429, 60, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(child, gfx::Rect(11, 430, 60, 70)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(child, gfx::Rect(10, 431, 60, 70)));
 
         this->leaveContributingSurface(child, occlusion);
         this->enterLayer(parent, occlusion);
@@ -1010,8 +938,8 @@
         EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 40, 70, 60)).IsEmpty());
         EXPECT_RECT_EQ(gfx::Rect(29, 40, 1, 60), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(29, 40, 70, 60)));
         EXPECT_RECT_EQ(gfx::Rect(30, 39, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 39, 70, 60)));
-        EXPECT_RECT_EQ(gfx::Rect(100, 40, 1, 60), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 40, 70, 60)));
-        EXPECT_RECT_EQ(gfx::Rect(30, 100, 70, 1), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 41, 70, 60)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(31, 40, 70, 60)));
+        EXPECT_RECT_EQ(gfx::Rect(), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(30, 41, 70, 60)));
 
         /* Justification for the above occlusion from |layer1| and |layer2|:
 
@@ -1062,7 +990,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(-20, -20, 1000, 1000));
 
         this->visitLayer(layer2, occlusion);
         this->enterContributingSurface(child2, occlusion);
@@ -1071,18 +998,10 @@
         EXPECT_EQ(gfx::Rect(-10, 420, 70, 80).ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
         EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 70, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-11, 420, 70, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-10, 419, 70, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 71, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 70, 81)));
-
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 70, 80)));
         EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-11, 420, 70, 80)));
         EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-10, 419, 70, 80)));
         EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 71, 80)));
         EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 70, 81)));
-        occlusion.setLayerClipRect(gfx::Rect(-20, -20, 1000, 1000));
 
         // There is nothing above child2's surface in the z-order.
         EXPECT_RECT_EQ(gfx::Rect(-10, 420, 70, 80), occlusion.unoccludedContributingSurfaceContentRect(child2, false, gfx::Rect(-10, 420, 70, 80)));
@@ -1094,12 +1013,6 @@
         EXPECT_EQ(gfx::Rect(0, 430, 70, 80).ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_EQ(gfx::Rect(-10, 430, 80, 70).ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
-        EXPECT_TRUE(occlusion.occludedLayer(child1, gfx::Rect(-10, 430, 80, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(-11, 430, 80, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(-10, 429, 80, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(-10, 430, 81, 70)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(-10, 430, 80, 71)));
-
         // child2's contents will occlude child1 below it.
         EXPECT_RECT_EQ(gfx::Rect(-10, 430, 10, 70), occlusion.unoccludedContributingSurfaceContentRect(child1, false, gfx::Rect(-10, 430, 80, 70)));
 
@@ -1172,7 +1085,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(-30, -30, 1000, 1000));
 
         this->visitLayer(layer2, occlusion);
         this->enterLayer(child2, occlusion);
@@ -1180,12 +1092,6 @@
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_EQ(gfx::Rect(-10, 420, 70, 80).ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
-        EXPECT_TRUE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 70, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-11, 420, 70, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-10, 419, 70, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 71, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(child2, gfx::Rect(-10, 420, 70, 81)));
-
         this->leaveLayer(child2, occlusion);
         this->enterContributingSurface(child2, occlusion);
 
@@ -1199,12 +1105,6 @@
         EXPECT_EQ(gfx::Rect(420, -10, 70, 80).ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_EQ(gfx::Rect(420, -20, 80, 90).ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
-        EXPECT_TRUE(occlusion.occludedLayer(child1, gfx::Rect(420, -20, 80, 90)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(419, -20, 80, 90)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(420, -21, 80, 90)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(420, -19, 80, 90)));
-        EXPECT_FALSE(occlusion.occludedLayer(child1, gfx::Rect(421, -20, 80, 90)));
-
         // child2's contents will occlude child1 below it.
         EXPECT_RECT_EQ(gfx::Rect(420, -20, 80, 90), occlusion.unoccludedContributingSurfaceContentRect(child1, false, gfx::Rect(420, -20, 80, 90)));
         EXPECT_RECT_EQ(gfx::Rect(490, -10, 10, 80), occlusion.unoccludedContributingSurfaceContentRect(child1, false, gfx::Rect(420, -10, 80, 90)));
@@ -1216,12 +1116,6 @@
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_EQ(gfx::Rect(10, 20, 90, 80).ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(10, 20, 90, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(9, 20, 90, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(10, 19, 90, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(11, 20, 90, 80)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(10, 21, 90, 80)));
-
         /* Justification for the above occlusion:
                       100
             +---------------------+
@@ -1282,7 +1176,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // Opacity layer won't contribute to occlusion.
         this->visitLayer(opacityLayer, occlusion);
@@ -1341,7 +1234,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(surface, occlusion);
 
@@ -1370,7 +1262,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(surface, occlusion);
 
@@ -1399,7 +1290,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(surface, occlusion);
 
@@ -1422,11 +1312,12 @@
     void runMyTest()
     {
         typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
-        typename Types::ContentLayerType* layer = this->createDrawingSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200), true);
+        typename Types::ContentLayerType* clip = this->createDrawingLayer(parent, this->identityMatrix, gfx::PointF(200, 100), gfx::Size(100, 100), false);
+        clip->setMasksToBounds(true);
+        typename Types::ContentLayerType* layer = this->createDrawingLayer(clip, this->identityMatrix, gfx::PointF(-200, -100), gfx::Size(200, 200), false);
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(200, 100, 100, 100));
 
         this->enterLayer(layer, occlusion);
 
@@ -1436,25 +1327,16 @@
         EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(100, 100, 100, 100)));
         EXPECT_FALSE(occlusion.occludedLayer(layer, gfx::Rect(200, 100, 100, 100)));
 
-        occlusion.useDefaultLayerClipRect();
-        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(200, 100, 100, 100)));
-        occlusion.setLayerClipRect(gfx::Rect(200, 100, 100, 100));
-
         this->leaveLayer(layer, occlusion);
-        this->visitContributingSurface(layer, occlusion);
-        this->enterLayer(parent, occlusion);
+        this->enterLayer(clip, occlusion);
 
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 100, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(200, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 200, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 200, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 200, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(-100, 0, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(0, -100, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(100, 0, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(0, 100, 100, 100)));
+        EXPECT_FALSE(occlusion.occludedLayer(clip, gfx::Rect(0, 0, 100, 100)));
 
-        EXPECT_RECT_EQ(gfx::Rect(200, 100, 100, 100), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 300)));
+        EXPECT_RECT_EQ(gfx::Rect(0, 0, 100, 100), occlusion.unoccludedLayerContentRect(clip, gfx::Rect(-100, -100, 300, 300)));
     }
 };
 
@@ -1471,7 +1353,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(200, 100, 100, 100));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->enterLayer(layer, occlusion);
 
@@ -1479,11 +1360,7 @@
         EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(100, 0, 100, 100)));
         EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(0, 100, 100, 100)));
         EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(100, 100, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(layer, gfx::Rect(200, 100, 100, 100)));
-
-        occlusion.useDefaultLayerClipRect();
         EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(200, 100, 100, 100)));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->leaveLayer(layer, occlusion);
         this->visitContributingSurface(layer, occlusion);
@@ -1512,11 +1389,12 @@
     void runMyTest()
     {
         typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
-        typename Types::ContentLayerType* layer = this->createDrawingSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200), true);
+        typename Types::ContentLayerType* clip = this->createDrawingLayer(parent, this->identityMatrix, gfx::PointF(100, 100), gfx::Size(100, 100), false);
+        clip->setMasksToBounds(true);
+        typename Types::ContentLayerType* layer = this->createDrawingSurface(clip, this->identityMatrix, gfx::PointF(-100, -100), gfx::Size(200, 200), true);
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(100, 100, 100, 100));
 
         this->enterLayer(layer, occlusion);
 
@@ -1527,19 +1405,22 @@
 
         this->leaveLayer(layer, occlusion);
         this->visitContributingSurface(layer, occlusion);
-        this->enterLayer(parent, occlusion);
 
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 200, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 200, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 200, 100, 100)));
+        EXPECT_EQ(gfx::Rect(100, 100, 100, 100).ToString(), occlusion.occlusionFromInsideTarget().ToString());
 
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 300)).IsEmpty());
+        this->enterLayer(clip, occlusion);
+
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(0, 0, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(0, 100, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(100, 0, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(100, 100, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(200, 100, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(200, 0, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(0, 200, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(100, 200, 100, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(clip, gfx::Rect(200, 200, 100, 100)));
+
+        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(clip, gfx::Rect(0, 0, 300, 300)).IsEmpty());
     }
 };
 
@@ -1556,7 +1437,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(100, 100, 100, 100));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->enterLayer(layer, occlusion);
 
@@ -1592,11 +1472,12 @@
     void runMyTest()
     {
         typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
-        typename Types::ContentLayerType* layer = this->createDrawingSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200), true);
+        typename Types::ContentLayerType* clip = this->createDrawingLayer(parent, this->identityMatrix, gfx::PointF(50, 50), gfx::Size(200, 200), false);
+        clip->setMasksToBounds(true);
+        typename Types::ContentLayerType* layer = this->createDrawingSurface(clip, this->identityMatrix, gfx::PointF(-50, -50), gfx::Size(200, 200), true);
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(50, 50, 200, 200));
 
         this->enterLayer(layer, occlusion);
 
@@ -1605,25 +1486,16 @@
         EXPECT_FALSE(occlusion.occludedLayer(layer, gfx::Rect(100, 0, 100, 100)));
         EXPECT_FALSE(occlusion.occludedLayer(layer, gfx::Rect(100, 100, 100, 100)));
 
+        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(0, 0, 100, 50)));
+        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(0, 0, 50, 100)));
+        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(100, 0, 100, 50)));
+        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(0, 100, 50, 100)));
+
         this->leaveLayer(layer, occlusion);
         this->visitContributingSurface(layer, occlusion);
-        this->enterLayer(parent, occlusion);
+        this->enterLayer(clip, occlusion);
 
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 100, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(200, 100, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(200, 0, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(0, 200, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(100, 200, 100, 100)));
-        EXPECT_FALSE(occlusion.occludedLayer(parent, gfx::Rect(200, 200, 100, 100)));
-
-        EXPECT_RECT_EQ(gfx::Rect(50, 50, 200, 200), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 300)));
-        EXPECT_RECT_EQ(gfx::Rect(200, 50, 50, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(200, 100, 50, 100), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 100, 300, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(200, 100, 50, 100), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(200, 100, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(100, 200, 100, 50), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(100, 200, 100, 100)));
+        EXPECT_EQ(gfx::Rect(50, 50, 150, 150).ToString(), occlusion.occlusionFromInsideTarget().ToString());
     }
 };
 
@@ -1640,7 +1512,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(50, 50, 200, 200));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->enterLayer(layer, occlusion);
 
@@ -1674,50 +1545,6 @@
 ALL_OCCLUSIONTRACKER_TEST(OcclusionTrackerTestViewportRectPartlyOverChild);
 
 template<class Types>
-class OcclusionTrackerTestLayerClipRectOverNothing : public OcclusionTrackerTest<Types> {
-protected:
-    OcclusionTrackerTestLayerClipRectOverNothing(bool opaqueLayers) : OcclusionTrackerTest<Types>(opaqueLayers) {}
-    void runMyTest()
-    {
-        typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
-        typename Types::ContentLayerType* layer = this->createDrawingSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(200, 200), true);
-        this->calcDrawEtc(parent);
-
-        TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(500, 500, 100, 100));
-
-        this->enterLayer(layer, occlusion);
-
-        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(0, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(0, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(100, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(100, 100, 100, 100)));
-
-        this->leaveLayer(layer, occlusion);
-        this->visitContributingSurface(layer, occlusion);
-        this->enterLayer(parent, occlusion);
-
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 100, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 0, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(0, 200, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(100, 200, 100, 100)));
-        EXPECT_TRUE(occlusion.occludedLayer(parent, gfx::Rect(200, 200, 100, 100)));
-
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 300)).IsEmpty());
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 100)).IsEmpty());
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 100, 300, 100)).IsEmpty());
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(200, 100, 100, 100)).IsEmpty());
-        EXPECT_TRUE(occlusion.unoccludedLayerContentRect(parent, gfx::Rect(100, 200, 100, 100)).IsEmpty());
-    }
-};
-
-ALL_OCCLUSIONTRACKER_TEST(OcclusionTrackerTestLayerClipRectOverNothing);
-
-template<class Types>
 class OcclusionTrackerTestViewportRectOverNothing : public OcclusionTrackerTest<Types> {
 protected:
     OcclusionTrackerTestViewportRectOverNothing(bool opaqueLayers) : OcclusionTrackerTest<Types>(opaqueLayers) {}
@@ -1728,7 +1555,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(500, 500, 100, 100));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->enterLayer(layer, occlusion);
 
@@ -1807,11 +1633,6 @@
         // Occluded since its outside the surface bounds.
         EXPECT_TRUE(occlusion.occludedLayer(layer, gfx::Rect(200, 100, 100, 100)));
 
-        // Test without any clip rect.
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
-        EXPECT_FALSE(occlusion.occludedLayer(layer, gfx::Rect(200, 100, 100, 100)));
-        occlusion.useDefaultLayerClipRect();
-
         this->leaveLayer(layer, occlusion);
         this->visitContributingSurface(layer, occlusion);
         this->enterLayer(parent, occlusion);
@@ -1888,7 +1709,7 @@
     void runMyTest()
     {
         gfx::Transform transform;
-        MathUtil::rotateEulerAngles(&transform, 0, 30, 0);
+        transform.RotateAboutYAxis(30);
 
         typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
         typename Types::LayerType* container = this->createLayer(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
@@ -2077,6 +1898,14 @@
     OcclusionTrackerTestAnimationOpacity1OnMainThread(bool opaqueLayers) : OcclusionTrackerTest<Types>(opaqueLayers) {}
     void runMyTest()
     {
+        // parent
+        // +--layer
+        // +--surface
+        // |  +--surfaceChild
+        // |  +--surfaceChild2
+        // +--parent2
+        // +--topmost
+
         typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300));
         typename Types::ContentLayerType* layer = this->createDrawingLayer(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300), true);
         typename Types::ContentLayerType* surface = this->createDrawingSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 300), true);
@@ -2098,22 +1927,34 @@
         this->visitLayer(topmost, occlusion);
         this->enterLayer(parent2, occlusion);
         // This occlusion will affect all surfaces.
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 250, 300), occlusion.unoccludedLayerContentRect(parent2, gfx::Rect(0, 0, 300, 300)));
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect(0, 0, 250, 300).ToString(), occlusion.unoccludedLayerContentRect(parent2, gfx::Rect(0, 0, 300, 300)).ToString());
         this->leaveLayer(parent2, occlusion);
 
         this->visitLayer(surfaceChild2, occlusion);
         this->enterLayer(surfaceChild, occlusion);
-        EXPECT_RECT_EQ(gfx::Rect(100, 0, 100, 300), occlusion.unoccludedLayerContentRect(surfaceChild, gfx::Rect(0, 0, 300, 300)));
+        EXPECT_EQ(gfx::Rect(0, 0, 100, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromOutsideTarget().ToString());
+        EXPECT_RECT_EQ(gfx::Rect(100, 0, 100, 300), occlusion.unoccludedLayerContentRect(surfaceChild, gfx::Rect(0, 0, 200, 300)));
         this->leaveLayer(surfaceChild, occlusion);
         this->enterLayer(surface, occlusion);
+        EXPECT_EQ(gfx::Rect(0, 0, 200, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_RECT_EQ(gfx::Rect(200, 0, 50, 300), occlusion.unoccludedLayerContentRect(surface, gfx::Rect(0, 0, 300, 300)));
         this->leaveLayer(surface, occlusion);
 
         this->enterContributingSurface(surface, occlusion);
         // Occlusion within the surface is lost when leaving the animating surface.
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_RECT_EQ(gfx::Rect(0, 0, 250, 300), occlusion.unoccludedContributingSurfaceContentRect(surface, false, gfx::Rect(0, 0, 300, 300)));
         this->leaveContributingSurface(surface, occlusion);
 
+        // Occlusion from outside the animating surface still exists.
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
+
         this->visitLayer(layer, occlusion);
         this->enterLayer(parent, occlusion);
 
@@ -2151,22 +1992,34 @@
         this->visitLayer(topmost, occlusion);
         this->enterLayer(parent2, occlusion);
         // This occlusion will affect all surfaces.
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_RECT_EQ(gfx::Rect(0, 0, 250, 300), occlusion.unoccludedLayerContentRect(parent, gfx::Rect(0, 0, 300, 300)));
         this->leaveLayer(parent2, occlusion);
 
         this->visitLayer(surfaceChild2, occlusion);
         this->enterLayer(surfaceChild, occlusion);
-        EXPECT_RECT_EQ(gfx::Rect(100, 0, 100, 300), occlusion.unoccludedLayerContentRect(surfaceChild, gfx::Rect(0, 0, 300, 300)));
+        EXPECT_EQ(gfx::Rect(0, 0, 100, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromOutsideTarget().ToString());
+        EXPECT_RECT_EQ(gfx::Rect(100, 0, 100, 300), occlusion.unoccludedLayerContentRect(surfaceChild, gfx::Rect(0, 0, 200, 300)));
         this->leaveLayer(surfaceChild, occlusion);
         this->enterLayer(surface, occlusion);
+        EXPECT_EQ(gfx::Rect(0, 0, 200, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_RECT_EQ(gfx::Rect(200, 0, 50, 300), occlusion.unoccludedLayerContentRect(surface, gfx::Rect(0, 0, 300, 300)));
         this->leaveLayer(surface, occlusion);
 
         this->enterContributingSurface(surface, occlusion);
         // Occlusion within the surface is lost when leaving the animating surface.
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
         EXPECT_RECT_EQ(gfx::Rect(0, 0, 250, 300), occlusion.unoccludedContributingSurfaceContentRect(surface, false, gfx::Rect(0, 0, 300, 300)));
         this->leaveContributingSurface(surface, occlusion);
 
+        // Occlusion from outside the animating surface still exists.
+        EXPECT_EQ(gfx::Rect(250, 0, 50, 300).ToString(), occlusion.occlusionFromInsideTarget().ToString());
+        EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
+
         this->visitLayer(layer, occlusion);
         this->enterLayer(parent, occlusion);
 
@@ -2341,7 +2194,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // |topmost| occludes the replica, but not the surface itself.
         this->visitLayer(topmost, occlusion);
@@ -2376,7 +2228,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // |topmost| occludes the surface, but not the entire surface's replica.
         this->visitLayer(topmost, occlusion);
@@ -2413,7 +2264,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // These occlude the surface and replica differently, so we can test each one.
         this->visitLayer(overReplica, occlusion);
@@ -2546,7 +2396,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // |topmost| occludes everything partially so we know occlusion is happening at all.
         this->visitLayer(topmost, occlusion);
@@ -2611,7 +2460,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // These layers occlude pixels directly beside the filteredSurface. Because filtered surface blends pixels in a radius, it will
         // need to see some of the pixels (up to radius far) underneath the occludingLayers.
@@ -2631,19 +2479,8 @@
         EXPECT_EQ(expectedOcclusion.ToString(), occlusion.occlusionFromInsideTarget().ToString());
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
 
-        // Everything outside the surface/replica is occluded but the surface/replica itself is not.
-        this->enterLayer(filteredSurface, occlusion);
-        EXPECT_RECT_EQ(gfx::Rect(1, 0, 99, 100), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(1, 0, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(0, 1, 100, 99), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(0, 1, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 99, 100), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(-1, 0, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 100, 99), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(0, -1, 100, 100)));
+        this->visitLayer(filteredSurface, occlusion);
 
-        EXPECT_RECT_EQ(gfx::Rect(300 + 1, 0, 99, 100), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(300 + 1, 0, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(300 + 0, 1, 100, 99), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(300 + 0, 1, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(300 + 0, 0, 99, 100), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(300 - 1, 0, 100, 100)));
-        EXPECT_RECT_EQ(gfx::Rect(300 + 0, 0, 100, 99), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(300 + 0, -1, 100, 100)));
-        this->leaveLayer(filteredSurface, occlusion);
-
         // The filtered layer/replica does not occlude.
         Region expectedOcclusionOutsideSurface;
         expectedOcclusionOutsideSurface.Union(gfx::Rect(-50, -50, 300, 50));
@@ -2746,7 +2583,6 @@
         this->calcDrawEtc(root);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(occludingLayerAbove, occlusion);
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
@@ -2778,7 +2614,7 @@
         typename Types::ContentLayerType* parent = this->createRoot(this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 150));
         // We stick the filtered surface inside a clipping surface so that we can make sure the clip is honored when exposing pixels for
         // the background filter.
-        typename Types::LayerType* clippingSurface = this->createSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 70));
+        typename Types::LayerType* clippingSurface = this->createDrawingSurface(parent, this->identityMatrix, gfx::PointF(0, 0), gfx::Size(300, 70), false);
         clippingSurface->setMasksToBounds(true);
         typename Types::LayerType* filteredSurface = this->createDrawingLayer(clippingSurface, this->identityMatrix, gfx::PointF(50, 50), gfx::Size(50, 50), false);
         this->createReplicaLayer(filteredSurface, this->identityMatrix, gfx::PointF(150, 0), gfx::Size());
@@ -2800,7 +2636,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // These layers occlude pixels directly beside the filteredSurface. Because filtered surface blends pixels in a radius, it will
         // need to see some of the pixels (up to radius far) underneath the occludingLayers.
@@ -2821,18 +2656,8 @@
         EXPECT_EQ(gfx::Rect().ToString(), occlusion.occlusionFromOutsideTarget().ToString());
 
         // Everything outside the surface/replica is occluded but the surface/replica itself is not.
-        this->enterLayer(filteredSurface, occlusion);
-        EXPECT_RECT_EQ(gfx::Rect(1, 0, 49, 50), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(1, 0, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(0, 1, 50, 49), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(0, 1, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 49, 50), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(-1, 0, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 50, 49), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(0, -1, 50, 50)));
+        this->visitLayer(filteredSurface, occlusion);
 
-        EXPECT_RECT_EQ(gfx::Rect(150 + 1, 0, 49, 50), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(150 + 1, 0, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(150 + 0, 1, 50, 49), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(150 + 0, 1, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(150 + 0, 0, 49, 50), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(150 - 1, 0, 50, 50)));
-        EXPECT_RECT_EQ(gfx::Rect(150 + 0, 0, 50, 49), occlusion.unoccludedLayerContentRect(filteredSurface, gfx::Rect(150 + 0, -1, 50, 50)));
-        this->leaveLayer(filteredSurface, occlusion);
-
         // The filtered layer/replica does not occlude.
         Region expectedOcclusionOutsideSurface;
         expectedOcclusionOutsideSurface.Union(gfx::Rect(-50, -50, 300, 50));
@@ -2848,6 +2673,7 @@
         // it needs should be removed some the occluded area so that when we get to the parent they are drawn.
         this->visitContributingSurface(filteredSurface, occlusion);
 
+        this->visitLayer(clippingSurface, occlusion);
         this->enterContributingSurface(clippingSurface, occlusion);
 
         Region expectedBlurredOcclusion;
@@ -2866,7 +2692,9 @@
 
         // Nothing in the (clipped) blur outsets for the filteredSurface is occluded.
         outsetRect = gfx::Rect(50 - outsetLeft, 50 - outsetTop, 50 + outsetLeft + outsetRight, 50 + outsetTop + outsetBottom);
-        clippedOutsetRect = gfx::IntersectRects(outsetRect, gfx::Rect(0 - outsetLeft, 0 - outsetTop, 300 + outsetLeft + outsetRight, 70 + outsetTop + outsetBottom));
+        clippedOutsetRect = outsetRect;
+        clippedOutsetRect.Intersect(gfx::Rect(0 - outsetLeft, 0 - outsetTop, 300 + outsetLeft + outsetRight, 70 + outsetTop + outsetBottom));
+        clippedOutsetRect.Intersect(gfx::Rect(0, 0, 300, 70));
         testRect = outsetRect;
         EXPECT_RECT_EQ(clippedOutsetRect, occlusion.unoccludedLayerContentRect(clippingSurface, testRect));
 
@@ -2886,7 +2714,9 @@
 
         // Nothing in the (clipped) blur outsets for the filteredSurface's replica is occluded.
         outsetRect = gfx::Rect(200 - outsetLeft, 50 - outsetTop, 50 + outsetLeft + outsetRight, 50 + outsetTop + outsetBottom);
-        clippedOutsetRect = gfx::IntersectRects(outsetRect, gfx::Rect(0 - outsetLeft, 0 - outsetTop, 300 + outsetLeft + outsetRight, 70 + outsetTop + outsetBottom));
+        clippedOutsetRect = outsetRect;
+        clippedOutsetRect.Intersect(gfx::Rect(0 - outsetLeft, 0 - outsetTop, 300 + outsetLeft + outsetRight, 70 + outsetTop + outsetBottom));
+        clippedOutsetRect.Intersect(gfx::Rect(0, 0, 300, 70));
         testRect = outsetRect;
         EXPECT_RECT_EQ(clippedOutsetRect, occlusion.unoccludedLayerContentRect(clippingSurface, testRect));
 
@@ -2934,7 +2764,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         // The surface has a background blur, so it blurs non-opaque pixels below it.
         this->visitLayer(filteredSurface, occlusion);
@@ -2983,7 +2812,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(aboveReplicaLayer, occlusion);
         this->visitLayer(aboveSurfaceLayer, occlusion);
@@ -3049,7 +2877,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
 
         this->visitLayer(besideReplicaLayer, occlusion);
         this->visitLayer(besideSurfaceLayer, occlusion);
@@ -3104,7 +2931,6 @@
         this->calcDrawEtc(parent);
 
         TestOcclusionTrackerWithClip<typename Types::LayerType, typename Types::RenderSurfaceType> occlusion(gfx::Rect(0, 0, 1000, 1000));
-        occlusion.setLayerClipRect(gfx::Rect(0, 0, 1000, 1000));
         occlusion.setMinimumTrackingSize(trackingSize);
 
         // The small layer is not tracked because it is too small.
@@ -3188,27 +3014,26 @@
 
         this->enterLayer(large, occlusion);
 
-        // Clipping from the smaller layer doesn't cross the surface boundary. The layer is clipped by its target surface which is not outside its target.
-        // TODO(danakj): This will change if we clip the layer to its target surface's contentRect.
+        // Clipping from the smaller layer is from outside the target surface.
         bool hasOcclusionFromOutsideTargetSurface = false;
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 200, 200), occlusion.unoccludedLayerContentRect(large, gfx::Rect(0, 0, 400, 400), &hasOcclusionFromOutsideTargetSurface));
-        EXPECT_FALSE(hasOcclusionFromOutsideTargetSurface);
+        EXPECT_RECT_EQ(gfx::Rect(0, 0, 100, 100), occlusion.unoccludedLayerContentRect(large, gfx::Rect(0, 0, 400, 400), &hasOcclusionFromOutsideTargetSurface));
+        EXPECT_TRUE(hasOcclusionFromOutsideTargetSurface);
 
         hasOcclusionFromOutsideTargetSurface = false;
         EXPECT_FALSE(occlusion.occludedLayer(large, gfx::Rect(0, 0, 400, 400), &hasOcclusionFromOutsideTargetSurface));
-        EXPECT_FALSE(hasOcclusionFromOutsideTargetSurface);
+        EXPECT_TRUE(hasOcclusionFromOutsideTargetSurface);
 
         this->leaveLayer(large, occlusion);
         this->visitLayer(small, occlusion);
 
-        // Clipping from the smaller layer doesn't cross the surface boundary.
+        // Clipping from the smaller layer is from outside the target surface.
         hasOcclusionFromOutsideTargetSurface = false;
-        EXPECT_RECT_EQ(gfx::Rect(0, 0, 200, 200), occlusion.unoccludedLayerContentRect(small, gfx::Rect(0, 0, 200, 200), &hasOcclusionFromOutsideTargetSurface));
-        EXPECT_FALSE(hasOcclusionFromOutsideTargetSurface);
+        EXPECT_RECT_EQ(gfx::Rect(0, 0, 100, 100), occlusion.unoccludedLayerContentRect(small, gfx::Rect(0, 0, 200, 200), &hasOcclusionFromOutsideTargetSurface));
+        EXPECT_TRUE(hasOcclusionFromOutsideTargetSurface);
 
         hasOcclusionFromOutsideTargetSurface = false;
         EXPECT_FALSE(occlusion.occludedLayer(small, gfx::Rect(0, 0, 200, 200), &hasOcclusionFromOutsideTargetSurface));
-        EXPECT_FALSE(hasOcclusionFromOutsideTargetSurface);
+        EXPECT_TRUE(hasOcclusionFromOutsideTargetSurface);
 
         this->enterContributingSurface(small, occlusion);
 
Index: src/cc/layer_tree_impl.cc
===================================================================
--- src/cc/layer_tree_impl.cc	(revision 184497)
+++ src/cc/layer_tree_impl.cc	(working copy)
@@ -4,18 +4,32 @@
 
 #include "cc/layer_tree_impl.h"
 
+#include "base/debug/trace_event.h"
+#include "cc/heads_up_display_layer_impl.h"
 #include "cc/layer_tree_host_common.h"
 #include "cc/layer_tree_host_impl.h"
+#include "ui/gfx/vector2d_conversions.h"
 
 namespace cc {
 
 LayerTreeImpl::LayerTreeImpl(LayerTreeHostImpl* layer_tree_host_impl)
-    : layer_tree_host_impl_(layer_tree_host_impl)
-    , source_frame_number_(-1)
-    , hud_layer_(0)
-    , root_scroll_layer_(0)
-    , currently_scrolling_layer_(0)
-    , scrolling_layer_id_from_previous_tree_(0) {
+    : layer_tree_host_impl_(layer_tree_host_impl),
+      source_frame_number_(-1),
+      hud_layer_(0),
+      root_scroll_layer_(0),
+      currently_scrolling_layer_(0),
+      background_color_(0),
+      has_transparent_background_(false),
+      page_scale_factor_(1),
+      page_scale_delta_(1),
+      sent_page_scale_delta_(1),
+      min_page_scale_factor_(0),
+      max_page_scale_factor_(0),
+      scrolling_layer_id_from_previous_tree_(0),
+      contents_textures_purged_(false),
+      viewport_size_invalid_(false),
+      needs_update_draw_properties_(true),
+      needs_full_tree_sync_(true) {
 }
 
 LayerTreeImpl::~LayerTreeImpl() {
@@ -43,8 +57,14 @@
 
 void LayerTreeImpl::SetRootLayer(scoped_ptr<LayerImpl> layer) {
   root_layer_ = layer.Pass();
+  root_scroll_layer_ = NULL;
+  currently_scrolling_layer_ = NULL;
+
+  layer_tree_host_impl_->OnCanDrawStateChangedForTree(this);
+}
+
+void LayerTreeImpl::FindRootScrollLayer() {
   root_scroll_layer_ = findRootScrollLayer(root_layer_.get());
-  currently_scrolling_layer_ = 0;
 
   if (root_layer_ && scrolling_layer_id_from_previous_tree_) {
     currently_scrolling_layer_ = LayerTreeHostCommon::findLayerInSubtree(
@@ -53,24 +73,237 @@
   }
 
   scrolling_layer_id_from_previous_tree_ = 0;
-
-  layer_tree_host_impl_->OnCanDrawStateChangedForTree(this);
 }
 
 scoped_ptr<LayerImpl> LayerTreeImpl::DetachLayerTree() {
   // Clear all data structures that have direct references to the layer tree.
   scrolling_layer_id_from_previous_tree_ =
     currently_scrolling_layer_ ? currently_scrolling_layer_->id() : 0;
+  root_scroll_layer_ = NULL;
   currently_scrolling_layer_ = NULL;
 
+  render_surface_layer_list_.clear();
+  set_needs_update_draw_properties();
   return root_layer_.Pass();
 }
 
+void LayerTreeImpl::pushPropertiesTo(LayerTreeImpl* target_tree) {
+  target_tree->SetPageScaleFactorAndLimits(
+      page_scale_factor(), min_page_scale_factor(), max_page_scale_factor());
+  target_tree->SetPageScaleDelta(
+      target_tree->page_scale_delta() / target_tree->sent_page_scale_delta());
+  target_tree->set_sent_page_scale_delta(1);
+
+  // This should match the property synchronization in
+  // LayerTreeHost::finishCommitOnImplThread().
+  target_tree->set_source_frame_number(source_frame_number());
+  target_tree->set_background_color(background_color());
+  target_tree->set_has_transparent_background(has_transparent_background());
+
+  if (ContentsTexturesPurged())
+    target_tree->SetContentsTexturesPurged();
+  else
+    target_tree->ResetContentsTexturesPurged();
+
+  if (ViewportSizeInvalid())
+    target_tree->SetViewportSizeInvalid();
+  else
+    target_tree->ResetViewportSizeInvalid();
+
+  if (hud_layer())
+    target_tree->set_hud_layer(static_cast<HeadsUpDisplayLayerImpl*>(
+        LayerTreeHostCommon::findLayerInSubtree(
+            target_tree->RootLayer(), hud_layer()->id())));
+  else
+    target_tree->set_hud_layer(NULL);
+}
+
+LayerImpl* LayerTreeImpl::RootScrollLayer() {
+  DCHECK(IsActiveTree());
+  return root_scroll_layer_;
+}
+
+LayerImpl* LayerTreeImpl::CurrentlyScrollingLayer() {
+  DCHECK(IsActiveTree());
+  return currently_scrolling_layer_;
+}
+
 void LayerTreeImpl::ClearCurrentlyScrollingLayer() {
   currently_scrolling_layer_ = NULL;
   scrolling_layer_id_from_previous_tree_ = 0;
 }
 
+void LayerTreeImpl::SetPageScaleFactorAndLimits(float page_scale_factor,
+    float min_page_scale_factor, float max_page_scale_factor)
+{
+  if (!page_scale_factor)
+    return;
+
+  min_page_scale_factor_ = min_page_scale_factor;
+  max_page_scale_factor_ = max_page_scale_factor;
+  page_scale_factor_ = page_scale_factor;
+}
+
+void LayerTreeImpl::SetPageScaleDelta(float delta)
+{
+  // Clamp to the current min/max limits.
+  float total = page_scale_factor_ * delta;
+  if (min_page_scale_factor_ && total < min_page_scale_factor_)
+    delta = min_page_scale_factor_ / page_scale_factor_;
+  else if (max_page_scale_factor_ && total > max_page_scale_factor_)
+    delta = max_page_scale_factor_ / page_scale_factor_;
+
+  if (delta == page_scale_delta_)
+    return;
+
+  page_scale_delta_ = delta;
+
+  if (IsActiveTree()) {
+    LayerTreeImpl* pending_tree = layer_tree_host_impl_->pendingTree();
+    if (pending_tree) {
+      DCHECK_EQ(1, pending_tree->sent_page_scale_delta());
+      pending_tree->SetPageScaleDelta(page_scale_delta_ / sent_page_scale_delta_);
+    }
+  }
+
+  UpdateMaxScrollOffset();
+  set_needs_update_draw_properties();
+}
+
+gfx::SizeF LayerTreeImpl::ScrollableViewportSize() const {
+  gfx::SizeF view_bounds;
+  // The clip layer should be used for scrolling bounds if available since it
+  // adjusts for non-overlay scrollbars. Otherwise, fall back to our knowledge
+  // of the physical viewport size.
+  LayerImpl* clip_layer = NULL;
+  if (root_scroll_layer_)
+    clip_layer = root_scroll_layer_->parent();
+  if (clip_layer && clip_layer->masksToBounds()) {
+    view_bounds = clip_layer->bounds();
+  } else {
+    view_bounds = gfx::ScaleSize(device_viewport_size(),
+        1 / device_scale_factor());
+  }
+  view_bounds.Scale(1 / total_page_scale_factor());
+
+  return view_bounds;
+}
+
+void LayerTreeImpl::UpdateMaxScrollOffset() {
+  if (!root_scroll_layer_ || !root_scroll_layer_->children().size())
+    return;
+
+  gfx::Vector2dF max_scroll = gfx::Rect(ScrollableSize()).bottom_right() -
+      gfx::RectF(ScrollableViewportSize()).bottom_right();
+
+  // The viewport may be larger than the contents in some cases, such as
+  // having a vertical scrollbar but no horizontal overflow.
+  max_scroll.ClampToMin(gfx::Vector2dF());
+
+  root_scroll_layer_->setMaxScrollOffset(gfx::ToFlooredVector2d(max_scroll));
+}
+
+gfx::Transform LayerTreeImpl::ImplTransform() const {
+  gfx::Transform transform;
+  transform.Scale(page_scale_delta_, page_scale_delta_);
+  if (settings().pageScalePinchZoomEnabled)
+      transform.Scale(page_scale_factor_, page_scale_factor_);
+  return transform;
+}
+
+struct UpdateTilePrioritiesForLayer {
+  void operator()(LayerImpl *layer) {
+    layer->updateTilePriorities();
+  }
+};
+
+void LayerTreeImpl::UpdateDrawProperties(UpdateDrawPropertiesReason reason) {
+  if (!needs_update_draw_properties_) {
+    if (reason == UPDATE_ACTIVE_TREE_FOR_DRAW && RootLayer())
+      LayerTreeHostCommon::callFunctionForSubtree<UpdateTilePrioritiesForLayer>(
+          RootLayer());
+    return;
+  }
+
+  needs_update_draw_properties_ = false;
+  render_surface_layer_list_.clear();
+
+  // For maxTextureSize.
+  if (!layer_tree_host_impl_->renderer())
+      return;
+
+  if (!RootLayer())
+    return;
+
+  if (root_scroll_layer_) {
+    root_scroll_layer_->setImplTransform(ImplTransform());
+    // Setting the impl transform re-sets this.
+    needs_update_draw_properties_ = false;
+  }
+
+  {
+    TRACE_EVENT1("cc", "LayerTreeImpl::UpdateDrawProperties", "IsActive", IsActiveTree());
+    bool update_tile_priorities =
+        reason == UPDATE_PENDING_TREE ||
+        reason == UPDATE_ACTIVE_TREE_FOR_DRAW;
+    LayerTreeHostCommon::calculateDrawProperties(
+        RootLayer(),
+        device_viewport_size(),
+        device_scale_factor(),
+        total_page_scale_factor(),
+        MaxTextureSize(),
+        settings().canUseLCDText,
+        render_surface_layer_list_,
+        update_tile_priorities);
+  }
+
+  DCHECK(!needs_update_draw_properties_) <<
+      "calcDrawProperties should not set_needs_update_draw_properties()";
+}
+
+static void ClearRenderSurfacesOnLayerImplRecursive(LayerImpl* current)
+{
+    DCHECK(current);
+    for (size_t i = 0; i < current->children().size(); ++i)
+        ClearRenderSurfacesOnLayerImplRecursive(current->children()[i]);
+    current->clearRenderSurface();
+}
+
+void LayerTreeImpl::ClearRenderSurfaces() {
+  ClearRenderSurfacesOnLayerImplRecursive(RootLayer());
+  render_surface_layer_list_.clear();
+  set_needs_update_draw_properties();
+}
+
+bool LayerTreeImpl::AreVisibleResourcesReady() const {
+  TRACE_EVENT0("cc", "LayerTreeImpl::AreVisibleResourcesReady");
+
+  typedef LayerIterator<LayerImpl,
+                        std::vector<LayerImpl*>,
+                        RenderSurfaceImpl,
+                        LayerIteratorActions::BackToFront> LayerIteratorType;
+  LayerIteratorType end = LayerIteratorType::end(&render_surface_layer_list_);
+  for (LayerIteratorType it = LayerIteratorType::begin(
+           &render_surface_layer_list_); it != end; ++it) {
+    if (it.representsItself() && !(*it)->areVisibleResourcesReady())
+      return false;
+  }
+
+  return true;
+}
+
+const LayerTreeImpl::LayerList& LayerTreeImpl::RenderSurfaceLayerList() const {
+  // If this assert triggers, then the list is dirty.
+  DCHECK(!needs_update_draw_properties_);
+  return render_surface_layer_list_;
+}
+
+gfx::Size LayerTreeImpl::ScrollableSize() const {
+  if (!root_scroll_layer_ || root_scroll_layer_->children().empty())
+    return gfx::Size();
+  return root_scroll_layer_->children()[0]->bounds();
+}
+
 LayerImpl* LayerTreeImpl::LayerById(int id) {
   LayerIdMap::iterator iter = layer_id_map_.find(id);
   return iter != layer_id_map_.end() ? iter->second : NULL;
@@ -86,10 +319,65 @@
   layer_id_map_.erase(layer->id());
 }
 
+void LayerTreeImpl::PushPersistedState(LayerTreeImpl* pendingTree) {
+  int id = currently_scrolling_layer_ ? currently_scrolling_layer_->id() : 0;
+  pendingTree->set_currently_scrolling_layer(
+      LayerTreeHostCommon::findLayerInSubtree(pendingTree->RootLayer(), id));
+}
+
+static void DidBecomeActiveRecursive(LayerImpl* layer) {
+  layer->didBecomeActive();
+  for (size_t i = 0; i < layer->children().size(); ++i)
+    DidBecomeActiveRecursive(layer->children()[i]);
+}
+
+void LayerTreeImpl::DidBecomeActive() {
+  if (RootLayer())
+    DidBecomeActiveRecursive(RootLayer());
+  FindRootScrollLayer();
+  UpdateMaxScrollOffset();
+}
+
+bool LayerTreeImpl::ContentsTexturesPurged() const {
+  return contents_textures_purged_;
+}
+
+void LayerTreeImpl::SetContentsTexturesPurged() {
+  contents_textures_purged_ = true;
+  layer_tree_host_impl_->OnCanDrawStateChangedForTree(this);
+}
+
+void LayerTreeImpl::ResetContentsTexturesPurged() {
+  contents_textures_purged_ = false;
+  layer_tree_host_impl_->OnCanDrawStateChangedForTree(this);
+}
+
+bool LayerTreeImpl::ViewportSizeInvalid() const {
+  return viewport_size_invalid_;
+}
+
+void LayerTreeImpl::SetViewportSizeInvalid() {
+  viewport_size_invalid_ = true;
+  layer_tree_host_impl_->OnCanDrawStateChangedForTree(this);
+}
+
+void LayerTreeImpl::ResetViewportSizeInvalid() {
+  viewport_size_invalid_ = false;
+  layer_tree_host_impl_->OnCanDrawStateChangedForTree(this);
+}
+
+Proxy* LayerTreeImpl::proxy() const {
+  return layer_tree_host_impl_->proxy();
+}
+
 const LayerTreeSettings& LayerTreeImpl::settings() const {
   return layer_tree_host_impl_->settings();
 }
 
+const RendererCapabilities& LayerTreeImpl::rendererCapabilities() const {
+  return layer_tree_host_impl_->rendererCapabilities();
+}
+
 OutputSurface* LayerTreeImpl::output_surface() const {
   return layer_tree_host_impl_->outputSurface();
 }
@@ -106,6 +394,14 @@
   return layer_tree_host_impl_->fpsCounter();
 }
 
+PaintTimeCounter* LayerTreeImpl::paint_time_counter() const {
+  return layer_tree_host_impl_->paintTimeCounter();
+}
+
+MemoryHistory* LayerTreeImpl::memory_history() const {
+  return layer_tree_host_impl_->memoryHistory();
+}
+
 bool LayerTreeImpl::IsActiveTree() const {
   return layer_tree_host_impl_->activeTree() == this;
 }
@@ -114,6 +410,10 @@
   return layer_tree_host_impl_->pendingTree() == this;
 }
 
+bool LayerTreeImpl::IsRecycleTree() const {
+  return layer_tree_host_impl_->recycleTree() == this;
+}
+
 LayerImpl* LayerTreeImpl::FindActiveTreeLayerById(int id) {
   LayerTreeImpl* tree = layer_tree_host_impl_->activeTree();
   if (!tree)
@@ -128,14 +428,22 @@
   return tree->LayerById(id);
 }
 
+int LayerTreeImpl::MaxTextureSize() const {
+  return layer_tree_host_impl_->rendererCapabilities().maxTextureSize;
+}
+
+bool LayerTreeImpl::PinchGestureActive() const {
+  return layer_tree_host_impl_->pinchGestureActive();
+}
+
+base::TimeTicks LayerTreeImpl::CurrentFrameTime() const {
+  return layer_tree_host_impl_->currentFrameTime();
+}
+
 void LayerTreeImpl::SetNeedsRedraw() {
   layer_tree_host_impl_->setNeedsRedraw();
 }
 
-void LayerTreeImpl::SetNeedsUpdateDrawProperties() {
-  layer_tree_host_impl_->setNeedsUpdateDrawProperties();
-}
-
 const LayerTreeDebugState& LayerTreeImpl::debug_state() const {
   return layer_tree_host_impl_->debugState();
 }
@@ -160,5 +468,8 @@
   return layer_tree_host_impl_->debugRectHistory();
 }
 
+AnimationRegistrar* LayerTreeImpl::animationRegistrar() const {
+  return layer_tree_host_impl_->animationRegistrar();
+}
 
 } // namespace cc
Index: src/cc/scrollbar_geometry_fixed_thumb.cc
===================================================================
--- src/cc/scrollbar_geometry_fixed_thumb.cc	(revision 184497)
+++ src/cc/scrollbar_geometry_fixed_thumb.cc	(working copy)
@@ -5,9 +5,10 @@
 #include "cc/scrollbar_geometry_fixed_thumb.h"
 
 #include <cmath>
-#include <public/WebRect.h>
-#include <public/WebScrollbar.h>
 
+#include "third_party/WebKit/Source/Platform/chromium/public/WebRect.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbar.h"
+
 using WebKit::WebRect;
 using WebKit::WebScrollbar;
 using WebKit::WebScrollbarThemeGeometry;
@@ -23,16 +24,6 @@
 {
 }
 
-void ScrollbarGeometryFixedThumb::update(WebScrollbar* scrollbar)
-{
-    int length = ScrollbarGeometryStub::thumbLength(scrollbar);
-
-    if (scrollbar->orientation() == WebScrollbar::Horizontal)
-        m_thumbSize = gfx::Size(length, scrollbar->size().height);
-    else
-        m_thumbSize = gfx::Size(scrollbar->size().width, length);
-}
-
 WebScrollbarThemeGeometry* ScrollbarGeometryFixedThumb::clone() const
 {
     ScrollbarGeometryFixedThumb* geometry = new ScrollbarGeometryFixedThumb(make_scoped_ptr(ScrollbarGeometryStub::clone()));
Index: src/cc/proxy.h
===================================================================
--- src/cc/proxy.h	(revision 184497)
+++ src/cc/proxy.h	(working copy)
@@ -7,9 +7,11 @@
 
 #include "base/basictypes.h"
 #include "base/logging.h"
+#include "base/memory/scoped_ptr.h"
 #include "base/time.h"
-#include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
+#include "skia/ext/refptr.h"
+#include "third_party/skia/include/core/SkPicture.h"
 
 namespace gfx {
 class Rect;
@@ -80,8 +82,6 @@
     // like compositeAndReadback while commits are deferred.
     virtual void setDeferCommits(bool) = 0;
 
-    virtual void didAddAnimation() = 0;
-
     virtual void mainThreadHasStoppedFlinging() = 0;
 
     virtual bool commitRequested() const = 0;
@@ -98,8 +98,9 @@
 
     virtual void acquireLayerTextures() = 0;
 
+    virtual skia::RefPtr<SkPicture> capturePicture() = 0;
+
     // Testing hooks
-    virtual void loseOutputSurface() = 0;
     virtual bool commitPendingForTesting() = 0;
 
 protected:
Index: src/cc/picture_pile.cc
===================================================================
--- src/cc/picture_pile.cc	(revision 184497)
+++ src/cc/picture_pile.cc	(working copy)
@@ -6,14 +6,19 @@
 
 #include "cc/picture_pile.h"
 #include "cc/picture_pile_impl.h"
+#include "cc/region.h"
 
 namespace {
 // Maximum number of pictures that can overlap before we collapse them into
 // a larger one.
 const int kMaxOverlapping = 2;
-// Maximum percentage area of the base picture another picture in the pile
-// can be.  If higher, we destroy the pile and recreate from scratch.
+// Maximum percentage area of the base picture another picture in the picture
+// list can be.  If higher, we destroy the list and recreate from scratch.
 const float kResetThreshold = 0.7f;
+// Layout pixel buffer around the visible layer rect to record.  Any base
+// picture that intersects the visible layer rect expanded by this distance
+// will be recorded.
+const int kPixelDistanceToRecord = 8000;
 }
 
 namespace cc {
@@ -24,30 +29,73 @@
 PicturePile::~PicturePile() {
 }
 
-void PicturePile::Resize(gfx::Size size) {
-  if (size_ == size)
-    return;
-
-  pile_.clear();
-  size_ = size;
-}
-
 void PicturePile::Update(
     ContentLayerClient* painter,
     const Region& invalidation,
+    gfx::Rect visible_layer_rect,
     RenderingStats& stats) {
-  if (pile_.empty()) {
-    ResetPile(painter, stats);
-    return;
+  gfx::Rect interest_rect = visible_layer_rect;
+  interest_rect.Inset(
+      -kPixelDistanceToRecord,
+      -kPixelDistanceToRecord,
+      -kPixelDistanceToRecord,
+      -kPixelDistanceToRecord);
+  for (Region::Iterator i(invalidation); i.has_rect(); i.next()) {
+    // Inflate all recordings from invalidations with a margin so that when
+    // scaled down to at least min_contents_scale, any final pixel touched by an
+    // invalidation can be fully rasterized by this picture.
+    gfx::Rect inflated_invalidation = i.rect();
+    inflated_invalidation.Inset(
+        -buffer_pixels(),
+        -buffer_pixels(),
+        -buffer_pixels(),
+        -buffer_pixels());
+    // Split this inflated invalidation across tile boundaries and apply it
+    // to all tiles that it touches.
+    for (TilingData::Iterator iter(&tiling_, inflated_invalidation);
+         iter; ++iter) {
+      gfx::Rect tile =
+          tiling_.TileBoundsWithBorder(iter.index_x(), iter.index_y());
+      if (!tile.Intersects(interest_rect)) {
+        // This invalidation touches a tile outside the interest rect, so
+        // just remove the entire picture list.
+        picture_list_map_.erase(iter.index());
+        continue;
+      }
+
+      gfx::Rect tile_invalidation =
+          gfx::IntersectRects(inflated_invalidation, tile);
+      if (tile_invalidation.IsEmpty())
+        continue;
+      PictureListMap::iterator find = picture_list_map_.find(iter.index());
+      if (find == picture_list_map_.end())
+        continue;
+      PictureList& pic_list = find->second;
+      // Leave empty pic_lists empty in case there are multiple invalidations.
+      if (!pic_list.empty())
+        InvalidateRect(pic_list, tile_invalidation);
+    }
   }
 
-  for (Region::Iterator i(invalidation); i.has_rect(); i.next())
-    InvalidateRect(i.rect());
+  // Walk through all pictures in the rect of interest and record.
+  for (TilingData::Iterator iter(&tiling_, interest_rect); iter; ++iter) {
+    // Create a picture in this list if it doesn't exist.
+    PictureList& pic_list = picture_list_map_[iter.index()];
+    if (pic_list.empty()) {
+      gfx::Rect tile =
+          tiling_.TileBoundsWithBorder(iter.index_x(), iter.index_y());
+      scoped_refptr<Picture> base_picture = Picture::Create(tile);
+      pic_list.push_back(base_picture);
+    }
 
-  for (Pile::iterator i = pile_.begin(); i != pile_.end(); ++i) {
-    if (!(*i)->HasRecording())
-      (*i)->Record(painter, stats);
+    for (PictureList::iterator pic = pic_list.begin();
+         pic != pic_list.end(); ++pic) {
+      if (!(*pic)->HasRecording())
+        (*pic)->Record(painter, stats);
+    }
   }
+
+  UpdateRecordedRegion();
 }
 
 class FullyContainedPredicate {
@@ -59,46 +107,47 @@
   gfx::Rect layer_rect_;
 };
 
-void PicturePile::InvalidateRect(gfx::Rect invalidation) {
-  if (invalidation.IsEmpty())
-    return;
+void PicturePile::InvalidateRect(
+    PictureList& picture_list,
+    gfx::Rect invalidation) {
+  DCHECK(!picture_list.empty());
 
-  std::vector<Pile::iterator> overlaps;
-  for (Pile::iterator i = pile_.begin(); i != pile_.end(); ++i) {
+  std::vector<PictureList::iterator> overlaps;
+  for (PictureList::iterator i = picture_list.begin();
+       i != picture_list.end(); ++i) {
     if ((*i)->LayerRect().Contains(invalidation) && !(*i)->HasRecording())
       return;
-    if ((*i)->LayerRect().Intersects(invalidation) && i != pile_.begin())
+    if ((*i)->LayerRect().Intersects(invalidation) && i != picture_list.begin())
       overlaps.push_back(i);
   }
 
   gfx::Rect picture_rect = invalidation;
   if (overlaps.size() >= kMaxOverlapping) {
     for (size_t j = 0; j < overlaps.size(); j++)
-      picture_rect = gfx::UnionRects(picture_rect, (*overlaps[j])->LayerRect());
+      picture_rect.Union((*overlaps[j])->LayerRect());
   }
-  if (picture_rect.size().GetArea() / static_cast<float>(size_.GetArea()) >
-      kResetThreshold)
-    picture_rect = gfx::Rect(size_);
 
+  Picture* base_picture = picture_list.front();
+  int max_pixels = kResetThreshold * base_picture->LayerRect().size().GetArea();
+  if (picture_rect.size().GetArea() > max_pixels) {
+    // This picture list will be entirely recreated, so clear it.
+    picture_list.clear();
+    return;
+  }
+
   FullyContainedPredicate pred(picture_rect);
-  pile_.erase(std::remove_if(pile_.begin(), pile_.end(), pred), pile_.end());
-
-  pile_.push_back(Picture::Create(picture_rect));
+  picture_list.erase(std::remove_if(picture_list.begin(),
+                                    picture_list.end(),
+                                    pred),
+                     picture_list.end());
+  picture_list.push_back(Picture::Create(picture_rect));
 }
 
 
-void PicturePile::ResetPile(ContentLayerClient* painter,
-                            RenderingStats& stats) {
-  pile_.clear();
-
-  scoped_refptr<Picture> base_picture = Picture::Create(gfx::Rect(size_));
-  base_picture->Record(painter, stats);
-  pile_.push_back(base_picture);
-}
-
 void PicturePile::PushPropertiesTo(PicturePileImpl* other) {
-  other->pile_ = pile_;
-  // Remove all old clones.
+  // TODO(enne): Don't clear clones or push anything if nothing has changed
+  // on this layer this frame.
+  PicturePileBase::PushPropertiesTo(other);
   other->clones_.clear();
 }
 
Index: src/cc/contents_scaling_layer.cc
===================================================================
--- src/cc/contents_scaling_layer.cc	(revision 184497)
+++ src/cc/contents_scaling_layer.cc	(working copy)
@@ -22,6 +22,7 @@
 
 void ContentsScalingLayer::calculateContentsScale(
     float ideal_contents_scale,
+    bool animating_transform_to_screen,
     float* contents_scale_x,
     float* contents_scale_y,
     gfx::Size* content_bounds) {
Index: src/cc/gl_renderer_pixeltest.cc
===================================================================
--- src/cc/gl_renderer_pixeltest.cc	(revision 184497)
+++ src/cc/gl_renderer_pixeltest.cc	(working copy)
@@ -93,14 +93,12 @@
 scoped_ptr<SharedQuadState> CreateTestSharedQuadState(
     gfx::Transform content_to_target_transform, gfx::Rect rect) {
   const gfx::Rect visible_content_rect = rect;
-  const gfx::Rect clipped_rect_in_target = rect;
   const gfx::Rect clip_rect = rect;
   const bool is_clipped = false;
   const float opacity = 1.0f;
   scoped_ptr<SharedQuadState> shared_state = SharedQuadState::Create();
   shared_state->SetAll(content_to_target_transform,
                        visible_content_rect,
-                       clipped_rect_in_target,
                        clip_rect,
                        is_clipped,
                        opacity);
@@ -116,7 +114,10 @@
                false,         // is_replica
                0,             // mask_resource_id
                rect,          // contents_changed_since_last_frame
-               gfx::RectF()); // mask_uv_rect
+               gfx::RectF(),  // mask_uv_rect
+               WebKit::WebFilterOperations(),   // foreground filters
+               skia::RefPtr<SkImageFilter>(),   // foreground filter
+               WebKit::WebFilterOperations());  // background filters
 
   return quad.PassAs<DrawQuad>();
 }
@@ -136,14 +137,12 @@
   scoped_ptr<SolidColorDrawQuad> color_quad = SolidColorDrawQuad::Create();
   color_quad->SetNew(shared_state.get(), rect, SK_ColorGREEN);
 
-  pass->quad_list.append(color_quad.PassAs<DrawQuad>());
+  pass->quad_list.push_back(color_quad.PassAs<DrawQuad>());
 
   RenderPassList pass_list;
-  pass_list.push_back(pass.get());
-  RenderPassIdHashMap pass_map;
-  pass_map.add(id, pass.PassAs<RenderPass>());
+  pass_list.push_back(pass.Pass());
 
-  renderer_->drawFrame(pass_list, pass_map);
+  renderer_->drawFrame(pass_list);
 
   EXPECT_TRUE(PixelsMatchReference(FilePath(FILE_PATH_LITERAL("green.png")),
                                    rect));
@@ -170,27 +169,23 @@
   scoped_ptr<SolidColorDrawQuad> yellow = SolidColorDrawQuad::Create();
   yellow->SetNew(shared_state.get(), gfx::Rect(100, 0, 100, 200), SK_ColorYELLOW);
 
-  child_pass->quad_list.append(blue.PassAs<DrawQuad>());
-  child_pass->quad_list.append(yellow.PassAs<DrawQuad>());
+  child_pass->quad_list.push_back(blue.PassAs<DrawQuad>());
+  child_pass->quad_list.push_back(yellow.PassAs<DrawQuad>());
 
   scoped_ptr<SharedQuadState> pass_shared_state =
       CreateTestSharedQuadState(gfx::Transform(), pass_rect);
-  root_pass->quad_list.append(
+  root_pass->quad_list.push_back(
       CreateTestRenderPassDrawQuad(pass_shared_state.get(),
                                    pass_rect,
                                    child_pass_id));
 
   RenderPassList pass_list;
-  pass_list.push_back(child_pass.get());
-  pass_list.push_back(root_pass.get());
+  pass_list.push_back(child_pass.Pass());
+  pass_list.push_back(root_pass.Pass());
 
-  RenderPassIdHashMap pass_map;
-  pass_map.add(child_pass_id, child_pass.Pass());
-  pass_map.add(root_pass_id, root_pass.Pass());
-
   renderer_->setEnlargePassTextureAmountForTesting(gfx::Vector2d(50, 75));
   renderer_->decideRenderPassAllocationsForFrame(pass_list);
-  renderer_->drawFrame(pass_list, pass_map);
+  renderer_->drawFrame(pass_list);
 
   EXPECT_TRUE(PixelsMatchReference(
       FilePath(FILE_PATH_LITERAL("blue_yellow.png")), viewport_rect));
Index: src/cc/gl_renderer.h
===================================================================
--- src/cc/gl_renderer.h	(revision 184497)
+++ src/cc/gl_renderer.h	(working copy)
@@ -60,11 +60,11 @@
 
     virtual void sendManagedMemoryStats(size_t bytesVisible, size_t bytesVisibleAndNearby, size_t bytesAllocated) OVERRIDE;
 
+    static void debugGLCall(WebKit::WebGraphicsContext3D*, const char* command, const char* file, int line);
+
 protected:
     GLRenderer(RendererClient*, OutputSurface*, ResourceProvider*);
 
-    static void debugGLCall(WebKit::WebGraphicsContext3D*, const char* command, const char* file, int line);
-
     bool isBackbufferDiscarded() const { return m_isBackbufferDiscarded; }
     bool initialize();
 
@@ -89,13 +89,12 @@
 
 private:
     static void toGLMatrix(float*, const gfx::Transform&);
-    static int priorityCutoffValue(WebKit::WebGraphicsMemoryAllocation::PriorityCutoff);
+    static ManagedMemoryPolicy::PriorityCutoff priorityCutoff(WebKit::WebGraphicsMemoryAllocation::PriorityCutoff);
 
     void drawCheckerboardQuad(const DrawingFrame&, const CheckerboardDrawQuad*);
     void drawDebugBorderQuad(const DrawingFrame&, const DebugBorderDrawQuad*);
     scoped_ptr<ScopedResource> drawBackgroundFilters(
         DrawingFrame&, const RenderPassDrawQuad*,
-        const WebKit::WebFilterOperations&,
         const gfx::Transform& contentsDeviceTransform,
         const gfx::Transform& contentsDeviceTransformInverse);
     void drawRenderPassQuad(DrawingFrame&, const RenderPassDrawQuad*);
@@ -232,6 +231,8 @@
 
     scoped_ptr<ResourceProvider::ScopedWriteLockGL> m_currentFramebufferLock;
 
+    scoped_refptr<ResourceProvider::Fence> m_lastSwapFence;
+
     DISALLOW_COPY_AND_ASSIGN(GLRenderer);
 };
 
Index: src/cc/io_surface_layer_impl.cc
===================================================================
--- src/cc/io_surface_layer_impl.cc	(revision 184497)
+++ src/cc/io_surface_layer_impl.cc	(working copy)
@@ -36,6 +36,19 @@
         context3d->deleteTexture(m_ioSurfaceTextureId);
 }
 
+scoped_ptr<LayerImpl> IOSurfaceLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return IOSurfaceLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+void IOSurfaceLayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    LayerImpl::pushPropertiesTo(layer);
+
+    IOSurfaceLayerImpl* ioSurfaceLayer = static_cast<IOSurfaceLayerImpl*>(layer);
+    ioSurfaceLayer->setIOSurfaceProperties(m_ioSurfaceId, m_ioSurfaceSize);
+}
+
 void IOSurfaceLayerImpl::willDraw(ResourceProvider* resourceProvider)
 {
     LayerImpl::willDraw(resourceProvider);
Index: src/cc/tile_priority.cc
===================================================================
--- src/cc/tile_priority.cc	(revision 184497)
+++ src/cc/tile_priority.cc	(working copy)
@@ -4,74 +4,92 @@
 
 #include "cc/tile_priority.h"
 
+#include "base/values.h"
+
 namespace {
 
 // TODO(qinmin): modify ui/range/Range.h to support template so that we
 // don't need to define this.
 struct Range {
-  Range(double start, double end) : start_(start), end_(end) {}
-  Range Intersects(const Range& other);
+  Range(float start, float end) : start_(start), end_(end) {}
   bool IsEmpty();
-  double start_;
-  double end_;
+  float start_;
+  float end_;
 };
 
-Range Range::Intersects(const Range& other) {
-  start_ = std::max(start_, other.start_);
-  end_ = std::min(end_, other.end_);
-  return Range(start_, end_);
+inline bool Intersects(const Range& a, const Range& b) {
+  return a.start_ < b.end_ && b.start_ < a.end_;
 }
 
+inline Range Intersect(const Range& a, const Range& b) {
+  return Range(std::max(a.start_, b.start_), std::min(a.end_, b.end_));
+}
+
 bool Range::IsEmpty() {
   return start_ >= end_;
 }
 
-// Calculate a time range that |value| will be larger than |threshold|
-// given the velocity of its change.
-Range TimeRangeValueLargerThanThreshold(
-    int value, int threshold, double velocity) {
-  double minimum_time = 0;
-  double maximum_time = cc::TilePriority::kMaxTimeToVisibleInSeconds;
+inline void IntersectNegativeHalfplane(Range& out, float previous,
+    float current, float target, float time_delta) {
+  float time_per_dist = time_delta / (current - previous);
+  float t = (target - current) * time_per_dist;
+  if (time_per_dist > 0.0f)
+    out.start_ = std::max(out.start_, t);
+  else
+    out.end_ = std::min(out.end_, t);
+}
 
-  if (velocity > 0) {
-    if (value < threshold)
-      minimum_time = std::min(cc::TilePriority::kMaxTimeToVisibleInSeconds,
-                              (threshold - value) / velocity);
-  } else if (velocity <= 0) {
-    if (value < threshold)
-      minimum_time = cc::TilePriority::kMaxTimeToVisibleInSeconds;
-    else if (velocity != 0)
-      maximum_time = std::min(maximum_time, (threshold - value) / velocity);
-  }
-
-  return Range(minimum_time, maximum_time);
+inline void IntersectPositiveHalfplane(Range& out, float previous,
+    float current, float target, float time_delta) {
+  float time_per_dist = time_delta / (current - previous);
+  float t = (target - current) * time_per_dist;
+  if (time_per_dist < 0.0f)
+    out.start_ = std::max(out.start_, t);
+  else
+    out.end_ = std::min(out.end_, t);
 }
 
 }  // namespace
 
 namespace cc {
 
-const double TilePriority::kMaxTimeToVisibleInSeconds = 1000;
+const float TilePriority::kMaxDistanceInContentSpace = 4096.0f;
 
-int TilePriority::manhattanDistance(const gfx::RectF& a, const gfx::RectF& b) {
-  gfx::RectF c = gfx::UnionRects(a, b);
-  // Rects touching the edge of the screen should not be considered visible.
-  // So we add 1 pixel here to avoid that situation.
-  int x = static_cast<int>(
-      std::max(0.0f, c.width() - a.width() - b.width() + 1));
-  int y = static_cast<int>(
-      std::max(0.0f, c.height() - a.height() - b.height() + 1));
-  return (x + y);
+// At 256x256 tiles, 80 tiles cover an area of ~1280x4906 pixels.
+const int64 TilePriority::
+    kNumTilesToCoverWithInflatedViewportRectForPrioritization = 80;
+
+scoped_ptr<base::Value> WhichTreeAsValue(WhichTree tree) {
+  switch (tree) {
+  case ACTIVE_TREE:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "ACTIVE_TREE"));
+  case PENDING_TREE:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "PENDING_TREE"));
+  default:
+      DCHECK(false) << "Unrecognized WhichTree value";
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "<unknown WhichTree value>"));
+  }
 }
 
-double TilePriority::TimeForBoundsToIntersect(gfx::RectF previous_bounds,
-                                              gfx::RectF current_bounds,
-                                              double time_delta,
-                                              gfx::RectF target_bounds) {
-  if (current_bounds.Intersects(target_bounds))
-    return 0;
 
-  if (previous_bounds.Intersects(target_bounds) || time_delta == 0)
+float TilePriority::TimeForBoundsToIntersect(const gfx::RectF& previous_bounds,
+                                             const gfx::RectF& current_bounds,
+                                             float time_delta,
+                                             const gfx::RectF& target_bounds) {
+  // Perform an intersection test explicitly between current and target.
+  if (current_bounds.x() < target_bounds.right() &&
+      current_bounds.y() < target_bounds.bottom() &&
+      target_bounds.x() < current_bounds.right() &&
+      target_bounds.y() < current_bounds.bottom())
+    return 0.0f;
+
+  const float kMaxTimeToVisibleInSeconds =
+      std::numeric_limits<float>::infinity();
+
+  if (time_delta == 0.0f)
     return kMaxTimeToVisibleInSeconds;
 
   // As we are trying to solve the case of both scaling and scrolling, using
@@ -80,25 +98,69 @@
   // each edge will stay on the same side of the target bounds. If there is an
   // overlap between these time ranges, the bounds must have intersect with
   // each other during that period of time.
-  double velocity =
-      (current_bounds.right() - previous_bounds.right()) / time_delta;
-  Range range = TimeRangeValueLargerThanThreshold(
-      current_bounds.right(), target_bounds.x(), velocity);
+  Range range(0.0f, kMaxTimeToVisibleInSeconds);
+  IntersectPositiveHalfplane(
+      range, previous_bounds.x(), current_bounds.x(),
+      target_bounds.right(), time_delta);
+  IntersectNegativeHalfplane(
+      range, previous_bounds.right(), current_bounds.right(),
+      target_bounds.x(), time_delta);
+  IntersectPositiveHalfplane(
+      range, previous_bounds.y(), current_bounds.y(),
+      target_bounds.bottom(), time_delta);
+  IntersectNegativeHalfplane(
+      range, previous_bounds.bottom(), current_bounds.bottom(),
+      target_bounds.y(), time_delta);
+  return range.IsEmpty() ? kMaxTimeToVisibleInSeconds : range.start_;
+}
 
-  velocity = (current_bounds.x() - previous_bounds.x()) / time_delta;
-  range = range.Intersects(TimeRangeValueLargerThanThreshold(
-      -current_bounds.x(), -target_bounds.right(), -velocity));
+scoped_ptr<base::Value> TileMemoryLimitPolicyAsValue(
+    TileMemoryLimitPolicy policy) {
+  switch (policy) {
+  case ALLOW_NOTHING:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "ALLOW_NOTHING"));
+  case ALLOW_ABSOLUTE_MINIMUM:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "ALLOW_ABSOLUTE_MINIMUM"));
+  case ALLOW_PREPAINT_ONLY:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "ALLOW_PREPAINT_ONLY"));
+  case ALLOW_ANYTHING:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "ALLOW_ANYTHING"));
+  default:
+      DCHECK(false) << "Unrecognized policy value";
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "<unknown>"));
+  }
+}
 
+scoped_ptr<base::Value> TreePriorityAsValue(TreePriority prio) {
+  switch (prio) {
+  case SAME_PRIORITY_FOR_BOTH_TREES:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "SAME_PRIORITY_FOR_BOTH_TREES"));
+  case SMOOTHNESS_TAKES_PRIORITY:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "SMOOTHNESS_TAKES_PRIORITY"));
+  case NEW_CONTENT_TAKES_PRIORITY:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "NEW_CONTENT_TAKES_PRIORITY"));
+  default:
+      DCHECK(false) << "Unrecognized priority value";
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "<unknown>"));
+  }
+}
 
-  velocity = (current_bounds.y() - previous_bounds.y()) / time_delta;
-  range = range.Intersects(TimeRangeValueLargerThanThreshold(
-      -current_bounds.y(), -target_bounds.bottom(), -velocity));
+scoped_ptr<base::Value> GlobalStateThatImpactsTilePriority::AsValue() const {
+  scoped_ptr<base::DictionaryValue> state(new base::DictionaryValue());
+  state->Set("memory_limit_policy", TileMemoryLimitPolicyAsValue(memory_limit_policy).release());
+  state->SetInteger("memory_limit_in_bytes", memory_limit_in_bytes);
+  state->Set("tree_priority", TreePriorityAsValue(tree_priority).release());
+  return state.PassAs<base::Value>();
+}
 
-  velocity = (current_bounds.bottom() - previous_bounds.bottom()) / time_delta;
-  range = range.Intersects(TimeRangeValueLargerThanThreshold(
-      current_bounds.bottom(), target_bounds.y(), velocity));
 
-  return range.IsEmpty() ? kMaxTimeToVisibleInSeconds : range.start_;
-}
-
 }  // namespace cc
Index: src/cc/scrollbar_animation_controller_linear_fade.h
===================================================================
--- src/cc/scrollbar_animation_controller_linear_fade.h	(revision 184497)
+++ src/cc/scrollbar_animation_controller_linear_fade.h	(working copy)
@@ -5,10 +5,12 @@
 #ifndef CC_SCROLLBAR_ANIMATION_CONTROLLER_LINEAR_FADE_H_
 #define CC_SCROLLBAR_ANIMATION_CONTROLLER_LINEAR_FADE_H_
 
+#include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
 #include "cc/scrollbar_animation_controller.h"
 
 namespace cc {
+class LayerImpl;
 
 class CC_EXPORT ScrollbarAnimationControllerLinearFade : public ScrollbarAnimationController {
 public:
@@ -16,23 +18,27 @@
 
     virtual ~ScrollbarAnimationControllerLinearFade();
 
-    virtual bool animate(double monotonicTime) OVERRIDE;
+    // ScrollbarAnimationController overrides.
+    virtual bool animate(base::TimeTicks) OVERRIDE;
+    virtual void didPinchGestureUpdate(base::TimeTicks) OVERRIDE;
+    virtual void didPinchGestureEnd(base::TimeTicks) OVERRIDE;
+    virtual void didUpdateScrollOffset(base::TimeTicks) OVERRIDE;
 
-    virtual void didPinchGestureUpdateAtTime(double monotonicTime) OVERRIDE;
-    virtual void didPinchGestureEndAtTime(double monotonicTime) OVERRIDE;
-    virtual void updateScrollOffsetAtTime(LayerImpl* scrollLayer, double monotonicTime) OVERRIDE;
-
 protected:
     ScrollbarAnimationControllerLinearFade(LayerImpl* scrollLayer, double fadeoutDelay, double fadeoutLength);
 
 private:
-    float opacityAtTime(double monotonicTime);
+    float opacityAtTime(base::TimeTicks);
 
-    double m_lastAwakenTime;
+    LayerImpl* m_scrollLayer;
+
+    base::TimeTicks m_lastAwakenTime;
     bool m_pinchGestureInEffect;
 
     double m_fadeoutDelay;
     double m_fadeoutLength;
+
+    double m_currentTimeForTesting;
 };
 
 } // namespace cc
Index: src/cc/resource_provider_unittest.cc
===================================================================
--- src/cc/resource_provider_unittest.cc	(revision 184497)
+++ src/cc/resource_provider_unittest.cc	(working copy)
@@ -8,8 +8,8 @@
 #include "cc/output_surface.h"
 #include "cc/scoped_ptr_deque.h"
 #include "cc/scoped_ptr_hash_map.h"
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
 #include "cc/test/fake_output_surface.h"
+#include "cc/test/fake_web_graphics_context_3d.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
@@ -20,6 +20,10 @@
 using namespace WebKit;
 
 using testing::Mock;
+using testing::NiceMock;
+using testing::Return;
+using testing::StrictMock;
+using testing::_;
 
 namespace cc {
 namespace {
@@ -96,7 +100,7 @@
     base::hash_map<unsigned, unsigned> m_syncPointForMailbox;
 };
 
-class ResourceProviderContext : public CompositorFakeWebGraphicsContext3D {
+class ResourceProviderContext : public FakeWebGraphicsContext3D {
 public:
     static scoped_ptr<ResourceProviderContext> create(ContextSharedData* sharedData) { return make_scoped_ptr(new ResourceProviderContext(Attributes(), sharedData)); }
 
@@ -125,7 +129,7 @@
 
     virtual WebGLId createTexture()
     {
-        WebGLId id = CompositorFakeWebGraphicsContext3D::createTexture();
+        WebGLId id = FakeWebGraphicsContext3D::createTexture();
         m_textures.add(id, scoped_ptr<Texture>());
         return id;
     }
@@ -196,7 +200,7 @@
         memcpy(pending->mailbox, mailbox, sizeof(pending->mailbox));
         pending->texture = m_textures.take(m_currentTexture);
         m_textures.set(m_currentTexture, scoped_ptr<Texture>());
-        m_pendingProduceTextures.append(pending.Pass());
+        m_pendingProduceTextures.push_back(pending.Pass());
     }
 
     virtual void consumeTextureCHROMIUM(WGC3Denum target, const WGC3Dbyte* mailbox)
@@ -223,7 +227,7 @@
 
 protected:
     ResourceProviderContext(const Attributes& attrs, ContextSharedData* sharedData)
-        : CompositorFakeWebGraphicsContext3D(attrs)
+        : FakeWebGraphicsContext3D(attrs)
         , m_sharedData(sharedData)
         , m_currentTexture(0)
         , m_lastWaitedSyncPoint(0)
@@ -563,6 +567,9 @@
 public:
     MOCK_METHOD2(bindTexture, void(WGC3Denum target, WebGLId texture));
     MOCK_METHOD3(texParameteri, void(WGC3Denum target, WGC3Denum pname, WGC3Dint param));
+
+    // Force all textures to be "1" so we can test for them.
+    virtual WebKit::WebGLId NextTextureId() { return 1; }
 };
 
 TEST_P(ResourceProviderTest, ScopedSampler)
@@ -580,13 +587,15 @@
     int textureId = 1;
 
     // Check that the texture gets created with the right sampler settings.
-    EXPECT_CALL(*context, bindTexture(GL_TEXTURE_2D, textureId));
+    EXPECT_CALL(*context, bindTexture(GL_TEXTURE_2D, textureId))
+        .Times(2); // Once to create and once to allocate.
     EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
     EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
     EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
     EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
     EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_POOL_CHROMIUM, GL_TEXTURE_POOL_UNMANAGED_CHROMIUM));
     ResourceProvider::ResourceId id = resourceProvider->createResource(size, format, ResourceProvider::TextureUsageAny);
+    resourceProvider->allocateForTesting(id);
 
     // Creating a sampler with the default filter should not change any texture
     // parameters.
@@ -640,6 +649,92 @@
     Mock::VerifyAndClearExpectations(context);
 }
 
+class AllocationTrackingContext3D : public FakeWebGraphicsContext3D {
+public:
+    MOCK_METHOD0(createTexture, WebGLId());
+    MOCK_METHOD1(deleteTexture, void(WebGLId texture_id));
+    MOCK_METHOD2(bindTexture, void(WGC3Denum target, WebGLId texture));
+    MOCK_METHOD9(texImage2D, void(WGC3Denum target, WGC3Dint level, WGC3Denum internalformat,
+                                  WGC3Dsizei width, WGC3Dsizei height, WGC3Dint border, WGC3Denum format,
+                                  WGC3Denum type, const void* pixels));
+    MOCK_METHOD9(texSubImage2D, void(WGC3Denum target, WGC3Dint level, WGC3Dint xoffset, WGC3Dint yoffset,
+                                     WGC3Dsizei width, WGC3Dsizei height, WGC3Denum format,
+                                     WGC3Denum type, const void* pixels));
+    MOCK_METHOD9(asyncTexImage2DCHROMIUM, void(WGC3Denum target, WGC3Dint level, WGC3Denum internalformat,
+                                              WGC3Dsizei width, WGC3Dsizei height, WGC3Dint border, WGC3Denum format,
+                                              WGC3Denum type, const void* pixels));
+    MOCK_METHOD9(asyncTexSubImage2DCHROMIUM, void(WGC3Denum target, WGC3Dint level, WGC3Dint xoffset, WGC3Dint yoffset,
+                                                  WGC3Dsizei width, WGC3Dsizei height, WGC3Denum format,
+                                                  WGC3Denum type, const void* pixels));
+};
+
+TEST_P(ResourceProviderTest, TextureAllocation)
+{
+    // Only for GL textures.
+    if (GetParam() != ResourceProvider::GLTexture)
+        return;
+    scoped_ptr<WebKit::WebGraphicsContext3D> mock_context(
+        static_cast<WebKit::WebGraphicsContext3D*>(new NiceMock<AllocationTrackingContext3D>));
+    scoped_ptr<OutputSurface> outputSurface(FakeOutputSurface::Create3d(mock_context.Pass()));
+
+    gfx::Size size(2, 2);
+    gfx::Vector2d offset(0, 0);
+    gfx::Rect rect(0, 0, 2, 2);
+    WGC3Denum format = GL_RGBA;
+    ResourceProvider::ResourceId id = 0;
+    uint8_t pixels[16] = {0};
+    int textureId = 123;
+
+    AllocationTrackingContext3D* context = static_cast<AllocationTrackingContext3D*>(outputSurface->Context3D());
+    scoped_ptr<ResourceProvider> resourceProvider(ResourceProvider::create(outputSurface.get()));
+
+    // Lazy allocation. Don't allocate when creating the resource.
+    EXPECT_CALL(*context, createTexture()).WillOnce(Return(textureId));
+    EXPECT_CALL(*context, deleteTexture(textureId)).Times(1);
+    EXPECT_CALL(*context, bindTexture(GL_TEXTURE_2D, textureId)).Times(1);
+    EXPECT_CALL(*context, texImage2D(_,_,_,_,_,_,_,_,_)).Times(0);
+    EXPECT_CALL(*context, asyncTexImage2DCHROMIUM(_,_,_,_,_,_,_,_,_)).Times(0);
+    id = resourceProvider->createResource(size, format, ResourceProvider::TextureUsageAny);
+    resourceProvider->deleteResource(id);
+    Mock::VerifyAndClearExpectations(context);
+
+    // Do allocate when we set the pixels.
+    EXPECT_CALL(*context, createTexture()).WillOnce(Return(textureId));
+    EXPECT_CALL(*context, deleteTexture(textureId)).Times(1);
+    EXPECT_CALL(*context, bindTexture(GL_TEXTURE_2D, textureId)).Times(3);
+    EXPECT_CALL(*context, texImage2D(_,_,_,2,2,_,_,_,_)).Times(1);
+    EXPECT_CALL(*context, texSubImage2D(_,_,_,_,2,2,_,_,_)).Times(1);
+    id = resourceProvider->createResource(size, format, ResourceProvider::TextureUsageAny);
+    resourceProvider->setPixels(id, pixels, rect, rect, offset);
+    resourceProvider->deleteResource(id);
+    Mock::VerifyAndClearExpectations(context);
+
+    // Same for setPixelsFromBuffer
+    EXPECT_CALL(*context, createTexture()).WillOnce(Return(textureId));
+    EXPECT_CALL(*context, deleteTexture(textureId)).Times(1);
+    EXPECT_CALL(*context, bindTexture(GL_TEXTURE_2D, textureId)).Times(3);
+    EXPECT_CALL(*context, texImage2D(_,_,_,2,2,_,_,_,_)).Times(1);
+    EXPECT_CALL(*context, texSubImage2D(_,_,_,_,2,2,_,_,_)).Times(1);
+    id = resourceProvider->createResource(size, format, ResourceProvider::TextureUsageAny);
+    resourceProvider->acquirePixelBuffer(id);
+    resourceProvider->setPixelsFromBuffer(id);
+    resourceProvider->releasePixelBuffer(id);
+    resourceProvider->deleteResource(id);
+    Mock::VerifyAndClearExpectations(context);
+
+    // Same for async version.
+    EXPECT_CALL(*context, createTexture()).WillOnce(Return(textureId));
+    EXPECT_CALL(*context, deleteTexture(textureId)).Times(1);
+    EXPECT_CALL(*context, bindTexture(GL_TEXTURE_2D, textureId)).Times(2);
+    EXPECT_CALL(*context, asyncTexImage2DCHROMIUM(_,_,_,2,2,_,_,_,_)).Times(1);
+    id = resourceProvider->createResource(size, format, ResourceProvider::TextureUsageAny);
+    resourceProvider->acquirePixelBuffer(id);
+    resourceProvider->beginSetPixels(id);
+    resourceProvider->releasePixelBuffer(id);
+    resourceProvider->deleteResource(id);
+    Mock::VerifyAndClearExpectations(context);
+}
+
 INSTANTIATE_TEST_CASE_P(ResourceProviderTests,
                         ResourceProviderTest,
                         ::testing::Values(ResourceProvider::GLTexture,
Index: src/cc/layer_tree_host_perftest.cc
===================================================================
--- src/cc/layer_tree_host_perftest.cc	(revision 184497)
+++ src/cc/layer_tree_host_perftest.cc	(working copy)
@@ -39,7 +39,8 @@
     if ((base::TimeTicks::HighResNow() - start_time_) >=
         base::TimeDelta::FromMilliseconds(kTimeLimitMillis))
       endTest();
-    impl->setNeedsRedraw();
+    else
+      impl->setNeedsRedraw();
   }
 
   virtual void buildTree() {}
@@ -79,10 +80,10 @@
   }
 
   scoped_refptr<NinePatchLayer> CreateDecorationLayer(float x, float y, int width, int height) {
-    return CreateDecorationLayer(x, y, width, height, gfx::Rect(0, 0, width, height));
+    return CreateDecorationLayer(x, y, width, height, gfx::Size(width + 1, height + 1), gfx::Rect(0, 0, width, height));
   }
 
-  scoped_refptr<NinePatchLayer> CreateDecorationLayer(float x, float y, int width, int height, gfx::Rect aperture, bool drawable=true) {
+  scoped_refptr<NinePatchLayer> CreateDecorationLayer(float x, float y, int width, int height, gfx::Size image_size, gfx::Rect aperture, bool drawable=true) {
     scoped_refptr<NinePatchLayer> layer = NinePatchLayer::create();
     layer->setAnchorPoint(gfx::Point());
     layer->setPosition(gfx::PointF(x, y));
@@ -90,7 +91,8 @@
     layer->setIsDrawable(drawable);
 
     SkBitmap bitmap;
-    bitmap.setConfig(SkBitmap::kARGB_8888_Config, 1, 1);
+    bitmap.setConfig(
+        SkBitmap::kARGB_8888_Config, image_size.width(), image_size.height());
     bitmap.allocPixels(NULL, NULL);
     layer->setBitmap(bitmap, aperture);
 
@@ -281,8 +283,14 @@
       success &= list->GetInteger(2, &aperture_width);
       success &= list->GetInteger(3, &aperture_height);
 
+      success &= dict->GetList("ImageBounds", &list);
+      int image_width, image_height;
+      success &= list->GetInteger(0, &image_width);
+      success &= list->GetInteger(1, &image_height);
+
       new_layer = CreateDecorationLayer(
           position_x, position_y, width, height,
+          gfx::Size(image_width, image_height),
           gfx::Rect(aperture_x, aperture_y, aperture_width, aperture_height),
           draws_content);
 
Index: src/cc/cc.gypi
===================================================================
--- src/cc/cc.gypi	(revision 184497)
+++ src/cc/cc.gypi	(working copy)
@@ -1,46 +0,0 @@
-# Copyright (c) 2012 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-{
-  'variables': {
-    'variables': {
-      'conditions': [
-        ['inside_chromium_build==1', {
-          'webkit_src_dir': '<(DEPTH)/third_party/WebKit',
-        }, {
-          'webkit_src_dir': '<(DEPTH)/../../..',
-        }],
-      ],
-    },
-    'webkit_src_dir': '<(webkit_src_dir)',
-    'conditions': [
-      ['inside_chromium_build==1', {
-        'cc_stubs_dirs': [],
-      }, {
-        'cc_stubs_dirs': [
-          '<(SHARED_INTERMEDIATE_DIR)/webkit',
-          '<(webkit_src_dir)',
-          '<(webkit_src_dir)/Source/WebCore/platform',
-          '<(webkit_src_dir)/Source/WebCore/platform/animation',
-          '<(webkit_src_dir)/Source/WebCore/platform/chromium',
-          '<(webkit_src_dir)/Source/WebCore/platform/graphics',
-          '<(webkit_src_dir)/Source/WebCore/platform/graphics/chromium',
-          '<(webkit_src_dir)/Source/WebCore/platform/graphics/filters',
-          '<(webkit_src_dir)/Source/WebCore/platform/graphics/gpu',
-          '<(webkit_src_dir)/Source/WebCore/platform/graphics/skia',
-          '<(webkit_src_dir)/Source/WebCore/platform/graphics/transforms',
-          '<(webkit_src_dir)/Source/WebCore/rendering',
-          '<(webkit_src_dir)/Source/WebCore/rendering/style',
-        ],
-      }],
-    ],
-  },
-  'conditions': [
-    ['inside_chromium_build==0', {
-      'defines': [
-        'INSIDE_WEBKIT_BUILD=1',
-      ],
-    }],
-  ],
-}
Index: src/cc/occlusion_tracker.cc
===================================================================
--- src/cc/occlusion_tracker.cc	(revision 184497)
+++ src/cc/occlusion_tracker.cc	(working copy)
@@ -13,8 +13,6 @@
 #include "ui/gfx/quad_f.h"
 #include "ui/gfx/rect_conversions.h"
 
-using namespace std;
-
 namespace cc {
 
 template<typename LayerType, typename RenderSurfaceType>
@@ -49,6 +47,7 @@
 
     if (layerIterator.representsItself)
         markOccludedBehindLayer(layerIterator.currentLayer);
+    // TODO(danakj): This should be done when entering the contributing surface, but in a way that the surface's own occlusion won't occlude itself.
     else if (layerIterator.representsContributingRenderSurface)
         leaveToRenderTarget(renderTarget);
 }
@@ -281,15 +280,15 @@
     if (layerIsInUnsorted3dRenderingContext(layer))
         return;
 
+    if (!layerTransformsToTargetKnown(layer))
+        return;
+
     Region opaqueContents = layer->visibleContentOpaqueRegion();
     if (opaqueContents.IsEmpty())
         return;
 
     DCHECK(layer->visibleContentRect().Contains(opaqueContents.bounds()));
 
-    if (!layerTransformsToTargetKnown(layer))
-        return;
-
     bool clipped;
     gfx::QuadF visibleTransformedQuad = MathUtil::mapQuad(layer->drawTransform(), gfx::QuadF(opaqueContents.bounds()), clipped);
     // FIXME: Find a rect interior to each transformed quad.
@@ -297,7 +296,7 @@
         return;
 
     gfx::Rect clipRectInTarget = gfx::IntersectRects(
-        layerClipRectInTarget(layer),
+        layer->renderTarget()->renderSurface()->contentRect(),
         screenSpaceClipRectInTargetSurface(layer->renderTarget()->renderSurface(), m_screenSpaceClipRect));
 
     for (Region::Iterator opaqueContentRects(opaqueContents); opaqueContentRects.has_rect(); opaqueContentRects.next()) {
@@ -337,7 +336,7 @@
 }
 
 template<typename LayerType, typename RenderSurfaceType>
-bool OcclusionTrackerBase<LayerType, RenderSurfaceType>::occluded(const LayerType* renderTarget, const gfx::Rect& contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, const gfx::Rect& clippedRectInTarget, bool* hasOcclusionFromOutsideTargetSurface) const
+bool OcclusionTrackerBase<LayerType, RenderSurfaceType>::occluded(const LayerType* renderTarget, gfx::Rect contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, bool isClipped, gfx::Rect clipRectInTarget, bool* hasOcclusionFromOutsideTargetSurface) const
 {
     if (hasOcclusionFromOutsideTargetSurface)
         *hasOcclusionFromOutsideTargetSurface = false;
@@ -365,14 +364,15 @@
     // Take the ToEnclosingRect at each step, as we want to contain any unoccluded partial pixels in the resulting Rect.
     Region unoccludedRegionInTargetSurface = gfx::ToEnclosingRect(MathUtil::mapClippedRect(drawTransform, gfx::RectF(contentRect)));
     // Layers can't clip across surfaces, so count this as internal occlusion.
-    // TODO(danakj): This would change if we clipped to the visibleContentRect().
-    unoccludedRegionInTargetSurface.Intersect(clippedRectInTarget);
+    if (isClipped)
+      unoccludedRegionInTargetSurface.Intersect(clipRectInTarget);
     unoccludedRegionInTargetSurface.Subtract(m_stack.back().occlusionFromInsideTarget);
     gfx::RectF unoccludedRectInTargetSurfaceWithoutOutsideOcclusion = unoccludedRegionInTargetSurface.bounds();
     unoccludedRegionInTargetSurface.Subtract(m_stack.back().occlusionFromOutsideTarget);
 
     // Treat other clipping as occlusion from outside the surface.
-    // TODO(danakj): We can clip to the target surface's contentRect() here, but tests will need some love.
+    // TODO(danakj): Clip to visibleContentRect?
+    unoccludedRegionInTargetSurface.Intersect(renderTarget->renderSurface()->contentRect());
     unoccludedRegionInTargetSurface.Intersect(screenSpaceClipRectInTargetSurface(renderTarget->renderSurface(), m_screenSpaceClipRect));
 
     gfx::RectF unoccludedRectInTargetSurface = unoccludedRegionInTargetSurface.bounds();
@@ -386,7 +386,7 @@
 }
 
 template<typename LayerType, typename RenderSurfaceType>
-gfx::Rect OcclusionTrackerBase<LayerType, RenderSurfaceType>::unoccludedContentRect(const LayerType* renderTarget, const gfx::Rect& contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, const gfx::Rect& clippedRectInTarget, bool* hasOcclusionFromOutsideTargetSurface) const
+gfx::Rect OcclusionTrackerBase<LayerType, RenderSurfaceType>::unoccludedContentRect(const LayerType* renderTarget, gfx::Rect contentRect, const gfx::Transform& drawTransform, bool implDrawTransformIsUnknown, bool isClipped, gfx::Rect clipRectInTarget, bool* hasOcclusionFromOutsideTargetSurface) const
 {
     if (hasOcclusionFromOutsideTargetSurface)
         *hasOcclusionFromOutsideTargetSurface = false;
@@ -414,14 +414,15 @@
     // Take the ToEnclosingRect at each step, as we want to contain any unoccluded partial pixels in the resulting Rect.
     Region unoccludedRegionInTargetSurface = gfx::ToEnclosingRect(MathUtil::mapClippedRect(drawTransform, gfx::RectF(contentRect)));
     // Layers can't clip across surfaces, so count this as internal occlusion.
-    // TODO(danakj): This would change if we clipped to the visibleContentRect().
-    unoccludedRegionInTargetSurface.Intersect(clippedRectInTarget);
+    if (isClipped)
+      unoccludedRegionInTargetSurface.Intersect(clipRectInTarget);
     unoccludedRegionInTargetSurface.Subtract(m_stack.back().occlusionFromInsideTarget);
     gfx::RectF unoccludedRectInTargetSurfaceWithoutOutsideOcclusion = unoccludedRegionInTargetSurface.bounds();
     unoccludedRegionInTargetSurface.Subtract(m_stack.back().occlusionFromOutsideTarget);
 
     // Treat other clipping as occlusion from outside the surface.
-    // TODO(danakj): We can clip to the target surface's contentRect() here, but tests will need some love.
+    // TODO(danakj): Clip to visibleContentRect?
+    unoccludedRegionInTargetSurface.Intersect(renderTarget->renderSurface()->contentRect());
     unoccludedRegionInTargetSurface.Intersect(screenSpaceClipRectInTargetSurface(renderTarget->renderSurface(), m_screenSpaceClipRect));
 
     gfx::RectF unoccludedRectInTargetSurface = unoccludedRegionInTargetSurface.bounds();
@@ -473,7 +474,6 @@
     // Take the ToEnclosingRect at each step, as we want to contain any unoccluded partial pixels in the resulting Rect.
     Region unoccludedRegionInTargetSurface = gfx::ToEnclosingRect(MathUtil::mapClippedRect(drawTransform, gfx::RectF(contentRect)));
     // Layers can't clip across surfaces, so count this as internal occlusion.
-    // TODO(danakj): This would change if we clipped to the visibleContentRect().
     if (surface->isClipped())
         unoccludedRegionInTargetSurface.Intersect(surface->clipRect());
     if (hasOcclusion) {
@@ -502,14 +502,6 @@
     return unoccludedRect;
 }
 
-template<typename LayerType, typename RenderSurfaceType>
-gfx::Rect OcclusionTrackerBase<LayerType, RenderSurfaceType>::layerClipRectInTarget(const LayerType* layer) const
-{
-    // TODO(danakj): Can we remove this use of drawableContentRect and just use the clipRect() and target surface contentRect?
-    // TODO(danakj): Or can we use visibleContentRect() which is much tighter?
-    return layer->drawableContentRect();
-}
-
 // Instantiate (and export) templates here for the linker.
 template class OcclusionTrackerBase<Layer, RenderSurface>;
 template class OcclusionTrackerBase<LayerImpl, RenderSurfaceImpl>;
Index: src/cc/layer_sorter_unittest.cc
===================================================================
--- src/cc/layer_sorter_unittest.cc	(revision 184497)
+++ src/cc/layer_sorter_unittest.cc	(working copy)
@@ -170,7 +170,7 @@
     // correct sorting dependency will not be found.
     gfx::Transform transformB;
     transformB.Translate3d(0, 0, 0.7);
-    MathUtil::rotateEulerAngles(&transformB, 0, 45, 0);
+    transformB.RotateAboutYAxis(45);
     transformB.Translate(-5, -5);
     LayerShape layerB(10, 10, perspectiveMatrix * transformB);
 
@@ -263,5 +263,55 @@
     EXPECT_EQ(5, layerList[4]->id());
 }
 
+TEST(LayerSorterTest, verifyConcidentLayerPrecisionLossResultsInDocumentOrder)
+{
+    FakeImplProxy proxy;
+    FakeLayerTreeHostImpl hostImpl(&proxy);
+
+    scoped_ptr<LayerImpl> layer1 = LayerImpl::create(hostImpl.activeTree(), 1);
+    scoped_ptr<LayerImpl> layer2 = LayerImpl::create(hostImpl.activeTree(), 2);
+
+    // Layer 1 should occur before layer 2 in paint.  However, due to numeric
+    // issues in the sorter, it will put the layers in the wrong order
+    // in some situations.  Here we test a patch that results in  document
+    // order rather than calculated order when numeric percision is suspect
+    // in calculated order.
+
+    gfx::Transform BehindMatrix;
+    BehindMatrix.Translate3d(0, 0, 0.999999f);
+    BehindMatrix.RotateAboutXAxis(38.5f);
+    BehindMatrix.RotateAboutYAxis(77.0f);
+    gfx::Transform FrontMatrix;
+    FrontMatrix.Translate3d(0, 0, 1.0f);
+    FrontMatrix.RotateAboutXAxis(38.5f);
+    FrontMatrix.RotateAboutYAxis(77.0f);
+
+    layer1->setBounds(gfx::Size(10, 10));
+    layer1->setContentBounds(gfx::Size(10, 10));
+    layer1->drawProperties().target_space_transform = BehindMatrix;
+    layer1->setDrawsContent(true);
+
+    layer2->setBounds(gfx::Size(10, 10));
+    layer2->setContentBounds(gfx::Size(10, 10));
+    layer2->drawProperties().target_space_transform = FrontMatrix;
+    layer2->setDrawsContent(true);
+
+    std::vector<LayerImpl*> layerList;
+    layerList.push_back(layer1.get());
+    layerList.push_back(layer2.get());
+
+    ASSERT_EQ(static_cast<size_t>(2), layerList.size());
+    EXPECT_EQ(1, layerList[0]->id());
+    EXPECT_EQ(2, layerList[1]->id());
+
+    LayerSorter layerSorter;
+    layerSorter.sort(layerList.begin(), layerList.end());
+
+    ASSERT_EQ(static_cast<size_t>(2), layerList.size());
+    EXPECT_EQ(1, layerList[0]->id());
+    EXPECT_EQ(2, layerList[1]->id());
+}
+
 }  // namespace
 }  // namespace cc
+
Index: src/cc/thread_proxy.h
===================================================================
--- src/cc/thread_proxy.h	(revision 184497)
+++ src/cc/thread_proxy.h	(working copy)
@@ -6,6 +6,7 @@
 #define CC_THREAD_PROXY_H_
 
 #include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
 #include "base/time.h"
 #include "cc/animation_events.h"
 #include "cc/completion_event.h"
@@ -41,13 +42,11 @@
     virtual bool recreateOutputSurface() OVERRIDE;
     virtual void renderingStats(RenderingStats*) OVERRIDE;
     virtual const RendererCapabilities& rendererCapabilities() const OVERRIDE;
-    virtual void loseOutputSurface() OVERRIDE;
     virtual void setNeedsAnimate() OVERRIDE;
     virtual void setNeedsCommit() OVERRIDE;
     virtual void setNeedsRedraw() OVERRIDE;
     virtual void setDeferCommits(bool) OVERRIDE;
     virtual bool commitRequested() const OVERRIDE;
-    virtual void didAddAnimation() OVERRIDE { }
     virtual void mainThreadHasStoppedFlinging() OVERRIDE;
     virtual void start() OVERRIDE;
     virtual void stop() OVERRIDE;
@@ -55,24 +54,32 @@
     virtual void acquireLayerTextures() OVERRIDE;
     virtual void forceSerializeOnSwapBuffers() OVERRIDE;
     virtual bool commitPendingForTesting() OVERRIDE;
+    virtual skia::RefPtr<SkPicture> capturePicture() OVERRIDE;
 
     // LayerTreeHostImplClient implementation
     virtual void didLoseOutputSurfaceOnImplThread() OVERRIDE;
     virtual void onSwapBuffersCompleteOnImplThread() OVERRIDE;
     virtual void onVSyncParametersChanged(base::TimeTicks timebase, base::TimeDelta interval) OVERRIDE;
     virtual void onCanDrawStateChanged(bool canDraw) OVERRIDE;
+    virtual void onHasPendingTreeStateChanged(bool hasPendingTree) OVERRIDE;
     virtual void setNeedsRedrawOnImplThread() OVERRIDE;
+    virtual void didUploadVisibleHighResolutionTileOnImplThread() OVERRIDE;
     virtual void setNeedsCommitOnImplThread() OVERRIDE;
     virtual void setNeedsManageTilesOnImplThread() OVERRIDE;
     virtual void postAnimationEventsToMainThreadOnImplThread(scoped_ptr<AnimationEventsVector>, base::Time wallClockTime) OVERRIDE;
     virtual bool reduceContentsTextureMemoryOnImplThread(size_t limitBytes, int priorityCutoff) OVERRIDE;
+    virtual void reduceWastedContentsTextureMemoryOnImplThread() OVERRIDE;
     virtual void sendManagedMemoryStats() OVERRIDE;
+    virtual bool isInsideDraw() OVERRIDE;
+    virtual void renewTreePriority() OVERRIDE;
 
     // SchedulerClient implementation
     virtual void scheduledActionBeginFrame() OVERRIDE;
     virtual ScheduledActionDrawAndSwapResult scheduledActionDrawAndSwapIfPossible() OVERRIDE;
     virtual ScheduledActionDrawAndSwapResult scheduledActionDrawAndSwapForced() OVERRIDE;
     virtual void scheduledActionCommit() OVERRIDE;
+    virtual void scheduledActionCheckForCompletedTileUploads() OVERRIDE;
+    virtual void scheduledActionActivatePendingTreeIfNeeded() OVERRIDE;
     virtual void scheduledActionBeginContextRecreation() OVERRIDE;
     virtual void scheduledActionAcquireLayerTexturesForMainThread() OVERRIDE;
     virtual void didAnticipatedDrawTimeChange(base::TimeTicks) OVERRIDE;
@@ -80,6 +87,8 @@
     // ResourceUpdateControllerClient implementation
     virtual void readyToFinalizeTextureUpdates() OVERRIDE;
 
+    int maxFramesPendingForTesting() const { return m_schedulerOnImplThread->maxFramesPending(); }
+
 private:
     ThreadProxy(LayerTreeHost*, scoped_ptr<Thread> implThread);
 
@@ -132,7 +141,11 @@
     ScheduledActionDrawAndSwapResult scheduledActionDrawAndSwapInternal(bool forcedDraw);
     void forceSerializeOnSwapBuffersOnImplThread(CompletionEvent*);
     void setNeedsForcedCommitOnImplThread();
+    void checkOutputSurfaceStatusOnImplThread();
     void commitPendingOnImplThreadForTesting(CommitPendingRequest* request);
+    void capturePictureOnImplThread(CompletionEvent*, skia::RefPtr<SkPicture>*);
+    void renewTreePriorityOnImplThread();
+    void didSwapUseIncompleteTileOnImplThread();
 
     // Accessed on main thread only.
     bool m_animateRequested; // Set only when setNeedsAnimate is called.
@@ -146,15 +159,20 @@
     bool m_texturesAcquired;
     bool m_inCompositeAndReadback;
     bool m_manageTilesPending;
+    // Weak pointer to use when posting tasks to the impl thread.
+    base::WeakPtr<ThreadProxy> m_implThreadWeakPtr;
 
+    base::WeakPtrFactory<ThreadProxy> m_weakFactoryOnImplThread;
+
+    base::WeakPtr<ThreadProxy> m_mainThreadWeakPtr;
+    base::WeakPtrFactory<ThreadProxy> m_weakFactory;
+
     scoped_ptr<LayerTreeHostImpl> m_layerTreeHostImpl;
 
     scoped_ptr<InputHandler> m_inputHandlerOnImplThread;
 
     scoped_ptr<Scheduler> m_schedulerOnImplThread;
 
-    scoped_refptr<ScopedThreadProxy> m_mainThreadProxy;
-
     // Holds on to the context we might use for compositing in between initializeContext()
     // and initializeRenderer() calls.
     scoped_ptr<OutputSurface> m_outputSurfaceBeforeInitializationOnImplThread;
@@ -168,6 +186,9 @@
     // Set when the main thread is waiting on a commit to complete.
     CompletionEvent* m_commitCompletionEventOnImplThread;
 
+    // Set when the main thread is waiting on a pending tree activation.
+    CompletionEvent* m_completionEventForCommitHeldOnTreeActivation;
+
     // Set when the main thread is waiting on layers to be drawn.
     CompletionEvent* m_textureAcquisitionCompletionEventOnImplThread;
 
@@ -178,11 +199,16 @@
 
     bool m_renderVSyncEnabled;
 
+    bool m_insideDraw;
+
     base::TimeDelta m_totalCommitTime;
     size_t m_totalCommitCount;
 
     bool m_deferCommits;
     scoped_ptr<BeginFrameAndCommitState> m_pendingDeferredCommit;
+
+    base::TimeTicks m_smoothnessTakesPriorityExpirationTime;
+    bool m_renewTreePriorityOnImplThreadPending;
 };
 
 }  // namespace cc
Index: src/cc/layer_animation_controller.cc
===================================================================
--- src/cc/layer_animation_controller.cc	(revision 184497)
+++ src/cc/layer_animation_controller.cc	(working copy)
@@ -4,53 +4,71 @@
 
 #include "cc/layer_animation_controller.h"
 
-#include "cc/active_animation.h"
+#include <algorithm>
+
+#include "cc/animation.h"
+#include "cc/animation_registrar.h"
 #include "cc/keyframed_animation_curve.h"
+#include "cc/layer_animation_value_observer.h"
+#include "cc/scoped_ptr_algorithm.h"
 #include "ui/gfx/transform.h"
 
 namespace cc {
 
-LayerAnimationController::LayerAnimationController(LayerAnimationControllerClient* client)
+LayerAnimationController::LayerAnimationController(int id)
     : m_forceSync(false)
-    , m_client(client)
+    , m_id(id)
+    , m_registrar(0)
+    , m_isActive(false)
 {
 }
 
 LayerAnimationController::~LayerAnimationController()
 {
+    if (m_registrar)
+        m_registrar->UnregisterAnimationController(this);
 }
 
-scoped_ptr<LayerAnimationController> LayerAnimationController::create(LayerAnimationControllerClient* client)
+scoped_refptr<LayerAnimationController> LayerAnimationController::create(int id)
 {
-    return make_scoped_ptr(new LayerAnimationController(client));
+    return make_scoped_refptr(new LayerAnimationController(id));
 }
 
 void LayerAnimationController::pauseAnimation(int animationId, double timeOffset)
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
         if (m_activeAnimations[i]->id() == animationId)
-            m_activeAnimations[i]->setRunState(ActiveAnimation::Paused, timeOffset + m_activeAnimations[i]->startTime());
+            m_activeAnimations[i]->setRunState(Animation::Paused, timeOffset + m_activeAnimations[i]->startTime());
     }
 }
 
+struct HasAnimationId {
+    HasAnimationId(int id) : m_id(id) { }
+    bool operator()(Animation* animation) const { return animation->id() == m_id; }
+private:
+    int m_id;
+};
+
 void LayerAnimationController::removeAnimation(int animationId)
 {
-    for (size_t i = 0; i < m_activeAnimations.size();) {
-        if (m_activeAnimations[i]->id() == animationId)
-            m_activeAnimations.remove(i);
-        else
-            i++;
-    }
+    ScopedPtrVector<Animation>& animations = m_activeAnimations;
+    animations.erase(cc::remove_if(animations, animations.begin(), animations.end(), HasAnimationId(animationId)), animations.end());
+    updateActivation();
 }
 
-void LayerAnimationController::removeAnimation(int animationId, ActiveAnimation::TargetProperty targetProperty)
+struct HasAnimationIdAndProperty {
+    HasAnimationIdAndProperty(int id, Animation::TargetProperty targetProperty) : m_id(id), m_targetProperty(targetProperty) { }
+    bool operator()(Animation* animation) const { return animation->id() == m_id && animation->targetProperty() == m_targetProperty; }
+private:
+    int m_id;
+    Animation::TargetProperty m_targetProperty;
+};
+
+void LayerAnimationController::removeAnimation(int animationId, Animation::TargetProperty targetProperty)
 {
-    for (size_t i = 0; i < m_activeAnimations.size();) {
-        if (m_activeAnimations[i]->id() == animationId && m_activeAnimations[i]->targetProperty() == targetProperty)
-            m_activeAnimations.remove(i);
-        else
-            i++;
-    }
+    ScopedPtrVector<Animation>& animations = m_activeAnimations;
+    animations.erase(cc::remove_if(animations, animations.begin(), animations.end(), HasAnimationIdAndProperty(animationId, targetProperty)), animations.end());
+    updateActivation();
 }
 
 // According to render layer backing, these are for testing only.
@@ -58,7 +76,7 @@
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
         if (!m_activeAnimations[i]->isFinished())
-            m_activeAnimations[i]->setRunState(ActiveAnimation::Paused, monotonicTime);
+            m_activeAnimations[i]->setRunState(Animation::Paused, monotonicTime);
     }
 }
 
@@ -66,8 +84,8 @@
 void LayerAnimationController::resumeAnimations(double monotonicTime)
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::Paused)
-            m_activeAnimations[i]->setRunState(ActiveAnimation::Running, monotonicTime);
+        if (m_activeAnimations[i]->runState() == Animation::Paused)
+            m_activeAnimations[i]->setRunState(Animation::Running, monotonicTime);
     }
 }
 
@@ -89,10 +107,15 @@
 
         pushPropertiesToImplThread(controllerImpl);
     }
+    controllerImpl->updateActivation();
+    updateActivation();
 }
 
 void LayerAnimationController::animate(double monotonicTime, AnimationEventsVector* events)
 {
+    if (!hasActiveObserver())
+        return;
+
     startAnimationsWaitingForNextTick(monotonicTime, events);
     startAnimationsWaitingForStartTime(monotonicTime, events);
     startAnimationsWaitingForTargetAvailability(monotonicTime, events);
@@ -100,14 +123,17 @@
     tickAnimations(monotonicTime);
     markAnimationsForDeletion(monotonicTime, events);
     startAnimationsWaitingForTargetAvailability(monotonicTime, events);
+
+    updateActivation();
 }
 
-void LayerAnimationController::addAnimation(scoped_ptr<ActiveAnimation> animation)
+void LayerAnimationController::addAnimation(scoped_ptr<Animation> animation)
 {
-    m_activeAnimations.append(animation.Pass());
+    m_activeAnimations.push_back(animation.Pass());
+    updateActivation();
 }
 
-ActiveAnimation* LayerAnimationController::getActiveAnimation(int groupId, ActiveAnimation::TargetProperty targetProperty) const
+Animation* LayerAnimationController::getAnimation(int groupId, Animation::TargetProperty targetProperty) const
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i)
         if (m_activeAnimations[i]->group() == groupId && m_activeAnimations[i]->targetProperty() == targetProperty)
@@ -115,7 +141,7 @@
     return 0;
 }
 
-ActiveAnimation* LayerAnimationController::getActiveAnimation(ActiveAnimation::TargetProperty targetProperty) const
+Animation* LayerAnimationController::getAnimation(Animation::TargetProperty targetProperty) const
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
         size_t index = m_activeAnimations.size() - i - 1;
@@ -134,10 +160,10 @@
     return false;
 }
 
-bool LayerAnimationController::isAnimatingProperty(ActiveAnimation::TargetProperty targetProperty) const
+bool LayerAnimationController::isAnimatingProperty(Animation::TargetProperty targetProperty) const
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() != ActiveAnimation::Finished && m_activeAnimations[i]->runState() != ActiveAnimation::Aborted && m_activeAnimations[i]->targetProperty() == targetProperty)
+        if (m_activeAnimations[i]->runState() != Animation::Finished && m_activeAnimations[i]->runState() != Animation::Aborted && m_activeAnimations[i]->targetProperty() == targetProperty)
             return true;
     }
     return false;
@@ -154,17 +180,39 @@
     }
 }
 
-void LayerAnimationController::setClient(LayerAnimationControllerClient* client)
+void LayerAnimationController::setAnimationRegistrar(AnimationRegistrar* registrar)
 {
-    m_client = client;
+    if (m_registrar == registrar)
+        return;
+
+    if (m_registrar)
+        m_registrar->UnregisterAnimationController(this);
+
+    m_registrar = registrar;
+    if (m_registrar)
+        m_registrar->RegisterAnimationController(this);
+
+    bool force = true;
+    updateActivation(force);
 }
 
+void LayerAnimationController::addObserver(LayerAnimationValueObserver* observer)
+{
+    if (!m_observers.HasObserver(observer))
+        m_observers.AddObserver(observer);
+}
+
+void LayerAnimationController::removeObserver(LayerAnimationValueObserver* observer)
+{
+    m_observers.RemoveObserver(observer);
+}
+
 void LayerAnimationController::pushNewAnimationsToImplThread(LayerAnimationController* controllerImpl) const
 {
     // Any new animations owned by the main thread's controller are cloned and adde to the impl thread's controller.
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
         // If the animation is already running on the impl thread, there is no need to copy it over.
-        if (controllerImpl->getActiveAnimation(m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty()))
+        if (controllerImpl->getAnimation(m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty()))
             continue;
 
         // If the animation is not running on the impl thread, it does not necessarily mean that it needs
@@ -175,32 +223,34 @@
             continue;
 
         // The new animation should be set to run as soon as possible.
-        ActiveAnimation::RunState initialRunState = ActiveAnimation::WaitingForTargetAvailability;
+        Animation::RunState initialRunState = Animation::WaitingForTargetAvailability;
         double startTime = 0;
-        scoped_ptr<ActiveAnimation> toAdd(m_activeAnimations[i]->cloneAndInitialize(ActiveAnimation::ControllingInstance, initialRunState, startTime));
+        scoped_ptr<Animation> toAdd(m_activeAnimations[i]->cloneAndInitialize(Animation::ControllingInstance, initialRunState, startTime));
         DCHECK(!toAdd->needsSynchronizedStartTime());
         controllerImpl->addAnimation(toAdd.Pass());
     }
 }
 
+struct IsCompleted {
+    IsCompleted(const LayerAnimationController& mainThreadController) : m_mainThreadController(mainThreadController) { }
+    bool operator()(Animation* animation) const { return !m_mainThreadController.getAnimation(animation->group(), animation->targetProperty()); }
+private:
+    const LayerAnimationController& m_mainThreadController;
+};
+
 void LayerAnimationController::removeAnimationsCompletedOnMainThread(LayerAnimationController* controllerImpl) const
 {
     // Delete all impl thread animations for which there is no corresponding main thread animation.
     // Each iteration, controller->m_activeAnimations.size() is decremented or i is incremented
     // guaranteeing progress towards loop termination.
-    for (size_t i = 0; i < controllerImpl->m_activeAnimations.size();) {
-        ActiveAnimation* current = getActiveAnimation(controllerImpl->m_activeAnimations[i]->group(), controllerImpl->m_activeAnimations[i]->targetProperty());
-        if (!current)
-            controllerImpl->m_activeAnimations.remove(i);
-        else
-            i++;
-    }
+    ScopedPtrVector<Animation>& animations = controllerImpl->m_activeAnimations;
+    animations.erase(cc::remove_if(animations, animations.begin(), animations.end(), IsCompleted(*this)), animations.end());
 }
 
 void LayerAnimationController::pushPropertiesToImplThread(LayerAnimationController* controllerImpl) const
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        ActiveAnimation* currentImpl = controllerImpl->getActiveAnimation(m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty());
+        Animation* currentImpl = controllerImpl->getAnimation(m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty());
         if (currentImpl)
             m_activeAnimations[i]->pushPropertiesTo(currentImpl);
     }
@@ -209,12 +259,12 @@
 void LayerAnimationController::startAnimationsWaitingForNextTick(double monotonicTime, AnimationEventsVector* events)
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::WaitingForNextTick) {
-            m_activeAnimations[i]->setRunState(ActiveAnimation::Running, monotonicTime);
+        if (m_activeAnimations[i]->runState() == Animation::WaitingForNextTick) {
+            m_activeAnimations[i]->setRunState(Animation::Running, monotonicTime);
             if (!m_activeAnimations[i]->hasSetStartTime())
                 m_activeAnimations[i]->setStartTime(monotonicTime);
             if (events)
-                events->push_back(AnimationEvent(AnimationEvent::Started, m_client->id(), m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty(), monotonicTime));
+                events->push_back(AnimationEvent(AnimationEvent::Started, m_id, m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty(), monotonicTime));
         }
     }
 }
@@ -222,10 +272,10 @@
 void LayerAnimationController::startAnimationsWaitingForStartTime(double monotonicTime, AnimationEventsVector* events)
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::WaitingForStartTime && m_activeAnimations[i]->startTime() <= monotonicTime) {
-            m_activeAnimations[i]->setRunState(ActiveAnimation::Running, monotonicTime);
+        if (m_activeAnimations[i]->runState() == Animation::WaitingForStartTime && m_activeAnimations[i]->startTime() <= monotonicTime) {
+            m_activeAnimations[i]->setRunState(Animation::Running, monotonicTime);
             if (events)
-                events->push_back(AnimationEvent(AnimationEvent::Started, m_client->id(), m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty(), monotonicTime));
+                events->push_back(AnimationEvent(AnimationEvent::Started, m_id, m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty(), monotonicTime));
         }
     }
 }
@@ -235,12 +285,12 @@
     // First collect running properties.
     TargetProperties blockedProperties;
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::Running || m_activeAnimations[i]->runState() == ActiveAnimation::Finished)
+        if (m_activeAnimations[i]->runState() == Animation::Running || m_activeAnimations[i]->runState() == Animation::Finished)
             blockedProperties.insert(m_activeAnimations[i]->targetProperty());
     }
 
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::WaitingForTargetAvailability) {
+        if (m_activeAnimations[i]->runState() == Animation::WaitingForTargetAvailability) {
             // Collect all properties for animations with the same group id (they should all also be in the list of animations).
             TargetProperties enqueuedProperties;
             enqueuedProperties.insert(m_activeAnimations[i]->targetProperty());
@@ -260,14 +310,14 @@
 
             // If the intersection is null, then we are free to start the animations in the group.
             if (nullIntersection) {
-                m_activeAnimations[i]->setRunState(ActiveAnimation::Running, monotonicTime);
+                m_activeAnimations[i]->setRunState(Animation::Running, monotonicTime);
                 if (!m_activeAnimations[i]->hasSetStartTime())
                     m_activeAnimations[i]->setStartTime(monotonicTime);
                 if (events)
-                    events->push_back(AnimationEvent(AnimationEvent::Started, m_client->id(), m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty(), monotonicTime));
+                    events->push_back(AnimationEvent(AnimationEvent::Started, m_id, m_activeAnimations[i]->group(), m_activeAnimations[i]->targetProperty(), monotonicTime));
                 for (size_t j = i + 1; j < m_activeAnimations.size(); ++j) {
                     if (m_activeAnimations[i]->group() == m_activeAnimations[j]->group()) {
-                        m_activeAnimations[j]->setRunState(ActiveAnimation::Running, monotonicTime);
+                        m_activeAnimations[j]->setRunState(Animation::Running, monotonicTime);
                         if (!m_activeAnimations[j]->hasSetStartTime())
                             m_activeAnimations[j]->setStartTime(monotonicTime);
                     }
@@ -285,13 +335,13 @@
     // (2) has an equal start time, but was added to the queue earlier, i.e.,
     // has a lower index in m_activeAnimations).
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::Running) {
+        if (m_activeAnimations[i]->runState() == Animation::Running) {
             for (size_t j = i + 1; j < m_activeAnimations.size(); ++j) {
-                if (m_activeAnimations[j]->runState() == ActiveAnimation::Running && m_activeAnimations[i]->targetProperty() == m_activeAnimations[j]->targetProperty()) {
+                if (m_activeAnimations[j]->runState() == Animation::Running && m_activeAnimations[i]->targetProperty() == m_activeAnimations[j]->targetProperty()) {
                     if (m_activeAnimations[i]->startTime() > m_activeAnimations[j]->startTime())
-                        m_activeAnimations[j]->setRunState(ActiveAnimation::Aborted, monotonicTime);
+                        m_activeAnimations[j]->setRunState(Animation::Aborted, monotonicTime);
                     else
-                        m_activeAnimations[i]->setRunState(ActiveAnimation::Aborted, monotonicTime);
+                        m_activeAnimations[i]->setRunState(Animation::Aborted, monotonicTime);
                 }
             }
         }
@@ -320,37 +370,35 @@
             for (size_t j = i; j < m_activeAnimations.size(); j++) {
                 if (groupId == m_activeAnimations[j]->group()) {
                     if (events)
-                        events->push_back(AnimationEvent(AnimationEvent::Finished, m_client->id(), m_activeAnimations[j]->group(), m_activeAnimations[j]->targetProperty(), monotonicTime));
-                    m_activeAnimations[j]->setRunState(ActiveAnimation::WaitingForDeletion, monotonicTime);
+                        events->push_back(AnimationEvent(AnimationEvent::Finished, m_id, m_activeAnimations[j]->group(), m_activeAnimations[j]->targetProperty(), monotonicTime));
+                    m_activeAnimations[j]->setRunState(Animation::WaitingForDeletion, monotonicTime);
                 }
             }
         }
     }
 }
 
+static bool isWaitingForDeletion(Animation* animation) { return animation->runState() == Animation::WaitingForDeletion; }
+
 void LayerAnimationController::purgeAnimationsMarkedForDeletion()
 {
-    for (size_t i = 0; i < m_activeAnimations.size();) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::WaitingForDeletion)
-            m_activeAnimations.remove(i);
-        else
-            i++;
-    }
+    ScopedPtrVector<Animation>& animations = m_activeAnimations;
+    animations.erase(cc::remove_if(animations, animations.begin(), animations.end(), isWaitingForDeletion), animations.end());
 }
 
 void LayerAnimationController::replaceImplThreadAnimations(LayerAnimationController* controllerImpl) const
 {
     controllerImpl->m_activeAnimations.clear();
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        scoped_ptr<ActiveAnimation> toAdd;
+        scoped_ptr<Animation> toAdd;
         if (m_activeAnimations[i]->needsSynchronizedStartTime()) {
             // We haven't received an animation started notification yet, so it
             // is important that we add it in a 'waiting' and not 'running' state.
-            ActiveAnimation::RunState initialRunState = ActiveAnimation::WaitingForTargetAvailability;
+            Animation::RunState initialRunState = Animation::WaitingForTargetAvailability;
             double startTime = 0;
-            toAdd = m_activeAnimations[i]->cloneAndInitialize(ActiveAnimation::ControllingInstance, initialRunState, startTime).Pass();
+            toAdd = m_activeAnimations[i]->cloneAndInitialize(Animation::ControllingInstance, initialRunState, startTime).Pass();
         } else
-            toAdd = m_activeAnimations[i]->clone(ActiveAnimation::ControllingInstance).Pass();
+            toAdd = m_activeAnimations[i]->clone(Animation::ControllingInstance).Pass();
 
         controllerImpl->addAnimation(toAdd.Pass());
     }
@@ -359,7 +407,7 @@
 void LayerAnimationController::tickAnimations(double monotonicTime)
 {
     for (size_t i = 0; i < m_activeAnimations.size(); ++i) {
-        if (m_activeAnimations[i]->runState() == ActiveAnimation::Running || m_activeAnimations[i]->runState() == ActiveAnimation::Paused) {
+        if (m_activeAnimations[i]->runState() == Animation::Running || m_activeAnimations[i]->runState() == Animation::Paused) {
             double trimmed = m_activeAnimations[i]->trimTimeToCurrentIteration(monotonicTime);
 
             // Animation assumes its initial value until it gets the synchronized start time
@@ -369,32 +417,69 @@
 
             switch (m_activeAnimations[i]->targetProperty()) {
 
-            case ActiveAnimation::Transform: {
+            case Animation::Transform: {
                 const TransformAnimationCurve* transformAnimationCurve = m_activeAnimations[i]->curve()->toTransformAnimationCurve();
-                const gfx::Transform matrix = transformAnimationCurve->getValue(trimmed).toTransform();
+                const gfx::Transform transform = transformAnimationCurve->getValue(trimmed);
                 if (m_activeAnimations[i]->isFinishedAt(monotonicTime))
-                    m_activeAnimations[i]->setRunState(ActiveAnimation::Finished, monotonicTime);
+                    m_activeAnimations[i]->setRunState(Animation::Finished, monotonicTime);
 
-                m_client->setTransformFromAnimation(matrix);
+                notifyObserversTransformAnimated(transform);
                 break;
             }
 
-            case ActiveAnimation::Opacity: {
+            case Animation::Opacity: {
                 const FloatAnimationCurve* floatAnimationCurve = m_activeAnimations[i]->curve()->toFloatAnimationCurve();
                 const float opacity = floatAnimationCurve->getValue(trimmed);
                 if (m_activeAnimations[i]->isFinishedAt(monotonicTime))
-                    m_activeAnimations[i]->setRunState(ActiveAnimation::Finished, monotonicTime);
+                    m_activeAnimations[i]->setRunState(Animation::Finished, monotonicTime);
 
-                m_client->setOpacityFromAnimation(opacity);
+                notifyObserversOpacityAnimated(opacity);
                 break;
             }
 
             // Do nothing for sentinel value.
-            case ActiveAnimation::TargetPropertyEnumSize:
+            case Animation::TargetPropertyEnumSize:
                 NOTREACHED();
             }
         }
     }
 }
 
+void LayerAnimationController::updateActivation(bool force)
+{
+    if (m_registrar) {
+        if (!m_activeAnimations.empty() && (!m_isActive || force))
+            m_registrar->DidActivateAnimationController(this);
+        else if (m_activeAnimations.empty() && (m_isActive || force))
+            m_registrar->DidDeactivateAnimationController(this);
+        m_isActive = !m_activeAnimations.empty();
+    }
+}
+
+void LayerAnimationController::notifyObserversOpacityAnimated(float opacity)
+{
+    FOR_EACH_OBSERVER(LayerAnimationValueObserver,
+                      m_observers,
+                      OnOpacityAnimated(opacity));
+}
+
+void LayerAnimationController::notifyObserversTransformAnimated(const gfx::Transform& transform)
+{
+    FOR_EACH_OBSERVER(LayerAnimationValueObserver,
+                      m_observers,
+                      OnTransformAnimated(transform));
+}
+
+bool LayerAnimationController::hasActiveObserver()
+{
+    if (m_observers.might_have_observers()) {
+        ObserverListBase<LayerAnimationValueObserver>::Iterator it(m_observers);
+        LayerAnimationValueObserver* obs;
+        while ((obs = it.GetNext()) != NULL)
+            if (obs->IsActive())
+                return true;
+    }
+    return false;
+}
+
 }  // namespace cc
Index: src/cc/texture_layer_impl.h
===================================================================
--- src/cc/texture_layer_impl.h	(revision 184497)
+++ src/cc/texture_layer_impl.h	(working copy)
@@ -5,6 +5,9 @@
 #ifndef CC_TEXTURE_LAYER_IMPL_H_
 #define CC_TEXTURE_LAYER_IMPL_H_
 
+#include <string>
+
+#include "base/callback.h"
 #include "cc/cc_export.h"
 #include "cc/layer_impl.h"
 
@@ -12,12 +15,15 @@
 
 class CC_EXPORT TextureLayerImpl : public LayerImpl {
 public:
-    static scoped_ptr<TextureLayerImpl> create(LayerTreeImpl* treeImpl, int id)
+    static scoped_ptr<TextureLayerImpl> create(LayerTreeImpl* treeImpl, int id, bool usesMailbox)
     {
-        return make_scoped_ptr(new TextureLayerImpl(treeImpl, id));
+        return make_scoped_ptr(new TextureLayerImpl(treeImpl, id, usesMailbox));
     }
     virtual ~TextureLayerImpl();
 
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+
     virtual void willDraw(ResourceProvider*) OVERRIDE;
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
     virtual void didDraw(ResourceProvider*) OVERRIDE;
@@ -30,15 +36,19 @@
     void setTextureId(unsigned id) { m_textureId = id; }
     void setPremultipliedAlpha(bool premultipliedAlpha) { m_premultipliedAlpha = premultipliedAlpha; }
     void setFlipped(bool flipped) { m_flipped = flipped; }
-    void setUVRect(const gfx::RectF& rect) { m_uvRect = rect; }
+    void setUVTopLeft(gfx::PointF topLeft) { m_uvTopLeft = topLeft; }
+    void setUVBottomRight(gfx::PointF bottomRight) { m_uvBottomRight = bottomRight; }
 
     // 1--2
     // |  |
     // 0--3
     void setVertexOpacity(const float vertexOpacity[4]);
+    virtual bool canClipSelf() const OVERRIDE;
 
+    void setTextureMailbox(const TextureMailbox&);
+
 private:
-    TextureLayerImpl(LayerTreeImpl* treeImpl, int id);
+    TextureLayerImpl(LayerTreeImpl* treeImpl, int id, bool usesMailbox);
 
     virtual const char* layerTypeAsString() const OVERRIDE;
 
@@ -46,8 +56,13 @@
     ResourceProvider::ResourceId m_externalTextureResource;
     bool m_premultipliedAlpha;
     bool m_flipped;
-    gfx::RectF m_uvRect;
+    gfx::PointF m_uvTopLeft;
+    gfx::PointF m_uvBottomRight;
     float m_vertexOpacity[4];
+
+    bool m_hasPendingMailbox;
+    TextureMailbox m_pendingTextureMailbox;
+    bool m_usesMailbox;
 };
 
 }
Index: src/cc/solid_color_layer_impl.cc
===================================================================
--- src/cc/solid_color_layer_impl.cc	(revision 184497)
+++ src/cc/solid_color_layer_impl.cc	(working copy)
@@ -19,6 +19,11 @@
 {
 }
 
+scoped_ptr<LayerImpl> SolidColorLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return SolidColorLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
 void SolidColorLayerImpl::appendQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData)
 {
     SharedQuadState* sharedQuadState = quadSink.useSharedQuadState(createSharedQuadState());
Index: src/cc/nine_patch_layer_impl.cc
===================================================================
--- src/cc/nine_patch_layer_impl.cc	(revision 184497)
+++ src/cc/nine_patch_layer_impl.cc	(working copy)
@@ -27,6 +27,23 @@
     return 0;
 }
 
+scoped_ptr<LayerImpl> NinePatchLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return NinePatchLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+void NinePatchLayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    LayerImpl::pushPropertiesTo(layer);
+    NinePatchLayerImpl* layerImpl = static_cast<NinePatchLayerImpl*>(layer);
+
+    if (!m_resourceId)
+        return;
+
+    layerImpl->setResourceId(m_resourceId);
+    layerImpl->setLayout(m_imageBounds, m_imageAperture);
+}
+
 void NinePatchLayerImpl::willDraw(ResourceProvider* resourceProvider)
 {
 }
@@ -112,35 +129,35 @@
     scoped_ptr<TextureDrawQuad> quad;
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, topLeft, opaqueRect, m_resourceId, premultipliedAlpha, uvTopLeft, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, topLeft, opaqueRect, m_resourceId, premultipliedAlpha, uvTopLeft.origin(), uvTopLeft.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, topRight, opaqueRect, m_resourceId, premultipliedAlpha, uvTopRight, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, topRight, opaqueRect, m_resourceId, premultipliedAlpha, uvTopRight.origin(), uvTopRight.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, bottomLeft, opaqueRect, m_resourceId, premultipliedAlpha, uvBottomLeft, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, bottomLeft, opaqueRect, m_resourceId, premultipliedAlpha, uvBottomLeft.origin(), uvBottomLeft.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, bottomRight, opaqueRect, m_resourceId, premultipliedAlpha, uvBottomRight, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, bottomRight, opaqueRect, m_resourceId, premultipliedAlpha, uvBottomRight.origin(), uvBottomRight.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, top, opaqueRect, m_resourceId, premultipliedAlpha, uvTop, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, top, opaqueRect, m_resourceId, premultipliedAlpha, uvTop.origin(), uvTop.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, left, opaqueRect, m_resourceId, premultipliedAlpha, uvLeft, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, left, opaqueRect, m_resourceId, premultipliedAlpha, uvLeft.origin(), uvLeft.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, right, opaqueRect, m_resourceId, premultipliedAlpha, uvRight, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, right, opaqueRect, m_resourceId, premultipliedAlpha, uvRight.origin(), uvRight.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 
     quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, bottom, opaqueRect, m_resourceId, premultipliedAlpha, uvBottom, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, bottom, opaqueRect, m_resourceId, premultipliedAlpha, uvBottom.origin(), uvBottom.bottom_right(), vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 }
 
@@ -162,6 +179,7 @@
 {
     str->append(indentString(indent));
     base::StringAppendF(str, "imageAperture: %s\n", m_imageAperture.ToString().c_str());
+    base::StringAppendF(str, "imageBounds: %s\n", m_imageBounds.ToString().c_str());
     LayerImpl::dumpLayerProperties(str, indent);
 }
 
@@ -176,6 +194,11 @@
     list->AppendInteger(m_imageAperture.size().height());
     result->Set("ImageAperture", list);
 
+    list = new base::ListValue;
+    list->AppendInteger(m_imageBounds.width());
+    list->AppendInteger(m_imageBounds.height());
+    result->Set("ImageBounds", list);
+
     return result;
 }
 
Index: src/cc/bitmap_content_layer_updater.cc
===================================================================
--- src/cc/bitmap_content_layer_updater.cc	(revision 184497)
+++ src/cc/bitmap_content_layer_updater.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "cc/bitmap_content_layer_updater.h"
 
 #include "cc/layer_painter.h"
+#include "cc/prioritized_resource.h"
 #include "cc/rendering_stats.h"
 #include "cc/resource_update.h"
 #include "cc/resource_update_queue.h"
Index: src/cc/gl_renderer.cc
===================================================================
--- src/cc/gl_renderer.cc	(revision 184497)
+++ src/cc/gl_renderer.cc	(working copy)
@@ -4,6 +4,10 @@
 
 #include "cc/gl_renderer.h"
 
+#include <set>
+#include <string>
+#include <vector>
+
 #include "base/debug/trace_event.h"
 #include "base/logging.h"
 #include "base/string_split.h"
@@ -25,6 +29,8 @@
 #include "cc/stream_video_draw_quad.h"
 #include "cc/texture_draw_quad.h"
 #include "cc/video_layer_impl.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSharedGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/khronos/GLES2/gl2ext.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -35,13 +41,7 @@
 #include "third_party/skia/include/gpu/SkGrTexturePixelRef.h"
 #include "ui/gfx/quad_f.h"
 #include "ui/gfx/rect_conversions.h"
-#include <public/WebGraphicsContext3D.h>
-#include <public/WebSharedGraphicsContext3D.h>
-#include <set>
-#include <string>
-#include <vector>
 
-using namespace std;
 using WebKit::WebGraphicsContext3D;
 using WebKit::WebGraphicsMemoryAllocation;
 using WebKit::WebSharedGraphicsContext3D;
@@ -50,6 +50,23 @@
 
 namespace {
 
+// TODO(epenner): This should probably be moved to output surface.
+//
+// This implements a simple fence based on client side swaps.
+// This is to isolate the ResourceProvider from 'frames' which
+// it shouldn't need to care about, while still allowing us to
+// enforce good texture recycling behavior strictly throughout
+// the compositor (don't recycle a texture while it's in use).
+class SimpleSwapFence : public ResourceProvider::Fence {
+public:
+    SimpleSwapFence() : m_hasPassed(false) {}
+    virtual bool hasPassed() OVERRIDE { return m_hasPassed; }
+    void setHasPassed() { m_hasPassed = true; }
+private:
+    virtual ~SimpleSwapFence() {}
+    bool m_hasPassed;
+};
+
 bool needsIOSurfaceReadbackWorkaround()
 {
 #if defined(OS_MACOSX)
@@ -97,7 +114,7 @@
     std::string extensionsString = UTF16ToASCII(m_context->getString(GL_EXTENSIONS));
     std::vector<std::string> extensionsList;
     base::SplitString(extensionsString, ' ', &extensionsList);
-    std::set<string> extensions(extensionsList.begin(), extensionsList.end());
+    std::set<std::string> extensions(extensionsList.begin(), extensionsList.end());
 
     if (settings().acceleratePainting && extensions.count("GL_EXT_texture_format_BGRA8888")
                                       && extensions.count("GL_EXT_read_format_bgra"))
@@ -118,7 +135,8 @@
     if (extensions.count("GL_CHROMIUM_iosurface"))
         DCHECK(extensions.count("GL_ARB_texture_rectangle"));
 
-    m_capabilities.usingGpuMemoryManager = extensions.count("GL_CHROMIUM_gpu_memory_manager");
+    m_capabilities.usingGpuMemoryManager = extensions.count("GL_CHROMIUM_gpu_memory_manager")
+                                           && settings().useMemoryManagement;
     if (m_capabilities.usingGpuMemoryManager)
         m_context->setMemoryAllocationChangedCallbackCHROMIUM(this);
 
@@ -132,6 +150,10 @@
     // The updater can access textures while the GLRenderer is using them.
     m_capabilities.allowPartialTextureUpdates = true;
 
+    // Check for texture fast paths. Currently we always use MO8 textures,
+    // so we only need to avoid POT textures if we have an NPOT fast-path.
+    m_capabilities.avoidPow2Textures = extensions.count("GL_CHROMIUM_fast_NPOT_MO8_textures");
+
     m_isUsingBindUniform = extensions.count("GL_CHROMIUM_bind_uniform_location");
 
     // Make sure scissoring starts as disabled.
@@ -438,7 +460,6 @@
 
 scoped_ptr<ScopedResource> GLRenderer::drawBackgroundFilters(
     DrawingFrame& frame, const RenderPassDrawQuad* quad,
-    const WebKit::WebFilterOperations& filters,
     const gfx::Transform& contentsDeviceTransform,
     const gfx::Transform& contentsDeviceTransformInverse)
 {
@@ -458,6 +479,7 @@
 
     // FIXME: When this algorithm changes, update LayerTreeHost::prioritizeTextures() accordingly.
 
+    const WebKit::WebFilterOperations& filters = quad->background_filters;
     if (filters.isEmpty())
         return scoped_ptr<ScopedResource>();
 
@@ -516,14 +538,10 @@
     if (!contentsTexture || !contentsTexture->id())
         return;
 
-    const RenderPass* renderPass = frame.renderPassesById->get(quad->render_pass_id);
-    DCHECK(renderPass);
-    if (!renderPass)
-        return;
-
     gfx::Transform quadRectMatrix;
     quadRectTransform(&quadRectMatrix, quad->quadTransform(), quad->rect);
-    gfx::Transform contentsDeviceTransform = MathUtil::to2dTransform(frame.windowMatrix * frame.projectionMatrix * quadRectMatrix);
+    gfx::Transform contentsDeviceTransform = frame.windowMatrix * frame.projectionMatrix * quadRectMatrix;
+    contentsDeviceTransform.FlattenTo2d();
 
     // Can only draw surface if device matrix is invertible.
     gfx::Transform contentsDeviceTransformInverse(gfx::Transform::kSkipInitialization);
@@ -531,16 +549,15 @@
         return;
 
     scoped_ptr<ScopedResource> backgroundTexture = drawBackgroundFilters(
-        frame, quad, renderPass->background_filters,
-        contentsDeviceTransform, contentsDeviceTransformInverse);
+        frame, quad, contentsDeviceTransform, contentsDeviceTransformInverse);
 
     // FIXME: Cache this value so that we don't have to do it for both the surface and its replica.
     // Apply filters to the contents texture.
     SkBitmap filterBitmap;
-    if (renderPass->filter) {
-        filterBitmap = applyImageFilter(this, renderPass->filter.get(), contentsTexture, m_client->hasImplThread());
+    if (quad->filter) {
+        filterBitmap = applyImageFilter(this, quad->filter.get(), contentsTexture, m_client->hasImplThread());
     } else {
-        filterBitmap = applyFilters(this, renderPass->filters, contentsTexture, m_client->hasImplThread());
+        filterBitmap = applyFilters(this, quad->filters, contentsTexture, m_client->hasImplThread());
     }
 
     // Draw the background texture if there is one.
@@ -647,7 +664,7 @@
         GLC(context(), context()->uniform2f(shaderTexScaleLocation,
                                             tex_scale_x, tex_scale_y));
     } else {
-      NOTREACHED();
+        DCHECK(isContextLost());
     }
 
     if (shaderMaskSamplerLocation != -1) {
@@ -670,7 +687,7 @@
         GLC(context(), context()->uniform3fv(shaderEdgeLocation, 8, edge));
     }
 
-    // Map device space quad to surface space. contentsDeviceTransform has no 3d component since it was generated with to2dTransform() so we don't need to project.
+    // Map device space quad to surface space. contentsDeviceTransform has no 3d component since it was flattened, so we don't need to project.
     gfx::QuadF surfaceQuad = MathUtil::mapQuad(contentsDeviceTransformInverse, deviceLayerEdges.ToQuadF(), clipped);
     DCHECK(!clipped);
 
@@ -775,7 +792,8 @@
 
 
     gfx::QuadF localQuad;
-    gfx::Transform deviceTransform = MathUtil::to2dTransform(frame.windowMatrix * frame.projectionMatrix * quad->quadTransform());
+    gfx::Transform deviceTransform = frame.windowMatrix * frame.projectionMatrix * quad->quadTransform();
+    deviceTransform.FlattenTo2d();
     if (!deviceTransform.IsInvertible())
         return;
 
@@ -866,7 +884,7 @@
         // Create device space quad.
         LayerQuad deviceQuad(leftEdge, topEdge, rightEdge, bottomEdge);
 
-        // Map device space quad to local space. deviceTransform has no 3d component since it was generated with to2dTransform() so we don't need to project.
+        // Map device space quad to local space. deviceTransform has no 3d component since it was flattened, so we don't need to project.
         // We should have already checked that the transform was uninvertible above.
         gfx::Transform inverseDeviceTransform(gfx::Transform::kSkipInitialization);
         bool didInvert = deviceTransform.GetInverse(&inverseDeviceTransform);
@@ -1090,8 +1108,9 @@
     }
 
     // Generate the uv-transform
-    const gfx::RectF& uvRect = quad->uv_rect;
-    Float4 uv = {uvRect.x(), uvRect.y(), uvRect.width(), uvRect.height()};
+    const gfx::PointF& uv0 = quad->uv_top_left;
+    const gfx::PointF& uv1 = quad->uv_bottom_right;
+    Float4 uv = {uv0.x(), uv0.y(), uv1.x() - uv0.x(), uv1.y() - uv0.y()};
     m_drawCache.uv_xform_data.push_back(uv);
 
     // Generate the vertex opacity
@@ -1120,8 +1139,9 @@
         binding.set(textureProgram(), context());
     setUseProgram(binding.programId);
     GLC(context(), context()->uniform1i(binding.samplerLocation, 0));
-    const gfx::RectF& uvRect = quad->uv_rect;
-    GLC(context(), context()->uniform4f(binding.texTransformLocation, uvRect.x(), uvRect.y(), uvRect.width(), uvRect.height()));
+    const gfx::PointF& uv0 = quad->uv_top_left;
+    const gfx::PointF& uv1 = quad->uv_bottom_right;
+    GLC(context(), context()->uniform4f(binding.texTransformLocation, uv0.x(), uv0.y(), uv1.x() - uv0.x(), uv1.y() - uv0.y()));
 
     GLC(context(), context()->uniform1fv(binding.vertexOpacityLocation, 4, quad->vertex_opacity));
 
@@ -1180,7 +1200,7 @@
         compositor_frame.metadata = m_client->makeCompositorFrameMetadata();
         compositor_frame.gl_frame_data.reset(new GLFrameData());
         // FIXME: Fill in GLFrameData when we implement swapping with it.
-        m_outputSurface->SendFrameToParentCompositor(compositor_frame);
+        m_outputSurface->SendFrameToParentCompositor(&compositor_frame);
     }
 }
 
@@ -1314,6 +1334,14 @@
 
     m_swapBufferRect = gfx::Rect();
 
+    // We don't have real fences, so we mark read fences as passed
+    // assuming a double-buffered GPU pipeline. A texture can be
+    // written to after one full frame has past since it was last read.
+    if (m_lastSwapFence)
+        static_cast<SimpleSwapFence*>(m_lastSwapFence.get())->setHasPassed();
+    m_lastSwapFence = m_resourceProvider->getReadLockFence();
+    m_resourceProvider->setReadLockFence(new SimpleSwapFence());
+
     return true;
 }
 
@@ -1330,9 +1358,9 @@
     if (allocation.bytesLimitWhenVisible) {
         ManagedMemoryPolicy policy(
             allocation.bytesLimitWhenVisible,
-            priorityCutoffValue(allocation.priorityCutoffWhenVisible),
+            priorityCutoff(allocation.priorityCutoffWhenVisible),
             allocation.bytesLimitWhenNotVisible,
-            priorityCutoffValue(allocation.priorityCutoffWhenNotVisible));
+            priorityCutoff(allocation.priorityCutoffWhenNotVisible));
 
         if (allocation.enforceButDoNotKeepAsPolicy)
             m_client->enforceManagedMemoryPolicy(policy);
@@ -1347,20 +1375,21 @@
         m_discardBackbufferWhenNotVisible = oldDiscardBackbufferWhenNotVisible;
 }
 
-int GLRenderer::priorityCutoffValue(WebKit::WebGraphicsMemoryAllocation::PriorityCutoff priorityCutoff)
+ManagedMemoryPolicy::PriorityCutoff GLRenderer::priorityCutoff(WebKit::WebGraphicsMemoryAllocation::PriorityCutoff priorityCutoff)
 {
+    // This is simple a 1:1 map, the names differ only because the WebKit names should be to match the cc names.
     switch (priorityCutoff) {
     case WebKit::WebGraphicsMemoryAllocation::PriorityCutoffAllowNothing:
-        return PriorityCalculator::allowNothingCutoff();
+        return ManagedMemoryPolicy::CUTOFF_ALLOW_NOTHING;
     case WebKit::WebGraphicsMemoryAllocation::PriorityCutoffAllowVisibleOnly:
-        return PriorityCalculator::allowVisibleOnlyCutoff();
+        return ManagedMemoryPolicy::CUTOFF_ALLOW_REQUIRED_ONLY;
     case WebKit::WebGraphicsMemoryAllocation::PriorityCutoffAllowVisibleAndNearby:
-        return PriorityCalculator::allowVisibleAndNearbyCutoff();
+        return ManagedMemoryPolicy::CUTOFF_ALLOW_NICE_TO_HAVE;
     case WebKit::WebGraphicsMemoryAllocation::PriorityCutoffAllowEverything:
-        return PriorityCalculator::allowEverythingCutoff();
+        return ManagedMemoryPolicy::CUTOFF_ALLOW_EVERYTHING;
     }
     NOTREACHED();
-    return 0;
+    return ManagedMemoryPolicy::CUTOFF_ALLOW_NOTHING;
 }
 
 void GLRenderer::enforceMemoryPolicy()
@@ -1513,7 +1542,7 @@
     unsigned textureId = m_currentFramebufferLock->textureId();
     GLC(m_context, m_context->framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId, 0));
 
-    DCHECK(m_context->checkFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE);
+    DCHECK(m_context->checkFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE || isContextLost());
 
     initializeMatrices(frame, framebufferRect, false);
     setDrawViewportSize(framebufferRect.size());
Index: src/cc/delegating_renderer.cc
===================================================================
--- src/cc/delegating_renderer.cc	(revision 184497)
+++ src/cc/delegating_renderer.cc	(working copy)
@@ -12,6 +12,7 @@
 #include "base/string_split.h"
 #include "base/string_util.h"
 #include "cc/checkerboard_draw_quad.h"
+#include "cc/compositor_frame.h"
 #include "cc/compositor_frame_ack.h"
 #include "cc/debug_border_draw_quad.h"
 #include "cc/render_pass.h"
@@ -28,17 +29,22 @@
 namespace cc {
 
 scoped_ptr<DelegatingRenderer> DelegatingRenderer::Create(
-    RendererClient* client, ResourceProvider* resource_provider) {
+    RendererClient* client,
+    OutputSurface* output_surface,
+    ResourceProvider* resource_provider) {
   scoped_ptr<DelegatingRenderer> renderer(
-      new DelegatingRenderer(client, resource_provider));
+      new DelegatingRenderer(client, output_surface, resource_provider));
   if (!renderer->Initialize())
     return scoped_ptr<DelegatingRenderer>();
   return renderer.Pass();
 }
 
 DelegatingRenderer::DelegatingRenderer(
-    RendererClient* client, ResourceProvider* resource_provider)
+    RendererClient* client,
+    OutputSurface* output_surface,
+    ResourceProvider* resource_provider)
     : Renderer(client),
+      output_surface_(output_surface),
       resource_provider_(resource_provider),
       visible_(true) {
   DCHECK(resource_provider_);
@@ -125,10 +131,27 @@
   return capabilities_;
 }
 
-void DelegatingRenderer::drawFrame(RenderPassList& render_passes_in_draw_order,
-                                   RenderPassIdHashMap& render_passes_by_id) {
+void DelegatingRenderer::drawFrame(
+    RenderPassList& render_passes_in_draw_order) {
   TRACE_EVENT0("cc", "DelegatingRenderer::drawFrame");
-  NOTIMPLEMENTED();
+
+  CompositorFrame out_frame;
+  out_frame.metadata = m_client->makeCompositorFrameMetadata();
+
+  out_frame.delegated_frame_data = make_scoped_ptr(new DelegatedFrameData);
+  DelegatedFrameData& out_data = *out_frame.delegated_frame_data;
+
+  out_data.size = viewportSize();
+  out_data.render_pass_list.swap(render_passes_in_draw_order);
+
+  ResourceProvider::ResourceIdArray resources;
+  for (size_t i = 0; i < out_data.render_pass_list.size(); ++i) {
+    for (size_t j = 0; j < out_data.render_pass_list[i]->quad_list.size(); ++j)
+      out_data.render_pass_list[i]->quad_list[j]->AppendResources(&resources);
+  }
+  resource_provider_->prepareSendToParent(resources, &out_data.resource_list);
+
+  output_surface_->SendFrameToParentCompositor(&out_frame);
 }
 
 bool DelegatingRenderer::swapBuffers() {
Index: src/cc/texture_uploader.cc
===================================================================
--- src/cc/texture_uploader.cc	(revision 184497)
+++ src/cc/texture_uploader.cc	(working copy)
@@ -13,11 +13,11 @@
 #include "cc/prioritized_resource.h"
 #include "cc/resource.h"
 #include "cc/util.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/khronos/GLES2/gl2ext.h"
 #include "ui/gfx/rect.h"
 #include "ui/gfx/vector2d.h"
-#include <public/WebGraphicsContext3D.h>
 
 namespace {
 
@@ -142,16 +142,16 @@
 
 void TextureUploader::beginQuery()
 {
-    if (m_availableQueries.isEmpty())
-      m_availableQueries.append(Query::create(m_context));
+    if (m_availableQueries.empty())
+      m_availableQueries.push_back(Query::create(m_context));
 
-    m_availableQueries.first()->begin();
+    m_availableQueries.front()->begin();
 }
 
 void TextureUploader::endQuery()
 {
-    m_availableQueries.first()->end();
-    m_pendingQueries.append(m_availableQueries.takeFirst());
+    m_availableQueries.front()->end();
+    m_pendingQueries.push_back(m_availableQueries.take_front());
     m_numBlockingTextureUploads++;
 }
 
@@ -342,18 +342,19 @@
 
 void TextureUploader::processQueries()
 {
-    while (!m_pendingQueries.isEmpty()) {
-        if (m_pendingQueries.first()->isPending())
+    while (!m_pendingQueries.empty()) {
+        if (m_pendingQueries.front()->isPending())
             break;
 
-        unsigned usElapsed = m_pendingQueries.first()->value();
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.TextureGpuUploadTimeUS", usElapsed, 0, 100000, 50);
+        unsigned usElapsed = m_pendingQueries.front()->value();
+        UMA_HISTOGRAM_CUSTOM_COUNTS("Renderer4.TextureGpuUploadTimeUS",
+                                    usElapsed, 0, 100000, 50);
 
         // Clamp the queries to saner values in case the queries fail.
         usElapsed = std::max(1u, usElapsed);
         usElapsed = std::min(15000u, usElapsed);
 
-        if (!m_pendingQueries.first()->isNonBlocking())
+        if (!m_pendingQueries.front()->isNonBlocking())
             m_numBlockingTextureUploads--;
 
         // Remove the min and max value from our history and insert the new one.
@@ -364,7 +365,7 @@
         }
         m_texturesPerSecondHistory.insert(texturesPerSecond);
 
-        m_availableQueries.append(m_pendingQueries.takeFirst());
+        m_availableQueries.push_back(m_pendingQueries.take_front());
     }
 }
 
Index: src/cc/layer_impl.cc
===================================================================
--- src/cc/layer_impl.cc	(revision 184497)
+++ src/cc/layer_impl.cc	(working copy)
@@ -7,6 +7,7 @@
 #include "base/debug/trace_event.h"
 #include "base/stringprintf.h"
 #include "base/values.h"
+#include "cc/animation_registrar.h"
 #include "cc/debug_border_draw_quad.h"
 #include "cc/debug_colors.h"
 #include "cc/layer_tree_debug_state.h"
@@ -16,6 +17,8 @@
 #include "cc/proxy.h"
 #include "cc/quad_sink.h"
 #include "cc/scrollbar_animation_controller.h"
+#include "cc/scrollbar_animation_controller_linear_fade.h"
+#include "cc/scrollbar_layer_impl.h"
 #include "ui/gfx/point_conversions.h"
 #include "ui/gfx/rect_conversions.h"
 
@@ -33,6 +36,7 @@
     , m_shouldScrollOnMainThread(false)
     , m_haveWheelEventHandlers(false)
     , m_backgroundColor(0)
+    , m_stackingOrderChanged(false)
     , m_doubleSided(true)
     , m_layerPropertyChanged(false)
     , m_layerSurfacePropertyChanged(false)
@@ -50,11 +54,15 @@
 #ifndef NDEBUG
     , m_betweenWillDrawAndDidDraw(false)
 #endif
-    , m_layerAnimationController(LayerAnimationController::create(this))
+    , m_horizontalScrollbarLayer(0)
+    , m_verticalScrollbarLayer(0)
 {
     DCHECK(m_layerId > 0);
     DCHECK(m_layerTreeImpl);
     m_layerTreeImpl->RegisterLayer(this);
+    AnimationRegistrar* registrar = m_layerTreeImpl->animationRegistrar();
+    m_layerAnimationController = registrar->GetAnimationControllerForId(m_layerId);
+    m_layerAnimationController->addObserver(this);
 }
 
 LayerImpl::~LayerImpl()
@@ -63,23 +71,30 @@
     DCHECK(!m_betweenWillDrawAndDidDraw);
 #endif
     m_layerTreeImpl->UnregisterLayer(this);
+    m_layerAnimationController->removeObserver(this);
 }
 
 void LayerImpl::addChild(scoped_ptr<LayerImpl> child)
 {
     child->setParent(this);
     DCHECK_EQ(layerTreeImpl(), child->layerTreeImpl());
-    m_children.append(child.Pass());
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    m_children.push_back(child.Pass());
+    layerTreeImpl()->set_needs_update_draw_properties();
 }
 
+LayerImpl* LayerImpl::childAt(size_t index) const
+{
+  DCHECK_LT(index, m_children.size());
+  return m_children[index];
+}
+
 scoped_ptr<LayerImpl> LayerImpl::removeChild(LayerImpl* child)
 {
-    for (size_t i = 0; i < m_children.size(); ++i) {
-        if (m_children[i] == child) {
-            scoped_ptr<LayerImpl> ret = m_children.take(i);
-            m_children.remove(i);
-            layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    for (ScopedPtrVector<LayerImpl>::iterator it = m_children.begin(); it != m_children.end(); ++it) {
+        if (*it == child) {
+            scoped_ptr<LayerImpl> ret = m_children.take(it);
+            m_children.erase(it);
+            layerTreeImpl()->set_needs_update_draw_properties();
             return ret.Pass();
         }
     }
@@ -89,16 +104,16 @@
 void LayerImpl::removeAllChildren()
 {
     m_children.clear();
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    layerTreeImpl()->set_needs_update_draw_properties();
 }
 
 void LayerImpl::clearChildList()
 {
-    if (m_children.isEmpty())
+    if (m_children.empty())
         return;
 
     m_children.clear();
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    layerTreeImpl()->set_needs_update_draw_properties();
 }
 
 void LayerImpl::createRenderSurface()
@@ -113,7 +128,6 @@
   scoped_ptr<SharedQuadState> state = SharedQuadState::Create();
   state->SetAll(m_drawProperties.target_space_transform,
                 m_drawProperties.visible_content_rect,
-                m_drawProperties.drawable_content_rect,
                 m_drawProperties.clip_rect,
                 m_drawProperties.is_clipped,
                 m_drawProperties.opacity);
@@ -201,6 +215,17 @@
     return 0;
 }
 
+void LayerImpl::setSentScrollDelta(const gfx::Vector2d& sentScrollDelta)
+{
+    // Pending tree never has sent scroll deltas
+    DCHECK(layerTreeImpl()->IsActiveTree());
+
+    if (m_sentScrollDelta == sentScrollDelta)
+        return;
+
+    m_sentScrollDelta = sentScrollDelta;
+}
+
 gfx::Vector2dF LayerImpl::scrollBy(const gfx::Vector2dF& scroll)
 {
     gfx::Vector2dF minDelta = -m_scrollOffset;
@@ -211,14 +236,7 @@
     newDelta.ClampToMax(maxDelta);
     gfx::Vector2dF unscrolled = m_scrollDelta + scroll - newDelta;
 
-    if (m_scrollDelta == newDelta)
-        return unscrolled;
-
-    m_scrollDelta = newDelta;
-    if (m_scrollbarAnimationController)
-        m_scrollbarAnimationController->updateScrollOffset(this);
-    noteLayerPropertyChangedForSubtree();
-
+    setScrollDelta(newDelta);
     return unscrolled;
 }
 
@@ -261,6 +279,11 @@
         return InputHandlerClient::ScrollIgnored;
     }
 
+    if (m_maxScrollOffset.x() <= 0 && m_maxScrollOffset.y() <= 0) {
+        TRACE_EVENT0("cc", "LayerImpl::tryScroll: Ignored. Technically scrollable, but has no affordance in either direction.");
+        return InputHandlerClient::ScrollIgnored;
+    }
+
     return InputHandlerClient::ScrollStarted;
 }
 
@@ -278,6 +301,81 @@
     return gfx::ToEnclosingRect(contentRect);
 }
 
+skia::RefPtr<SkPicture> LayerImpl::getPicture()
+{
+    return skia::RefPtr<SkPicture>();
+}
+
+bool LayerImpl::canClipSelf() const
+{
+    return false;
+}
+
+bool LayerImpl::areVisibleResourcesReady() const
+{
+    return true;
+}
+
+scoped_ptr<LayerImpl> LayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return LayerImpl::create(treeImpl, m_layerId);
+}
+
+void LayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    layer->setAnchorPoint(m_anchorPoint);
+    layer->setAnchorPointZ(m_anchorPointZ);
+    layer->setBackgroundColor(m_backgroundColor);
+    layer->setBounds(m_bounds);
+    layer->setContentBounds(contentBounds());
+    layer->setContentsScale(contentsScaleX(), contentsScaleY());
+    layer->setDebugName(m_debugName);
+    layer->setDoubleSided(m_doubleSided);
+    layer->setDrawCheckerboardForMissingTiles(m_drawCheckerboardForMissingTiles);
+    layer->setForceRenderSurface(m_forceRenderSurface);
+    layer->setDrawsContent(drawsContent());
+    layer->setFilters(filters());
+    layer->setFilter(filter());
+    layer->setBackgroundFilters(backgroundFilters());
+    layer->setMasksToBounds(m_masksToBounds);
+    layer->setShouldScrollOnMainThread(m_shouldScrollOnMainThread);
+    layer->setHaveWheelEventHandlers(m_haveWheelEventHandlers);
+    layer->setNonFastScrollableRegion(m_nonFastScrollableRegion);
+    layer->setTouchEventHandlerRegion(m_touchEventHandlerRegion);
+    layer->setContentsOpaque(m_contentsOpaque);
+    if (!opacityIsAnimating())
+        layer->setOpacity(m_opacity);
+    layer->setPosition(m_position);
+    layer->setIsContainerForFixedPositionLayers(m_isContainerForFixedPositionLayers);
+    layer->setFixedToContainerLayer(m_fixedToContainerLayer);
+    layer->setPreserves3D(preserves3D());
+    layer->setUseParentBackfaceVisibility(m_useParentBackfaceVisibility);
+    layer->setSublayerTransform(m_sublayerTransform);
+    if (!transformIsAnimating())
+        layer->setTransform(m_transform);
+
+    layer->setScrollable(m_scrollable);
+    layer->setScrollOffset(m_scrollOffset);
+    layer->setMaxScrollOffset(m_maxScrollOffset);
+
+    // If the main thread commits multiple times before the impl thread actually draws, then damage tracking
+    // will become incorrect if we simply clobber the updateRect here. The LayerImpl's updateRect needs to
+    // accumulate (i.e. union) any update changes that have occurred on the main thread.
+    m_updateRect.Union(layer->updateRect());
+    layer->setUpdateRect(m_updateRect);
+
+    layer->setScrollDelta(layer->scrollDelta() - layer->sentScrollDelta());
+    layer->setSentScrollDelta(gfx::Vector2d());
+
+    layer->setStackingOrderChanged(m_stackingOrderChanged);
+
+    m_layerAnimationController->pushAnimationUpdatesTo(layer->layerAnimationController());
+
+    // Reset any state that should be cleared for the next update.
+    m_stackingOrderChanged = false;
+    m_updateRect = gfx::RectF();
+}
+
 std::string LayerImpl::indentString(int indent)
 {
     std::string str;
@@ -381,9 +479,10 @@
 
 void LayerImpl::setStackingOrderChanged(bool stackingOrderChanged)
 {
-    // We don't need to store this flag; we only need to track that the change occurred.
-    if (stackingOrderChanged)
+    if (stackingOrderChanged) {
+        m_stackingOrderChanged = true;
         noteLayerPropertyChangedForSubtree();
+    }
 }
 
 bool LayerImpl::layerSurfacePropertyChanged() const
@@ -409,13 +508,13 @@
 void LayerImpl::noteLayerSurfacePropertyChanged()
 {
     m_layerSurfacePropertyChanged = true;
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    layerTreeImpl()->set_needs_update_draw_properties();
 }
 
 void LayerImpl::noteLayerPropertyChanged()
 {
     m_layerPropertyChanged = true;
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    layerTreeImpl()->set_needs_update_draw_properties();
 }
 
 void LayerImpl::noteLayerPropertyChangedForSubtree()
@@ -426,7 +525,7 @@
 
 void LayerImpl::noteLayerPropertyChangedForDescendants()
 {
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
+    layerTreeImpl()->set_needs_update_draw_properties();
     for (size_t i = 0; i < m_children.size(); ++i)
         m_children[i]->noteLayerPropertyChangedForSubtree();
 }
@@ -466,24 +565,19 @@
      return m_layerId;
 }
 
-float LayerImpl::opacity() const
+void LayerImpl::OnOpacityAnimated(float opacity)
 {
-     return m_opacity;
-}
-
-void LayerImpl::setOpacityFromAnimation(float opacity)
-{
     setOpacity(opacity);
 }
 
-const gfx::Transform& LayerImpl::transform() const
+void LayerImpl::OnTransformAnimated(const gfx::Transform& transform)
 {
-     return m_transform;
+    setTransform(transform);
 }
 
-void LayerImpl::setTransformFromAnimation(const gfx::Transform& transform)
+bool LayerImpl::IsActive() const
 {
-    setTransform(transform);
+    return m_layerTreeImpl->IsActiveTree();
 }
 
 void LayerImpl::setBounds(const gfx::Size& bounds)
@@ -541,6 +635,11 @@
   return m_replicaLayer.Pass();
 }
 
+ScrollbarLayerImpl* LayerImpl::toScrollbarLayer()
+{
+    return 0;
+}
+
 void LayerImpl::setDrawsContent(bool drawsContent)
 {
     if (m_drawsContent == drawsContent)
@@ -633,9 +732,14 @@
     noteLayerSurfacePropertyChanged();
 }
 
+float LayerImpl::opacity() const
+{
+    return m_opacity;
+}
+
 bool LayerImpl::opacityIsAnimating() const
 {
-    return m_layerAnimationController->isAnimatingProperty(ActiveAnimation::Opacity);
+    return m_layerAnimationController->isAnimatingProperty(Animation::Opacity);
 }
 
 void LayerImpl::setPosition(const gfx::PointF& position)
@@ -675,9 +779,14 @@
     noteLayerSurfacePropertyChanged();
 }
 
+const gfx::Transform& LayerImpl::transform() const
+{
+    return m_transform;
+}
+
 bool LayerImpl::transformIsAnimating() const
 {
-    return m_layerAnimationController->isAnimatingProperty(ActiveAnimation::Transform);
+    return m_layerAnimationController->isAnimatingProperty(Animation::Transform);
 }
 
 void LayerImpl::setContentBounds(const gfx::Size& contentBounds)
@@ -699,6 +808,50 @@
     noteLayerPropertyChanged();
 }
 
+void LayerImpl::calculateContentsScale(
+    float idealContentsScale,
+    bool animatingTransformToScreen,
+    float* contentsScaleX,
+    float* contentsScaleY,
+    gfx::Size* contentBounds)
+{
+    // Base LayerImpl has all of its content scales and content bounds pushed
+    // from its Layer during commit and just reuses those values as-is.
+    *contentsScaleX = this->contentsScaleX();
+    *contentsScaleY = this->contentsScaleY();
+    *contentBounds = this->contentBounds();
+}
+
+void LayerImpl::updateScrollbarPositions()
+{
+    gfx::Vector2dF currentOffset = m_scrollOffset + m_scrollDelta;
+
+    if (m_horizontalScrollbarLayer) {
+        m_horizontalScrollbarLayer->setCurrentPos(currentOffset.x());
+        m_horizontalScrollbarLayer->setTotalSize(m_bounds.width());
+        m_horizontalScrollbarLayer->setMaximum(m_maxScrollOffset.x());
+    }
+    if (m_verticalScrollbarLayer) {
+        m_verticalScrollbarLayer->setCurrentPos(currentOffset.y());
+        m_verticalScrollbarLayer->setTotalSize(m_bounds.height());
+        m_verticalScrollbarLayer->setMaximum(m_maxScrollOffset.y());
+    }
+
+    if (currentOffset == m_lastScrollOffset)
+        return;
+    m_lastScrollOffset = currentOffset;
+
+    if (m_scrollbarAnimationController)
+        m_scrollbarAnimationController->didUpdateScrollOffset(base::TimeTicks::Now());
+
+    // Get the m_currentOffset.y() value for a sanity-check on scrolling
+    // benchmark metrics. Specifically, we want to make sure
+    // BasicMouseWheelSmoothScrollGesture has proper scroll curves.
+    if (layerTreeImpl()->IsActiveTree()) {
+        TRACE_COUNTER_ID1("gpu", "scroll_offset_y", this->id(), currentOffset.y());
+    }
+}
+
 void LayerImpl::setScrollOffset(gfx::Vector2d scrollOffset)
 {
     if (m_scrollOffset == scrollOffset)
@@ -706,6 +859,7 @@
 
     m_scrollOffset = scrollOffset;
     noteLayerPropertyChangedForSubtree();
+    updateScrollbarPositions();
 }
 
 void LayerImpl::setScrollDelta(const gfx::Vector2dF& scrollDelta)
@@ -713,8 +867,24 @@
     if (m_scrollDelta == scrollDelta)
         return;
 
+    if (layerTreeImpl()->IsActiveTree())
+    {
+        LayerImpl* pending_twin = layerTreeImpl()->FindPendingTreeLayerById(id());
+        if (pending_twin) {
+            // The pending twin can't mirror the scroll delta of the active
+            // layer.  Although the delta - sent scroll delta difference is
+            // identical for both twins, the sent scroll delta for the pending
+            // layer is zero, as anything that has been sent has been baked
+            // into the layer's position/scroll offset as a part of commit.
+            DCHECK(pending_twin->sentScrollDelta().IsZero());
+            pending_twin->setScrollDelta(scrollDelta - sentScrollDelta());
+        }
+    }
+
     m_scrollDelta = scrollDelta;
     noteLayerPropertyChangedForSubtree();
+
+    updateScrollbarPositions();
 }
 
 void LayerImpl::setImplTransform(const gfx::Transform& transform)
@@ -752,47 +922,51 @@
         return;
     m_maxScrollOffset = maxScrollOffset;
 
-    layerTreeImpl()->SetNeedsUpdateDrawProperties();
-
-    if (!m_scrollbarAnimationController)
-        return;
-    m_scrollbarAnimationController->updateScrollOffset(this);
+    layerTreeImpl()->set_needs_update_draw_properties();
+    updateScrollbarPositions();
 }
 
-ScrollbarLayerImpl* LayerImpl::horizontalScrollbarLayer()
+void LayerImpl::setScrollbarOpacity(float opacity)
 {
-    return m_scrollbarAnimationController ? m_scrollbarAnimationController->horizontalScrollbarLayer() : 0;
+    if (m_horizontalScrollbarLayer)
+        m_horizontalScrollbarLayer->setOpacity(opacity);
+    if (m_verticalScrollbarLayer)
+        m_verticalScrollbarLayer->setOpacity(opacity);
 }
 
-const ScrollbarLayerImpl* LayerImpl::horizontalScrollbarLayer() const
+inline scoped_ptr<ScrollbarAnimationController> createScrollbarAnimationControllerWithFade(LayerImpl* layer)
 {
-    return m_scrollbarAnimationController ? m_scrollbarAnimationController->horizontalScrollbarLayer() : 0;
+    double fadeoutDelay = 0.3;
+    double fadeoutLength = 0.3;
+    return ScrollbarAnimationControllerLinearFade::create(layer, fadeoutDelay, fadeoutLength).PassAs<ScrollbarAnimationController>();
 }
 
-void LayerImpl::setHorizontalScrollbarLayer(ScrollbarLayerImpl* scrollbarLayer)
+void LayerImpl::didBecomeActive()
 {
-    if (!m_scrollbarAnimationController)
-        m_scrollbarAnimationController = ScrollbarAnimationController::create(this);
-    m_scrollbarAnimationController->setHorizontalScrollbarLayer(scrollbarLayer);
-    m_scrollbarAnimationController->updateScrollOffset(this);
-}
+    if (!m_layerTreeImpl->settings().useLinearFadeScrollbarAnimator)
+        return;
 
-ScrollbarLayerImpl* LayerImpl::verticalScrollbarLayer()
-{
-    return m_scrollbarAnimationController ? m_scrollbarAnimationController->verticalScrollbarLayer() : 0;
+    bool needScrollbarAnimationController = m_horizontalScrollbarLayer || m_verticalScrollbarLayer;
+    if (needScrollbarAnimationController) {
+        if (!m_scrollbarAnimationController)
+            m_scrollbarAnimationController = createScrollbarAnimationControllerWithFade(this);
+    } else {
+        m_scrollbarAnimationController.reset();
+    }
+
 }
-
-const ScrollbarLayerImpl* LayerImpl::verticalScrollbarLayer() const
+void LayerImpl::setHorizontalScrollbarLayer(ScrollbarLayerImpl* scrollbarLayer)
 {
-    return m_scrollbarAnimationController ? m_scrollbarAnimationController->verticalScrollbarLayer() : 0;
+    m_horizontalScrollbarLayer = scrollbarLayer;
+    if (m_horizontalScrollbarLayer)
+        m_horizontalScrollbarLayer->setScrollLayerId(id());
 }
 
 void LayerImpl::setVerticalScrollbarLayer(ScrollbarLayerImpl* scrollbarLayer)
 {
-    if (!m_scrollbarAnimationController)
-        m_scrollbarAnimationController = ScrollbarAnimationController::create(this);
-    m_scrollbarAnimationController->setVerticalScrollbarLayer(scrollbarLayer);
-    m_scrollbarAnimationController->updateScrollOffset(this);
+    m_verticalScrollbarLayer = scrollbarLayer;
+    if (m_verticalScrollbarLayer)
+        m_verticalScrollbarLayer->setScrollLayerId(id());
 }
 
 }  // namespace cc
Index: src/cc/nine_patch_layer_unittest.cc
===================================================================
--- src/cc/nine_patch_layer_unittest.cc	(revision 184497)
+++ src/cc/nine_patch_layer_unittest.cc	(working copy)
@@ -7,18 +7,19 @@
 #include "cc/layer_tree_host.h"
 #include "cc/occlusion_tracker.h"
 #include "cc/overdraw_metrics.h"
+#include "cc/prioritized_resource_manager.h"
 #include "cc/rendering_stats.h"
 #include "cc/resource_provider.h"
+#include "cc/resource_update_queue.h"
 #include "cc/single_thread_proxy.h"
-#include "cc/resource_update_queue.h"
-#include "cc/texture_uploader.h"
 #include "cc/test/fake_layer_tree_host_client.h"
 #include "cc/test/fake_output_surface.h"
 #include "cc/test/geometry_test_utils.h"
 #include "cc/test/layer_tree_test_common.h"
-#include "SkBitmap.h"
+#include "cc/texture_uploader.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 
 using ::testing::Mock;
 using ::testing::_;
Index: src/cc/frame_rate_counter.cc
===================================================================
--- src/cc/frame_rate_counter.cc	(revision 184497)
+++ src/cc/frame_rate_counter.cc	(working copy)
@@ -4,7 +4,7 @@
 
 #include "cc/frame_rate_counter.h"
 
-#include <cmath>
+#include <limits>
 
 #include "base/metrics/histogram.h"
 #include "cc/proxy.h"
@@ -15,46 +15,37 @@
 const double FrameRateCounter::kFrameTooSlow = 1.0 / 4.0;
 const double FrameRateCounter::kDroppedFrameTime = 1.0 / 50.0;
 
-// safeMod works on -1, returning m-1 in that case.
-static inline int safeMod(int number, int modulus)
-{
-    return (number + modulus) % modulus;
-}
-
 // static
 scoped_ptr<FrameRateCounter> FrameRateCounter::create(bool hasImplThread) {
   return make_scoped_ptr(new FrameRateCounter(hasImplThread));
 }
 
-inline base::TimeDelta FrameRateCounter::frameInterval(int frameNumber) const
+inline base::TimeDelta FrameRateCounter::recentFrameInterval(size_t n) const
 {
-    return m_timeStampHistory[frameIndex(frameNumber)] -
-        m_timeStampHistory[frameIndex(frameNumber - 1)];
+    DCHECK(n > 0);
+    return m_ringBuffer.ReadBuffer(n) - m_ringBuffer.ReadBuffer(n - 1);
 }
 
-inline int FrameRateCounter::frameIndex(int frameNumber) const
-{
-    return safeMod(frameNumber, kTimeStampHistorySize);
-}
-
 FrameRateCounter::FrameRateCounter(bool hasImplThread)
     : m_hasImplThread(hasImplThread)
-    , m_currentFrameNumber(1)
     , m_droppedFrameCount(0)
 {
-    m_timeStampHistory[0] = base::TimeTicks::Now();
-    m_timeStampHistory[1] = m_timeStampHistory[0];
-    for (int i = 2; i < kTimeStampHistorySize; i++)
-        m_timeStampHistory[i] = base::TimeTicks();
 }
 
-void FrameRateCounter::markBeginningOfFrame(base::TimeTicks timestamp)
+void FrameRateCounter::saveTimeStamp(base::TimeTicks timestamp)
 {
-    m_timeStampHistory[frameIndex(m_currentFrameNumber)] = timestamp;
-    base::TimeDelta frameIntervalSeconds = frameInterval(m_currentFrameNumber);
+    m_ringBuffer.SaveToBuffer(timestamp);
 
-    if (m_hasImplThread && m_currentFrameNumber > 0) {
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.CompositorThreadImplDrawDelay", frameIntervalSeconds.InMilliseconds(), 1, 120, 60);
+    // Check if frame interval can be computed.
+    if (m_ringBuffer.CurrentIndex() < 2)
+        return;
+
+    base::TimeDelta frameIntervalSeconds = recentFrameInterval(m_ringBuffer.BufferSize() - 1);
+
+    if (m_hasImplThread && m_ringBuffer.CurrentIndex() > 0) {
+        UMA_HISTOGRAM_CUSTOM_COUNTS("Renderer4.CompositorThreadImplDrawDelay",
+                                    frameIntervalSeconds.InMilliseconds(),
+                                    1, 120, 60);
     }
 
     if (!isBadFrameInterval(frameIntervalSeconds) &&
@@ -62,11 +53,6 @@
         ++m_droppedFrameCount;
 }
 
-void FrameRateCounter::markEndOfFrame()
-{
-    m_currentFrameNumber += 1;
-}
-
 bool FrameRateCounter::isBadFrameInterval(base::TimeDelta intervalBetweenConsecutiveFrames) const
 {
     double delta = intervalBetweenConsecutiveFrames.InSecondsF();
@@ -76,14 +62,30 @@
     return intervalTooFast || intervalTooSlow;
 }
 
-bool FrameRateCounter::isBadFrame(int frameNumber) const
+void FrameRateCounter::getMinAndMaxFPS(double& minFPS, double& maxFPS) const
 {
-    return isBadFrameInterval(frameInterval(frameNumber));
+    minFPS = std::numeric_limits<double>::max();
+    maxFPS = 0;
+
+    for (size_t i = m_ringBuffer.BufferSize() - 1; i > 0 && m_ringBuffer.IsFilledIndex(i - 1); --i) {
+        base::TimeDelta delta = recentFrameInterval(i);
+
+        if (isBadFrameInterval(delta))
+            continue;
+
+        DCHECK(delta.InSecondsF() > 0);
+        double fps = 1.0 / delta.InSecondsF();
+
+        minFPS = std::min(fps, minFPS);
+        maxFPS = std::max(fps, maxFPS);
+    }
+
+    if (minFPS > maxFPS)
+        minFPS = maxFPS;
 }
 
 double FrameRateCounter::getAverageFPS() const
 {
-    int frameNumber = m_currentFrameNumber - 1;
     int frameCount = 0;
     double frameTimesTotal = 0;
     double averageFPS = 0;
@@ -99,30 +101,32 @@
     //
     // isBadFrameInterval encapsulates the frame too slow/frame too fast logic.
 
-    while (frameIndex(frameNumber) != frameIndex(m_currentFrameNumber) && frameNumber >= 0 && frameTimesTotal < 1.0) {
-        base::TimeDelta delta = frameInterval(frameNumber);
+    for (size_t i = m_ringBuffer.BufferSize() - 1; i > 0 && m_ringBuffer.IsFilledIndex(i - 1) && frameTimesTotal < 1.0; --i) {
+        base::TimeDelta delta = recentFrameInterval(i);
 
         if (!isBadFrameInterval(delta)) {
             frameCount++;
             frameTimesTotal += delta.InSecondsF();
         } else if (frameCount)
             break;
-
-        frameNumber--;
     }
 
-    if (frameCount)
+    if (frameCount) {
+        DCHECK(frameTimesTotal > 0);
         averageFPS = frameCount / frameTimesTotal;
+    }
 
     return averageFPS;
 }
 
-base::TimeTicks FrameRateCounter::timeStampOfRecentFrame(int n) const
+base::TimeTicks FrameRateCounter::timeStampOfRecentFrame(size_t n) const
 {
-    DCHECK(n >= 0);
-    DCHECK(n < kTimeStampHistorySize);
-    int desiredIndex = (frameIndex(m_currentFrameNumber) + n) % kTimeStampHistorySize;
-    return m_timeStampHistory[desiredIndex];
+    DCHECK(n < m_ringBuffer.BufferSize());
+
+    if (m_ringBuffer.IsFilledIndex(n))
+        return m_ringBuffer.ReadBuffer(n);
+
+    return base::TimeTicks();
 }
 
 }  // namespace cc
Index: src/cc/picture_pile_impl.cc
===================================================================
--- src/cc/picture_pile_impl.cc	(revision 184497)
+++ src/cc/picture_pile_impl.cc	(working copy)
@@ -4,10 +4,12 @@
 
 #include "base/debug/trace_event.h"
 #include "cc/picture_pile_impl.h"
+#include "cc/region.h"
 #include "cc/rendering_stats.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/core/SkSize.h"
 #include "ui/gfx/rect_conversions.h"
+#include "ui/gfx/skia_util.h"
 
 namespace cc {
 
@@ -15,7 +17,8 @@
   return make_scoped_refptr(new PicturePileImpl());
 }
 
-PicturePileImpl::PicturePileImpl() {
+PicturePileImpl::PicturePileImpl()
+    : slow_down_raster_scale_factor_for_debug_(0) {
 }
 
 PicturePileImpl::~PicturePileImpl() {
@@ -37,9 +40,19 @@
 scoped_refptr<PicturePileImpl> PicturePileImpl::CloneForDrawing() const {
   TRACE_EVENT0("cc", "PicturePileImpl::CloneForDrawing");
   scoped_refptr<PicturePileImpl> clone = Create();
-  for (PicturePile::Pile::const_iterator i = pile_.begin();
-       i != pile_.end(); ++i)
-    clone->pile_.push_back((*i)->Clone());
+  clone->tiling_ = tiling_;
+  for (PictureListMap::const_iterator map_iter = picture_list_map_.begin();
+       map_iter != picture_list_map_.end(); ++map_iter) {
+    const PictureList& this_pic_list = map_iter->second;
+    PictureList& clone_pic_list = clone->picture_list_map_[map_iter->first];
+    for (PictureList::const_iterator pic_iter = this_pic_list.begin();
+         pic_iter != this_pic_list.end(); ++pic_iter) {
+      clone_pic_list.push_back((*pic_iter)->Clone());
+    }
+  }
+  clone->min_contents_scale_ = min_contents_scale_;
+  clone->set_slow_down_raster_scale_factor(
+      slow_down_raster_scale_factor_for_debug_);
 
   return clone;
 }
@@ -49,44 +62,113 @@
     gfx::Rect content_rect,
     float contents_scale,
     RenderingStats* stats) {
+
+  DCHECK(contents_scale >= min_contents_scale_);
+
   base::TimeTicks rasterizeBeginTime = base::TimeTicks::Now();
 
-  // TODO(enne): do this more efficiently, i.e. top down with Skia clips
   canvas->save();
   canvas->translate(-content_rect.x(), -content_rect.y());
-  SkRect layer_skrect = SkRect::MakeXYWH(
-      content_rect.x(),
-      content_rect.y(),
-      content_rect.width(),
-      content_rect.height());
-  canvas->clipRect(layer_skrect);
-  canvas->scale(contents_scale, contents_scale);
+  canvas->clipRect(gfx::RectToSkRect(content_rect));
 
-  gfx::Rect layer_rect = gfx::ToEnclosedRect(gfx::ScaleRect(gfx::RectF(content_rect), 1 / contents_scale));
+  gfx::Rect layer_rect = gfx::ToEnclosingRect(
+      gfx::ScaleRect(content_rect, 1.f / contents_scale));
 
-  for (PicturePile::Pile::const_iterator i = pile_.begin();
-       i != pile_.end(); ++i) {
-    if (!(*i)->LayerRect().Intersects(layer_rect))
+  Region unclipped(content_rect);
+  for (TilingData::Iterator tile_iter(&tiling_, layer_rect);
+       tile_iter; ++tile_iter) {
+    PictureListMap::iterator map_iter =
+        picture_list_map_.find(tile_iter.index());
+    if (map_iter == picture_list_map_.end())
       continue;
-    (*i)->Raster(canvas);
+    PictureList& pic_list= map_iter->second;
+    if (pic_list.empty())
+      continue;
 
-    SkISize deviceSize = canvas->getDeviceSize();
-    stats->totalPixelsRasterized += deviceSize.width() * deviceSize.height();
+    // Raster through the picture list top down, using clips to make sure that
+    // pictures on top are not overdrawn by pictures on the bottom.
+    for (PictureList::reverse_iterator i = pic_list.rbegin();
+         i != pic_list.rend(); ++i) {
+      // This is intentionally *enclosed* rect, so that the clip is aligned on
+      // integral post-scale content pixels and does not extend past the edges
+      // of the picture's layer rect.  The min_contents_scale enforces that
+      // enough buffer pixels have been added such that the enclosed rect
+      // encompasses all invalidated pixels at any larger scale level.
+      gfx::Rect content_clip = gfx::ToEnclosedRect(
+          gfx::ScaleRect((*i)->LayerRect(), contents_scale));
+      if (!unclipped.Intersects(content_clip))
+        continue;
+
+      if (slow_down_raster_scale_factor_for_debug_) {
+        for (int j = 0; j < slow_down_raster_scale_factor_for_debug_; ++j)
+          (*i)->Raster(canvas, content_clip, contents_scale);
+      } else {
+        (*i)->Raster(canvas, content_clip, contents_scale);
+      }
+
+      // Don't allow pictures underneath to draw where this picture did.
+      canvas->clipRect(
+          gfx::RectToSkRect(content_clip),
+          SkRegion::kDifference_Op);
+      unclipped.Subtract(content_clip);
+
+      stats->totalPixelsRasterized +=
+          content_clip.width() * content_clip.height();
+    }
   }
   canvas->restore();
 
-  stats->totalRasterizeTimeInSeconds += (base::TimeTicks::Now() -
-                                         rasterizeBeginTime).InSecondsF();
+  stats->totalRasterizeTime += base::TimeTicks::Now() - rasterizeBeginTime;
 }
 
 void PicturePileImpl::GatherPixelRefs(
-    const gfx::Rect& rect, std::list<skia::LazyPixelRef*>& pixel_refs) {
+    gfx::Rect content_rect,
+    float contents_scale,
+    std::list<skia::LazyPixelRef*>& pixel_refs) {
   std::list<skia::LazyPixelRef*> result;
-  for (PicturePile::Pile::const_iterator i = pile_.begin();
-      i != pile_.end(); ++i) {
-    (*i)->GatherPixelRefs(rect, result);
-    pixel_refs.splice(pixel_refs.end(), result);
+
+  gfx::Rect layer_rect = gfx::ToEnclosingRect(
+      gfx::ScaleRect(content_rect, 1.f / contents_scale));
+
+  for (TilingData::Iterator tile_iter(&tiling_, layer_rect);
+       tile_iter; ++tile_iter) {
+    PictureListMap::iterator map_iter =
+        picture_list_map_.find(tile_iter.index());
+    if (map_iter == picture_list_map_.end())
+      continue;
+
+    PictureList& pic_list = map_iter->second;
+    for (PictureList::const_iterator i = pic_list.begin();
+         i != pic_list.end(); ++i) {
+      (*i)->GatherPixelRefs(layer_rect, result);
+      pixel_refs.splice(pixel_refs.end(), result);
+    }
   }
 }
 
+void PicturePileImpl::PushPropertiesTo(PicturePileImpl* other) {
+  PicturePileBase::PushPropertiesTo(other);
+  other->clones_ = clones_;
+}
+
+skia::RefPtr<SkPicture> PicturePileImpl::GetFlattenedPicture() {
+  TRACE_EVENT0("cc", "PicturePileImpl::GetFlattenedPicture");
+
+  gfx::Rect layer_rect(tiling_.total_size());
+  skia::RefPtr<SkPicture> picture = skia::AdoptRef(new SkPicture);
+  if (layer_rect.IsEmpty())
+    return picture;
+
+  SkCanvas* canvas = picture->beginRecording(
+      layer_rect.width(),
+      layer_rect.height(),
+      SkPicture::kUsePathBoundsForClip_RecordingFlag);
+
+  RenderingStats stats;
+  Raster(canvas, layer_rect, 1.0, &stats);
+  picture->endRecording();
+
+  return picture;
+}
+
 }  // namespace cc
Index: src/cc/shader.cc
===================================================================
--- src/cc/shader.cc	(revision 184497)
+++ src/cc/shader.cc	(working copy)
@@ -6,7 +6,7 @@
 
 #include "base/basictypes.h"
 #include "base/logging.h"
-#include <public/WebGraphicsContext3D.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 
 #define SHADER0(Src) #Src
 #define SHADER(Src) SHADER0(Src)
Index: src/cc/thread_proxy.cc
===================================================================
--- src/cc/thread_proxy.cc	(revision 184497)
+++ src/cc/thread_proxy.cc	(working copy)
@@ -4,6 +4,7 @@
 
 #include "cc/thread_proxy.h"
 
+#include "base/auto_reset.h"
 #include "base/bind.h"
 #include "base/debug/trace_event.h"
 #include "cc/delay_based_time_source.h"
@@ -11,11 +12,12 @@
 #include "cc/frame_rate_controller.h"
 #include "cc/input_handler.h"
 #include "cc/layer_tree_host.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/output_surface.h"
+#include "cc/prioritized_resource_manager.h"
 #include "cc/scheduler.h"
-#include "cc/scoped_thread_proxy.h"
 #include "cc/thread.h"
-#include <public/WebSharedGraphicsContext3D.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSharedGraphicsContext3D.h"
 
 using WebKit::WebSharedGraphicsContext3D;
 
@@ -24,6 +26,9 @@
 // Measured in seconds.
 const double contextRecreationTickRate = 0.03;
 
+// Measured in seconds.
+const double smoothnessTakesPriorityExpirationDelay = 0.25;
+
 }  // namespace
 
 namespace cc {
@@ -44,15 +49,19 @@
     , m_texturesAcquired(true)
     , m_inCompositeAndReadback(false)
     , m_manageTilesPending(false)
-    , m_mainThreadProxy(ScopedThreadProxy::create(Proxy::mainThread()))
+    , m_weakFactoryOnImplThread(ALLOW_THIS_IN_INITIALIZER_LIST(this))
+    , m_weakFactory(ALLOW_THIS_IN_INITIALIZER_LIST(this))
     , m_beginFrameCompletionEventOnImplThread(0)
     , m_readbackRequestOnImplThread(0)
     , m_commitCompletionEventOnImplThread(0)
+    , m_completionEventForCommitHeldOnTreeActivation(0)
     , m_textureAcquisitionCompletionEventOnImplThread(0)
     , m_nextFrameIsNewlyCommittedFrameOnImplThread(false)
     , m_renderVSyncEnabled(layerTreeHost->settings().renderVSyncEnabled)
+    , m_insideDraw(false)
     , m_totalCommitCount(0)
     , m_deferCommits(false)
+    , m_renewTreePriorityOnImplThreadPending(false)
 {
     TRACE_EVENT0("cc", "ThreadProxy::ThreadProxy");
     DCHECK(isMainThread());
@@ -82,7 +91,7 @@
     {
         DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
         CompletionEvent beginFrameCompletion;
-        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::forceBeginFrameOnImplThread, base::Unretained(this), &beginFrameCompletion));
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::forceBeginFrameOnImplThread, m_implThreadWeakPtr, &beginFrameCompletion));
         beginFrameCompletion.wait();
     }
     m_inCompositeAndReadback = true;
@@ -95,7 +104,7 @@
     request.pixels = pixels;
     {
         DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
-        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::requestReadbackOnImplThread, base::Unretained(this), &request));
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::requestReadbackOnImplThread, m_implThreadWeakPtr, &request));
         request.completion.wait();
     }
     return request.success;
@@ -119,7 +128,7 @@
 void ThreadProxy::startPageScaleAnimation(gfx::Vector2d targetOffset, bool useAnchor, float scale, base::TimeDelta duration)
 {
     DCHECK(Proxy::isMainThread());
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::requestStartPageScaleAnimationOnImplThread, base::Unretained(this), targetOffset, useAnchor, scale, duration));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::requestStartPageScaleAnimationOnImplThread, m_implThreadWeakPtr, targetOffset, useAnchor, scale, duration));
 }
 
 void ThreadProxy::requestStartPageScaleAnimationOnImplThread(gfx::Vector2d targetOffset, bool useAnchor, float scale, base::TimeDelta duration)
@@ -137,7 +146,7 @@
     // Make sure all GL drawing is finished on the impl thread.
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     CompletionEvent completion;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::finishAllRenderingOnImplThread, base::Unretained(this), &completion));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::finishAllRenderingOnImplThread, m_implThreadWeakPtr, &completion));
     completion.wait();
 }
 
@@ -154,14 +163,14 @@
     if (!context.get())
         return false;
 
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::initializeOutputSurfaceOnImplThread, base::Unretained(this), base::Passed(context.Pass())));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::initializeOutputSurfaceOnImplThread, m_implThreadWeakPtr, base::Passed(&context)));
     return true;
 }
 
 void ThreadProxy::setSurfaceReady()
 {
     TRACE_EVENT0("cc", "ThreadProxy::setSurfaceReady");
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setSurfaceReadyOnImplThread, base::Unretained(this)));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setSurfaceReadyOnImplThread, m_implThreadWeakPtr));
 }
 
 void ThreadProxy::setSurfaceReadyOnImplThread()
@@ -175,7 +184,7 @@
     TRACE_EVENT0("cc", "ThreadProxy::setVisible");
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     CompletionEvent completion;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setVisibleOnImplThread, base::Unretained(this), &completion, visible));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setVisibleOnImplThread, m_implThreadWeakPtr, &completion, visible));
     completion.wait();
 }
 
@@ -197,7 +206,7 @@
     RendererCapabilities capabilities;
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     Proxy::implThread()->postTask(base::Bind(&ThreadProxy::initializeRendererOnImplThread,
-                                             base::Unretained(this),
+                                             m_implThreadWeakPtr,
                                              &completion,
                                              &initializeSucceeded,
                                              &capabilities));
@@ -231,9 +240,9 @@
     RendererCapabilities capabilities;
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     Proxy::implThread()->postTask(base::Bind(&ThreadProxy::recreateOutputSurfaceOnImplThread,
-                                             base::Unretained(this),
+                                             m_implThreadWeakPtr,
                                              &completion,
-                                             base::Passed(outputSurface.Pass()),
+                                             base::Passed(&outputSurface),
                                              &recreateSucceeded,
                                              &capabilities));
     completion.wait();
@@ -250,8 +259,8 @@
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     CompletionEvent completion;
     Proxy::implThread()->postTask(base::Bind(&ThreadProxy::renderingStatsOnImplThread,
-                                             base::Unretained(this),  &completion, stats));
-    stats->totalCommitTimeInSeconds = m_totalCommitTime.InSecondsF();
+                                             m_implThreadWeakPtr,  &completion, stats));
+    stats->totalCommitTime = m_totalCommitTime;
     stats->totalCommitCount = m_totalCommitCount;
 
     completion.wait();
@@ -263,11 +272,6 @@
     return m_RendererCapabilitiesMainThreadCopy;
 }
 
-void ThreadProxy::loseOutputSurface()
-{
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::didLoseOutputSurfaceOnImplThread, base::Unretained(this)));
-}
-
 void ThreadProxy::setNeedsAnimate()
 {
     DCHECK(isMainThread());
@@ -280,7 +284,7 @@
     if (m_commitRequestSentToImplThread)
         return;
     m_commitRequestSentToImplThread = true;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setNeedsCommitOnImplThread, base::Unretained(this)));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setNeedsCommitOnImplThread, m_implThreadWeakPtr));
 }
 
 void ThreadProxy::setNeedsCommit()
@@ -294,13 +298,22 @@
     if (m_commitRequestSentToImplThread)
         return;
     m_commitRequestSentToImplThread = true;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setNeedsCommitOnImplThread, base::Unretained(this)));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setNeedsCommitOnImplThread, m_implThreadWeakPtr));
 }
 
 void ThreadProxy::didLoseOutputSurfaceOnImplThread()
 {
     DCHECK(isImplThread());
     TRACE_EVENT0("cc", "ThreadProxy::didLoseOutputSurfaceOnImplThread");
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::checkOutputSurfaceStatusOnImplThread, m_implThreadWeakPtr));
+}
+
+void ThreadProxy::checkOutputSurfaceStatusOnImplThread()
+{
+    DCHECK(isImplThread());
+    TRACE_EVENT0("cc", "ThreadProxy::checkOutputSurfaceStatusOnImplThread");
+    if (!m_layerTreeHostImpl->isContextLost())
+        return;
     m_schedulerOnImplThread->didLoseOutputSurface();
 }
 
@@ -309,7 +322,7 @@
     DCHECK(isImplThread());
     TRACE_EVENT0("cc", "ThreadProxy::onSwapBuffersCompleteOnImplThread");
     m_schedulerOnImplThread->didSwapBuffersComplete();
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadProxy::didCompleteSwapBuffers, base::Unretained(this)));
+    Proxy::mainThread()->postTask(base::Bind(&ThreadProxy::didCompleteSwapBuffers, m_mainThreadWeakPtr));
 }
 
 void ThreadProxy::onVSyncParametersChanged(base::TimeTicks timebase, base::TimeDelta interval)
@@ -326,6 +339,13 @@
     m_schedulerOnImplThread->setCanDraw(canDraw);
 }
 
+void ThreadProxy::onHasPendingTreeStateChanged(bool hasPendingTree)
+{
+    DCHECK(isImplThread());
+    TRACE_EVENT1("cc", "ThreadProxy::onHasPendingTreeStateChanged", "hasPendingTree", hasPendingTree);
+    m_schedulerOnImplThread->setHasPendingTree(hasPendingTree);
+}
+
 void ThreadProxy::setNeedsCommitOnImplThread()
 {
     DCHECK(isImplThread());
@@ -337,7 +357,7 @@
 {
     if (m_manageTilesPending)
       return;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::manageTilesOnImplThread, base::Unretained(this)));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::manageTilesOnImplThread, m_implThreadWeakPtr));
     m_manageTilesPending = true;
 }
 
@@ -360,7 +380,7 @@
 {
     DCHECK(isImplThread());
     TRACE_EVENT0("cc", "ThreadProxy::postAnimationEventsToMainThreadOnImplThread");
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadProxy::setAnimationEvents, base::Unretained(this), base::Passed(events.Pass()), wallClockTime));
+    Proxy::mainThread()->postTask(base::Bind(&ThreadProxy::setAnimationEvents, m_mainThreadWeakPtr, base::Passed(&events), wallClockTime));
 }
 
 bool ThreadProxy::reduceContentsTextureMemoryOnImplThread(size_t limitBytes, int priorityCutoff)
@@ -381,6 +401,16 @@
     return true;
 }
 
+void ThreadProxy::reduceWastedContentsTextureMemoryOnImplThread()
+{
+    DCHECK(isImplThread());
+
+    if (!m_layerTreeHost->contentsTextureManager())
+        return;
+
+    m_layerTreeHost->contentsTextureManager()->reduceWastedMemoryOnImplThread(m_layerTreeHostImpl->resourceProvider());
+}
+
 void ThreadProxy::sendManagedMemoryStats()
 {
     DCHECK(isImplThread());
@@ -389,18 +419,29 @@
     if (!m_layerTreeHost->contentsTextureManager())
         return;
 
+    // If we are using impl-side painting, then sendManagedMemoryStats is called
+    // directly after the tile manager's manage function, and doesn't need to
+    // interact with main thread's layer tree.
+    if (m_layerTreeHost->settings().implSidePainting)
+        return;
+
     m_layerTreeHostImpl->sendManagedMemoryStats(
         m_layerTreeHost->contentsTextureManager()->memoryVisibleBytes(),
         m_layerTreeHost->contentsTextureManager()->memoryVisibleAndNearbyBytes(),
         m_layerTreeHost->contentsTextureManager()->memoryUseBytes());
 }
 
+bool ThreadProxy::isInsideDraw()
+{
+    return m_insideDraw;
+}
+
 void ThreadProxy::setNeedsRedraw()
 {
     DCHECK(isMainThread());
     TRACE_EVENT0("cc", "ThreadProxy::setNeedsRedraw");
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setFullRootLayerDamageOnImplThread, base::Unretained(this)));
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setNeedsRedrawOnImplThread, base::Unretained(this)));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setFullRootLayerDamageOnImplThread, m_implThreadWeakPtr));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::setNeedsRedrawOnImplThread, m_implThreadWeakPtr));
 }
 
 void ThreadProxy::setDeferCommits(bool deferCommits)
@@ -415,7 +456,7 @@
         TRACE_EVENT_ASYNC_END0("cc", "ThreadProxy::setDeferCommits", this);
 
     if (!m_deferCommits && m_pendingDeferredCommit)
-        m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadProxy::beginFrame, base::Unretained(this), base::Passed(m_pendingDeferredCommit.Pass())));
+        Proxy::mainThread()->postTask(base::Bind(&ThreadProxy::beginFrame, m_mainThreadWeakPtr, base::Passed(&m_pendingDeferredCommit)));
 }
 
 bool ThreadProxy::commitRequested() const
@@ -431,6 +472,20 @@
     m_schedulerOnImplThread->setNeedsRedraw();
 }
 
+void ThreadProxy::didSwapUseIncompleteTileOnImplThread()
+{
+   DCHECK(isImplThread());
+   TRACE_EVENT0("cc", "ThreadProxy::didSwapUseIncompleteTileOnImplThread");
+   m_schedulerOnImplThread->didSwapUseIncompleteTile();
+}
+
+void ThreadProxy::didUploadVisibleHighResolutionTileOnImplThread()
+{
+   DCHECK(isImplThread());
+   TRACE_EVENT0("cc", "ThreadProxy::didUploadVisibleHighResolutionTileOnImplThread");
+   m_schedulerOnImplThread->setNeedsRedraw();
+}
+
 void ThreadProxy::mainThreadHasStoppedFlinging()
 {
     if (m_inputHandlerOnImplThread)
@@ -448,6 +503,8 @@
     Proxy::implThread()->postTask(base::Bind(&ThreadProxy::initializeImplOnImplThread, base::Unretained(this), &completion, handler.release()));
     completion.wait();
 
+    m_mainThreadWeakPtr = m_weakFactory.GetWeakPtr();
+
     m_started = true;
 }
 
@@ -462,11 +519,11 @@
         DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
 
         CompletionEvent completion;
-        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::layerTreeHostClosedOnImplThread, base::Unretained(this), &completion));
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::layerTreeHostClosedOnImplThread, m_implThreadWeakPtr, &completion));
         completion.wait();
     }
 
-    m_mainThreadProxy->shutdown(); // Stop running tasks posted to us.
+    m_weakFactory.InvalidateWeakPtrs();
 
     DCHECK(!m_layerTreeHostImpl.get()); // verify that the impl deleted.
     m_layerTreeHost = 0;
@@ -477,7 +534,7 @@
 {
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     CompletionEvent completion;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::forceSerializeOnSwapBuffersOnImplThread, base::Unretained(this), &completion));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::forceSerializeOnSwapBuffersOnImplThread, m_implThreadWeakPtr, &completion));
     completion.wait();
 }
 
@@ -517,10 +574,10 @@
     scoped_ptr<BeginFrameAndCommitState> beginFrameState(new BeginFrameAndCommitState);
     beginFrameState->monotonicFrameBeginTime = base::TimeTicks::Now();
     beginFrameState->scrollInfo = m_layerTreeHostImpl->processScrollDeltas();
-    beginFrameState->implTransform = m_layerTreeHostImpl->implTransform();
+    beginFrameState->implTransform = m_layerTreeHostImpl->activeTree()->ImplTransform();
     DCHECK_GT(m_layerTreeHostImpl->memoryAllocationLimitBytes(), 0u);
     beginFrameState->memoryAllocationLimitBytes = m_layerTreeHostImpl->memoryAllocationLimitBytes();
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadProxy::beginFrame, base::Unretained(this), base::Passed(beginFrameState.Pass())));
+    Proxy::mainThread()->postTask(base::Bind(&ThreadProxy::beginFrame, m_mainThreadWeakPtr, base::Passed(&beginFrameState)));
 
     if (m_beginFrameCompletionEventOnImplThread) {
         m_beginFrameCompletionEventOnImplThread->signal();
@@ -568,7 +625,7 @@
         m_commitRequestSentToImplThread = false;
 
         TRACE_EVENT0("cc", "EarlyOut_NotVisible");
-        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::beginFrameAbortedOnImplThread, base::Unretained(this)));
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::beginFrameAbortedOnImplThread, m_implThreadWeakPtr));
         return;
     }
 
@@ -625,7 +682,7 @@
 
         base::TimeTicks startTime = base::TimeTicks::HighResNow();
         CompletionEvent completion;
-        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::beginFrameCompleteOnImplThread, base::Unretained(this), &completion, queue.release()));
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::beginFrameCompleteOnImplThread, m_implThreadWeakPtr, &completion, queue.release()));
         completion.wait();
         base::TimeTicks endTime = base::TimeTicks::HighResNow();
 
@@ -692,39 +749,57 @@
     m_currentResourceUpdateControllerOnImplThread->finalize();
     m_currentResourceUpdateControllerOnImplThread.reset();
 
-    // If there are linked evicted backings, these backings' resources may be put into the
-    // impl tree, so we can't draw yet. Determine this before clearing all evicted backings.
-    bool newImplTreeHasNoEvictedResources = !m_layerTreeHost->contentsTextureManager()->linkedEvictedBackingsExist();
-
     m_layerTreeHostImpl->beginCommit();
     m_layerTreeHost->beginCommitOnImplThread(m_layerTreeHostImpl.get());
     m_layerTreeHost->finishCommitOnImplThread(m_layerTreeHostImpl.get());
-
-    if (newImplTreeHasNoEvictedResources) {
-        if (m_layerTreeHostImpl->contentsTexturesPurged())
-            m_layerTreeHostImpl->resetContentsTexturesPurged();
-    }
-
     m_layerTreeHostImpl->commitComplete();
 
     m_nextFrameIsNewlyCommittedFrameOnImplThread = true;
 
-    m_commitCompletionEventOnImplThread->signal();
-    m_commitCompletionEventOnImplThread = 0;
+    if (m_layerTreeHost->settings().implSidePainting && m_layerTreeHost->blocksPendingCommit())
+    {
+        // For some layer types in impl-side painting, the commit is held until
+        // the pending tree is activated.
+        TRACE_EVENT_INSTANT0("cc", "HoldCommit");
+        m_completionEventForCommitHeldOnTreeActivation = m_commitCompletionEventOnImplThread;
+        m_commitCompletionEventOnImplThread = 0;
+    }
+    else
+    {
+        m_commitCompletionEventOnImplThread->signal();
+        m_commitCompletionEventOnImplThread = 0;
+    }
 
     // SetVisible kicks off the next scheduler action, so this must be last.
     m_schedulerOnImplThread->setVisible(m_layerTreeHostImpl->visible());
 }
 
+void ThreadProxy::scheduledActionCheckForCompletedTileUploads()
+{
+    DCHECK(isImplThread());
+    TRACE_EVENT0("cc", "ThreadProxy::scheduledActionCheckForCompletedTileUploads");
+    m_layerTreeHostImpl->checkForCompletedTileUploads();
+}
+
+void ThreadProxy::scheduledActionActivatePendingTreeIfNeeded()
+{
+    DCHECK(isImplThread());
+    TRACE_EVENT0("cc", "ThreadProxy::scheduledActionActivatePendingTreeIfNeeded");
+    m_layerTreeHostImpl->activatePendingTreeIfNeeded();
+}
+
 void ThreadProxy::scheduledActionBeginContextRecreation()
 {
     DCHECK(isImplThread());
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadProxy::beginContextRecreation, base::Unretained(this)));
+    Proxy::mainThread()->postTask(base::Bind(&ThreadProxy::beginContextRecreation, m_mainThreadWeakPtr));
 }
 
 ScheduledActionDrawAndSwapResult ThreadProxy::scheduledActionDrawAndSwapInternal(bool forcedDraw)
 {
     TRACE_EVENT0("cc", "ThreadProxy::scheduledActionDrawAndSwap");
+
+    base::AutoReset<bool> markInside(&m_insideDraw, true);
+
     ScheduledActionDrawAndSwapResult result;
     result.didDraw = false;
     result.didSwap = false;
@@ -743,6 +818,8 @@
 
     if (m_inputHandlerOnImplThread.get())
         m_inputHandlerOnImplThread->animate(monotonicTime);
+
+    m_layerTreeHostImpl->activatePendingTreeIfNeeded();
     m_layerTreeHostImpl->animate(monotonicTime, wallClockTime);
 
     // This method is called on a forced draw, regardless of whether we are able to produce a frame,
@@ -762,6 +839,15 @@
     }
     m_layerTreeHostImpl->didDrawAllLayers(frame);
 
+    // Check for tree activation.
+    if (m_completionEventForCommitHeldOnTreeActivation && !m_layerTreeHostImpl->pendingTree())
+    {
+        TRACE_EVENT_INSTANT0("cc", "ReleaseCommitbyActivation");
+        DCHECK(m_layerTreeHostImpl->settings().implSidePainting);
+        m_completionEventForCommitHeldOnTreeActivation->signal();
+        m_completionEventForCommitHeldOnTreeActivation = 0;
+    }
+
     // Check for a pending compositeAndReadback.
     if (m_readbackRequestOnImplThread) {
         m_readbackRequestOnImplThread->success = false;
@@ -771,15 +857,24 @@
         }
         m_readbackRequestOnImplThread->completion.signal();
         m_readbackRequestOnImplThread = 0;
-    } else if (drawFrame)
+    } else if (drawFrame) {
         result.didSwap = m_layerTreeHostImpl->swapBuffers();
 
+        if (frame.containsIncompleteTile)
+          didSwapUseIncompleteTileOnImplThread();
+    }
+
     // Tell the main thread that the the newly-commited frame was drawn.
     if (m_nextFrameIsNewlyCommittedFrameOnImplThread) {
         m_nextFrameIsNewlyCommittedFrameOnImplThread = false;
-        m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadProxy::didCommitAndDrawFrame, base::Unretained(this)));
+        Proxy::mainThread()->postTask(base::Bind(&ThreadProxy::didCommitAndDrawFrame, m_mainThreadWeakPtr));
     }
 
+    if (drawFrame)
+        checkOutputSurfaceStatusOnImplThread();
+
+    m_layerTreeHostImpl->beginNextFrame();
+
     return result;
 }
 
@@ -798,7 +893,7 @@
     TRACE_EVENT0("cc", "ThreadProxy::acquireLayerTextures");
     DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
     CompletionEvent completion;
-    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::acquireLayerTexturesForMainThreadOnImplThread, base::Unretained(this), &completion));
+    Proxy::implThread()->postTask(base::Bind(&ThreadProxy::acquireLayerTexturesForMainThreadOnImplThread, m_implThreadWeakPtr, &completion));
     completion.wait(); // Block until it is safe to write to layer textures from the main thread.
 
     m_texturesAcquired = true;
@@ -900,13 +995,17 @@
         frameRateController.reset(new FrameRateController(DelayBasedTimeSource::create(displayRefreshInterval, Proxy::implThread())));
     else
         frameRateController.reset(new FrameRateController(Proxy::implThread()));
-    m_schedulerOnImplThread = Scheduler::create(this, frameRateController.Pass());
+    SchedulerSettings schedulerSettings;
+    schedulerSettings.implSidePainting = m_layerTreeHost->settings().implSidePainting;
+    m_schedulerOnImplThread = Scheduler::create(this, frameRateController.Pass(),
+                                                schedulerSettings);
     m_schedulerOnImplThread->setVisible(m_layerTreeHostImpl->visible());
 
     m_inputHandlerOnImplThread = scoped_ptr<InputHandler>(handler);
     if (m_inputHandlerOnImplThread.get())
         m_inputHandlerOnImplThread->bindToClient(m_layerTreeHostImpl.get());
 
+    m_implThreadWeakPtr = m_weakFactoryOnImplThread.GetWeakPtr();
     completion->signal();
 }
 
@@ -927,6 +1026,11 @@
         *capabilities = m_layerTreeHostImpl->rendererCapabilities();
         m_schedulerOnImplThread->setSwapBuffersCompleteSupported(
                 capabilities->usingSwapCompleteCallback);
+
+        int maxFramesPending = FrameRateController::kDefaultMaxFramesPending;
+        if (m_layerTreeHostImpl->outputSurface()->Capabilities().has_parent_compositor)
+            maxFramesPending = 1;
+        m_schedulerOnImplThread->setMaxFramesPending(maxFramesPending);
     }
 
     completion->signal();
@@ -940,6 +1044,7 @@
     m_inputHandlerOnImplThread.reset();
     m_layerTreeHostImpl.reset();
     m_schedulerOnImplThread.reset();
+    m_weakFactoryOnImplThread.InvalidateWeakPtrs();
     completion->signal();
 }
 
@@ -989,7 +1094,7 @@
     CommitPendingRequest commitPendingRequest;
     {
         DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
-        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::commitPendingOnImplThreadForTesting, base::Unretained(this), &commitPendingRequest));
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::commitPendingOnImplThreadForTesting, m_implThreadWeakPtr, &commitPendingRequest));
         commitPendingRequest.completion.wait();
     }
     return commitPendingRequest.commitPending;
@@ -998,8 +1103,96 @@
 void ThreadProxy::commitPendingOnImplThreadForTesting(CommitPendingRequest* request)
 {
     DCHECK(isImplThread());
-    request->commitPending = m_schedulerOnImplThread->commitPending();
+    if (m_layerTreeHostImpl->outputSurface())
+        request->commitPending = m_schedulerOnImplThread->commitPending();
+    else
+        request->commitPending = false;
     request->completion.signal();
 }
 
+skia::RefPtr<SkPicture> ThreadProxy::capturePicture()
+{
+    DCHECK(isMainThread());
+    CompletionEvent completion;
+    skia::RefPtr<SkPicture> picture;
+    {
+        DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
+        Proxy::implThread()->postTask(base::Bind(&ThreadProxy::capturePictureOnImplThread,
+                                                 m_implThreadWeakPtr,
+                                                 &completion,
+                                                 &picture));
+        completion.wait();
+    }
+    return picture;
+}
+
+void ThreadProxy::capturePictureOnImplThread(CompletionEvent* completion, skia::RefPtr<SkPicture>* picture)
+{
+    DCHECK(isImplThread());
+    *picture = m_layerTreeHostImpl->capturePicture();
+    completion->signal();
+}
+
+void ThreadProxy::renewTreePriority()
+{
+    bool smoothnessTakesPriority =
+        m_layerTreeHostImpl->pinchGestureActive() ||
+        m_layerTreeHostImpl->currentlyScrollingLayer();
+
+    // Update expiration time if smoothness currently takes priority.
+    if (smoothnessTakesPriority) {
+        m_smoothnessTakesPriorityExpirationTime = base::TimeTicks::Now() +
+            base::TimeDelta::FromMilliseconds(
+                smoothnessTakesPriorityExpirationDelay * 1000);
+    }
+
+    // We use the same priority for both trees by default.
+    TreePriority priority = SAME_PRIORITY_FOR_BOTH_TREES;
+
+    // Smoothness takes priority if expiration time is in the future.
+    if (m_smoothnessTakesPriorityExpirationTime > base::TimeTicks::Now())
+        priority = SMOOTHNESS_TAKES_PRIORITY;
+
+    // New content always takes priority when the active tree has
+    // evicted resources or there is an invalid viewport size.
+    if (m_layerTreeHostImpl->activeTree()->ContentsTexturesPurged() ||
+        m_layerTreeHostImpl->activeTree()->ViewportSizeInvalid())
+        priority = NEW_CONTENT_TAKES_PRIORITY;
+
+    m_layerTreeHostImpl->setTreePriority(priority);
+
+    // Notify the the client of this compositor via the output surface.
+    // TODO(epenner): Route this to compositor-thread instead of output-surface
+    // after GTFO refactor of compositor-thread (http://crbug/170828).
+    if (m_layerTreeHostImpl->outputSurface()) {
+        m_layerTreeHostImpl->outputSurface()->UpdateSmoothnessTakesPriority(
+            priority == SMOOTHNESS_TAKES_PRIORITY);
+    }
+
+    base::TimeDelta delay = m_smoothnessTakesPriorityExpirationTime -
+        base::TimeTicks::Now();
+
+    // Need to make sure a delayed task is posted when we have smoothness
+    // takes priority expiration time in the future.
+    if (delay <= base::TimeDelta())
+        return;
+    if (m_renewTreePriorityOnImplThreadPending)
+        return;
+
+    Proxy::implThread()->postDelayedTask(
+        base::Bind(&ThreadProxy::renewTreePriorityOnImplThread,
+                   m_weakFactoryOnImplThread.GetWeakPtr()),
+        delay.InMilliseconds());
+
+    m_renewTreePriorityOnImplThreadPending = true;
+}
+
+void ThreadProxy::renewTreePriorityOnImplThread()
+{
+    DCHECK(m_renewTreePriorityOnImplThreadPending);
+    m_renewTreePriorityOnImplThreadPending = false;
+
+    renewTreePriority();
+}
+
 }  // namespace cc
Index: src/cc/layer_unittest.cc
===================================================================
--- src/cc/layer_unittest.cc	(revision 184497)
+++ src/cc/layer_unittest.cc	(working copy)
@@ -58,7 +58,7 @@
 
 class MockLayerPainter : public LayerPainter {
 public:
-    virtual void paint(SkCanvas*, const gfx::Rect&, gfx::RectF&) OVERRIDE { }
+    virtual void paint(SkCanvas*, gfx::Rect, gfx::RectF&) OVERRIDE { }
 };
 
 
@@ -93,7 +93,7 @@
 
     void verifyTestTreeInitialState() const
     {
-        ASSERT_EQ(static_cast<size_t>(3), m_parent->children().size());
+        ASSERT_EQ(3U, m_parent->children().size());
         EXPECT_EQ(m_child1, m_parent->children()[0]);
         EXPECT_EQ(m_child2, m_parent->children()[1]);
         EXPECT_EQ(m_child3, m_parent->children()[2]);
@@ -101,17 +101,17 @@
         EXPECT_EQ(m_parent.get(), m_child2->parent());
         EXPECT_EQ(m_parent.get(), m_child3->parent());
 
-        ASSERT_EQ(static_cast<size_t>(2), m_child1->children().size());
+        ASSERT_EQ(2U, m_child1->children().size());
         EXPECT_EQ(m_grandChild1, m_child1->children()[0]);
         EXPECT_EQ(m_grandChild2, m_child1->children()[1]);
         EXPECT_EQ(m_child1.get(), m_grandChild1->parent());
         EXPECT_EQ(m_child1.get(), m_grandChild2->parent());
 
-        ASSERT_EQ(static_cast<size_t>(1), m_child2->children().size());
+        ASSERT_EQ(1U, m_child2->children().size());
         EXPECT_EQ(m_grandChild3, m_child2->children()[0]);
         EXPECT_EQ(m_child2.get(), m_grandChild3->parent());
 
-        ASSERT_EQ(static_cast<size_t>(0), m_child3->children().size());
+        ASSERT_EQ(0U, m_child3->children().size());
     }
 
     void createSimpleTestTree()
@@ -167,13 +167,13 @@
     scoped_refptr<Layer> child = Layer::create();
 
     // Upon creation, layers should not have children or parent.
-    ASSERT_EQ(static_cast<size_t>(0), parent->children().size());
+    ASSERT_EQ(0U, parent->children().size());
     EXPECT_FALSE(child->parent());
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, m_layerTreeHost->setRootLayer(parent));
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->addChild(child));
 
-    ASSERT_EQ(static_cast<size_t>(1), parent->children().size());
+    ASSERT_EQ(1U, parent->children().size());
     EXPECT_EQ(child.get(), parent->children()[0]);
     EXPECT_EQ(parent.get(), child->parent());
     EXPECT_EQ(parent.get(), child->rootLayer());
@@ -211,24 +211,24 @@
 
     parent->setLayerTreeHost(m_layerTreeHost.get());
 
-    ASSERT_EQ(static_cast<size_t>(0), parent->children().size());
+    ASSERT_EQ(0U, parent->children().size());
 
     // Case 1: inserting to empty list.
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->insertChild(child3, 0));
-    ASSERT_EQ(static_cast<size_t>(1), parent->children().size());
+    ASSERT_EQ(1U, parent->children().size());
     EXPECT_EQ(child3, parent->children()[0]);
     EXPECT_EQ(parent.get(), child3->parent());
 
     // Case 2: inserting to beginning of list
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->insertChild(child1, 0));
-    ASSERT_EQ(static_cast<size_t>(2), parent->children().size());
+    ASSERT_EQ(2U, parent->children().size());
     EXPECT_EQ(child1, parent->children()[0]);
     EXPECT_EQ(child3, parent->children()[1]);
     EXPECT_EQ(parent.get(), child1->parent());
 
     // Case 3: inserting to middle of list
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->insertChild(child2, 1));
-    ASSERT_EQ(static_cast<size_t>(3), parent->children().size());
+    ASSERT_EQ(3U, parent->children().size());
     EXPECT_EQ(child1, parent->children()[0]);
     EXPECT_EQ(child2, parent->children()[1]);
     EXPECT_EQ(child3, parent->children()[2]);
@@ -237,7 +237,7 @@
     // Case 4: inserting to end of list
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->insertChild(child4, 3));
 
-    ASSERT_EQ(static_cast<size_t>(4), parent->children().size());
+    ASSERT_EQ(4U, parent->children().size());
     EXPECT_EQ(child1, parent->children()[0]);
     EXPECT_EQ(child2, parent->children()[1]);
     EXPECT_EQ(child3, parent->children()[2]);
@@ -253,18 +253,18 @@
     scoped_refptr<Layer> child1 = Layer::create();
     scoped_refptr<Layer> child2 = Layer::create();
 
-    ASSERT_EQ(static_cast<size_t>(0), parent->children().size());
+    ASSERT_EQ(0U, parent->children().size());
 
     // insert to an out-of-bounds index
     parent->insertChild(child1, 53);
 
-    ASSERT_EQ(static_cast<size_t>(1), parent->children().size());
+    ASSERT_EQ(1U, parent->children().size());
     EXPECT_EQ(child1, parent->children()[0]);
 
     // insert another child to out-of-bounds, when list is not already empty.
     parent->insertChild(child2, 2459);
 
-    ASSERT_EQ(static_cast<size_t>(2), parent->children().size());
+    ASSERT_EQ(2U, parent->children().size());
     EXPECT_EQ(child1, parent->children()[0]);
     EXPECT_EQ(child2, parent->children()[1]);
 }
@@ -277,12 +277,12 @@
 
     parent->setLayerTreeHost(m_layerTreeHost.get());
 
-    ASSERT_EQ(static_cast<size_t>(0), parent->children().size());
+    ASSERT_EQ(0U, parent->children().size());
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->insertChild(child1, 0));
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, parent->insertChild(child2, 1));
 
-    ASSERT_EQ(static_cast<size_t>(2), parent->children().size());
+    ASSERT_EQ(2U, parent->children().size());
     EXPECT_EQ(child1, parent->children()[0]);
     EXPECT_EQ(child2, parent->children()[1]);
 
@@ -290,7 +290,7 @@
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(AtLeast(1), parent->insertChild(child1, 1));
 
     // child1 should now be at the end of the list.
-    ASSERT_EQ(static_cast<size_t>(2), parent->children().size());
+    ASSERT_EQ(2U, parent->children().size());
     EXPECT_EQ(child2, parent->children()[0]);
     EXPECT_EQ(child1, parent->children()[1]);
 
@@ -305,6 +305,11 @@
     EXPECT_FALSE(child4->parent());
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(AtLeast(1), m_parent->replaceChild(m_child2.get(), child4));
+    EXPECT_FALSE(m_parent->needsDisplayForTesting());
+    EXPECT_FALSE(m_child1->needsDisplayForTesting());
+    EXPECT_FALSE(m_child2->needsDisplayForTesting());
+    EXPECT_FALSE(m_child3->needsDisplayForTesting());
+    EXPECT_FALSE(child4->needsDisplayForTesting());
 
     ASSERT_EQ(static_cast<size_t>(3), m_parent->children().size());
     EXPECT_EQ(m_child1, m_parent->children()[0]);
@@ -315,6 +320,32 @@
     EXPECT_FALSE(m_child2->parent());
 }
 
+TEST_F(LayerTest, replaceChildWithNewChildAutomaticRasterScale)
+{
+    createSimpleTestTree();
+    scoped_refptr<Layer> child4 = Layer::create();
+    EXPECT_SET_NEEDS_COMMIT(1, m_child1->setAutomaticallyComputeRasterScale(true));
+    EXPECT_SET_NEEDS_COMMIT(1, m_child2->setAutomaticallyComputeRasterScale(true));
+    EXPECT_SET_NEEDS_COMMIT(1, m_child3->setAutomaticallyComputeRasterScale(true));
+
+    EXPECT_FALSE(child4->parent());
+
+    EXPECT_SET_NEEDS_FULL_TREE_SYNC(AtLeast(1), m_parent->replaceChild(m_child2.get(), child4));
+    EXPECT_FALSE(m_parent->needsDisplayForTesting());
+    EXPECT_FALSE(m_child1->needsDisplayForTesting());
+    EXPECT_FALSE(m_child2->needsDisplayForTesting());
+    EXPECT_FALSE(m_child3->needsDisplayForTesting());
+    EXPECT_FALSE(child4->needsDisplayForTesting());
+
+    ASSERT_EQ(3U, m_parent->children().size());
+    EXPECT_EQ(m_child1, m_parent->children()[0]);
+    EXPECT_EQ(child4, m_parent->children()[1]);
+    EXPECT_EQ(m_child3, m_parent->children()[2]);
+    EXPECT_EQ(m_parent.get(), child4->parent());
+
+    EXPECT_FALSE(m_child2->parent());
+}
+
 TEST_F(LayerTest, replaceChildWithNewChildThatHasOtherParent)
 {
     createSimpleTestTree();
@@ -323,13 +354,13 @@
     scoped_refptr<Layer> testLayer = Layer::create();
     scoped_refptr<Layer> child4 = Layer::create();
     testLayer->addChild(child4);
-    ASSERT_EQ(static_cast<size_t>(1), testLayer->children().size());
+    ASSERT_EQ(1U, testLayer->children().size());
     EXPECT_EQ(child4, testLayer->children()[0]);
     EXPECT_EQ(testLayer.get(), child4->parent());
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(AtLeast(1), m_parent->replaceChild(m_child2.get(), child4));
 
-    ASSERT_EQ(static_cast<size_t>(3), m_parent->children().size());
+    ASSERT_EQ(3U, m_parent->children().size());
     EXPECT_EQ(m_child1, m_parent->children()[0]);
     EXPECT_EQ(child4, m_parent->children()[1]);
     EXPECT_EQ(m_child3, m_parent->children()[2]);
@@ -337,7 +368,7 @@
 
     // testLayer should no longer have child4,
     // and child2 should no longer have a parent.
-    ASSERT_EQ(static_cast<size_t>(0), testLayer->children().size());
+    ASSERT_EQ(0U, testLayer->children().size());
     EXPECT_FALSE(m_child2->parent());
 }
 
@@ -359,7 +390,7 @@
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(AtLeast(3), m_parent->removeAllChildren());
 
-    ASSERT_EQ(static_cast<size_t>(0), m_parent->children().size());
+    ASSERT_EQ(0U, m_parent->children().size());
     EXPECT_FALSE(m_child1->parent());
     EXPECT_FALSE(m_child2->parent());
     EXPECT_FALSE(m_child3->parent());
@@ -379,7 +410,7 @@
 
     // Set up and verify initial test conditions: child1 has a parent, child2 has no parent.
     oldParent->addChild(child1);
-    ASSERT_EQ(static_cast<size_t>(0), newParent->children().size());
+    ASSERT_EQ(0U, newParent->children().size());
     EXPECT_EQ(oldParent.get(), child1->parent());
     EXPECT_FALSE(child2->parent());
 
@@ -387,7 +418,7 @@
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(AtLeast(1), newParent->setChildren(newChildren));
 
-    ASSERT_EQ(static_cast<size_t>(2), newParent->children().size());
+    ASSERT_EQ(2U, newParent->children().size());
     EXPECT_EQ(newParent.get(), child1->parent());
     EXPECT_EQ(newParent.get(), child2->parent());
 
@@ -466,51 +497,36 @@
     gfx::RectF outOfBoundsDirtyRect = gfx::RectF(400, 405, 500, 502);
 
     // Before anything, testLayer should not be dirty.
-    EXPECT_FALSE(testLayer->needsDisplay());
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
 
     // This is just initialization, but setNeedsCommit behavior is verified anyway to avoid warnings.
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(testBounds));
-    testLayer = Layer::create();
-    testLayer->setLayerTreeHost(m_layerTreeHost.get());
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setIsDrawable(true));
-    EXPECT_FALSE(testLayer->needsDisplay());
+    EXPECT_TRUE(testLayer->needsDisplayForTesting());
 
     // The real test begins here.
+    testLayer->resetNeedsDisplayForTesting();
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
 
-    // Case 1: needsDisplay flag should not change because of an empty dirty rect.
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setNeedsDisplayRect(emptyDirtyRect));
-    EXPECT_FALSE(testLayer->needsDisplay());
-
-    // Case 2: basic.
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setNeedsDisplayRect(dirty1));
-    EXPECT_TRUE(testLayer->needsDisplay());
-
-    // Case 3: a second dirty rect.
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setNeedsDisplayRect(dirty2));
-    EXPECT_TRUE(testLayer->needsDisplay());
-
-    // Case 4: Layer should accept dirty rects that go beyond its bounds.
-    testLayer = Layer::create();
-    testLayer->setLayerTreeHost(m_layerTreeHost.get());
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setIsDrawable(true));
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(testBounds));
+    // Case 1: Layer should accept dirty rects that go beyond its bounds.
+    testLayer->resetNeedsDisplayForTesting();
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setNeedsDisplayRect(outOfBoundsDirtyRect));
-    EXPECT_TRUE(testLayer->needsDisplay());
+    EXPECT_TRUE(testLayer->needsDisplayForTesting());
+    testLayer->resetNeedsDisplayForTesting();
 
-    // Case 5: setNeedsDisplay() without the dirty rect arg.
-    testLayer = Layer::create();
-    testLayer->setLayerTreeHost(m_layerTreeHost.get());
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setIsDrawable(true));
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(testBounds));
+    // Case 2: setNeedsDisplay() without the dirty rect arg.
+    testLayer->resetNeedsDisplayForTesting();
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setNeedsDisplay());
-    EXPECT_TRUE(testLayer->needsDisplay());
+    EXPECT_TRUE(testLayer->needsDisplayForTesting());
+    testLayer->resetNeedsDisplayForTesting();
 
-    // Case 6: setNeedsDisplay() with a non-drawable layer
-    testLayer = Layer::create();
-    testLayer->setLayerTreeHost(m_layerTreeHost.get());
-    EXPECT_SET_NEEDS_COMMIT(0, testLayer->setBounds(testBounds));
+    // Case 3: setNeedsDisplay() with a non-drawable layer
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setIsDrawable(false));
+    testLayer->resetNeedsDisplayForTesting();
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
     EXPECT_SET_NEEDS_COMMIT(0, testLayer->setNeedsDisplayRect(dirty1));
-    EXPECT_TRUE(testLayer->needsDisplay());
+    EXPECT_TRUE(testLayer->needsDisplayForTesting());
 }
 
 TEST_F(LayerTest, checkPropertyChangeCausesCorrectBehavior)
@@ -522,7 +538,7 @@
     scoped_refptr<Layer> dummyLayer = Layer::create(); // just a dummy layer for this test case.
 
     // sanity check of initial test condition
-    EXPECT_FALSE(testLayer->needsDisplay());
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
 
     // Next, test properties that should call setNeedsCommit (but not setNeedsDisplay)
     // All properties need to be set to new values in order for setNeedsCommit to be called.
@@ -533,12 +549,13 @@
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setOpacity(0.5));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setContentsOpaque(true));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setPosition(gfx::PointF(4, 9)));
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setSublayerTransform(MathUtil::createGfxTransform(0, 0, 0, 0, 0, 0)));
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setSublayerTransform(gfx::Transform(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setScrollable(true));
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setScrollOffset(gfx::Vector2d(10, 10)));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setShouldScrollOnMainThread(true));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setNonFastScrollableRegion(gfx::Rect(1, 1, 2, 2)));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setHaveWheelEventHandlers(true));
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setTransform(MathUtil::createGfxTransform(0, 0, 0, 0, 0, 0)));
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setTransform(gfx::Transform(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setDoubleSided(false));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setDebugName("Test Layer"));
     EXPECT_SET_NEEDS_COMMIT(1, testLayer->setDrawCheckerboardForMissingTiles(!testLayer->drawCheckerboardForMissingTiles()));
@@ -546,14 +563,29 @@
 
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, testLayer->setMaskLayer(dummyLayer.get()));
     EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, testLayer->setReplicaLayer(dummyLayer.get()));
-    EXPECT_SET_NEEDS_FULL_TREE_SYNC(1, testLayer->setScrollOffset(gfx::Vector2d(10, 10)));
 
     // The above tests should not have caused a change to the needsDisplay flag.
-    EXPECT_FALSE(testLayer->needsDisplay());
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
+}
 
-    // Test properties that should call setNeedsDisplay and setNeedsCommit
-    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(gfx::Size(5, 10)));
-    EXPECT_TRUE(testLayer->needsDisplay());
+TEST_F(LayerTest, setBoundsTriggersSetNeedsRedrawAfterGettingNonEmptyBounds)
+{
+    scoped_refptr<Layer> testLayer = Layer::create();
+    testLayer->setLayerTreeHost(m_layerTreeHost.get());
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setIsDrawable(true));
+
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(gfx::Size(0, 10)));
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(gfx::Size(10, 10)));
+    EXPECT_TRUE(testLayer->needsDisplayForTesting());
+
+    testLayer->resetNeedsDisplayForTesting();
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
+
+    // Calling setBounds only invalidates on the first time.
+    EXPECT_SET_NEEDS_COMMIT(1, testLayer->setBounds(gfx::Size(7, 10)));
+    EXPECT_FALSE(testLayer->needsDisplayForTesting());
 }
 
 TEST_F(LayerTest, verifyPushPropertiesAccumulatesUpdateRect)
@@ -807,7 +839,7 @@
     scoped_ptr<KeyframedFloatAnimationCurve> curve(KeyframedFloatAnimationCurve::create());
     curve->addKeyframe(FloatKeyframe::create(0, 0.3f, scoped_ptr<TimingFunction>()));
     curve->addKeyframe(FloatKeyframe::create(1, 0.7f, scoped_ptr<TimingFunction>()));
-    scoped_ptr<ActiveAnimation> animation(ActiveAnimation::create(curve.PassAs<AnimationCurve>(), 0, 0, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> animation(Animation::create(curve.PassAs<AnimationCurve>(), 0, 0, Animation::Opacity));
 
     return layer->addAnimation(animation.Pass());
 }
@@ -839,25 +871,5 @@
     EXPECT_TRUE(addTestAnimation(layer.get()));
 }
 
-class MockLayer : public Layer {
-public:
-    bool needsDisplay() const { return m_needsDisplay; }
-
-private:
-    virtual ~MockLayer()
-    {
-    }
-};
-
-TEST(LayerTestWithoutFixture, setBoundsTriggersSetNeedsRedrawAfterGettingNonEmptyBounds)
-{
-    scoped_refptr<MockLayer> layer(new MockLayer);
-    EXPECT_FALSE(layer->needsDisplay());
-    layer->setBounds(gfx::Size(0, 10));
-    EXPECT_FALSE(layer->needsDisplay());
-    layer->setBounds(gfx::Size(10, 10));
-    EXPECT_TRUE(layer->needsDisplay());
-}
-
 }  // namespace
 }  // namespace cc
Index: src/cc/render_surface_filters_unittest.cc
===================================================================
--- src/cc/render_surface_filters_unittest.cc	(revision 184497)
+++ src/cc/render_surface_filters_unittest.cc	(working copy)
@@ -4,10 +4,9 @@
 
 #include "cc/render_surface_filters.h"
 
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include <public/WebFilterOperation.h>
-#include <public/WebFilterOperations.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperation.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 
 using namespace WebKit;
 
Index: src/cc/overdraw_metrics.cc
===================================================================
--- src/cc/overdraw_metrics.cc	(revision 184497)
+++ src/cc/overdraw_metrics.cc	(working copy)
@@ -144,23 +144,57 @@
 
     switch (metricsType) {
     case DrawingToScreen: {
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.pixelCountOpaque_Draw", static_cast<int>(normalization * m_pixelsDrawnOpaque), 100, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.pixelCountTranslucent_Draw", static_cast<int>(normalization * m_pixelsDrawnTranslucent), 100, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.pixelCountCulled_Draw", static_cast<int>(normalization * m_pixelsCulledForDrawing), 100, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.pixelCountOpaque_Draw",
+            static_cast<int>(normalization * m_pixelsDrawnOpaque),
+            100, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.pixelCountTranslucent_Draw",
+            static_cast<int>(normalization * m_pixelsDrawnTranslucent),
+            100, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.pixelCountCulled_Draw",
+            static_cast<int>(normalization * m_pixelsCulledForDrawing),
+            100, 1000000, 50);
 
         TRACE_COUNTER_ID1("cc", "DrawPixelsCulled", layerTreeHost, m_pixelsCulledForDrawing);
         TRACE_EVENT2("cc", "OverdrawMetrics", "PixelsDrawnOpaque", m_pixelsDrawnOpaque, "PixelsDrawnTranslucent", m_pixelsDrawnTranslucent);
         break;
     }
     case UpdateAndCommit: {
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.pixelCountPainted", static_cast<int>(normalization * m_pixelsPainted), 100, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.pixelCountOpaque_Upload", static_cast<int>(normalization * m_pixelsUploadedOpaque), 100, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.pixelCountTranslucent_Upload", static_cast<int>(normalization * m_pixelsUploadedTranslucent), 100, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.tileCountCulled_Upload", static_cast<int>(tileNormalization * m_tilesCulledForUpload), 100, 10000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.renderSurfaceTextureBytes_ViewportScaled", static_cast<int>(byteNormalization * m_renderSurfaceTextureUseBytes), 10, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.renderSurfaceTextureBytes_Unscaled", static_cast<int>(m_renderSurfaceTextureUseBytes / 1000), 1000, 100000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.contentsTextureBytes_ViewportScaled", static_cast<int>(byteNormalization * m_contentsTextureUseBytes), 10, 1000000, 50);
-        HISTOGRAM_CUSTOM_COUNTS("Renderer4.contentsTextureBytes_Unscaled", static_cast<int>(m_contentsTextureUseBytes / 1000), 1000, 100000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.pixelCountPainted",
+            static_cast<int>(normalization * m_pixelsPainted),
+            100, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.pixelCountOpaque_Upload",
+            static_cast<int>(normalization * m_pixelsUploadedOpaque),
+            100, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.pixelCountTranslucent_Upload",
+            static_cast<int>(normalization * m_pixelsUploadedTranslucent),
+            100, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.tileCountCulled_Upload",
+            static_cast<int>(tileNormalization * m_tilesCulledForUpload),
+            100, 10000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.renderSurfaceTextureBytes_ViewportScaled",
+            static_cast<int>(
+                byteNormalization * m_renderSurfaceTextureUseBytes),
+            10, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.renderSurfaceTextureBytes_Unscaled",
+            static_cast<int>(m_renderSurfaceTextureUseBytes / 1000),
+            1000, 100000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.contentsTextureBytes_ViewportScaled",
+            static_cast<int>(byteNormalization * m_contentsTextureUseBytes),
+            10, 1000000, 50);
+        UMA_HISTOGRAM_CUSTOM_COUNTS(
+            "Renderer4.contentsTextureBytes_Unscaled",
+            static_cast<int>(m_contentsTextureUseBytes / 1000),
+            1000, 100000000, 50);
 
         {
             TRACE_COUNTER_ID1("cc", "UploadTilesCulled", layerTreeHost, m_tilesCulledForUpload);
Index: src/cc/scrollbar_layer.h
===================================================================
--- src/cc/scrollbar_layer.h	(revision 184497)
+++ src/cc/scrollbar_layer.h	(working copy)
@@ -6,15 +6,15 @@
 #ifndef CC_SCROLLBAR_LAYER_H_
 #define CC_SCROLLBAR_LAYER_H_
 
-#include "cc/caching_bitmap_content_layer_updater.h"
 #include "cc/cc_export.h"
 #include "cc/contents_scaling_layer.h"
-#include <public/WebScrollbar.h>
-#include <public/WebScrollbarThemeGeometry.h>
-#include <public/WebScrollbarThemePainter.h>
+#include "cc/layer_updater.h"
+#include "cc/scrollbar_theme_painter.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbar.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbarThemeGeometry.h"
 
 namespace cc {
-
+class CachingBitmapContentLayerUpdater;
 class ResourceUpdateQueue;
 class Scrollbar;
 class ScrollbarThemeComposite;
@@ -23,11 +23,17 @@
 public:
     virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
 
-    static scoped_refptr<ScrollbarLayer> create(scoped_ptr<WebKit::WebScrollbar>, WebKit::WebScrollbarThemePainter, scoped_ptr<WebKit::WebScrollbarThemeGeometry>, int scrollLayerId);
+    static scoped_refptr<ScrollbarLayer> create(
+        scoped_ptr<WebKit::WebScrollbar>,
+        scoped_ptr<ScrollbarThemePainter>,
+        scoped_ptr<WebKit::WebScrollbarThemeGeometry>,
+        int scrollLayerId);
 
     int scrollLayerId() const { return m_scrollLayerId; }
     void setScrollLayerId(int id);
 
+    WebKit::WebScrollbar::Orientation orientation() const;
+
     // Layer interface
     virtual void setTexturePriorities(const PriorityCalculator&) OVERRIDE;
     virtual void update(ResourceUpdateQueue&, const OcclusionTracker*, RenderingStats&) OVERRIDE;
@@ -35,6 +41,7 @@
     virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
     virtual void calculateContentsScale(
         float idealContentsScale,
+        bool animatingTransformToScreen,
         float* contentsScaleX,
         float* contentsScaleY,
         gfx::Size* contentBounds) OVERRIDE;
@@ -42,7 +49,11 @@
     virtual ScrollbarLayer* toScrollbarLayer() OVERRIDE;
 
 protected:
-    ScrollbarLayer(scoped_ptr<WebKit::WebScrollbar>, WebKit::WebScrollbarThemePainter, scoped_ptr<WebKit::WebScrollbarThemeGeometry>, int scrollLayerId);
+    ScrollbarLayer(
+        scoped_ptr<WebKit::WebScrollbar>,
+        scoped_ptr<ScrollbarThemePainter>,
+        scoped_ptr<WebKit::WebScrollbarThemeGeometry>,
+        int scrollLayerId);
     virtual ~ScrollbarLayer();
 
 private:
@@ -50,16 +61,21 @@
     void createUpdaterIfNeeded();
     gfx::Rect scrollbarLayerRectToContentRect(const gfx::Rect& layerRect) const;
 
+    bool isDirty() const { return !m_dirtyRect.IsEmpty(); }
+
     int maxTextureSize();
     float clampScaleToMaxTextureSize(float scale);
 
     scoped_ptr<WebKit::WebScrollbar> m_scrollbar;
-    WebKit::WebScrollbarThemePainter m_painter;
+    scoped_ptr<ScrollbarThemePainter> m_painter;
     scoped_ptr<WebKit::WebScrollbarThemeGeometry> m_geometry;
+    gfx::Size m_thumbSize;
     int m_scrollLayerId;
 
-    GLenum m_textureFormat;
+    unsigned m_textureFormat;
 
+    gfx::RectF m_dirtyRect;
+
     scoped_refptr<CachingBitmapContentLayerUpdater> m_backTrackUpdater;
     scoped_refptr<CachingBitmapContentLayerUpdater> m_foreTrackUpdater;
     scoped_refptr<CachingBitmapContentLayerUpdater> m_thumbUpdater;
Index: src/cc/cc_tests.gyp
===================================================================
--- src/cc/cc_tests.gyp	(revision 184497)
+++ src/cc/cc_tests.gyp	(working copy)
@@ -6,12 +6,13 @@
   'variables': {
     'chromium_code': 0,
     'cc_unit_tests_source_files': [
-      'active_animation_unittest.cc',
+      'animation_unittest.cc',
       'content_layer_unittest.cc',
       'contents_scaling_layer_unittest.cc',
       'damage_tracker_unittest.cc',
       'delay_based_time_source_unittest.cc',
       'delegated_renderer_layer_impl_unittest.cc',
+      'delegating_renderer_unittest.cc',
       'draw_quad_unittest.cc',
       'float_quad_unittest.cc',
       'frame_rate_controller_unittest.cc',
@@ -28,11 +29,16 @@
       'layer_tree_host_common_unittest.cc',
       'layer_tree_host_impl_unittest.cc',
       'layer_tree_host_unittest.cc',
+      'layer_tree_host_unittest_animation.cc',
+      'layer_tree_host_unittest_context.cc',
+      'layer_tree_host_unittest_occlusion.cc',
+      'layer_tree_host_unittest_scroll.cc',
       'layer_unittest.cc',
       'math_util_unittest.cc',
       'nine_patch_layer_impl_unittest.cc',
       'nine_patch_layer_unittest.cc',
       'occlusion_tracker_unittest.cc',
+      'picture_layer_impl_unittest.cc',
       'picture_layer_tiling_set_unittest.cc',
       'picture_layer_tiling_unittest.cc',
       'prioritized_resource_unittest.cc',
@@ -56,17 +62,23 @@
       'tile_priority_unittest.cc',
       'tiled_layer_impl_unittest.cc',
       'tiled_layer_unittest.cc',
+      'tiling_data_unittest.cc',
+      'top_controls_manager_unittest.cc',
+      'transform_operations_unittest.cc',
       'tree_synchronizer_unittest.cc',
       'timing_function_unittest.cc',
       'test/fake_web_graphics_context_3d_unittest.cc',
+      'vsync_time_source_unittest.cc',
     ],
     'cc_tests_support_files': [
       'test/animation_test_common.cc',
       'test/animation_test_common.h',
-      'test/compositor_fake_web_graphics_context_3d.cc',
-      'test/compositor_fake_web_graphics_context_3d.h',
+      'test/fake_content_layer.cc',
+      'test/fake_content_layer.h',
       'test/fake_content_layer_client.cc',
       'test/fake_content_layer_client.h',
+      'test/fake_content_layer_impl.cc',
+      'test/fake_content_layer_impl.h',
       'test/fake_impl_proxy.h',
       'test/fake_output_surface.h',
       'test/fake_layer_tree_host_client.cc',
@@ -79,13 +91,21 @@
       'test/fake_picture_layer_tiling_client.h',
       'test/fake_proxy.cc',
       'test/fake_proxy.h',
+      'test/fake_scrollbar_layer.cc',
+      'test/fake_scrollbar_layer.h',
+      'test/fake_scrollbar_theme_painter.h',
+      'test/fake_scrollbar_theme_painter.cc',
       'test/fake_tile_manager_client.h',
       'test/fake_output_surface.cc',
       'test/fake_output_surface.h',
       'test/fake_software_output_device.cc',
       'test/fake_software_output_device.h',
+      'test/fake_video_frame_provider.cc',
+      'test/fake_video_frame_provider.h',
       'test/fake_web_graphics_context_3d.cc',
       'test/fake_web_graphics_context_3d.h',
+      'test/fake_web_scrollbar.cc',
+      'test/fake_web_scrollbar.h',
       'test/fake_web_scrollbar_theme_geometry.cc',
       'test/fake_web_scrollbar_theme_geometry.h',
       'test/geometry_test_utils.cc',
@@ -192,6 +212,7 @@
         '../third_party/WebKit/Source/WebKit/chromium/WebKit.gyp:webkit',
         '../third_party/mesa/mesa.gyp:osmesa',
         '../ui/gl/gl.gyp:gl',
+        '../ui/ui.gyp:ui',
       ],
       'sources': [
         '<@(cc_tests_support_files)',
Index: src/cc/page_scale_animation.cc
===================================================================
--- src/cc/page_scale_animation.cc	(revision 184497)
+++ src/cc/page_scale_animation.cc	(working copy)
@@ -87,6 +87,11 @@
     // We will interpolate between the two anchors during the animation.
     inferTargetScrollOffsetFromStartAnchor();
     clampTargetScrollOffset();
+
+    if (m_startPageScaleFactor == m_targetPageScaleFactor) {
+        m_targetAnchor = m_startAnchor;
+        return;
+    }
     inferTargetAnchorFromScrollOffsets();
 }
 
Index: src/cc/video_layer_impl.cc
===================================================================
--- src/cc/video_layer_impl.cc	(revision 184497)
+++ src/cc/video_layer_impl.cc	(working copy)
@@ -13,6 +13,7 @@
 #include "cc/resource_provider.h"
 #include "cc/stream_video_draw_quad.h"
 #include "cc/texture_draw_quad.h"
+#include "cc/video_frame_provider_client_impl.h"
 #include "cc/yuv_video_draw_quad.h"
 #include "media/filters/skcanvas_video_renderer.h"
 #include "third_party/khronos/GLES2/gl2.h"
@@ -20,37 +21,36 @@
 
 namespace cc {
 
-VideoLayerImpl::VideoLayerImpl(LayerTreeImpl* treeImpl, int id, WebKit::WebVideoFrameProvider* provider,
-                               const FrameUnwrapper& unwrapper)
+// static
+scoped_ptr<VideoLayerImpl> VideoLayerImpl::create(LayerTreeImpl* treeImpl, int id, VideoFrameProvider* provider)
+{
+    scoped_ptr<VideoLayerImpl> layer(new VideoLayerImpl(treeImpl, id));
+    layer->setProviderClientImpl(VideoFrameProviderClientImpl::Create(provider));
+    DCHECK(treeImpl->proxy()->isImplThread());
+    DCHECK(treeImpl->proxy()->isMainThreadBlocked());
+    return layer.Pass();
+}
+
+VideoLayerImpl::VideoLayerImpl(LayerTreeImpl* treeImpl, int id)
     : LayerImpl(treeImpl, id)
-    , m_provider(provider)
-    , m_unwrapper(unwrapper)
-    , m_webFrame(0)
     , m_frame(0)
     , m_format(GL_INVALID_VALUE)
     , m_convertYUV(false)
     , m_externalTextureResource(0)
 {
-    // This matrix is the default transformation for stream textures, and flips on the Y axis.
-    m_streamTextureMatrix = MathUtil::createGfxTransform(
-        1, 0, 0, 0,
-        0, -1, 0, 0,
-        0, 0, 1, 0,
-        0, 1, 0, 1);
-
-    // This only happens during a commit on the compositor thread while the main
-    // thread is blocked. That makes this a thread-safe call to set the video
-    // frame provider client that does not require a lock. The same is true of
-    // the call in the destructor.
-    m_provider->setVideoFrameProviderClient(this);
 }
 
 VideoLayerImpl::~VideoLayerImpl()
 {
-    // See comment in constructor for why this doesn't need a lock.
-    if (m_provider) {
-        m_provider->setVideoFrameProviderClient(0);
-        m_provider = 0;
+    if (!m_providerClientImpl->Stopped()) {
+        // In impl side painting, we may have a pending and active layer
+        // associated with the video provider at the same time. Both have a ref
+        // on the VideoFrameProviderClientImpl, but we stop when the first
+        // LayerImpl (the one on the pending tree) is destroyed since we know
+        // the main thread is blocked for this commit.
+        DCHECK(layerTreeImpl()->proxy()->isImplThread());
+        DCHECK(layerTreeImpl()->proxy()->isMainThreadBlocked());
+        m_providerClientImpl->Stop();
     }
     freePlaneData(layerTreeImpl()->resource_provider());
 
@@ -61,15 +61,24 @@
 #endif
 }
 
-void VideoLayerImpl::stopUsingProvider()
+scoped_ptr<LayerImpl> VideoLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
 {
-    // Block the provider from shutting down until this client is done
-    // using the frame.
-    base::AutoLock locker(m_providerLock);
-    DCHECK(!m_frame);
-    m_provider = 0;
+    return scoped_ptr<LayerImpl>(new VideoLayerImpl(treeImpl, id()));
 }
 
+void VideoLayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    LayerImpl::pushPropertiesTo(layer);
+
+    VideoLayerImpl* other = static_cast<VideoLayerImpl*>(layer);
+    other->setProviderClientImpl(m_providerClientImpl);
+}
+
+void VideoLayerImpl::didBecomeActive()
+{
+    m_providerClientImpl->set_active_video_layer(this);
+}
+
 // Convert media::VideoFrame::Format to OpenGL enum values.
 static GLenum convertVFCFormatToGLenum(const media::VideoFrame& frame)
 {
@@ -118,6 +127,7 @@
 {
     LayerImpl::willDraw(resourceProvider);
 
+
     // Explicitly acquire and release the provider mutex so it can be held from
     // willDraw to didDraw. Since the compositor thread is in the middle of
     // drawing, the layer will not be destroyed before didDraw is called.
@@ -125,27 +135,19 @@
     // is the GPU process locking it. As the GPU process can't cause the
     // destruction of the provider (calling stopUsingProvider), holding this
     // lock should not cause a deadlock.
-    m_providerLock.Acquire();
+    m_frame = m_providerClientImpl->AcquireLockAndCurrentFrame();
 
     willDrawInternal(resourceProvider);
     freeUnusedPlaneData(resourceProvider);
 
     if (!m_frame)
-        m_providerLock.Release();
+        m_providerClientImpl->ReleaseLock();
 }
 
 void VideoLayerImpl::willDrawInternal(ResourceProvider* resourceProvider)
 {
     DCHECK(!m_externalTextureResource);
 
-    if (!m_provider) {
-        m_frame = 0;
-        return;
-    }
-
-    m_webFrame = m_provider->getCurrentFrame();
-    m_frame = m_unwrapper.Run(m_webFrame);
-
     if (!m_frame)
         return;
 
@@ -158,7 +160,7 @@
     DCHECK_EQ(m_frame->visible_rect().y(), 0);
 
     if (m_format == GL_INVALID_VALUE) {
-        m_provider->putCurrentFrame(m_webFrame);
+        m_providerClientImpl->PutCurrentFrame(m_frame);
         m_frame = 0;
         return;
     }
@@ -175,13 +177,13 @@
         m_format = GL_RGBA;
 
     if (!allocatePlaneData(resourceProvider)) {
-        m_provider->putCurrentFrame(m_webFrame);
+        m_providerClientImpl->PutCurrentFrame(m_frame);
         m_frame = 0;
         return;
     }
 
     if (!copyPlaneData(resourceProvider)) {
-        m_provider->putCurrentFrame(m_webFrame);
+        m_providerClientImpl->PutCurrentFrame(m_frame);
         m_frame = 0;
         return;
     }
@@ -228,22 +230,24 @@
         // RGBA software decoder.
         const FramePlane& plane = m_framePlanes[media::VideoFrame::kRGBPlane];
         bool premultipliedAlpha = true;
-        gfx::RectF uvRect(0, 0, texWidthScale, texHeightScale);
+        gfx::PointF uvTopLeft(0.f, 0.f);
+        gfx::PointF uvBottomRight(texWidthScale, texHeightScale);
         const float opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
         bool flipped = false;
         scoped_ptr<TextureDrawQuad> textureQuad = TextureDrawQuad::Create();
-        textureQuad->SetNew(sharedQuadState, quadRect, opaqueRect, plane.resourceId, premultipliedAlpha, uvRect, opacity, flipped);
+        textureQuad->SetNew(sharedQuadState, quadRect, opaqueRect, plane.resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, opacity, flipped);
         quadSink.append(textureQuad.PassAs<DrawQuad>(), appendQuadsData);
         break;
     }
     case GL_TEXTURE_2D: {
         // NativeTexture hardware decoder.
         bool premultipliedAlpha = true;
-        gfx::RectF uvRect(0, 0, texWidthScale, texHeightScale);
+        gfx::PointF uvTopLeft(0.f, 0.f);
+        gfx::PointF uvBottomRight(texWidthScale, texHeightScale);
         const float opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
         bool flipped = false;
         scoped_ptr<TextureDrawQuad> textureQuad = TextureDrawQuad::Create();
-        textureQuad->SetNew(sharedQuadState, quadRect, opaqueRect, m_externalTextureResource, premultipliedAlpha, uvRect, opacity, flipped);
+        textureQuad->SetNew(sharedQuadState, quadRect, opaqueRect, m_externalTextureResource, premultipliedAlpha, uvTopLeft, uvBottomRight, opacity, flipped);
         quadSink.append(textureQuad.PassAs<DrawQuad>(), appendQuadsData);
         break;
     }
@@ -256,7 +260,7 @@
     }
     case GL_TEXTURE_EXTERNAL_OES: {
         // StreamTexture hardware decoder.
-        gfx::Transform transform(m_streamTextureMatrix);
+        gfx::Transform transform(m_providerClientImpl->stream_texture_matrix());
         transform.Scale(texWidthScale, texHeightScale);
         scoped_ptr<StreamVideoDrawQuad> streamVideoQuad = StreamVideoDrawQuad::Create();
         streamVideoQuad->SetNew(sharedQuadState, quadRect, opaqueRect, m_frame->texture_id(), transform);
@@ -286,10 +290,10 @@
         m_externalTextureResource = 0;
     }
 
-    m_provider->putCurrentFrame(m_webFrame);
+    m_providerClientImpl->PutCurrentFrame(m_frame);
     m_frame = 0;
 
-    m_providerLock.Release();
+    m_providerClientImpl->ReleaseLock();
 }
 
 static gfx::Size videoFrameDimension(media::VideoFrame* frame, int plane) {
@@ -398,21 +402,6 @@
         m_framePlanes[i].freeData(resourceProvider);
 }
 
-void VideoLayerImpl::didReceiveFrame()
-{
-    setNeedsRedraw();
-}
-
-void VideoLayerImpl::didUpdateMatrix(const float matrix[16])
-{
-    m_streamTextureMatrix = MathUtil::createGfxTransform(
-        matrix[0], matrix[1], matrix[2], matrix[3],
-        matrix[4], matrix[5], matrix[6], matrix[7],
-        matrix[8], matrix[9], matrix[10], matrix[11],
-        matrix[12], matrix[13], matrix[14], matrix[15]);
-    setNeedsRedraw();
-}
-
 void VideoLayerImpl::didLoseOutputSurface()
 {
     freePlaneData(layerTreeImpl()->resource_provider());
@@ -423,6 +412,11 @@
     layerTreeImpl()->SetNeedsRedraw();
 }
 
+void VideoLayerImpl::setProviderClientImpl(scoped_refptr<VideoFrameProviderClientImpl> providerClientImpl)
+{
+    m_providerClientImpl = providerClientImpl;
+}
+
 const char* VideoLayerImpl::layerTypeAsString() const
 {
     return "VideoLayer";
Index: src/cc/animation_curve.h
===================================================================
--- src/cc/animation_curve.h	(revision 184497)
+++ src/cc/animation_curve.h	(working copy)
@@ -5,10 +5,9 @@
 #ifndef CC_ANIMATION_CURVE_H_
 #define CC_ANIMATION_CURVE_H_
 
-#include <public/WebTransformationMatrix.h>
-
 #include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
+#include "ui/gfx/transform.h"
 
 namespace cc {
 
@@ -46,7 +45,7 @@
 public:
     virtual ~TransformAnimationCurve() { }
 
-    virtual WebKit::WebTransformationMatrix getValue(double t) const = 0;
+    virtual gfx::Transform getValue(double t) const = 0;
 
     // Partial Animation implementation.
     virtual Type type() const OVERRIDE;
Index: src/cc/texture_draw_quad.cc
===================================================================
--- src/cc/texture_draw_quad.cc	(revision 184497)
+++ src/cc/texture_draw_quad.cc	(working copy)
@@ -5,6 +5,7 @@
 #include "cc/texture_draw_quad.h"
 
 #include "base/logging.h"
+#include "ui/gfx/vector2d_f.h"
 
 namespace cc {
 
@@ -12,6 +13,10 @@
     : resource_id(0),
       premultiplied_alpha(false),
       flipped(false) {
+  this->vertex_opacity[0] = 0.f;
+  this->vertex_opacity[1] = 0.f;
+  this->vertex_opacity[2] = 0.f;
+  this->vertex_opacity[3] = 0.f;
 }
 
 scoped_ptr<TextureDrawQuad> TextureDrawQuad::Create() {
@@ -21,7 +26,8 @@
 void TextureDrawQuad::SetNew(const SharedQuadState* shared_quad_state,
                              gfx::Rect rect, gfx::Rect opaque_rect,
                              unsigned resource_id, bool premultiplied_alpha,
-                             const gfx::RectF& uv_rect,
+                             gfx::PointF uv_top_left,
+                             gfx::PointF uv_bottom_right,
                              const float vertex_opacity[4], bool flipped) {
   gfx::Rect visible_rect = rect;
   bool needs_blending = vertex_opacity[0] != 1.0f || vertex_opacity[1] != 1.0f
@@ -30,7 +36,8 @@
                    opaque_rect, visible_rect, needs_blending);
   this->resource_id = resource_id;
   this->premultiplied_alpha = premultiplied_alpha;
-  this->uv_rect = uv_rect;
+  this->uv_top_left = uv_top_left;
+  this->uv_bottom_right = uv_bottom_right;
   this->vertex_opacity[0] = vertex_opacity[0];
   this->vertex_opacity[1] = vertex_opacity[1];
   this->vertex_opacity[2] = vertex_opacity[2];
@@ -42,13 +49,15 @@
                              gfx::Rect rect, gfx::Rect opaque_rect,
                              gfx::Rect visible_rect, bool needs_blending,
                              unsigned resource_id, bool premultiplied_alpha,
-                             const gfx::RectF& uv_rect,
+                             gfx::PointF uv_top_left,
+                             gfx::PointF uv_bottom_right,
                              const float vertex_opacity[4], bool flipped) {
   DrawQuad::SetAll(shared_quad_state, DrawQuad::TEXTURE_CONTENT, rect,
                    opaque_rect, visible_rect, needs_blending);
   this->resource_id = resource_id;
   this->premultiplied_alpha = premultiplied_alpha;
-  this->uv_rect = uv_rect;
+  this->uv_top_left = uv_top_left;
+  this->uv_bottom_right = uv_bottom_right;
   this->vertex_opacity[0] = vertex_opacity[0];
   this->vertex_opacity[1] = vertex_opacity[1];
   this->vertex_opacity[2] = vertex_opacity[2];
@@ -56,6 +65,11 @@
   this->flipped = flipped;
 }
 
+void TextureDrawQuad::AppendResources(
+    ResourceProvider::ResourceIdArray* resources) {
+  resources->push_back(resource_id);
+}
+
 const TextureDrawQuad* TextureDrawQuad::MaterialCast(const DrawQuad* quad) {
   DCHECK(quad->material == DrawQuad::TEXTURE_CONTENT);
   return static_cast<const TextureDrawQuad*>(quad);
@@ -64,18 +78,17 @@
 bool TextureDrawQuad::PerformClipping() {
   // This only occurs if the rect is only scaled and translated (and thus still
   // axis aligned).
-  if (!quadTransform().IsScaleOrTranslation())
+  if (!quadTransform().IsPositiveScaleOrTranslation())
     return false;
 
   // Grab our scale and make sure it's positive.
-  float x_scale = quadTransform().matrix().getDouble(0, 0);
-  float y_scale = quadTransform().matrix().getDouble(1, 1);
-  if (x_scale <= 0.0f || y_scale <= 0.0f)
-    return false;
+  float x_scale = static_cast<float>(quadTransform().matrix().getDouble(0, 0));
+  float y_scale = static_cast<float>(quadTransform().matrix().getDouble(1, 1));
 
   // Grab our offset.
-  gfx::Vector2dF offset(quadTransform().matrix().getDouble(0, 3),
-                        quadTransform().matrix().getDouble(1, 3));
+  gfx::Vector2dF offset(
+      static_cast<float>(quadTransform().matrix().getDouble(0, 3)),
+      static_cast<float>(quadTransform().matrix().getDouble(1, 3)));
 
   // Transform the rect by the scale and offset.
   gfx::RectF rectF = rect;
@@ -86,18 +99,24 @@
   gfx::RectF clippedRect = IntersectRects(rectF, clipRect());
   if (clippedRect.IsEmpty()) {
     rect = gfx::Rect();
-    uv_rect = gfx::RectF();
+    uv_top_left = gfx::PointF();
+    uv_bottom_right = gfx::PointF();
     return true;
   }
 
   // Create a new uv-rect by clipping the old one to the new bounds.
-  uv_rect = gfx::RectF(
-      uv_rect.x()
-          + uv_rect.width() / rectF.width() * (clippedRect.x() - rectF.x()),
-      uv_rect.y()
-          + uv_rect.height() / rectF.height() * (clippedRect.y() - rectF.y()),
-      uv_rect.width() / rectF.width() * clippedRect.width(),
-      uv_rect.height() / rectF.height() * clippedRect.height());
+  gfx::Vector2dF uv_scale(uv_bottom_right - uv_top_left);
+  uv_scale.Scale(1.f / rectF.width(), 1.f / rectF.height());
+  uv_bottom_right = uv_top_left +
+      gfx::ScaleVector2d(
+          clippedRect.bottom_right() - rectF.origin(),
+          uv_scale.x(),
+          uv_scale.y());
+  uv_top_left = uv_top_left +
+      gfx::ScaleVector2d(
+          clippedRect.origin() - rectF.origin(),
+          uv_scale.x(),
+          uv_scale.y());
 
   // Indexing according to the quad vertex generation:
   // 1--2
Index: src/cc/texture_draw_quad.h
===================================================================
--- src/cc/texture_draw_quad.h	(revision 184497)
+++ src/cc/texture_draw_quad.h	(working copy)
@@ -21,7 +21,8 @@
               gfx::Rect opaque_rect,
               unsigned resource_id,
               bool premultiplied_alpha,
-              const gfx::RectF& uv_rect,
+              gfx::PointF uv_top_left,
+              gfx::PointF uv_bottom_right,
               const float vertex_opacity[4],
               bool flipped);
 
@@ -32,16 +33,21 @@
               bool needs_blending,
               unsigned resource_id,
               bool premultiplied_alpha,
-              const gfx::RectF& uv_rect,
+              gfx::PointF uv_top_left,
+              gfx::PointF uv_bottom_right,
               const float vertex_opacity[4],
               bool flipped);
 
   unsigned resource_id;
   bool premultiplied_alpha;
-  gfx::RectF uv_rect;
+  gfx::PointF uv_top_left;
+  gfx::PointF uv_bottom_right;
   float vertex_opacity[4];
   bool flipped;
 
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources)
+      OVERRIDE;
+
   static const TextureDrawQuad* MaterialCast(const DrawQuad*);
 
   bool PerformClipping();
Index: src/cc/rendering_stats.h
===================================================================
--- src/cc/rendering_stats.h	(revision 184497)
+++ src/cc/rendering_stats.h	(working copy)
@@ -16,9 +16,9 @@
     int64 numAnimationFrames;
     int64 numFramesSentToScreen;
     int64 droppedFrameCount;
-    double totalPaintTimeInSeconds;
-    double totalRasterizeTimeInSeconds;
-    double totalCommitTimeInSeconds;
+    base::TimeDelta totalPaintTime;
+    base::TimeDelta totalRasterizeTime;
+    base::TimeDelta totalCommitTime;
     int64 totalCommitCount;
     int64 totalPixelsPainted;
     int64 totalPixelsRasterized;
@@ -29,8 +29,8 @@
     int64 totalDeferredImageDecodeCount;
     int64 totalDeferredImageCacheHitCount;
     int64 totalImageGatheringCount;
-    double totalDeferredImageDecodeTimeInSeconds;
-    double totalImageGatheringTimeInSeconds;
+    base::TimeDelta totalDeferredImageDecodeTime;
+    base::TimeDelta totalImageGatheringTime;
     // Note: when adding new members, please remember to update enumerateFields
     // in rendering_stats.cc.
 
Index: src/cc/direct_renderer.cc
===================================================================
--- src/cc/direct_renderer.cc	(revision 184497)
+++ src/cc/direct_renderer.cc	(working copy)
@@ -8,6 +8,7 @@
 
 #include "base/debug/trace_event.h"
 #include "base/metrics/histogram.h"
+#include "cc/draw_quad.h"
 #include "cc/math_util.h"
 #include "ui/gfx/rect_conversions.h"
 #include "ui/gfx/transform.h"
@@ -157,16 +158,15 @@
     }
 }
 
-void DirectRenderer::drawFrame(RenderPassList& renderPassesInDrawOrder, RenderPassIdHashMap& renderPassesById)
+void DirectRenderer::drawFrame(RenderPassList& renderPassesInDrawOrder)
 {
     TRACE_EVENT0("cc", "DirectRenderer::drawFrame");
-    HISTOGRAM_COUNTS("Renderer4.renderPassCount", renderPassesInDrawOrder.size());
+    UMA_HISTOGRAM_COUNTS("Renderer4.renderPassCount", renderPassesInDrawOrder.size());
 
     const RenderPass* rootRenderPass = renderPassesInDrawOrder.back();
     DCHECK(rootRenderPass);
 
     DrawingFrame frame;
-    frame.renderPassesById = &renderPassesById;
     frame.rootRenderPass = rootRenderPass;
     frame.rootDamageRect = capabilities().usingPartialSwap ? rootRenderPass->damage_rect : rootRenderPass->output_rect;
     frame.rootDamageRect.Intersect(gfx::Rect(gfx::Point(), viewportSize()));
@@ -177,7 +177,6 @@
     finishDrawingFrame(frame);
 
     renderPassesInDrawOrder.clear();
-    renderPassesById.clear();
 }
 
 gfx::RectF DirectRenderer::computeScissorRectForRenderPass(const DrawingFrame& frame)
Index: src/cc/scrollbar_layer_impl.cc
===================================================================
--- src/cc/scrollbar_layer_impl.cc	(revision 184497)
+++ src/cc/scrollbar_layer_impl.cc	(working copy)
@@ -4,8 +4,11 @@
 
 #include "cc/scrollbar_layer_impl.h"
 
+#include "cc/layer_tree_impl.h"
+#include "cc/layer_tree_settings.h"
 #include "cc/quad_sink.h"
 #include "cc/scrollbar_animation_controller.h"
+#include "cc/solid_color_draw_quad.h"
 #include "cc/texture_draw_quad.h"
 #include "ui/gfx/rect_conversions.h"
 
@@ -14,17 +17,22 @@
 
 namespace cc {
 
-scoped_ptr<ScrollbarLayerImpl> ScrollbarLayerImpl::create(LayerTreeImpl* treeImpl, int id)
+scoped_ptr<ScrollbarLayerImpl> ScrollbarLayerImpl::create(LayerTreeImpl* treeImpl, int id, scoped_ptr<ScrollbarGeometryFixedThumb> geometry)
 {
-    return make_scoped_ptr(new ScrollbarLayerImpl(treeImpl, id));
+    return make_scoped_ptr(new ScrollbarLayerImpl(treeImpl, id, geometry.Pass()));
 }
 
-ScrollbarLayerImpl::ScrollbarLayerImpl(LayerTreeImpl* treeImpl, int id)
+ScrollbarLayerImpl::ScrollbarLayerImpl(LayerTreeImpl* treeImpl, int id, scoped_ptr<ScrollbarGeometryFixedThumb> geometry)
     : ScrollbarLayerImplBase(treeImpl, id)
     , m_scrollbar(this)
     , m_backTrackResourceId(0)
     , m_foreTrackResourceId(0)
     , m_thumbResourceId(0)
+    , m_geometry(geometry.Pass())
+    , m_currentPos(0)
+    , m_totalSize(0)
+    , m_maximum(0)
+    , m_scrollLayerId(-1)
     , m_scrollbarOverlayStyle(WebScrollbar::ScrollbarOverlayStyleDefault)
     , m_orientation(WebScrollbar::Horizontal)
     , m_controlSize(WebScrollbar::RegularScrollbar)
@@ -42,9 +50,9 @@
 {
 }
 
-void ScrollbarLayerImpl::setScrollbarGeometry(scoped_ptr<ScrollbarGeometryFixedThumb> geometry)
+ScrollbarLayerImpl* ScrollbarLayerImpl::toScrollbarLayer()
 {
-    m_geometry = geometry.Pass();
+    return this;
 }
 
 void ScrollbarLayerImpl::setScrollbarData(WebScrollbar* scrollbar)
@@ -61,8 +69,19 @@
     m_isOverlayScrollbar = scrollbar->isOverlay();
 
     scrollbar->getTickmarks(m_tickmarks);
+}
 
-    m_geometry->update(scrollbar);
+void ScrollbarLayerImpl::setThumbSize(gfx::Size size)
+{
+    m_thumbSize = size;
+    if (!m_geometry) {
+        // In impl-side painting, the ScrollbarLayerImpl in the pending tree
+        // simply holds properties that are later pushed to the active tree's
+        // layer, but it doesn't hold geometry or append quads.
+        DCHECK(layerTreeImpl()->IsPendingTree());
+        return;
+    }
+    m_geometry->setThumbSize(size);
 }
 
 float ScrollbarLayerImpl::currentPos() const
@@ -98,11 +117,31 @@
     return gfx::ToEnclosingRect(contentRect);
 }
 
+scoped_ptr<LayerImpl> ScrollbarLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return ScrollbarLayerImpl::create(treeImpl, id(), m_geometry.Pass()).PassAs<LayerImpl>();
+}
+
+void ScrollbarLayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    LayerImpl::pushPropertiesTo(layer);
+
+    ScrollbarLayerImpl* scrollbarLayer = static_cast<ScrollbarLayerImpl*>(layer);
+
+    scrollbarLayer->setScrollbarData(&m_scrollbar);
+    scrollbarLayer->setThumbSize(m_thumbSize);
+
+    scrollbarLayer->setBackTrackResourceId(m_backTrackResourceId);
+    scrollbarLayer->setForeTrackResourceId(m_foreTrackResourceId);
+    scrollbarLayer->setThumbResourceId(m_thumbResourceId);
+}
+
 void ScrollbarLayerImpl::appendQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData)
 {
-    bool premultipledAlpha = false;
+    bool premultipledAlpha = true;
     bool flipped = false;
-    gfx::RectF uvRect(0, 0, 1, 1);
+    gfx::PointF uvTopLeft(0.f, 0.f);
+    gfx::PointF uvBottomRight(1.f, 1.f);
     gfx::Rect boundsRect(gfx::Point(), bounds());
     gfx::Rect contentBoundsRect(gfx::Point(), contentBounds());
 
@@ -114,12 +153,27 @@
     if (!m_geometry->hasThumb(&m_scrollbar))
         thumbRect = WebRect();
 
+    if (layerTreeImpl()->settings().solidColorScrollbars) {
+        int thicknessOverride = layerTreeImpl()->settings().solidColorScrollbarThicknessDIP;
+        if (thicknessOverride != -1) {
+            if (m_scrollbar.orientation() == WebScrollbar::Vertical)
+                thumbRect.width = thicknessOverride;
+            else
+                thumbRect.height = thicknessOverride;
+        }
+        gfx::Rect quadRect(scrollbarLayerRectToContentRect(thumbRect));
+        scoped_ptr<SolidColorDrawQuad> quad = SolidColorDrawQuad::Create();
+        quad->SetNew(sharedQuadState, quadRect, layerTreeImpl()->settings().solidColorScrollbarColor);
+        quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
+        return;
+    }
+
     if (m_thumbResourceId && !thumbRect.isEmpty()) {
         gfx::Rect quadRect(scrollbarLayerRectToContentRect(thumbRect));
         gfx::Rect opaqueRect;
         const float opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
         scoped_ptr<TextureDrawQuad> quad = TextureDrawQuad::Create();
-        quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_thumbResourceId, premultipledAlpha, uvRect, opacity, flipped);
+        quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_thumbResourceId, premultipledAlpha, uvTopLeft, uvBottomRight, opacity, flipped);
         quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
     }
 
@@ -130,9 +184,10 @@
     if (m_foreTrackResourceId && !foreTrackRect.isEmpty()) {
         gfx::Rect quadRect(scrollbarLayerRectToContentRect(foreTrackRect));
         gfx::Rect opaqueRect(contentsOpaque() ? quadRect : gfx::Rect());
+        gfx::RectF uvRect(toUVRect(foreTrackRect, boundsRect));
         const float opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
         scoped_ptr<TextureDrawQuad> quad = TextureDrawQuad::Create();
-        quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_foreTrackResourceId, premultipledAlpha, toUVRect(foreTrackRect, boundsRect), opacity, flipped);
+        quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_foreTrackResourceId, premultipledAlpha, uvRect.origin(), uvRect.bottom_right(), opacity, flipped);
         quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
     }
 
@@ -143,7 +198,7 @@
         gfx::Rect opaqueRect(contentsOpaque() ? quadRect : gfx::Rect());
         const float opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
         scoped_ptr<TextureDrawQuad> quad = TextureDrawQuad::Create();
-        quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_backTrackResourceId, premultipledAlpha, uvRect, opacity, flipped);
+        quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_backTrackResourceId, premultipledAlpha, uvTopLeft, uvBottomRight, opacity, flipped);
         quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
     }
 }
@@ -162,7 +217,7 @@
 
 int ScrollbarLayerImpl::Scrollbar::value() const
 {
-    return m_owner->m_currentPos;
+    return m_owner->currentPos();
 }
 
 WebKit::WebPoint ScrollbarLayerImpl::Scrollbar::location() const
@@ -182,12 +237,12 @@
 
 int ScrollbarLayerImpl::Scrollbar::maximum() const
 {
-    return m_owner->m_maximum;
+    return m_owner->maximum();
 }
 
 int ScrollbarLayerImpl::Scrollbar::totalSize() const
 {
-    return m_owner->m_totalSize;
+    return m_owner->totalSize();
 }
 
 bool ScrollbarLayerImpl::Scrollbar::isScrollViewScrollbar() const
Index: src/cc/texture_copier_unittest.cc
===================================================================
--- src/cc/texture_copier_unittest.cc	(revision 184497)
+++ src/cc/texture_copier_unittest.cc	(working copy)
@@ -54,8 +54,8 @@
         EXPECT_CALL(*mockContext, enable(GL_SCISSOR_TEST));
     }
 
-    int sourceTextureId = 1;
-    int destTextureId = 2;
+    int sourceTextureId = mockContext->createTexture();
+    int destTextureId = mockContext->createTexture();
     gfx::Size size(256, 128);
     scoped_ptr<AcceleratedTextureCopier> copier(AcceleratedTextureCopier::create(mockContext.get(), false));
     TextureCopier::Parameters copy = { sourceTextureId, destTextureId, size };
Index: src/cc/layer_painter.h
===================================================================
--- src/cc/layer_painter.h	(revision 184497)
+++ src/cc/layer_painter.h	(working copy)
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-
 #ifndef CC_LAYER_PAINTER_H_
 #define CC_LAYER_PAINTER_H_
 
@@ -20,8 +19,9 @@
 class CC_EXPORT LayerPainter {
 public:
     virtual ~LayerPainter() { }
-    virtual void paint(SkCanvas*, const gfx::Rect& contentRect, gfx::RectF& opaque) = 0;
+    virtual void paint(SkCanvas*, gfx::Rect contentRect, gfx::RectF& opaque) = 0;
 };
 
-} // namespace cc
+}  // namespace cc
+
 #endif  // CC_LAYER_PAINTER_H_
Index: src/cc/scoped_thread_proxy.cc
===================================================================
--- src/cc/scoped_thread_proxy.cc	(revision 184497)
+++ src/cc/scoped_thread_proxy.cc	(working copy)
@@ -1,44 +0,0 @@
-// Copyright 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "cc/scoped_thread_proxy.h"
-
-#include "base/bind.h"
-
-namespace cc {
-
-ScopedThreadProxy::ScopedThreadProxy(cc::Thread* targetThread)
-    : m_targetThread(targetThread)
-    , m_shutdown(false)
-{
-}
-
-ScopedThreadProxy::~ScopedThreadProxy()
-{
-}
-
-void ScopedThreadProxy::postTask(const tracked_objects::Location& location, base::Closure cb)
-{
-    m_targetThread->postTask(base::Bind(&ScopedThreadProxy::runTaskIfNotShutdown, this, cb));
-}
-
-void ScopedThreadProxy::shutdown()
-{
-    DCHECK(m_targetThread->belongsToCurrentThread());
-    DCHECK(!m_shutdown);
-    m_shutdown = true;
-}
-
-void ScopedThreadProxy::runTaskIfNotShutdown(base::Closure cb)
-{
-    // If our shutdown flag is set, it's possible that m_targetThread has already been destroyed so don't
-    // touch it.
-    if (m_shutdown) {
-        return;
-    }
-    DCHECK(m_targetThread->belongsToCurrentThread());
-    cb.Run();
-}
-
-}  // namespace cc
Index: src/cc/keyframed_animation_curve.h
===================================================================
--- src/cc/keyframed_animation_curve.h	(revision 184497)
+++ src/cc/keyframed_animation_curve.h	(working copy)
@@ -9,7 +9,7 @@
 #include "cc/cc_export.h"
 #include "cc/scoped_ptr_vector.h"
 #include "cc/timing_function.h"
-#include <public/WebTransformOperations.h>
+#include "cc/transform_operations.h"
 
 namespace cc {
 
@@ -46,17 +46,17 @@
 
 class CC_EXPORT TransformKeyframe : public Keyframe {
 public:
-    static scoped_ptr<TransformKeyframe> create(double time, const WebKit::WebTransformOperations& value, scoped_ptr<TimingFunction>);
+    static scoped_ptr<TransformKeyframe> create(double time, const TransformOperations& value, scoped_ptr<TimingFunction>);
     virtual ~TransformKeyframe();
 
-    const WebKit::WebTransformOperations& value() const;
+    const TransformOperations& value() const;
 
     scoped_ptr<TransformKeyframe> clone() const;
 
 private:
-    TransformKeyframe(double time, const WebKit::WebTransformOperations& value, scoped_ptr<TimingFunction>);
+    TransformKeyframe(double time, const TransformOperations& value, scoped_ptr<TimingFunction>);
 
-    WebKit::WebTransformOperations m_value;
+    TransformOperations m_value;
 };
 
 class CC_EXPORT KeyframedFloatAnimationCurve : public FloatAnimationCurve {
@@ -99,7 +99,7 @@
     virtual scoped_ptr<AnimationCurve> clone() const OVERRIDE;
 
     // TransformAnimationCurve implementation
-    virtual WebKit::WebTransformationMatrix getValue(double t) const OVERRIDE;
+    virtual gfx::Transform getValue(double t) const OVERRIDE;
 
 private:
     KeyframedTransformAnimationCurve();
Index: src/cc/layer_tree_settings.h
===================================================================
--- src/cc/layer_tree_settings.h	(revision 184497)
+++ src/cc/layer_tree_settings.h	(working copy)
@@ -8,6 +8,7 @@
 #include "base/basictypes.h"
 #include "cc/cc_export.h"
 #include "cc/layer_tree_debug_state.h"
+#include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/size.h"
 
 namespace cc {
@@ -24,15 +25,25 @@
   bool perTilePaintingEnabled;
   bool partialSwapEnabled;
   bool cacheRenderPassContents;
+  bool rightAlignedSchedulingEnabled;
   bool acceleratedAnimationEnabled;
   bool pageScalePinchZoomEnabled;
   bool backgroundColorInsteadOfCheckerboard;
   bool showOverdrawInTracing;
   bool canUseLCDText;
   bool shouldClearRootRenderPass;
+  bool useLinearFadeScrollbarAnimator;
+  bool solidColorScrollbars;
+  SkColor solidColorScrollbarColor;
+  int solidColorScrollbarThicknessDIP;
+  bool calculateTopControlsPosition;
+  bool useMemoryManagement;
+  float minimumContentsScale;
+  float lowResContentsScaleFactor;
   double refreshRate;
   size_t maxPartialTextureUpdates;
   size_t numRasterThreads;
+  int topControlsHeightPx;
   gfx::Size defaultTileSize;
   gfx::Size maxUntiledLayerSize;
   gfx::Size minimumOcclusionTrackingSize;
Index: src/cc/PRESUBMIT.py
===================================================================
--- src/cc/PRESUBMIT.py	(revision 184497)
+++ src/cc/PRESUBMIT.py	(working copy)
@@ -11,6 +11,7 @@
 import re
 
 CC_SOURCE_FILES=(r'^cc/.*\.(cc|h)$',)
+CC_PERF_TEST =(r'^.*_perftest.*\.(cc|h)$',)
 
 def CheckAsserts(input_api, output_api, white_list=CC_SOURCE_FILES, black_list=None):
   black_list = tuple(black_list or input_api.DEFAULT_BLACK_LIST)
@@ -38,9 +39,35 @@
       items=notreached_files)]
   return []
 
+def CheckSpamLogging(input_api, output_api, white_list=CC_SOURCE_FILES, black_list=None):
+  black_list = tuple(black_list or input_api.DEFAULT_BLACK_LIST)
+  source_file_filter = lambda x: input_api.FilterSourceFile(x, white_list, black_list)
+
+  log_info = []
+  printf = []
+
+  for f in input_api.AffectedSourceFiles(source_file_filter):
+    contents = input_api.ReadFile(f, 'rb')
+    if re.search(r"\bD?LOG\s*\(\s*INFO\s*\)", contents):
+      log_info.append(f.LocalPath())
+    if re.search(r"\bf?printf\(", contents):
+      printf.append(f.LocalPath())
+
+  if log_info:
+    return [output_api.PresubmitError(
+      'These files spam the console log with LOG(INFO):',
+      items=log_info)]
+  if printf:
+    return [output_api.PresubmitError(
+      'These files spam the console log with printf/fprintf:',
+      items=printf)]
+  return []
+
+
 def CheckChangeOnUpload(input_api, output_api):
   results = []
   results += CheckAsserts(input_api, output_api)
+  results += CheckSpamLogging(input_api, output_api, black_list=CC_PERF_TEST)
   return results
 
 def GetPreferredTrySlaves(project, change):
Index: src/cc/layer.h
===================================================================
--- src/cc/layer.h	(revision 184497)
+++ src/cc/layer.h	(working copy)
@@ -5,7 +5,6 @@
 #ifndef CC_LAYER_H_
 #define CC_LAYER_H_
 
-#include <public/WebFilterOperations.h>
 #include <string>
 #include <vector>
 
@@ -14,11 +13,13 @@
 #include "cc/cc_export.h"
 #include "cc/draw_properties.h"
 #include "cc/layer_animation_controller.h"
-#include "cc/layer_animation_observer.h"
+#include "cc/layer_animation_event_observer.h"
+#include "cc/layer_animation_value_observer.h"
 #include "cc/occlusion_tracker.h"
 #include "cc/region.h"
 #include "cc/render_surface.h"
 #include "skia/ext/refptr.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkImageFilter.h"
 #include "ui/gfx/rect.h"
@@ -32,7 +33,7 @@
 
 namespace cc {
 
-class ActiveAnimation;
+class Animation;
 struct AnimationEvent;
 class LayerAnimationDelegate;
 class LayerImpl;
@@ -46,21 +47,14 @@
 
 // Base class for composited layers. Special layer types are derived from
 // this class.
-class CC_EXPORT Layer : public base::RefCounted<Layer>, public LayerAnimationControllerClient {
+class CC_EXPORT Layer : public base::RefCounted<Layer>,
+                        public LayerAnimationValueObserver {
 public:
     typedef std::vector<scoped_refptr<Layer> > LayerList;
 
     static scoped_refptr<Layer> create();
 
-    // LayerAnimationControllerClient implementation
-    virtual int id() const OVERRIDE;
-    virtual void setOpacityFromAnimation(float) OVERRIDE;
-    virtual float opacity() const OVERRIDE;
-    virtual void setTransformFromAnimation(const gfx::Transform&) OVERRIDE;
-    // A layer's transform operates layer space. That is, entirely in logical,
-    // non-page-scaled pixels (that is, they have page zoom baked in, but not page scale).
-    // The root layer is a special case -- it operates in physical pixels.
-    virtual const gfx::Transform& transform() const OVERRIDE;
+    int id() const;
 
     Layer* rootLayer();
     Layer* parent() { return m_parent; }
@@ -73,6 +67,7 @@
     void setChildren(const LayerList&);
 
     const LayerList& children() const { return m_children; }
+    Layer* childAt(size_t index);
 
     void setAnchorPoint(const gfx::PointF&);
     gfx::PointF anchorPoint() const { return m_anchorPoint; }
@@ -99,9 +94,9 @@
 
     virtual void setNeedsDisplayRect(const gfx::RectF& dirtyRect);
     void setNeedsDisplay() { setNeedsDisplayRect(gfx::RectF(gfx::PointF(), bounds())); }
-    virtual bool needsDisplay() const;
 
     void setOpacity(float);
+    float opacity() const;
     bool opacityIsAnimating() const;
 
     void setFilters(const WebKit::WebFilterOperations&);
@@ -131,6 +126,7 @@
     const gfx::Transform& sublayerTransform() const { return m_sublayerTransform; }
 
     void setTransform(const gfx::Transform&);
+    const gfx::Transform& transform() const;
     bool transformIsAnimating() const;
 
     DrawProperties<Layer, RenderSurface>& drawProperties() { return m_drawProperties; }
@@ -169,11 +165,9 @@
     bool haveWheelEventHandlers() const { return m_haveWheelEventHandlers; }
 
     void setNonFastScrollableRegion(const Region&);
-    void setNonFastScrollableRegionChanged() { m_nonFastScrollableRegionChanged = true; }
     const Region& nonFastScrollableRegion() const { return m_nonFastScrollableRegion; }
 
     void setTouchEventHandlerRegion(const Region&);
-    void setTouchEventHandlerRegionChanged() { m_touchEventHandlerRegionChanged = true; }
     const Region& touchEventHandlerRegion() const { return m_touchEventHandlerRegion; }
 
     void setLayerScrollClient(WebKit::WebLayerScrollClient* layerScrollClient) { m_layerScrollClient = layerScrollClient; }
@@ -234,6 +228,7 @@
     gfx::Size contentBounds() const { return m_drawProperties.content_bounds; }
     virtual void calculateContentsScale(
         float idealContentsScale,
+        bool animatingTransformToScreen,
         float* contentsScaleX,
         float* contentsScaleY,
         gfx::Size* contentBounds);
@@ -261,7 +256,7 @@
     // Set the priority of all desired textures in this layer.
     virtual void setTexturePriorities(const PriorityCalculator&) { }
 
-    bool addAnimation(scoped_ptr<ActiveAnimation>);
+    bool addAnimation(scoped_ptr<Animation>);
     void pauseAnimation(int animationId, double timeOffset);
     void removeAnimation(int animationId);
 
@@ -269,8 +264,8 @@
     void resumeAnimations(double monotonicTime);
 
     LayerAnimationController* layerAnimationController() { return m_layerAnimationController.get(); }
-    void setLayerAnimationController(scoped_ptr<LayerAnimationController>);
-    scoped_ptr<LayerAnimationController> releaseLayerAnimationController();
+    void setLayerAnimationController(scoped_refptr<LayerAnimationController>);
+    scoped_refptr<LayerAnimationController> releaseLayerAnimationController();
 
     void setLayerAnimationDelegate(WebKit::WebAnimationDelegate* layerAnimationDelegate) { m_layerAnimationDelegate = layerAnimationDelegate; }
 
@@ -279,8 +274,8 @@
     virtual void notifyAnimationStarted(const AnimationEvent&, double wallClockTime);
     virtual void notifyAnimationFinished(double wallClockTime);
 
-    void addLayerAnimationObserver(LayerAnimationObserver* animationObserver);
-    void removeLayerAnimationObserver(LayerAnimationObserver* animationObserver);
+    void addLayerAnimationEventObserver(LayerAnimationEventObserver* animationObserver);
+    void removeLayerAnimationEventObserver(LayerAnimationEventObserver* animationObserver);
 
     virtual Region visibleContentOpaqueRegion() const;
 
@@ -292,7 +287,17 @@
     // compatible with the main thread running freely, such as a double-buffered
     // canvas that doesn't want to be triple-buffered across all three trees.
     virtual bool blocksPendingCommit() const;
+    // Returns true if anything in this tree blocksPendingCommit.
+    bool blocksPendingCommitRecursive() const;
 
+    virtual bool canClipSelf() const;
+
+    // Constructs a LayerImpl of the correct runtime type for this Layer type.
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl);
+
+    bool needsDisplayForTesting() const { return m_needsDisplay; }
+    void resetNeedsDisplayForTesting() { m_needsDisplay = false; }
+
 protected:
     friend class LayerImpl;
     friend class TreeSynchronizer;
@@ -317,8 +322,6 @@
 
     scoped_refptr<Layer> m_maskLayer;
 
-    // Constructs a LayerImpl of the correct runtime type for this Layer type.
-    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl);
     int m_layerId;
 
     // When true, the layer is about to perform an update. Any commit requests
@@ -332,14 +335,17 @@
     bool hasAncestor(Layer*) const;
     bool descendantIsFixedToContainerLayer() const;
 
-    size_t numChildren() const { return m_children.size(); }
-
     // Returns the index of the child or -1 if not found.
     int indexOfChild(const Layer*);
 
     // This should only be called from removeFromParent.
     void removeChild(Layer*);
 
+    // LayerAnimationValueObserver implementation.
+    virtual void OnOpacityAnimated(float) OVERRIDE;
+    virtual void OnTransformAnimated(const gfx::Transform&) OVERRIDE;
+    virtual bool IsActive() const OVERRIDE;
+
     LayerList m_children;
     Layer* m_parent;
 
@@ -348,9 +354,10 @@
     // updated via setLayerTreeHost() if a layer moves between trees.
     LayerTreeHost* m_layerTreeHost;
 
-    scoped_ptr<LayerAnimationController> m_layerAnimationController;
-    ObserverList<LayerAnimationObserver> m_layerAnimationObservers;
+    ObserverList<LayerAnimationEventObserver> m_layerAnimationObservers;
 
+    scoped_refptr<LayerAnimationController> m_layerAnimationController;
+
     // Layer properties.
     gfx::Size m_bounds;
 
@@ -360,9 +367,7 @@
     bool m_shouldScrollOnMainThread;
     bool m_haveWheelEventHandlers;
     Region m_nonFastScrollableRegion;
-    bool m_nonFastScrollableRegionChanged;
     Region m_touchEventHandlerRegion;
-    bool m_touchEventHandlerRegionChanged;
     gfx::PointF m_position;
     gfx::PointF m_anchorPoint;
     SkColor m_backgroundColor;
Index: src/cc/scheduler.cc
===================================================================
--- src/cc/scheduler.cc	(revision 184497)
+++ src/cc/scheduler.cc	(working copy)
@@ -10,9 +10,13 @@
 
 namespace cc {
 
-Scheduler::Scheduler(SchedulerClient* client, scoped_ptr<FrameRateController> frameRateController)
-    : m_client(client)
+Scheduler::Scheduler(SchedulerClient* client,
+                     scoped_ptr<FrameRateController> frameRateController,
+                     const SchedulerSettings& schedulerSettings)
+    : m_settings(schedulerSettings)
+    , m_client(client)
     , m_frameRateController(frameRateController.Pass())
+    , m_stateMachine(schedulerSettings)
     , m_insideProcessScheduledActions(false)
 {
     DCHECK(m_client);
@@ -43,6 +47,12 @@
     processScheduledActions();
 }
 
+void Scheduler::setHasPendingTree(bool hasPendingTree)
+{
+    m_stateMachine.setHasPendingTree(hasPendingTree);
+    processScheduledActions();
+}
+
 void Scheduler::setNeedsCommit()
 {
     m_stateMachine.setNeedsCommit();
@@ -62,6 +72,12 @@
     processScheduledActions();
 }
 
+void Scheduler::didSwapUseIncompleteTile()
+{
+    m_stateMachine.didSwapUseIncompleteTile();
+    processScheduledActions();
+}
+
 void Scheduler::setNeedsForcedRedraw()
 {
     m_stateMachine.setNeedsForcedRedraw();
@@ -93,6 +109,11 @@
     m_frameRateController->setMaxFramesPending(maxFramesPending);
 }
 
+int Scheduler::maxFramesPending() const
+{
+    return m_frameRateController->maxFramesPending();
+}
+
 void Scheduler::setSwapBuffersCompleteSupported(bool supported)
 {
     m_frameRateController->setSwapBuffersCompleteSupported(supported);
@@ -162,6 +183,12 @@
         case SchedulerStateMachine::ACTION_COMMIT:
             m_client->scheduledActionCommit();
             break;
+        case SchedulerStateMachine::ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS:
+            m_client->scheduledActionCheckForCompletedTileUploads();
+            break;
+        case SchedulerStateMachine::ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED:
+            m_client->scheduledActionActivatePendingTreeIfNeeded();
+            break;
         case SchedulerStateMachine::ACTION_DRAW_IF_POSSIBLE: {
             ScheduledActionDrawAndSwapResult result = m_client->scheduledActionDrawAndSwapIfPossible();
             m_stateMachine.didDrawIfPossibleCompleted(result.didDraw);
Index: src/cc/resource_pool.cc
===================================================================
--- src/cc/resource_pool.cc	(revision 184497)
+++ src/cc/resource_pool.cc	(working copy)
@@ -11,7 +11,7 @@
 ResourcePool::Resource::Resource(cc::ResourceProvider* resource_provider,
                                  const gfx::Size& size,
                                  GLenum format)
-    : cc::Resource(resource_provider->createResource(
+    : cc::Resource(resource_provider->createManagedResource(
                        size,
                        format,
                        ResourceProvider::TextureUsageAny),
@@ -43,6 +43,12 @@
        it != resources_.end(); ++it) {
     Resource* resource = *it;
 
+    // TODO(epenner): It would be nice to DCHECK that this
+    // doesn't happen two frames in a row for any resource
+    // in this pool.
+    if (!resource_provider_->canLockForWrite(resource->id()))
+      continue;
+
     if (resource->size() != size)
       continue;
     if (resource->format() != format)
@@ -55,6 +61,12 @@
   // Create new resource.
   Resource* resource = new Resource(
       resource_provider_, size, format);
+
+  // Extend all read locks on all resources until the resource is
+  // finished being used, such that we know when resources are
+  // truly safe to recycle.
+  resource_provider_->enableReadLockFences(resource->id(), true);
+
   memory_usage_bytes_ += resource->bytes();
   return make_scoped_ptr(resource);
 }
Index: src/cc/rate_limiter.cc
===================================================================
--- src/cc/rate_limiter.cc	(revision 184497)
+++ src/cc/rate_limiter.cc	(working copy)
@@ -6,7 +6,7 @@
 
 #include "base/debug/trace_event.h"
 #include "cc/thread.h"
-#include <public/WebGraphicsContext3D.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 
 namespace cc {
 
Index: src/cc/image_layer.h
===================================================================
--- src/cc/image_layer.h	(revision 184497)
+++ src/cc/image_layer.h	(working copy)
@@ -23,6 +23,7 @@
     virtual void update(ResourceUpdateQueue&, const OcclusionTracker*, RenderingStats&) OVERRIDE;
     virtual void calculateContentsScale(
         float idealContentsScale,
+        bool animating_transform_to_screen,
         float* contentsScaleX,
         float* contentsScaleY,
         gfx::Size* contentBounds) OVERRIDE;
Index: src/cc/delegated_renderer_layer_impl.h
===================================================================
--- src/cc/delegated_renderer_layer_impl.h	(revision 184497)
+++ src/cc/delegated_renderer_layer_impl.h	(working copy)
@@ -5,6 +5,7 @@
 #ifndef CC_DELEGATED_RENDERER_LAYER_IMPL_H_
 #define CC_DELEGATED_RENDERER_LAYER_IMPL_H_
 
+#include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
 #include "cc/layer_impl.h"
 #include "cc/scoped_ptr_vector.h"
@@ -12,36 +13,54 @@
 namespace cc {
 
 class CC_EXPORT DelegatedRendererLayerImpl : public LayerImpl {
-public:
-    static scoped_ptr<DelegatedRendererLayerImpl> create(LayerTreeImpl* treeImpl, int id) { return make_scoped_ptr(new DelegatedRendererLayerImpl(treeImpl, id)); }
-    virtual ~DelegatedRendererLayerImpl();
+ public:
+  static scoped_ptr<DelegatedRendererLayerImpl> Create(
+      LayerTreeImpl* tree_impl, int id) {
+    return make_scoped_ptr(new DelegatedRendererLayerImpl(tree_impl, id));
+  }
+  virtual ~DelegatedRendererLayerImpl();
 
-    virtual bool hasDelegatedContent() const OVERRIDE;
-    virtual bool hasContributingDelegatedRenderPasses() const OVERRIDE;
+  // LayerImpl overrides.
+  virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*) OVERRIDE;
+  virtual bool hasDelegatedContent() const OVERRIDE;
+  virtual bool hasContributingDelegatedRenderPasses() const OVERRIDE;
+  virtual RenderPass::Id firstContributingRenderPassId() const OVERRIDE;
+  virtual RenderPass::Id nextContributingRenderPassId(
+      RenderPass::Id previous) const OVERRIDE;
+  virtual void didLoseOutputSurface() OVERRIDE;
+  virtual void appendQuads(
+      QuadSink& quad_sink, AppendQuadsData& append_quads_data) OVERRIDE;
 
-    // This gives ownership of the RenderPasses to the layer.
-    void setRenderPasses(ScopedPtrVector<RenderPass>&);
-    void clearRenderPasses();
+  // This gives ownership of the RenderPasses to the layer.
+  void SetRenderPasses(ScopedPtrVector<RenderPass>&);
+  void ClearRenderPasses();
 
-    virtual void didLoseOutputSurface() OVERRIDE;
+  // Set the size at which the frame should be displayed, with the origin at the
+  // layer's origin. This must always contain at least the layer's bounds. A
+  // value of (0, 0) implies that the frame should be displayed to fit exactly
+  // in the layer's bounds.
+  void set_display_size(gfx::Size size) { display_size_ = size; }
 
-    virtual RenderPass::Id firstContributingRenderPassId() const OVERRIDE;
-    virtual RenderPass::Id nextContributingRenderPassId(RenderPass::Id) const OVERRIDE;
+  void AppendContributingRenderPasses(RenderPassSink* render_pass_sink);
 
-    void appendContributingRenderPasses(RenderPassSink&);
-    virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
+ private:
+  DelegatedRendererLayerImpl(LayerTreeImpl* tree_impl, int id);
 
-private:
-    DelegatedRendererLayerImpl(LayerTreeImpl* treeImpl, int id);
+  RenderPass::Id ConvertDelegatedRenderPassId(
+      RenderPass::Id delegated_render_pass_id) const;
 
-    RenderPass::Id convertDelegatedRenderPassId(RenderPass::Id delegatedRenderPassId) const;
+  void AppendRenderPassQuads(
+      QuadSink* quad_sink,
+      AppendQuadsData* append_quads_data,
+      const RenderPass* delegated_render_pass,
+      gfx::Size frame_size) const;
 
-    void appendRenderPassQuads(QuadSink&, AppendQuadsData&, const RenderPass* fromDelegatedRenderPass) const;
+  // LayerImpl overrides.
+  virtual const char* layerTypeAsString() const OVERRIDE;
 
-    virtual const char* layerTypeAsString() const OVERRIDE;
-
-    ScopedPtrVector<RenderPass> m_renderPassesInDrawOrder;
-    base::hash_map<RenderPass::Id, int> m_renderPassesIndexById;
+  ScopedPtrVector<RenderPass> render_passes_in_draw_order_;
+  base::hash_map<RenderPass::Id, int> render_passes_index_by_id_;
+  gfx::Size display_size_;
 };
 
 }
Index: src/cc/picture_pile.h
===================================================================
--- src/cc/picture_pile.h	(revision 184497)
+++ src/cc/picture_pile.h	(working copy)
@@ -5,50 +5,39 @@
 #ifndef CC_PICTURE_PILE_H_
 #define CC_PICTURE_PILE_H_
 
-#include <list>
-
-#include "base/basictypes.h"
-#include "cc/cc_export.h"
-#include "cc/picture.h"
-#include "cc/region.h"
-#include "cc/scoped_ptr_vector.h"
+#include "cc/picture_pile_base.h"
 #include "ui/gfx/rect.h"
-#include "ui/gfx/size.h"
 
 namespace cc {
 class PicturePileImpl;
+class Region;
 struct RenderingStats;
 
-class CC_EXPORT PicturePile {
-public:
+class CC_EXPORT PicturePile : public PicturePileBase {
+ public:
   PicturePile();
-  ~PicturePile();
 
-  // Resize the PicturePile, invalidating / dropping recorded pictures as
-  // necessary.
-  void Resize(gfx::Size);
-  gfx::Size size() const { return size_; }
-
   // Re-record parts of the picture that are invalid.
   // Invalidations are in layer space.
   void Update(
       ContentLayerClient* painter,
       const Region& invalidation,
+      gfx::Rect visible_layer_rect,
       RenderingStats& stats);
 
   // Update other with a shallow copy of this (main => compositor thread commit)
   void PushPropertiesTo(PicturePileImpl* other);
 
-private:
+ private:
+  virtual ~PicturePile();
   friend class PicturePileImpl;
 
-  void InvalidateRect(gfx::Rect invalidation);
-  void ResetPile(ContentLayerClient* painter, RenderingStats& stats);
+  // Add an invalidation to this picture list.  If the list needs to be
+  // entirely recreated, leave it empty.  Do not call this on an empty list.
+  void InvalidateRect(
+      PictureList& picture_list,
+      gfx::Rect invalidation);
 
-  typedef std::list<scoped_refptr<Picture> > Pile;
-  Pile pile_;
-  gfx::Size size_;
-
   DISALLOW_COPY_AND_ASSIGN(PicturePile);
 };
 
Index: src/cc/nine_patch_layer_impl.h
===================================================================
--- src/cc/nine_patch_layer_impl.h	(revision 184497)
+++ src/cc/nine_patch_layer_impl.h	(working copy)
@@ -28,6 +28,9 @@
     void setResourceId(unsigned id) { m_resourceId = id; }
     void setLayout(const gfx::Size& imageBounds, const gfx::Rect& aperture);
 
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+
     virtual void willDraw(ResourceProvider*) OVERRIDE;
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
     virtual void didDraw(ResourceProvider*) OVERRIDE;
Index: src/cc/solid_color_layer_impl.h
===================================================================
--- src/cc/solid_color_layer_impl.h	(revision 184497)
+++ src/cc/solid_color_layer_impl.h	(working copy)
@@ -5,6 +5,7 @@
 #ifndef CC_SOLID_COLOR_LAYER_IMPL_H_
 #define CC_SOLID_COLOR_LAYER_IMPL_H_
 
+#include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
 #include "cc/layer_impl.h"
 
@@ -18,6 +19,8 @@
     }
     virtual ~SolidColorLayerImpl();
 
+    // LayerImpl overrides.
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*) OVERRIDE;
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
 
 protected:
Index: src/cc/switches.h
===================================================================
--- src/cc/switches.h	(revision 184497)
+++ src/cc/switches.h	(working copy)
@@ -21,6 +21,8 @@
 CC_EXPORT extern const char kEnableImplSidePainting[];
 CC_EXPORT extern const char kEnablePartialSwap[];
 CC_EXPORT extern const char kEnablePerTilePainting[];
+CC_EXPORT extern const char kEnableRightAlignedScheduling[];
+CC_EXPORT extern const char kEnableTopControlsPositionCalculation[];
 CC_EXPORT extern const char kJankInsteadOfCheckerboard[];
 CC_EXPORT extern const char kNumRasterThreads[];
 CC_EXPORT extern const char kShowPropertyChangedRects[];
@@ -30,6 +32,9 @@
 CC_EXPORT extern const char kShowOccludingRects[];
 CC_EXPORT extern const char kShowNonOccludingRects[];
 CC_EXPORT extern const char kTraceOverdraw[];
+CC_EXPORT extern const char kTopControlsHeight[];
+CC_EXPORT extern const char kSlowDownRasterScaleFactor[];
+CC_EXPORT extern const char kLowResolutionContentsScaleFactor[];
 
 }  // namespace switches
 }  // namespace cc
Index: src/cc/heads_up_display_layer_impl.h
===================================================================
--- src/cc/heads_up_display_layer_impl.h	(revision 184497)
+++ src/cc/heads_up_display_layer_impl.h	(working copy)
@@ -21,6 +21,8 @@
 class DebugRectHistory;
 class FontAtlas;
 class FrameRateCounter;
+class MemoryHistory;
+class PaintTimeCounter;
 
 class CC_EXPORT HeadsUpDisplayLayerImpl : public LayerImpl {
 public:
@@ -32,6 +34,9 @@
 
     void setFontAtlas(scoped_ptr<FontAtlas>);
 
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+
     virtual void willDraw(ResourceProvider*) OVERRIDE;
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
     void updateHudTexture(ResourceProvider*);
@@ -42,25 +47,48 @@
     virtual bool layerIsAlwaysDamaged() const OVERRIDE;
 
 private:
+    struct Graph {
+        Graph(double indicatorValue, double startUpperBound);
+
+        // Eases the upper bound, which limits what is currently visible in the graph,
+        // so that the graph always scales to either it's max or defaultUpperBound.
+        static double updateUpperBound(Graph*);
+
+        double value;
+        double min;
+        double max;
+
+        double currentUpperBound;
+        const double defaultUpperBound;
+        const double indicator;
+    };
+
     HeadsUpDisplayLayerImpl(LayerTreeImpl* treeImpl, int id);
 
     virtual const char* layerTypeAsString() const OVERRIDE;
 
     void drawHudContents(SkCanvas*);
-    int drawFPSCounter(SkCanvas*, FrameRateCounter*);
-    void drawFPSCounterText(SkCanvas*, SkPaint&, FrameRateCounter*, SkRect);
-    void drawFPSCounterGraphAndHistogram(SkCanvas* canvas, SkPaint& paint, FrameRateCounter* fpsCounter, SkRect graphBounds, SkRect histogramBounds);
+
+    void drawTextLeftAligned(SkCanvas*, SkPaint*, const SkRect& bounds, const std::string& text);
+    void drawTextRightAligned(SkCanvas*, SkPaint*, const SkRect& bounds, const std::string& text);
+
+    void drawGraphBackground(SkCanvas*, SkPaint*, const SkRect& bounds);
+    void drawGraphLines(SkCanvas*, SkPaint*, const SkRect& bounds, const Graph&);
+
+    int drawFPSDisplay(SkCanvas*, FrameRateCounter*, const int& top);
+    int drawMemoryDisplay(SkCanvas*, MemoryHistory*, const int& top);
+    int drawPaintTimeDisplay(SkCanvas*, PaintTimeCounter*, const int& top);
+
     void drawDebugRects(SkCanvas*, DebugRectHistory*);
 
     scoped_ptr<FontAtlas> m_fontAtlas;
     scoped_ptr<ScopedResource> m_hudTexture;
     scoped_ptr<SkCanvas> m_hudCanvas;
 
-    double m_averageFPS;
-    double m_minFPS;
-    double m_maxFPS;
+    Graph m_fpsGraph;
+    Graph m_paintTimeGraph;
 
-    base::TimeTicks textUpdateTime;
+    base::TimeTicks m_timeOfLastGraphUpdate;
 };
 
 }  // namespace cc
Index: src/cc/tile.cc
===================================================================
--- src/cc/tile.cc	(revision 184497)
+++ src/cc/tile.cc	(working copy)
@@ -14,12 +14,14 @@
            gfx::Size tile_size,
            GLenum format,
            gfx::Rect content_rect,
+           gfx::Rect opaque_rect,
            float contents_scale)
   : tile_manager_(tile_manager),
     picture_pile_(picture_pile),
     tile_size_(tile_size),
     format_(format),
     content_rect_(content_rect),
+    opaque_rect_(opaque_rect),
     contents_scale_(contents_scale) {
   tile_manager_->RegisterTile(this);
 }
@@ -28,23 +30,4 @@
   tile_manager_->UnregisterTile(this);
 }
 
-void Tile::set_priority(WhichTree tree, const TilePriority& priority) {
-  tile_manager_->WillModifyTilePriority(this, tree, priority);
-  priority_[tree] = priority;
-}
-
-ResourceProvider::ResourceId Tile::GetResourceId() const {
-  if (!managed_state_.resource)
-    return 0;
-  if (managed_state_.resource_is_being_initialized)
-    return 0;
-
-  return managed_state_.resource->id();
-}
-
-size_t Tile::bytes_consumed_if_allocated() const {
-  DCHECK(format_ == GL_RGBA);
-  return 4 * tile_size_.width() * tile_size_.height();
-}
-
 }  // namespace cc
Index: src/cc/scrollbar_animation_controller_linear_fade_unittest.cc
===================================================================
--- src/cc/scrollbar_animation_controller_linear_fade_unittest.cc	(revision 184497)
+++ src/cc/scrollbar_animation_controller_linear_fade_unittest.cc	(working copy)
@@ -8,6 +8,7 @@
 #include "cc/single_thread_proxy.h"
 #include "cc/test/fake_impl_proxy.h"
 #include "cc/test/fake_layer_tree_host_impl.h"
+#include "cc/test/fake_web_scrollbar_theme_geometry.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace cc {
@@ -24,99 +25,134 @@
     virtual void SetUp()
     {
         m_scrollLayer = LayerImpl::create(m_hostImpl.activeTree(), 1);
-        m_scrollLayer->addChild(LayerImpl::create(m_hostImpl.activeTree(), 2));
-        m_contentLayer = m_scrollLayer->children()[0];
-        m_scrollbarLayer = ScrollbarLayerImpl::create(m_hostImpl.activeTree(), 3);
+        scoped_ptr<ScrollbarGeometryFixedThumb> geometry(ScrollbarGeometryFixedThumb::create(FakeWebScrollbarThemeGeometry::create(false)));
+        m_scrollbarLayer = ScrollbarLayerImpl::create(m_hostImpl.activeTree(), 2, geometry.Pass());
 
         m_scrollLayer->setMaxScrollOffset(gfx::Vector2d(50, 50));
-        m_contentLayer->setBounds(gfx::Size(50, 50));
+        m_scrollLayer->setBounds(gfx::Size(50, 50));
+        m_scrollLayer->setHorizontalScrollbarLayer(m_scrollbarLayer.get());
 
         m_scrollbarController = ScrollbarAnimationControllerLinearFade::create(m_scrollLayer.get(), 2, 3);
-        m_scrollbarController->setHorizontalScrollbarLayer(m_scrollbarLayer.get());
     }
 
     FakeImplProxy m_proxy;
     FakeLayerTreeHostImpl m_hostImpl;
     scoped_ptr<ScrollbarAnimationControllerLinearFade> m_scrollbarController;
     scoped_ptr<LayerImpl> m_scrollLayer;
-    LayerImpl* m_contentLayer;
     scoped_ptr<ScrollbarLayerImpl> m_scrollbarLayer;
 
 };
 
 TEST_F(ScrollbarAnimationControllerLinearFadeTest, verifyHiddenInBegin)
 {
-    m_scrollbarController->animate(0);
+    m_scrollbarController->animate(base::TimeTicks());
     EXPECT_FLOAT_EQ(0, m_scrollbarLayer->opacity());
-    m_scrollbarController->updateScrollOffsetAtTime(m_scrollLayer.get(), 0);
-    m_scrollbarController->animate(0);
-    EXPECT_FLOAT_EQ(0, m_scrollbarLayer->opacity());
 }
 
 TEST_F(ScrollbarAnimationControllerLinearFadeTest, verifyAwakenByScroll)
 {
-    m_scrollLayer->setScrollDelta(gfx::Vector2d(1, 1));
-    m_scrollbarController->updateScrollOffsetAtTime(m_scrollLayer.get(), 0);
-    m_scrollbarController->animate(0);
+    base::TimeTicks time;
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->didUpdateScrollOffset(time);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(1);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollLayer->setScrollDelta(gfx::Vector2d(2, 2));
-    m_scrollbarController->updateScrollOffsetAtTime(m_scrollLayer.get(), 1);
-    m_scrollbarController->animate(2);
+    m_scrollbarController->didUpdateScrollOffset(time);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(3);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(4);
-    // Note that we use 3.0f to avoid "argument is truncated from 'double' to
-    // 'float'" warnings on Windows.
-    EXPECT_FLOAT_EQ(2 / 3.0f, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(5);
-    EXPECT_FLOAT_EQ(1 / 3.0f, m_scrollbarLayer->opacity());
-    m_scrollLayer->setScrollDelta(gfx::Vector2d(3, 3));
-    m_scrollbarController->updateScrollOffsetAtTime(m_scrollLayer.get(), 5);
-    m_scrollbarController->animate(6);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
+    EXPECT_FLOAT_EQ(2.0f / 3.0f, m_scrollbarLayer->opacity());
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
+    EXPECT_FLOAT_EQ(1.0f / 3.0f, m_scrollbarLayer->opacity());
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->didUpdateScrollOffset(time);
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(7);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(8);
-    EXPECT_FLOAT_EQ(2 / 3.0f, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(9);
-    EXPECT_FLOAT_EQ(1 / 3.0f, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(10);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
+    EXPECT_FLOAT_EQ(2.0f / 3.0f, m_scrollbarLayer->opacity());
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
+    EXPECT_FLOAT_EQ(1.0f / 3.0f, m_scrollbarLayer->opacity());
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(0, m_scrollbarLayer->opacity());
 }
 
 TEST_F(ScrollbarAnimationControllerLinearFadeTest, verifyForceAwakenByPinch)
 {
-    m_scrollbarController->didPinchGestureBeginAtTime(0);
-    m_scrollbarController->didPinchGestureUpdateAtTime(0);
-    m_scrollbarController->animate(0);
+    base::TimeTicks time;
+    m_scrollbarController->didPinchGestureUpdate(time);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(1);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollLayer->setScrollDelta(gfx::Vector2d(1, 1));
-    m_scrollbarController->updateScrollOffsetAtTime(m_scrollLayer.get(), 1);
-    m_scrollbarController->animate(2);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
+    m_scrollbarController->didUpdateScrollOffset(time);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(3);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(4);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(5);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(6);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->didPinchGestureEndAtTime(6);
-    m_scrollbarController->animate(7);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->didPinchGestureEnd(time);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(8);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(9);
+
+    time += base::TimeDelta::FromSeconds(2);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(2 / 3.0f, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(10);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(1 / 3.0f, m_scrollbarLayer->opacity());
-    m_scrollbarController->animate(11);
+
+    time += base::TimeDelta::FromSeconds(1);
+    m_scrollbarController->animate(time);
     EXPECT_FLOAT_EQ(0, m_scrollbarLayer->opacity());
 
 }
Index: src/cc/animation_events.h
===================================================================
--- src/cc/animation_events.h	(revision 184497)
+++ src/cc/animation_events.h	(working copy)
@@ -7,14 +7,14 @@
 
 #include <vector>
 
-#include "cc/active_animation.h"
+#include "cc/animation.h"
 
 namespace cc {
 
 struct AnimationEvent {
     enum Type { Started, Finished };
 
-    AnimationEvent(Type type, int layerId, int groupId, ActiveAnimation::TargetProperty targetProperty, double monotonicTime)
+    AnimationEvent(Type type, int layerId, int groupId, Animation::TargetProperty targetProperty, double monotonicTime)
         : type(type)
         , layerId(layerId)
         , groupId(groupId)
@@ -26,7 +26,7 @@
     Type type;
     int layerId;
     int groupId;
-    ActiveAnimation::TargetProperty targetProperty;
+    Animation::TargetProperty targetProperty;
     double monotonicTime;
 };
 
Index: src/cc/debug_colors.cc
===================================================================
--- src/cc/debug_colors.cc	(revision 184497)
+++ src/cc/debug_colors.cc	(working copy)
@@ -18,6 +18,10 @@
 SkColor DebugColors::TiledContentLayerBorderColor() { return SkColorSetARGB(128, 255, 128, 0); }
 int DebugColors::TiledContentLayerBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
 
+// Image layers are olive.
+SkColor DebugColors::ImageLayerBorderColor() { return SkColorSetARGB(128, 128, 128, 0); }
+int DebugColors::ImageLayerBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
+
 // Non-tiled content layers area green.
 SkColor DebugColors::ContentLayerBorderColor() { return SkColorSetARGB(128, 0, 128, 32); }
 int DebugColors::ContentLayerBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
@@ -38,12 +42,24 @@
 SkColor DebugColors::SurfaceReplicaBorderColor() { return SkColorSetARGB(100, 160, 0, 255); }
 int DebugColors::SurfaceReplicaBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
 
-// Tile borders are cyan.
-SkColor DebugColors::TileBorderColor() { return SkColorSetARGB(100, 80, 200, 200); }
-int DebugColors::TileBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(1, tree_impl); }
-
 // ======= Tile colors =======
 
+// High-res tile borders are cyan.
+SkColor DebugColors::HighResTileBorderColor() { return SkColorSetARGB(100, 80, 200, 200); }
+int DebugColors::HighResTileBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(1, tree_impl); }
+
+// Low-res tile borders are purple.
+SkColor DebugColors::LowResTileBorderColor() { return SkColorSetARGB(100, 212, 83, 192); }
+int DebugColors::LowResTileBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
+
+// Other high-resolution tile borders are yellow.
+SkColor DebugColors::ExtraHighResTileBorderColor() { return SkColorSetARGB(100, 239, 231, 20); }
+int DebugColors::ExtraHighResTileBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
+
+// Other low-resolution tile borders are green.
+SkColor DebugColors::ExtraLowResTileBorderColor() { return SkColorSetARGB(100, 93, 186, 18); }
+int DebugColors::ExtraLowResTileBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
+
 // Missing tile borders are red.
 SkColor DebugColors::MissingTileBorderColor() { return SkColorSetARGB(100, 255, 0, 0); }
 int DebugColors::MissingTileBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(1, tree_impl); }
@@ -100,4 +116,12 @@
 int DebugColors::NonOccludingRectBorderWidth(const LayerTreeImpl* tree_impl) { return Scale(2, tree_impl); }
 SkColor DebugColors::NonOccludingRectFillColor() { return SkColorSetARGB(10, 200, 0, 100); }
 
+// ======= HUD widget colors =======
+
+SkColor DebugColors::PlatformLayerTreeTextColor() { return SK_ColorRED; }
+SkColor DebugColors::FPSDisplayTextAndGraphColor() { return SK_ColorRED; }
+
+// Paint time display has the same green as used for paint time in the WebInspector
+SkColor DebugColors::PaintTimeDisplayTextAndGraphColor() { return SkColorSetRGB(95, 160, 80); }
+
 }  // namespace cc
Index: src/cc/picture_pile_impl.h
===================================================================
--- src/cc/picture_pile_impl.h	(revision 184497)
+++ src/cc/picture_pile_impl.h	(working copy)
@@ -8,20 +8,17 @@
 #include <list>
 #include <map>
 
-#include "base/basictypes.h"
-#include "base/memory/ref_counted.h"
 #include "base/threading/thread.h"
 #include "cc/cc_export.h"
-#include "cc/picture.h"
-#include "cc/picture_pile.h"
-#include "cc/scoped_ptr_vector.h"
-#include "ui/gfx/rect.h"
+#include "cc/picture_pile_base.h"
+#include "skia/ext/refptr.h"
+#include "third_party/skia/include/core/SkPicture.h"
 
 namespace cc {
 struct RenderingStats;
 
-class CC_EXPORT PicturePileImpl : public base::RefCounted<PicturePileImpl> {
-public:
+class CC_EXPORT PicturePileImpl : public PicturePileBase {
+ public:
   static scoped_refptr<PicturePileImpl> Create();
 
   // Get paint-safe version of this picture for a specific thread.
@@ -39,21 +36,31 @@
       float contents_scale,
       RenderingStats* stats);
 
-  void GatherPixelRefs(const gfx::Rect&, std::list<skia::LazyPixelRef*>&);
+  void GatherPixelRefs(
+      gfx::Rect content_rect,
+      float contents_scale,
+      std::list<skia::LazyPixelRef*>& pixel_refs);
 
-private:
+  void PushPropertiesTo(PicturePileImpl* other);
+
+  skia::RefPtr<SkPicture> GetFlattenedPicture();
+
+  void set_slow_down_raster_scale_factor(int factor) {
+    slow_down_raster_scale_factor_for_debug_ = factor;
+  }
+
+ protected:
   friend class PicturePile;
 
   PicturePileImpl();
-  ~PicturePileImpl();
+  virtual ~PicturePileImpl();
 
-  PicturePile::Pile pile_;
-
   typedef std::map<base::PlatformThreadId, scoped_refptr<PicturePileImpl> >
       CloneMap;
   CloneMap clones_;
 
-  friend class base::RefCounted<PicturePileImpl>;
+  int slow_down_raster_scale_factor_for_debug_;
+
   DISALLOW_COPY_AND_ASSIGN(PicturePileImpl);
 };
 
Index: src/cc/debug_colors.h
===================================================================
--- src/cc/debug_colors.h	(revision 184497)
+++ src/cc/debug_colors.h	(working copy)
@@ -17,6 +17,9 @@
   static SkColor TiledContentLayerBorderColor();
   static int TiledContentLayerBorderWidth(const LayerTreeImpl* tree_impl);
 
+  static SkColor ImageLayerBorderColor();
+  static int ImageLayerBorderWidth(const LayerTreeImpl* tree_impl);
+
   static SkColor ContentLayerBorderColor();
   static int ContentLayerBorderWidth(const LayerTreeImpl* tree_impl);
 
@@ -32,9 +35,18 @@
   static SkColor SurfaceReplicaBorderColor();
   static int SurfaceReplicaBorderWidth(const LayerTreeImpl* tree_impl);
 
-  static SkColor TileBorderColor();
-  static int TileBorderWidth(const LayerTreeImpl* tree_impl);
+  static SkColor HighResTileBorderColor();
+  static int HighResTileBorderWidth(const LayerTreeImpl* tree_impl);
 
+  static SkColor LowResTileBorderColor();
+  static int LowResTileBorderWidth(const LayerTreeImpl* tree_impl);
+
+  static SkColor ExtraHighResTileBorderColor();
+  static int ExtraHighResTileBorderWidth(const LayerTreeImpl* tree_impl);
+
+  static SkColor ExtraLowResTileBorderColor();
+  static int ExtraLowResTileBorderWidth(const LayerTreeImpl* tree_impl);
+
   static SkColor MissingTileBorderColor();
   static int MissingTileBorderWidth(const LayerTreeImpl* tree_impl);
 
@@ -73,6 +85,10 @@
   static int NonOccludingRectBorderWidth(const LayerTreeImpl* tree_impl);
   static SkColor NonOccludingRectFillColor();
 
+  static SkColor PlatformLayerTreeTextColor();
+  static SkColor FPSDisplayTextAndGraphColor();
+  static SkColor PaintTimeDisplayTextAndGraphColor();
+
   DISALLOW_IMPLICIT_CONSTRUCTORS(DebugColors);
 };
 
Index: src/cc/tiled_layer_impl.cc
===================================================================
--- src/cc/tiled_layer_impl.cc	(revision 184497)
+++ src/cc/tiled_layer_impl.cc	(working copy)
@@ -19,8 +19,6 @@
 #include "third_party/skia/include/core/SkColor.h"
 #include "ui/gfx/quad_f.h"
 
-using namespace std;
-
 namespace cc {
 
 // Temporary diagnostic.
@@ -115,6 +113,29 @@
     *width = DebugColors::TiledContentLayerBorderWidth(layerTreeImpl());
 }
 
+scoped_ptr<LayerImpl> TiledLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return TiledLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+void TiledLayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    LayerImpl::pushPropertiesTo(layer);
+
+    TiledLayerImpl* tiledLayer = static_cast<TiledLayerImpl*>(layer);
+
+    tiledLayer->setSkipsDraw(m_skipsDraw);
+    tiledLayer->setTilingData(*m_tiler);
+
+    for (LayerTilingData::TileMap::const_iterator iter = m_tiler->tiles().begin(); iter != m_tiler->tiles().end(); ++iter) {
+        int i = iter->first.first;
+        int j = iter->first.second;
+        DrawableTile* tile = static_cast<DrawableTile*>(iter->second);
+
+        tiledLayer->pushTileProperties(i, j, tile->resourceId(), tile->opaqueRect(), tile->contentsSwizzled());
+    }
+}
+
 void TiledLayerImpl::appendQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData)
 {
     const gfx::Rect& contentRect = visibleContentRect();
@@ -140,8 +161,8 @@
                     borderColor = DebugColors::MissingTileBorderColor();
                     borderWidth = DebugColors::MissingTileBorderWidth(layerTreeImpl());
                 } else {
-                    borderColor = DebugColors::TileBorderColor();
-                    borderWidth = DebugColors::TileBorderWidth(layerTreeImpl());
+                    borderColor = DebugColors::HighResTileBorderColor();
+                    borderWidth = DebugColors::HighResTileBorderWidth(layerTreeImpl());
                 }
                 scoped_ptr<DebugBorderDrawQuad> debugBorderQuad = DebugBorderDrawQuad::Create();
                 debugBorderQuad->SetNew(sharedQuadState, tileRect, borderColor, borderWidth);
Index: src/cc/delegated_renderer_layer_impl_unittest.cc
===================================================================
--- src/cc/delegated_renderer_layer_impl_unittest.cc	(revision 184497)
+++ src/cc/delegated_renderer_layer_impl_unittest.cc	(working copy)
@@ -6,6 +6,7 @@
 
 #include "cc/append_quads_data.h"
 #include "cc/layer_tree_host_impl.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/quad_sink.h"
 #include "cc/render_pass_draw_quad.h"
 #include "cc/scoped_ptr_vector.h"
@@ -28,435 +29,1207 @@
 namespace {
 
 class DelegatedRendererLayerImplTest : public testing::Test {
-public:
-    DelegatedRendererLayerImplTest()
-        : m_proxy(scoped_ptr<Thread>(NULL))
-        , m_alwaysImplThreadAndMainThreadBlocked(&m_proxy)
-    {
-        LayerTreeSettings settings;
-        settings.minimumOcclusionTrackingSize = gfx::Size();
+ public:
+  DelegatedRendererLayerImplTest()
+      : proxy_(scoped_ptr<Thread>(NULL))
+      , always_impl_thread_and_main_thread_blocked_(&proxy_) {
+    LayerTreeSettings settings;
+    settings.minimumOcclusionTrackingSize = gfx::Size();
 
-        m_hostImpl = LayerTreeHostImpl::create(settings, &m_client, &m_proxy);
-        m_hostImpl->initializeRenderer(createFakeOutputSurface());
-        m_hostImpl->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
-    }
+    host_impl_ = LayerTreeHostImpl::create(settings, &client_, &proxy_);
+    host_impl_->initializeRenderer(createFakeOutputSurface());
+    host_impl_->setViewportSize(gfx::Size(10, 10), gfx::Size(10, 10));
+  }
 
-protected:
-    FakeProxy m_proxy;
-    FakeLayerTreeHostImplClient m_client;
-    DebugScopedSetImplThreadAndMainThreadBlocked m_alwaysImplThreadAndMainThreadBlocked;
-    scoped_ptr<LayerTreeHostImpl> m_hostImpl;
+ protected:
+  FakeProxy proxy_;
+  FakeLayerTreeHostImplClient client_;
+  DebugScopedSetImplThreadAndMainThreadBlocked
+      always_impl_thread_and_main_thread_blocked_;
+  scoped_ptr<LayerTreeHostImpl> host_impl_;
 };
 
-class DelegatedRendererLayerImplTestSimple : public DelegatedRendererLayerImplTest {
-public:
-    DelegatedRendererLayerImplTestSimple()
-        : DelegatedRendererLayerImplTest()
-    {
-        scoped_ptr<LayerImpl> rootLayer = SolidColorLayerImpl::create(m_hostImpl->activeTree(), 1).PassAs<LayerImpl>();
-        scoped_ptr<LayerImpl> layerBefore = SolidColorLayerImpl::create(m_hostImpl->activeTree(), 2).PassAs<LayerImpl>();
-        scoped_ptr<LayerImpl> layerAfter = SolidColorLayerImpl::create(m_hostImpl->activeTree(), 3).PassAs<LayerImpl>();
-        scoped_ptr<DelegatedRendererLayerImpl> delegatedRendererLayer = DelegatedRendererLayerImpl::create(m_hostImpl->activeTree(), 4);
+class DelegatedRendererLayerImplTestSimple
+    : public DelegatedRendererLayerImplTest {
+ public:
+  DelegatedRendererLayerImplTestSimple()
+      : DelegatedRendererLayerImplTest() {
+    scoped_ptr<LayerImpl> root_layer = SolidColorLayerImpl::create(
+        host_impl_->activeTree(), 1).PassAs<LayerImpl>();
+    scoped_ptr<LayerImpl> layer_before = SolidColorLayerImpl::create(
+        host_impl_->activeTree(), 2).PassAs<LayerImpl>();
+    scoped_ptr<LayerImpl> layer_after = SolidColorLayerImpl::create(
+        host_impl_->activeTree(), 3).PassAs<LayerImpl>();
+    scoped_ptr<DelegatedRendererLayerImpl> delegated_renderer_layer =
+        DelegatedRendererLayerImpl::Create(host_impl_->activeTree(), 4);
 
-        m_hostImpl->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
-        rootLayer->setBounds(gfx::Size(100, 100));
+    host_impl_->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
+    root_layer->setBounds(gfx::Size(100, 100));
 
-        layerBefore->setPosition(gfx::Point(20, 20));
-        layerBefore->setBounds(gfx::Size(14, 14));
-        layerBefore->setContentBounds(gfx::Size(14, 14));
-        layerBefore->setDrawsContent(true);
-        layerBefore->setForceRenderSurface(true);
+    layer_before->setPosition(gfx::Point(20, 20));
+    layer_before->setBounds(gfx::Size(14, 14));
+    layer_before->setContentBounds(gfx::Size(14, 14));
+    layer_before->setDrawsContent(true);
+    layer_before->setForceRenderSurface(true);
 
-        layerAfter->setPosition(gfx::Point(5, 5));
-        layerAfter->setBounds(gfx::Size(15, 15));
-        layerAfter->setContentBounds(gfx::Size(15, 15));
-        layerAfter->setDrawsContent(true);
-        layerAfter->setForceRenderSurface(true);
+    layer_after->setPosition(gfx::Point(5, 5));
+    layer_after->setBounds(gfx::Size(15, 15));
+    layer_after->setContentBounds(gfx::Size(15, 15));
+    layer_after->setDrawsContent(true);
+    layer_after->setForceRenderSurface(true);
 
-        delegatedRendererLayer->setPosition(gfx::Point(3, 3));
-        delegatedRendererLayer->setBounds(gfx::Size(10, 10));
-        delegatedRendererLayer->setContentBounds(gfx::Size(10, 10));
-        delegatedRendererLayer->setDrawsContent(true);
-        gfx::Transform transform;
-        transform.Translate(1, 1);
-        delegatedRendererLayer->setTransform(transform);
+    delegated_renderer_layer->setPosition(gfx::Point(3, 3));
+    delegated_renderer_layer->setBounds(gfx::Size(10, 10));
+    delegated_renderer_layer->setContentBounds(gfx::Size(10, 10));
+    delegated_renderer_layer->setDrawsContent(true);
+    gfx::Transform transform;
+    transform.Translate(1.0, 1.0);
+    delegated_renderer_layer->setTransform(transform);
 
-        ScopedPtrVector<RenderPass> delegatedRenderPasses;
-        TestRenderPass* pass1 = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 6), gfx::Rect(6, 6, 6, 6), gfx::Transform());
-        addQuad(pass1, gfx::Rect(0, 0, 6, 6), 33u);
-        TestRenderPass* pass2 = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 7), gfx::Rect(7, 7, 7, 7), gfx::Transform());
-        addQuad(pass2, gfx::Rect(0, 0, 7, 7), 22u);
-        addRenderPassQuad(pass2, pass1);
-        TestRenderPass* pass3 = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 8), gfx::Rect(8, 8, 8, 8), gfx::Transform());
-        addRenderPassQuad(pass3, pass2);
-        delegatedRendererLayer->setRenderPasses(delegatedRenderPasses);
+    ScopedPtrVector<RenderPass> delegated_render_passes;
+    TestRenderPass* pass1 = addRenderPass(
+        delegated_render_passes,
+        RenderPass::Id(9, 6),
+        gfx::Rect(6, 6, 6, 6),
+        gfx::Transform());
+    addQuad(pass1, gfx::Rect(0, 0, 6, 6), 33u);
+    TestRenderPass* pass2 = addRenderPass(
+        delegated_render_passes,
+        RenderPass::Id(9, 7),
+        gfx::Rect(7, 7, 7, 7),
+        gfx::Transform());
+    addQuad(pass2, gfx::Rect(0, 0, 7, 7), 22u);
+    addRenderPassQuad(pass2, pass1);
+    TestRenderPass* pass3 = addRenderPass(
+        delegated_render_passes,
+        RenderPass::Id(9, 8),
+        gfx::Rect(0, 0, 8, 8),
+        gfx::Transform());
+    addRenderPassQuad(pass3, pass2);
+    delegated_renderer_layer->SetRenderPasses(delegated_render_passes);
 
-        // The RenderPasses should be taken by the layer.
-        EXPECT_EQ(0u, delegatedRenderPasses.size());
+    // The RenderPasses should be taken by the layer.
+    EXPECT_EQ(0u, delegated_render_passes.size());
 
-        m_rootLayerPtr = rootLayer.get();
-        m_layerBeforePtr = layerBefore.get();
-        m_layerAfterPtr = layerAfter.get();
-        m_delegatedRendererLayerPtr = delegatedRendererLayer.get();
+    root_layer_ = root_layer.get();
+    layer_before_ = layer_before.get();
+    layer_after_ = layer_after.get();
+    delegated_renderer_layer_ = delegated_renderer_layer.get();
 
-        // Force the delegated RenderPasses to come before the RenderPass from layerAfter.
-        layerAfter->addChild(delegatedRendererLayer.PassAs<LayerImpl>());
-        rootLayer->addChild(layerAfter.Pass());
+    // Force the delegated RenderPasses to come before the RenderPass from
+    // layer_after.
+    layer_after->addChild(delegated_renderer_layer.PassAs<LayerImpl>());
+    root_layer->addChild(layer_after.Pass());
 
-        // Get the RenderPass generated by layerBefore to come before the delegated RenderPasses.
-        rootLayer->addChild(layerBefore.Pass());
+    // Get the RenderPass generated by layer_before to come before the delegated
+    // RenderPasses.
+    root_layer->addChild(layer_before.Pass());
+    host_impl_->activeTree()->SetRootLayer(root_layer.Pass());
+  }
 
-        m_hostImpl->setRootLayer(rootLayer.Pass());
-    }
-
-protected:
-    LayerImpl* m_rootLayerPtr;
-    LayerImpl* m_layerBeforePtr;
-    LayerImpl* m_layerAfterPtr;
-    DelegatedRendererLayerImpl* m_delegatedRendererLayerPtr;
+ protected:
+  LayerImpl* root_layer_;
+  LayerImpl* layer_before_;
+  LayerImpl* layer_after_;
+  DelegatedRendererLayerImpl* delegated_renderer_layer_;
 };
 
-TEST_F(DelegatedRendererLayerImplTestSimple, AddsContributingRenderPasses)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestSimple, AddsContributingRenderPasses) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
-    ASSERT_EQ(5u, frame.renderPasses.size());
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes.
+  ASSERT_EQ(5u, frame.renderPasses.size());
 
-    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
-    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
-    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
-    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
-    EXPECT_EQ(2, frame.renderPasses[2]->id.index);
-    // And all other RenderPasses should be non-delegated.
-    EXPECT_NE(4, frame.renderPasses[0]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[0]->id.index);
-    EXPECT_NE(4, frame.renderPasses[3]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[3]->id.index);
-    EXPECT_NE(4, frame.renderPasses[4]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[4]->id.index);
+  // The DelegatedRendererLayer should have added its contributing RenderPasses
+  // to the frame.
+  EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
+  EXPECT_EQ(1, frame.renderPasses[1]->id.index);
+  EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
+  EXPECT_EQ(2, frame.renderPasses[2]->id.index);
+  // And all other RenderPasses should be non-delegated.
+  EXPECT_NE(4, frame.renderPasses[0]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[0]->id.index);
+  EXPECT_NE(4, frame.renderPasses[3]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[3]->id.index);
+  EXPECT_NE(4, frame.renderPasses[4]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[4]->id.index);
 
-    // The DelegatedRendererLayer should have added its RenderPasses to the frame in order.
-    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[1]->output_rect);
-    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[2]->output_rect);
+  // The DelegatedRendererLayer should have added its RenderPasses to the frame
+  // in order.
+  EXPECT_EQ(gfx::Rect(6, 6, 6, 6).ToString(),
+            frame.renderPasses[1]->output_rect.ToString());
+  EXPECT_EQ(gfx::Rect(7, 7, 7, 7).ToString(),
+            frame.renderPasses[2]->output_rect.ToString());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestSimple, AddsQuadsToContributingRenderPasses)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestSimple,
+       AddsQuadsToContributingRenderPasses) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
-    ASSERT_EQ(5u, frame.renderPasses.size());
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes.
+  ASSERT_EQ(5u, frame.renderPasses.size());
 
-    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
-    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
-    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
-    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
-    EXPECT_EQ(2, frame.renderPasses[2]->id.index);
+  // The DelegatedRendererLayer should have added its contributing RenderPasses
+  // to the frame.
+  EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
+  EXPECT_EQ(1, frame.renderPasses[1]->id.index);
+  EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
+  EXPECT_EQ(2, frame.renderPasses[2]->id.index);
 
-    // The DelegatedRendererLayer should have added copies of its quads to contributing RenderPasses.
-    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);
+  // The DelegatedRendererLayer should have added copies of its quads to
+  // contributing RenderPasses.
+  ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
+  EXPECT_EQ(gfx::Rect(0, 0, 6, 6).ToString(),
+            frame.renderPasses[1]->quad_list[0]->rect.ToString());
 
-    // Verify it added the right quads.
-    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 7, 7), frame.renderPasses[2]->quad_list[0]->rect);
-    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[2]->quad_list[1]->rect);
-    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);
+  // Verify it added the right quads.
+  ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
+  EXPECT_EQ(gfx::Rect(0, 0, 7, 7).ToString(),
+            frame.renderPasses[2]->quad_list[0]->rect.ToString());
+  EXPECT_EQ(gfx::Rect(6, 6, 6, 6).ToString(),
+            frame.renderPasses[2]->quad_list[1]->rect.ToString());
+  ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
+  EXPECT_EQ(gfx::Rect(0, 0, 6, 6).ToString(),
+            frame.renderPasses[1]->quad_list[0]->rect.ToString());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestSimple, AddsQuadsToTargetRenderPass)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestSimple, AddsQuadsToTargetRenderPass) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
-    ASSERT_EQ(5u, frame.renderPasses.size());
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes.
+  ASSERT_EQ(5u, frame.renderPasses.size());
 
-    // The layer's target is the RenderPass from m_layerAfter.
-    EXPECT_EQ(RenderPass::Id(3, 0), frame.renderPasses[3]->id);
+  // The layer's target is the RenderPass from m_layer_after.
+  EXPECT_EQ(RenderPass::Id(3, 0), frame.renderPasses[3]->id);
 
-    // The DelegatedRendererLayer should have added copies of quads in its root RenderPass to its target RenderPass.
-    // The m_layerAfter also adds one quad.
-    ASSERT_EQ(2u, frame.renderPasses[3]->quad_list.size());
+  // The DelegatedRendererLayer should have added copies of quads in its root
+  // RenderPass to its target RenderPass. The m_layer_after also adds one quad.
+  ASSERT_EQ(2u, frame.renderPasses[3]->quad_list.size());
 
-    // Verify it added the right quads.
-    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[3]->quad_list[0]->rect);
+  // Verify it added the right quads.
+  EXPECT_EQ(gfx::Rect(7, 7, 7, 7).ToString(),
+            frame.renderPasses[3]->quad_list[0]->rect.ToString());
 
-    // Its target layer should have a quad as well.
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 15, 15), frame.renderPasses[3]->quad_list[1]->rect);
+  // Its target layer should have a quad as well.
+  EXPECT_EQ(gfx::Rect(0, 0, 15, 15).ToString(),
+            frame.renderPasses[3]->quad_list[1]->rect.ToString());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestSimple, QuadsFromRootRenderPassAreModifiedForTheTarget)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestSimple,
+       QuadsFromRootRenderPassAreModifiedForTheTarget) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes.
-    ASSERT_EQ(5u, frame.renderPasses.size());
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes.
+  ASSERT_EQ(5u, frame.renderPasses.size());
 
-    // The DelegatedRendererLayer is at position 3,3 compared to its target, and has a translation transform of 1,1.
-    // So its root RenderPass' quads should all be transformed by that combined amount.
-    gfx::Transform transform;
-    transform.Translate(4, 4);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(transform, frame.renderPasses[3]->quad_list[0]->quadTransform());
+  // The DelegatedRendererLayer is at position 3,3 compared to its target, and
+  // has a translation transform of 1,1. So its root RenderPass' quads should
+  // all be transformed by that combined amount.
+  // The DelegatedRendererLayer has a size of 10x10, but the root delegated
+  // RenderPass has a size of 8x8, so any quads should be scaled by 10/8.
+  gfx::Transform transform;
+  transform.Translate(4.0, 4.0);
+  transform.Scale(10.0 / 8.0, 10.0 / 8.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      transform, frame.renderPasses[3]->quad_list[0]->quadTransform());
 
-    // Quads from non-root RenderPasses should not be shifted though.
-    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[0]->quadTransform());
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[1]->quadTransform());
-    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[1]->quad_list[0]->quadTransform());
+  // Quads from non-root RenderPasses should not be shifted though.
+  ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      gfx::Transform(), frame.renderPasses[2]->quad_list[0]->quadTransform());
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      gfx::Transform(), frame.renderPasses[2]->quad_list[1]->quadTransform());
+  ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      gfx::Transform(), frame.renderPasses[1]->quad_list[0]->quadTransform());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestSimple, DoesNotOwnARenderSurface)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestSimple, DoesNotOwnARenderSurface) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // If the DelegatedRendererLayer is axis aligned and has opacity 1, then
-    // it has no need to be a renderSurface for the quads it carries.
-    EXPECT_FALSE(m_delegatedRendererLayerPtr->renderSurface());
+  // If the DelegatedRendererLayer is axis aligned and has opacity 1, then it
+  // has no need to be a renderSurface for the quads it carries.
+  EXPECT_FALSE(delegated_renderer_layer_->renderSurface());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestSimple, DoesOwnARenderSurface)
-{
-    m_delegatedRendererLayerPtr->setOpacity(0.5f);
+TEST_F(DelegatedRendererLayerImplTestSimple, DoesOwnARenderSurfaceForOpacity) {
+  delegated_renderer_layer_->setOpacity(0.5f);
 
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // This test case has quads from multiple layers in the delegated renderer,
-    // so if the DelegatedRendererLayer has opacity < 1, it should end up with
-    // a render surface.
-    EXPECT_TRUE(m_delegatedRendererLayerPtr->renderSurface());
+  // This test case has quads from multiple layers in the delegated renderer, so
+  // if the DelegatedRendererLayer has opacity < 1, it should end up with a
+  // render surface.
+  EXPECT_TRUE(delegated_renderer_layer_->renderSurface());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-class DelegatedRendererLayerImplTestOwnSurface : public DelegatedRendererLayerImplTestSimple {
-public:
-    DelegatedRendererLayerImplTestOwnSurface()
-        : DelegatedRendererLayerImplTestSimple()
+TEST_F(DelegatedRendererLayerImplTestSimple,
+       DoesOwnARenderSurfaceForTransform) {
+  gfx::Transform rotation;
+  rotation.RotateAboutZAxis(30.0);
+  delegated_renderer_layer_->setTransform(rotation);
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  // This test case has quads from multiple layers in the delegated renderer, so
+  // if the DelegatedRendererLayer has opacity < 1, it should end up with a
+  // render surface.
+  EXPECT_TRUE(delegated_renderer_layer_->renderSurface());
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+class DelegatedRendererLayerImplTestOwnSurface
+    : public DelegatedRendererLayerImplTestSimple {
+ public:
+  DelegatedRendererLayerImplTestOwnSurface()
+      : DelegatedRendererLayerImplTestSimple() {
+    delegated_renderer_layer_->setForceRenderSurface(true);
+  }
+};
+
+TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsRenderPasses) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes and its owned surface
+  // added one pass.
+  ASSERT_EQ(6u, frame.renderPasses.size());
+
+  // The DelegatedRendererLayer should have added its contributing RenderPasses
+  // to the frame.
+  EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
+  EXPECT_EQ(1, frame.renderPasses[1]->id.index);
+  EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
+  EXPECT_EQ(2, frame.renderPasses[2]->id.index);
+  // The DelegatedRendererLayer should have added a RenderPass for its surface
+  // to the frame.
+  EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[3]->id.index);
+  // And all other RenderPasses should be non-delegated.
+  EXPECT_NE(4, frame.renderPasses[0]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[0]->id.index);
+  EXPECT_NE(4, frame.renderPasses[4]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[4]->id.index);
+  EXPECT_NE(4, frame.renderPasses[5]->id.layer_id);
+  EXPECT_EQ(0, frame.renderPasses[5]->id.index);
+
+  // The DelegatedRendererLayer should have added its RenderPasses to the frame
+  // in order.
+  EXPECT_EQ(gfx::Rect(6, 6, 6, 6).ToString(),
+            frame.renderPasses[1]->output_rect.ToString());
+  EXPECT_EQ(gfx::Rect(7, 7, 7, 7).ToString(),
+            frame.renderPasses[2]->output_rect.ToString());
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestOwnSurface,
+       AddsQuadsToContributingRenderPasses) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes and its owned surface
+  // added one pass.
+  ASSERT_EQ(6u, frame.renderPasses.size());
+
+  // The DelegatedRendererLayer should have added its contributing RenderPasses
+  // to the frame.
+  EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
+  EXPECT_EQ(1, frame.renderPasses[1]->id.index);
+  EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
+  EXPECT_EQ(2, frame.renderPasses[2]->id.index);
+
+  // The DelegatedRendererLayer should have added copies of its quads to
+  // contributing RenderPasses.
+  ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
+  EXPECT_EQ(gfx::Rect(0, 0, 6, 6).ToString(),
+            frame.renderPasses[1]->quad_list[0]->rect.ToString());
+
+  // Verify it added the right quads.
+  ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
+  EXPECT_EQ(gfx::Rect(0, 0, 7, 7).ToString(),
+            frame.renderPasses[2]->quad_list[0]->rect.ToString());
+  EXPECT_EQ(gfx::Rect(6, 6, 6, 6).ToString(),
+            frame.renderPasses[2]->quad_list[1]->rect.ToString());
+  ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
+  EXPECT_EQ(gfx::Rect(0, 0, 6, 6).ToString(),
+            frame.renderPasses[1]->quad_list[0]->rect.ToString());
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsQuadsToTargetRenderPass) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes and its owned surface
+  // added one pass.
+  ASSERT_EQ(6u, frame.renderPasses.size());
+
+  // The layer's target is the RenderPass owned by itself.
+  EXPECT_EQ(RenderPass::Id(4, 0), frame.renderPasses[3]->id);
+
+  // The DelegatedRendererLayer should have added copies of quads in its root
+  // RenderPass to its target RenderPass.
+  // The m_layer_after also adds one quad.
+  ASSERT_EQ(1u, frame.renderPasses[3]->quad_list.size());
+
+  // Verify it added the right quads.
+  EXPECT_EQ(gfx::Rect(7, 7, 7, 7).ToString(),
+            frame.renderPasses[3]->quad_list[0]->rect.ToString());
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestOwnSurface,
+       QuadsFromRootRenderPassAreNotModifiedForTheTarget) {
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  // Each non-DelegatedRendererLayer added one RenderPass. The
+  // DelegatedRendererLayer added two contributing passes and its owned surface
+  // added one pass.
+  ASSERT_EQ(6u, frame.renderPasses.size());
+
+  // Because the DelegatedRendererLayer owns a RenderSurfaceImpl, its root
+  // RenderPass' quads do not need to be translated at all. However, they are
+  // scaled from the frame's size (8x8) to the layer's bounds (10x10).
+  gfx::Transform transform;
+  transform.Scale(10.0 / 8.0, 10.0 / 8.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      transform, frame.renderPasses[3]->quad_list[0]->quadTransform());
+
+  // Quads from non-root RenderPasses should not be shifted either.
+  ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      gfx::Transform(), frame.renderPasses[2]->quad_list[0]->quadTransform());
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      gfx::Transform(), frame.renderPasses[2]->quad_list[1]->quadTransform());
+  ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      gfx::Transform(), frame.renderPasses[1]->quad_list[0]->quadTransform());
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+class DelegatedRendererLayerImplTestTransform
+    : public DelegatedRendererLayerImplTest {
+ public:
+  void SetUpTest() {
+    scoped_ptr<LayerImpl> root_layer = LayerImpl::create(
+        host_impl_->activeTree(), 1);
+    scoped_ptr<DelegatedRendererLayerImpl> delegated_renderer_layer =
+        DelegatedRendererLayerImpl::Create(host_impl_->activeTree(), 2);
+
+    host_impl_->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
+    root_layer->setBounds(gfx::Size(100, 100));
+
+    delegated_renderer_layer->setPosition(gfx::Point(20, 20));
+    delegated_renderer_layer->setBounds(gfx::Size(30, 30)); 
+    delegated_renderer_layer->setContentBounds(gfx::Size(30, 30));
+    delegated_renderer_layer->setDrawsContent(true);
+    gfx::Transform transform;
+    transform.Scale(2.0, 2.0);
+    transform.Translate(8.0, 8.0);
+    delegated_renderer_layer->setTransform(transform);
+
+    ScopedPtrVector<RenderPass> delegated_render_passes;
+
+    gfx::Rect child_pass_rect(20, 20, 7, 7);
+    gfx::Transform child_pass_transform;
+    child_pass_transform.Scale(0.8, 0.8);
+    child_pass_transform.Translate(9.0, 9.0);
+    gfx::Rect child_pass_clip_rect(21, 21, 3, 3);
+    bool child_pass_clipped = false;
+
     {
-        m_delegatedRendererLayerPtr->setForceRenderSurface(true);
+      TestRenderPass* pass = addRenderPass(
+          delegated_render_passes,
+          RenderPass::Id(10, 7),
+          child_pass_rect,
+          gfx::Transform());
+      MockQuadCuller quad_sink(pass->quad_list, pass->shared_quad_state_list);
+      AppendQuadsData data(pass->id);
+      SharedQuadState* shared_quad_state = quad_sink.useSharedQuadState(
+          SharedQuadState::Create());
+      shared_quad_state->SetAll(
+          child_pass_transform,
+          child_pass_rect,
+          child_pass_clip_rect,
+          child_pass_clipped,
+          1.f);
+
+      scoped_ptr<SolidColorDrawQuad> color_quad;
+      color_quad = SolidColorDrawQuad::Create();
+      color_quad->SetNew(shared_quad_state, gfx::Rect(20, 20, 3, 7), 1u);
+      quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
+
+      color_quad = SolidColorDrawQuad::Create();
+      color_quad->SetNew(shared_quad_state, gfx::Rect(23, 20, 4, 7), 1u);
+      quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
     }
+
+    gfx::Rect root_pass_rect(0, 0, 50, 50);
+    gfx::Transform root_pass_transform;
+    root_pass_transform.Scale(1.5, 1.5);
+    root_pass_transform.Translate(7.0, 7.0);
+    gfx::Rect root_pass_clip_rect(10, 10, 35, 35);
+    bool root_pass_clipped = root_delegated_render_pass_is_clipped_;
+
+    TestRenderPass* pass = addRenderPass(
+        delegated_render_passes,
+        RenderPass::Id(9, 6),
+        root_pass_rect,
+        gfx::Transform());
+    MockQuadCuller quad_sink(pass->quad_list, pass->shared_quad_state_list);
+    AppendQuadsData data(pass->id);
+    SharedQuadState* shared_quad_state = quad_sink.useSharedQuadState(SharedQuadState::Create());
+    shared_quad_state->SetAll(
+        root_pass_transform,
+        root_pass_rect,
+        root_pass_clip_rect,
+        root_pass_clipped,
+        1.f);
+
+    scoped_ptr<RenderPassDrawQuad> render_pass_quad =
+        RenderPassDrawQuad::Create();
+    render_pass_quad->SetNew(
+        shared_quad_state,
+        gfx::Rect(5, 5, 7, 7),  // rect
+        RenderPass::Id(10, 7),  // render_pass_id
+        false,  // is_replica
+        0,  // mask_resource_id
+        child_pass_rect,  // contents_changed_since_last_frame
+        gfx::RectF(),  // mask_uv_rect
+        WebKit::WebFilterOperations(),  // filters
+        skia::RefPtr<SkImageFilter>(),  // filter
+        WebKit::WebFilterOperations());  // background_filters
+    quad_sink.append(render_pass_quad.PassAs<DrawQuad>(), data);
+
+    scoped_ptr<SolidColorDrawQuad> color_quad;
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(0, 0, 10, 10), 1u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
+
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(0, 10, 10, 10), 2u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
+
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(10, 0, 10, 10), 3u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
+
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(10, 10, 10, 10), 4u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
+
+    delegated_renderer_layer->SetRenderPasses(delegated_render_passes);
+
+    // The RenderPasses should be taken by the layer.
+    EXPECT_EQ(0u, delegated_render_passes.size());
+
+    root_layer_ = root_layer.get();
+    delegated_renderer_layer_ = delegated_renderer_layer.get();
+
+    root_layer->addChild(delegated_renderer_layer.PassAs<LayerImpl>());
+    host_impl_->activeTree()->SetRootLayer(root_layer.Pass());
+  }
+
+  void VerifyRenderPasses(
+      const LayerTreeHostImpl::FrameData& frame,
+      size_t num_render_passes,
+      const SharedQuadState** root_delegated_shared_quad_state,
+      const SharedQuadState** contrib_delegated_shared_quad_state) {
+    ASSERT_EQ(num_render_passes, frame.renderPasses.size());
+    // The contributing render pass in the DelegatedRendererLayer.
+    EXPECT_EQ(2, frame.renderPasses[0]->id.layer_id);
+    EXPECT_EQ(1, frame.renderPasses[0]->id.index);
+    // The root render pass.
+    EXPECT_EQ(1, frame.renderPasses.back()->id.layer_id);
+    EXPECT_EQ(0, frame.renderPasses.back()->id.index);
+
+    const QuadList& contrib_delegated_quad_list =
+        frame.renderPasses[0]->quad_list;
+    ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+
+    const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+    ASSERT_EQ(5u, root_delegated_quad_list.size());
+
+    // All quads in a render pass should share the same state.
+    *contrib_delegated_shared_quad_state =
+        contrib_delegated_quad_list[0]->shared_quad_state;
+    EXPECT_EQ(*contrib_delegated_shared_quad_state,
+              contrib_delegated_quad_list[1]->shared_quad_state);
+
+    *root_delegated_shared_quad_state =
+        root_delegated_quad_list[0]->shared_quad_state;
+    EXPECT_EQ(*root_delegated_shared_quad_state,
+              root_delegated_quad_list[1]->shared_quad_state);
+    EXPECT_EQ(*root_delegated_shared_quad_state,
+              root_delegated_quad_list[2]->shared_quad_state);
+    EXPECT_EQ(*root_delegated_shared_quad_state,
+              root_delegated_quad_list[3]->shared_quad_state);
+    EXPECT_EQ(*root_delegated_shared_quad_state,
+              root_delegated_quad_list[4]->shared_quad_state);
+
+    EXPECT_NE(*contrib_delegated_shared_quad_state,
+              *root_delegated_shared_quad_state);
+  }
+
+ protected:
+  LayerImpl* root_layer_;
+  DelegatedRendererLayerImpl* delegated_renderer_layer_;
+  bool root_delegated_render_pass_is_clipped_;
 };
 
-TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsRenderPasses)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestTransform, QuadsUnclipped_NoSurface) {
+  root_delegated_render_pass_is_clipped_ = false;
+  SetUpTest();
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
-    ASSERT_EQ(6u, frame.renderPasses.size());
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
-    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
-    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
-    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
-    EXPECT_EQ(2, frame.renderPasses[2]->id.index);
-    // The DelegatedRendererLayer should have added a RenderPass for its surface to the frame.
-    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[3]->id.index);
-    // And all other RenderPasses should be non-delegated.
-    EXPECT_NE(4, frame.renderPasses[0]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[0]->id.index);
-    EXPECT_NE(4, frame.renderPasses[4]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[4]->id.index);
-    EXPECT_NE(4, frame.renderPasses[5]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[5]->id.index);
+  const SharedQuadState* root_delegated_shared_quad_state = NULL;
+  const SharedQuadState* contrib_delegated_shared_quad_state = NULL;
+  VerifyRenderPasses(
+      frame,
+      2,
+      &root_delegated_shared_quad_state,
+      &contrib_delegated_shared_quad_state);
 
-    // The DelegatedRendererLayer should have added its RenderPasses to the frame in order.
-    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[1]->output_rect);
-    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[2]->output_rect);
+  // When the quads don't have a clip of their own, the clip rect is set to
+  // the drawableContentRect of the delegated renderer layer.
+  EXPECT_EQ(gfx::Rect(21, 21, 60, 60).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  // Even though the quads in the root pass have no clip of their own, they
+  // inherit the clip rect from the delegated renderer layer if it does not
+  // own a surface.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  gfx::Transform expected;
+  // This is the transform from the layer's space to its target.
+  // The position (20) - the width / scale (30 / 2) = 20 - 15 = 5
+  expected.Translate(5.0, 5.0);
+  expected.Scale(2.0, 2.0);
+  expected.Translate(8.0, 8.0);
+  // The frame has size 50x50 but the layer's bounds are 30x30.
+  expected.Scale(30.0 / 50.0, 30.0 / 50.0);
+  // This is the transform within the source frame.
+  expected.Scale(1.5, 1.5);
+  expected.Translate(7.0, 7.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, root_delegated_shared_quad_state->content_to_target_transform);
+
+  // The contributing render pass should not be transformed from its input.
+  EXPECT_EQ(gfx::Rect(21, 21, 3, 3).ToString(),
+            contrib_delegated_shared_quad_state->clip_rect.ToString());
+  EXPECT_FALSE(contrib_delegated_shared_quad_state->is_clipped);
+  expected.MakeIdentity();
+  expected.Scale(0.8, 0.8);
+  expected.Translate(9.0, 9.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected,
+      contrib_delegated_shared_quad_state->content_to_target_transform);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsQuadsToContributingRenderPasses)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestTransform, QuadsClipped_NoSurface) {
+  root_delegated_render_pass_is_clipped_ = true;
+  SetUpTest();
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
-    ASSERT_EQ(6u, frame.renderPasses.size());
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // The DelegatedRendererLayer should have added its contributing RenderPasses to the frame.
-    EXPECT_EQ(4, frame.renderPasses[1]->id.layer_id);
-    EXPECT_EQ(1, frame.renderPasses[1]->id.index);
-    EXPECT_EQ(4, frame.renderPasses[2]->id.layer_id);
-    EXPECT_EQ(2, frame.renderPasses[2]->id.index);
+  const SharedQuadState* root_delegated_shared_quad_state = NULL;
+  const SharedQuadState* contrib_delegated_shared_quad_state = NULL;
+  VerifyRenderPasses(
+      frame,
+      2,
+      &root_delegated_shared_quad_state,
+      &contrib_delegated_shared_quad_state);
 
-    // The DelegatedRendererLayer should have added copies of its quads to contributing RenderPasses.
-    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);
+  // Since the quads have a clip_rect it should be modified by delegated
+  // renderer layer's drawTransform.
+  // The position of the resulting clip_rect is:
+  // (clip rect position (10) * scale to layer (30/50) + translate (8)) *
+  //     layer scale (2) + layer position (20) = 48
+  // But the layer is centered, so: 48 - (width / 2) = 48 - 30 / 2 = 33
+  //
+  // The size is 35x35 scaled to fit inside the layer's bounds at 30x30 from
+  // a frame at 50x50: 35 * 2 (layer's scale) * 30 / 50 = 42.
+  EXPECT_EQ(gfx::Rect(33, 33, 42, 42).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
 
-    // Verify it added the right quads.
-    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 7, 7), frame.renderPasses[2]->quad_list[0]->rect);
-    EXPECT_RECT_EQ(gfx::Rect(6, 6, 6, 6), frame.renderPasses[2]->quad_list[1]->rect);
-    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
-    EXPECT_RECT_EQ(gfx::Rect(0, 0, 6, 6), frame.renderPasses[1]->quad_list[0]->rect);
+  // The quads had a clip and it should be preserved.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  gfx::Transform expected;
+  // This is the transform from the layer's space to its target.
+  // The position (20) - the width / scale (30 / 2) = 20 - 15 = 5
+  expected.Translate(5.0, 5.0);
+  expected.Scale(2.0, 2.0);
+  expected.Translate(8.0, 8.0);
+  // The frame has size 50x50 but the layer's bounds are 30x30.
+  expected.Scale(30.0 / 50.0, 30.0 / 50.0);
+  // This is the transform within the source frame.
+  expected.Scale(1.5, 1.5);
+  expected.Translate(7.0, 7.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, root_delegated_shared_quad_state->content_to_target_transform);
+
+  // The contributing render pass should not be transformed from its input.
+  EXPECT_EQ(gfx::Rect(21, 21, 3, 3).ToString(),
+            contrib_delegated_shared_quad_state->clip_rect.ToString());
+  EXPECT_FALSE(contrib_delegated_shared_quad_state->is_clipped);
+  expected.MakeIdentity();
+  expected.Scale(0.8, 0.8);
+  expected.Translate(9.0, 9.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected,
+      contrib_delegated_shared_quad_state->content_to_target_transform);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestOwnSurface, AddsQuadsToTargetRenderPass)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestTransform, QuadsUnclipped_Surface) {
+  root_delegated_render_pass_is_clipped_ = false;
+  SetUpTest();
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
-    ASSERT_EQ(6u, frame.renderPasses.size());
+  delegated_renderer_layer_->setForceRenderSurface(true);
 
-    // The layer's target is the RenderPass owned by itself.
-    EXPECT_EQ(RenderPass::Id(4, 0), frame.renderPasses[3]->id);
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // The DelegatedRendererLayer should have added copies of quads in its root RenderPass to its target RenderPass.
-    // The m_layerAfter also adds one quad.
-    ASSERT_EQ(1u, frame.renderPasses[3]->quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state = NULL;
+  const SharedQuadState* contrib_delegated_shared_quad_state = NULL;
+  VerifyRenderPasses(
+      frame,
+      3,
+      &root_delegated_shared_quad_state,
+      &contrib_delegated_shared_quad_state);
 
-    // Verify it added the right quads.
-    EXPECT_RECT_EQ(gfx::Rect(7, 7, 7, 7), frame.renderPasses[3]->quad_list[0]->rect);
+  // When the layer owns a surface, then its position and translation are not
+  // a part of its draw transform.
+  // The position of the resulting clip_rect is:
+  // (clip rect position (10) * scale to layer (30/50)) * layer scale (2) = 12
+  // The size is 35x35 scaled to fit inside the layer's bounds at 30x30 from
+  // a frame at 50x50: 35 * 2 (layer's scale) * 30 / 50 = 42.
+  EXPECT_EQ(gfx::Rect(12, 12, 42, 42).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  // Since the layer owns a surface it doesn't need to clip its quads, so
+  // unclipped quads remain unclipped.
+  EXPECT_FALSE(root_delegated_shared_quad_state->is_clipped);
+
+  gfx::Transform expected;
+  expected.Scale(2.0, 2.0);
+  // The frame has size 50x50 but the layer's bounds are 30x30.
+  expected.Scale(30.0 / 50.0, 30.0 / 50.0);
+  // This is the transform within the source frame.
+  expected.Scale(1.5, 1.5);
+  expected.Translate(7.0, 7.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, root_delegated_shared_quad_state->content_to_target_transform);
+
+  // The contributing render pass should not be transformed from its input.
+  EXPECT_EQ(gfx::Rect(21, 21, 3, 3).ToString(),
+            contrib_delegated_shared_quad_state->clip_rect.ToString());
+  EXPECT_FALSE(contrib_delegated_shared_quad_state->is_clipped);
+  expected.MakeIdentity();
+  expected.Scale(0.8, 0.8);
+  expected.Translate(9.0, 9.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected,
+      contrib_delegated_shared_quad_state->content_to_target_transform);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-TEST_F(DelegatedRendererLayerImplTestOwnSurface, QuadsFromRootRenderPassAreNotModifiedForTheTarget)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestTransform, QuadsClipped_Surface) {
+  root_delegated_render_pass_is_clipped_ = true;
+  SetUpTest();
 
-    // Each non-DelegatedRendererLayer added one RenderPass. The DelegatedRendererLayer added two contributing passes and its owned surface added one pass.
-    ASSERT_EQ(6u, frame.renderPasses.size());
+  delegated_renderer_layer_->setForceRenderSurface(true);
 
-    // Because the DelegatedRendererLayer owns a RenderSurfaceImpl, its root RenderPass' quads do not need to be
-    // modified at all.
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[3]->quad_list[0]->quadTransform());
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    // Quads from non-root RenderPasses should not be shifted though.
-    ASSERT_EQ(2u, frame.renderPasses[2]->quad_list.size());
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[0]->quadTransform());
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[2]->quad_list[1]->quadTransform());
-    ASSERT_EQ(1u, frame.renderPasses[1]->quad_list.size());
-    EXPECT_TRANSFORMATION_MATRIX_EQ(gfx::Transform(), frame.renderPasses[1]->quad_list[0]->quadTransform());
+  const SharedQuadState* root_delegated_shared_quad_state = NULL;
+  const SharedQuadState* contrib_delegated_shared_quad_state = NULL;
+  VerifyRenderPasses(
+      frame,
+      3,
+      &root_delegated_shared_quad_state,
+      &contrib_delegated_shared_quad_state);
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+  // When the layer owns a surface, then its position and translation are not
+  // a part of its draw transform.
+  // The position of the resulting clip_rect is:
+  // (clip rect position (10) * scale to layer (30/50)) * layer scale (2) = 12
+  // The size is 35x35 scaled to fit inside the layer's bounds at 30x30 from
+  // a frame at 50x50: 35 * 2 (layer's scale) * 30 / 50 = 42.
+  EXPECT_EQ(gfx::Rect(12, 12, 42, 42).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+
+  // The quads had a clip and it should be preserved.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  gfx::Transform expected;
+  expected.Scale(2.0, 2.0);
+  // The frame has size 50x50 but the layer's bounds are 30x30.
+  expected.Scale(30.0 / 50.0, 30.0 / 50.0);
+  // This is the transform within the source frame.
+  expected.Scale(1.5, 1.5);
+  expected.Translate(7.0, 7.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, root_delegated_shared_quad_state->content_to_target_transform);
+
+  // The contributing render pass should not be transformed from its input.
+  EXPECT_EQ(gfx::Rect(21, 21, 3, 3).ToString(),
+            contrib_delegated_shared_quad_state->clip_rect.ToString());
+  EXPECT_FALSE(contrib_delegated_shared_quad_state->is_clipped);
+  expected.MakeIdentity();
+  expected.Scale(0.8, 0.8);
+  expected.Translate(9.0, 9.0);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected,
+      contrib_delegated_shared_quad_state->content_to_target_transform);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
-class DelegatedRendererLayerImplTestSharedData : public DelegatedRendererLayerImplTest {
-public:
-    DelegatedRendererLayerImplTestSharedData()
-        : DelegatedRendererLayerImplTest()
+class DelegatedRendererLayerImplTestClip
+    : public DelegatedRendererLayerImplTest {
+ public:
+  void SetUpTest() {
+    scoped_ptr<LayerImpl> root_layer =
+        LayerImpl::create(host_impl_->activeTree(), 1);
+    scoped_ptr<DelegatedRendererLayerImpl> delegated_renderer_layer =
+        DelegatedRendererLayerImpl::Create(host_impl_->activeTree(), 2);
+    scoped_ptr<LayerImpl> clip_layer =
+        LayerImpl::create(host_impl_->activeTree(), 3);
+    scoped_ptr<LayerImpl> origin_layer =
+        LayerImpl::create(host_impl_->activeTree(), 4);
+
+    host_impl_->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
+    root_layer->setBounds(gfx::Size(100, 100));
+
+    delegated_renderer_layer->setPosition(gfx::Point(20, 20));
+    delegated_renderer_layer->setBounds(gfx::Size(50, 50)); 
+    delegated_renderer_layer->setContentBounds(gfx::Size(50, 50));
+    delegated_renderer_layer->setDrawsContent(true);
+
+    ScopedPtrVector<RenderPass> delegated_render_passes;
+
+    gfx::Rect child_pass_rect(20, 20, 7, 7);
+    gfx::Transform child_pass_transform;
+    gfx::Rect child_pass_clip_rect(21, 21, 3, 3);
+    bool child_pass_clipped = false;
+
     {
-        scoped_ptr<LayerImpl> rootLayer = LayerImpl::create(m_hostImpl->activeTree(), 1);
-        scoped_ptr<DelegatedRendererLayerImpl> delegatedRendererLayer = DelegatedRendererLayerImpl::create(m_hostImpl->activeTree(), 2);
+      TestRenderPass* pass = addRenderPass(
+          delegated_render_passes,
+          RenderPass::Id(10, 7),
+          child_pass_rect,
+          gfx::Transform());
+      MockQuadCuller quad_sink(pass->quad_list, pass->shared_quad_state_list);
+      AppendQuadsData data(pass->id);
+      SharedQuadState* shared_quad_state =
+          quad_sink.useSharedQuadState(SharedQuadState::Create());
+      shared_quad_state->SetAll(
+          child_pass_transform,
+          child_pass_rect,
+          child_pass_clip_rect,
+          child_pass_clipped,
+          1.f);
 
-        m_hostImpl->setViewportSize(gfx::Size(100, 100), gfx::Size(100, 100));
-        rootLayer->setBounds(gfx::Size(100, 100));
+      scoped_ptr<SolidColorDrawQuad> color_quad;
+      color_quad = SolidColorDrawQuad::Create();
+      color_quad->SetNew(shared_quad_state, gfx::Rect(20, 20, 3, 7), 1u);
+      quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
 
-        delegatedRendererLayer->setPosition(gfx::Point(20, 20));
-        delegatedRendererLayer->setBounds(gfx::Size(20, 20));
-        delegatedRendererLayer->setContentBounds(gfx::Size(20, 20));
-        delegatedRendererLayer->setDrawsContent(true);
-        gfx::Transform transform;
-        transform.Translate(10, 10);
-        delegatedRendererLayer->setTransform(transform);
+      color_quad = SolidColorDrawQuad::Create();
+      color_quad->SetNew(shared_quad_state, gfx::Rect(23, 20, 4, 7), 1u);
+      quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
+    }
 
-        ScopedPtrVector<RenderPass> delegatedRenderPasses;
-        gfx::Rect passRect(0, 0, 50, 50);
-        TestRenderPass* pass = addRenderPass(delegatedRenderPasses, RenderPass::Id(9, 6), passRect, gfx::Transform());
-        MockQuadCuller quadSink(pass->quad_list, pass->shared_quad_state_list);
-        AppendQuadsData data(pass->id);
-        SharedQuadState* sharedState = quadSink.useSharedQuadState(SharedQuadState::Create());
-        sharedState->SetAll(gfx::Transform(), passRect, passRect, passRect, false, 1);
-        scoped_ptr<SolidColorDrawQuad> colorQuad;
+    gfx::Rect root_pass_rect(0, 0, 50, 50);
+    gfx::Transform root_pass_transform;
+    gfx::Rect root_pass_clip_rect(5, 5, 40, 40);
+    bool root_pass_clipped = root_delegated_render_pass_is_clipped_;
 
-        colorQuad = SolidColorDrawQuad::Create();
-        colorQuad->SetNew(sharedState, gfx::Rect(0, 0, 10, 10), 1u);
-        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);
+    TestRenderPass* pass = addRenderPass(
+        delegated_render_passes,
+        RenderPass::Id(9, 6),
+        root_pass_rect,
+        gfx::Transform());
+    MockQuadCuller quad_sink(pass->quad_list, pass->shared_quad_state_list);
+    AppendQuadsData data(pass->id);
+    SharedQuadState* shared_quad_state =
+        quad_sink.useSharedQuadState(SharedQuadState::Create());
+    shared_quad_state->SetAll(root_pass_transform, root_pass_rect, root_pass_clip_rect, root_pass_clipped, 1);
 
-        colorQuad = SolidColorDrawQuad::Create();
-        colorQuad->SetNew(sharedState, gfx::Rect(0, 10, 10, 10), 2u);
-        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);
+    scoped_ptr<RenderPassDrawQuad> render_pass_quad =
+        RenderPassDrawQuad::Create();
+    render_pass_quad->SetNew(
+        shared_quad_state,
+        gfx::Rect(5, 5, 7, 7),  // rect
+        RenderPass::Id(10, 7),  // render_pass_id
+        false,  // is_replica
+        0,  // mask_resource_id
+        child_pass_rect,  // contents_changed_since_last_frame
+        gfx::RectF(),  // mask_uv_rect
+        WebKit::WebFilterOperations(),  // filters
+        skia::RefPtr<SkImageFilter>(),  // filter
+        WebKit::WebFilterOperations());  // background_filters
+    quad_sink.append(render_pass_quad.PassAs<DrawQuad>(), data);
 
-        colorQuad = SolidColorDrawQuad::Create();
-        colorQuad->SetNew(sharedState, gfx::Rect(10, 0, 10, 10), 3u);
-        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);
+    scoped_ptr<SolidColorDrawQuad> color_quad;
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(0, 0, 10, 10), 1u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
 
-        colorQuad = SolidColorDrawQuad::Create();
-        colorQuad->SetNew(sharedState, gfx::Rect(10, 10, 10, 10), 4u);
-        quadSink.append(colorQuad.PassAs<DrawQuad>(), data);
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(0, 10, 10, 10), 2u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
 
-        delegatedRendererLayer->setRenderPasses(delegatedRenderPasses);
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(10, 0, 10, 10), 3u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
 
-        // The RenderPasses should be taken by the layer.
-        EXPECT_EQ(0u, delegatedRenderPasses.size());
+    color_quad = SolidColorDrawQuad::Create();
+    color_quad->SetNew(shared_quad_state, gfx::Rect(10, 10, 10, 10), 4u);
+    quad_sink.append(color_quad.PassAs<DrawQuad>(), data);
 
-        m_rootLayerPtr = rootLayer.get();
-        m_delegatedRendererLayerPtr = delegatedRendererLayer.get();
+    delegated_renderer_layer->SetRenderPasses(delegated_render_passes);
 
-        rootLayer->addChild(delegatedRendererLayer.PassAs<LayerImpl>());
+    // The RenderPasses should be taken by the layer.
+    EXPECT_EQ(0u, delegated_render_passes.size());
 
-        m_hostImpl->setRootLayer(rootLayer.Pass());
+    root_layer_ = root_layer.get();
+    delegated_renderer_layer_ = delegated_renderer_layer.get();
+
+    if (clip_delegated_renderer_layer_) {
+      gfx::Rect clip_rect(21, 27, 23, 21);
+
+      clip_layer->setPosition(clip_rect.origin());
+      clip_layer->setBounds(clip_rect.size());
+      clip_layer->setContentBounds(clip_rect.size());
+      clip_layer->setMasksToBounds(true);
+
+      origin_layer->setPosition(
+          gfx::PointAtOffsetFromOrigin(-clip_rect.OffsetFromOrigin()));
+
+      origin_layer->addChild(delegated_renderer_layer.PassAs<LayerImpl>());
+      clip_layer->addChild(origin_layer.Pass());
+      root_layer->addChild(clip_layer.Pass());
+    } else {
+      root_layer->addChild(delegated_renderer_layer.PassAs<LayerImpl>());
     }
 
-protected:
-    LayerImpl* m_rootLayerPtr;
-    DelegatedRendererLayerImpl* m_delegatedRendererLayerPtr;
+    host_impl_->activeTree()->SetRootLayer(root_layer.Pass());
+  }
+
+ protected:
+  LayerImpl* root_layer_;
+  DelegatedRendererLayerImpl* delegated_renderer_layer_;
+  bool root_delegated_render_pass_is_clipped_;
+  bool clip_delegated_renderer_layer_;
 };
 
-TEST_F(DelegatedRendererLayerImplTestSharedData, SharedData)
-{
-    LayerTreeHostImpl::FrameData frame;
-    EXPECT_TRUE(m_hostImpl->prepareToDraw(frame));
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsUnclipped_LayerUnclipped_NoSurface) {
+  root_delegated_render_pass_is_clipped_ = false;
+  clip_delegated_renderer_layer_ = false;
+  SetUpTest();
 
-    ASSERT_EQ(1u, frame.renderPasses.size());
-    EXPECT_EQ(1, frame.renderPasses[0]->id.layer_id);
-    EXPECT_EQ(0, frame.renderPasses[0]->id.index);
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
 
-    const QuadList& quadList = frame.renderPasses[0]->quad_list;
-    ASSERT_EQ(4u, quadList.size());
+  ASSERT_EQ(2u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
 
-    // All quads should share the same state.
-    const SharedQuadState* sharedState = quadList[0]->shared_quad_state;
-    EXPECT_EQ(sharedState, quadList[1]->shared_quad_state);
-    EXPECT_EQ(sharedState, quadList[2]->shared_quad_state);
-    EXPECT_EQ(sharedState, quadList[3]->shared_quad_state);
+  // When the quads don't have a clip of their own, the clip rect is set to
+  // the drawableContentRect of the delegated renderer layer.
+  EXPECT_EQ(gfx::Rect(20, 20, 50, 50).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+  // Quads are clipped to the delegated renderer layer.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
 
-    // The state should be transformed only once.
-    EXPECT_RECT_EQ(gfx::Rect(30, 30, 50, 50), sharedState->clipped_rect_in_target);
-    gfx::Transform expected;
-    expected.Translate(30, 30);
-    EXPECT_TRANSFORMATION_MATRIX_EQ(expected, sharedState->content_to_target_transform);
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
 
-    m_hostImpl->drawLayers(frame);
-    m_hostImpl->didDrawAllLayers(frame);
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsClipped_LayerUnclipped_NoSurface) {
+  root_delegated_render_pass_is_clipped_ = true;
+  clip_delegated_renderer_layer_ = false;
+  SetUpTest();
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(2u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list =
+      frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the quads have a clip of their own, it is used.
+  EXPECT_EQ(gfx::Rect(25, 25, 40, 40).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+  // Quads came with a clip rect.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
 }
 
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsUnclipped_LayerClipped_NoSurface) {
+  root_delegated_render_pass_is_clipped_ = false;
+  clip_delegated_renderer_layer_ = true;
+  SetUpTest();
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(2u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the quads don't have a clip of their own, the clip rect is set to
+  // the drawableContentRect of the delegated renderer layer. When the layer
+  // is clipped, that should be seen in the quads' clip_rect.
+  EXPECT_EQ(gfx::Rect(21, 27, 23, 21).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+  // Quads are clipped to the delegated renderer layer.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsClipped_LayerClipped_NoSurface) {
+  root_delegated_render_pass_is_clipped_ = true;
+  clip_delegated_renderer_layer_ = true;
+  SetUpTest();
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(2u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the quads have a clip of their own, it is used, but it is
+  // combined with the clip rect of the delegated renderer layer.
+  EXPECT_EQ(gfx::Rect(25, 27, 19, 21).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+  // Quads came with a clip rect.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsUnclipped_LayerUnclipped_Surface) {
+  root_delegated_render_pass_is_clipped_ = false;
+  clip_delegated_renderer_layer_ = false;
+  SetUpTest();
+
+  delegated_renderer_layer_->setForceRenderSurface(true);
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(3u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the layer owns a surface, the quads don't need to be clipped
+  // further than they already specify. If they aren't clipped, then their
+  // clip rect is ignored, and they are not set as clipped.
+  EXPECT_FALSE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsClipped_LayerUnclipped_Surface) {
+  root_delegated_render_pass_is_clipped_ = true;
+  clip_delegated_renderer_layer_ = false;
+  SetUpTest();
+
+  delegated_renderer_layer_->setForceRenderSurface(true);
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(3u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list = frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state = root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the quads have a clip of their own, it is used.
+  EXPECT_EQ(gfx::Rect(5, 5, 40, 40).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+  // Quads came with a clip rect.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestClip,
+       QuadsUnclipped_LayerClipped_Surface) {
+  root_delegated_render_pass_is_clipped_ = false;
+  clip_delegated_renderer_layer_ = true;
+  SetUpTest();
+
+  delegated_renderer_layer_->setForceRenderSurface(true);
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(3u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the layer owns a surface, the quads don't need to be clipped
+  // further than they already specify. If they aren't clipped, then their
+  // clip rect is ignored, and they are not set as clipped.
+  EXPECT_FALSE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
+TEST_F(DelegatedRendererLayerImplTestClip, QuadsClipped_LayerClipped_Surface) {
+  root_delegated_render_pass_is_clipped_ = true;
+  clip_delegated_renderer_layer_ = true;
+  SetUpTest();
+
+  delegated_renderer_layer_->setForceRenderSurface(true);
+
+  LayerTreeHostImpl::FrameData frame;
+  EXPECT_TRUE(host_impl_->prepareToDraw(frame));
+
+  ASSERT_EQ(3u, frame.renderPasses.size());
+  const QuadList& contrib_delegated_quad_list =
+      frame.renderPasses[0]->quad_list;
+  ASSERT_EQ(2u, contrib_delegated_quad_list.size());
+  const QuadList& root_delegated_quad_list = frame.renderPasses[1]->quad_list;
+  ASSERT_EQ(5u, root_delegated_quad_list.size());
+  const SharedQuadState* root_delegated_shared_quad_state =
+      root_delegated_quad_list[0]->shared_quad_state;
+  const SharedQuadState* contrib_delegated_shared_quad_state =
+      contrib_delegated_quad_list[0]->shared_quad_state;
+
+  // When the quads have a clip of their own, it is used, but it is
+  // combined with the clip rect of the delegated renderer layer. If the
+  // layer owns a surface, then it does not have a clip rect of its own.
+  EXPECT_EQ(gfx::Rect(5, 5, 40, 40).ToString(),
+            root_delegated_shared_quad_state->clip_rect.ToString());
+  // Quads came with a clip rect.
+  EXPECT_TRUE(root_delegated_shared_quad_state->is_clipped);
+
+  host_impl_->drawLayers(frame);
+  host_impl_->didDrawAllLayers(frame);
+}
+
 }  // namespace
 }  // namespace cc
Index: src/cc/math_util.cc
===================================================================
--- src/cc/math_util.cc	(revision 184497)
+++ src/cc/math_util.cc	(working copy)
@@ -357,27 +357,6 @@
     return h.cartesianPoint2d();
 }
 
-void MathUtil::flattenTransformTo2d(gfx::Transform& transform)
-{
-    // Set both the 3rd row and 3rd column to (0, 0, 1, 0).
-    //
-    // One useful interpretation of doing this operation:
-    //  - For x and y values, the new transform behaves effectively like an orthographic
-    //    projection was added to the matrix sequence.
-    //  - For z values, the new transform overrides any effect that the transform had on
-    //    z, and instead it preserves the z value for any points that are transformed.
-    //  - Because of linearity of transforms, this flattened transform also preserves the
-    //    effect that any subsequent (post-multiplied) transforms would have on z values.
-    //
-    transform.matrix().setDouble(2, 0, 0);
-    transform.matrix().setDouble(2, 1, 0);
-    transform.matrix().setDouble(0, 2, 0);
-    transform.matrix().setDouble(1, 2, 0);
-    transform.matrix().setDouble(2, 2, 1);
-    transform.matrix().setDouble(3, 2, 0);
-    transform.matrix().setDouble(2, 3, 0);
-}
-
 static inline float scaleOnAxis(double a, double b, double c)
 {
     return std::sqrt(a * a + b * b + c * c);
@@ -406,86 +385,4 @@
     return gfx::Vector2dF(projectedLength * destination.x(), projectedLength * destination.y());
 }
 
-void MathUtil::rotateEulerAngles(gfx::Transform* transform, double eulerX, double eulerY, double eulerZ)
-{
-    // TODO (shawnsingh): make this implementation faster and more accurate by
-    // hard-coding each matrix instead of calling RotateAbout().
-    gfx::Transform rotationAboutX;
-    gfx::Transform rotationAboutY;
-    gfx::Transform rotationAboutZ;
-
-    rotationAboutX.RotateAboutXAxis(eulerX);
-    rotationAboutY.RotateAboutYAxis(eulerY);
-    rotationAboutZ.RotateAboutZAxis(eulerZ);
-
-    gfx::Transform composite = rotationAboutZ * rotationAboutY * rotationAboutX;
-    transform->PreconcatTransform(composite);
-}
-
-gfx::Transform MathUtil::to2dTransform(const gfx::Transform& transform)
-{
-    gfx::Transform result = transform;
-    SkMatrix44& matrix = result.matrix();
-    matrix.setDouble(0, 2, 0);
-    matrix.setDouble(1, 2, 0);
-    matrix.setDouble(2, 2, 1);
-    matrix.setDouble(3, 2, 0);
-
-    matrix.setDouble(2, 0, 0);
-    matrix.setDouble(2, 1, 0);
-    matrix.setDouble(2, 3, 0);
-
-    return result;
-}
-
-gfx::Transform MathUtil::createGfxTransform(double m11, double m12, double m13, double m14,
-                                            double m21, double m22, double m23, double m24,
-                                            double m31, double m32, double m33, double m34,
-                                            double m41, double m42, double m43, double m44)
-{
-    gfx::Transform result;
-    SkMatrix44& matrix = result.matrix();
-
-    // Initialize column 1
-    matrix.setDouble(0, 0, m11);
-    matrix.setDouble(1, 0, m12);
-    matrix.setDouble(2, 0, m13);
-    matrix.setDouble(3, 0, m14);
-
-    // Initialize column 2
-    matrix.setDouble(0, 1, m21);
-    matrix.setDouble(1, 1, m22);
-    matrix.setDouble(2, 1, m23);
-    matrix.setDouble(3, 1, m24);
-
-    // Initialize column 3
-    matrix.setDouble(0, 2, m31);
-    matrix.setDouble(1, 2, m32);
-    matrix.setDouble(2, 2, m33);
-    matrix.setDouble(3, 2, m34);
-
-    // Initialize column 4
-    matrix.setDouble(0, 3, m41);
-    matrix.setDouble(1, 3, m42);
-    matrix.setDouble(2, 3, m43);
-    matrix.setDouble(3, 3, m44);
-
-    return result;
-}
-
-gfx::Transform MathUtil::createGfxTransform(double a, double b, double c,
-                                            double d, double e, double f)
-{
-    gfx::Transform result;
-    SkMatrix44& matrix = result.matrix();
-    matrix.setDouble(0, 0, a);
-    matrix.setDouble(1, 0, b);
-    matrix.setDouble(0, 1, c);
-    matrix.setDouble(1, 1, d);
-    matrix.setDouble(0, 3, e);
-    matrix.setDouble(1, 3, f);
-
-    return result;
-}
-
 }  // namespace cc
Index: src/cc/scoped_ptr_deque.h
===================================================================
--- src/cc/scoped_ptr_deque.h	(revision 184497)
+++ src/cc/scoped_ptr_deque.h	(working copy)
@@ -18,11 +18,25 @@
 template <typename T>
 class ScopedPtrDeque {
  public:
-  typedef typename std::deque<T*>::iterator iterator;
   typedef typename std::deque<T*>::const_iterator const_iterator;
   typedef typename std::deque<T*>::reverse_iterator reverse_iterator;
-  typedef typename std::deque<T*>::const_reverse_iterator const_reverse_iterator;
+  typedef typename std::deque<T*>::const_reverse_iterator
+      const_reverse_iterator;
 
+#if defined(OS_ANDROID)
+  // On Android the iterator is not a class, so we can't block assignment.
+  typedef typename std::deque<T*>::iterator iterator;
+#else
+  // Ban setting values on the iterator directly. New pointers must be passed
+  // to methods on the ScopedPtrDeque class to appear in the deque.
+  class iterator : public std::deque<T*>::iterator {
+   public:
+    iterator(const typename std::deque<T*>::iterator& other)
+        : std::deque<T*>::iterator(other) {}
+    T* const& operator*() { return std::deque<T*>::iterator::operator*(); }
+  };
+#endif
+
   ScopedPtrDeque() {}
 
   ~ScopedPtrDeque() { clear(); }
@@ -31,37 +45,37 @@
     return data_.size();
   }
 
-  T* Peek(size_t index) const {
+  T* at(size_t index) const {
     DCHECK(index < size());
     return data_[index];
   }
 
   T* operator[](size_t index) const {
-    return Peek(index);
+    return at(index);
   }
 
-  T* first() const {
-    DCHECK(!isEmpty());
-    return Peek(0);
+  T* front() const {
+    DCHECK(!empty());
+    return at(0);
   }
 
-  T* last() const {
-    DCHECK(!isEmpty());
-    return Peek(size() - 1);
+  T* back() const {
+    DCHECK(!empty());
+    return at(size() - 1);
   }
 
-  bool isEmpty() const {
-    return size() == 0;
+  bool empty() const {
+    return data_.empty();
   }
 
-  scoped_ptr<T> takeFirst() {
-    scoped_ptr<T> ret(first());
+  scoped_ptr<T> take_front() {
+    scoped_ptr<T> ret(front());
     data_.pop_front();
     return ret.Pass();
   }
 
-  scoped_ptr<T> takeLast() {
-    scoped_ptr<T> ret(last());
+  scoped_ptr<T> take_back() {
+    scoped_ptr<T> ret(back());
     data_.pop_back();
     return ret.Pass();
   }
@@ -70,18 +84,32 @@
     STLDeleteElements(&data_);
   }
 
-  void append(scoped_ptr<T> item) {
+  void push_front(scoped_ptr<T> item) {
+    data_.push_front(item.release());
+  }
+
+  void push_back(scoped_ptr<T> item) {
     data_.push_back(item.release());
   }
 
-  void insert(size_t index, scoped_ptr<T> item) {
-    DCHECK(index < size());
-    data_.insert(data_.begin() + index, item.release());
+  void insert(iterator position, scoped_ptr<T> item) {
+    DCHECK(position <= end());
+    data_.insert(position, item.release());
   }
 
-  iterator begin() { return data_.begin(); }
+  void swap(iterator a, iterator b) {
+    DCHECK(a < end());
+    DCHECK(b < end());
+    if (a == end() || b == end() || a == b)
+      return;
+    typename std::deque<T*>::iterator writable_a = a;
+    typename std::deque<T*>::iterator writable_b = b;
+    std::swap(*writable_a, *writable_b);
+  }
+
+  iterator begin() { return static_cast<iterator>(data_.begin()); }
   const_iterator begin() const { return data_.begin(); }
-  iterator end() { return data_.end(); }
+  iterator end() { return static_cast<iterator>(data_.end()); }
   const_iterator end() const { return data_.end(); }
 
   reverse_iterator rbegin() { return data_.rbegin(); }
Index: src/cc/resource_update_controller_unittest.cc
===================================================================
--- src/cc/resource_update_controller_unittest.cc	(revision 184497)
+++ src/cc/resource_update_controller_unittest.cc	(working copy)
@@ -4,6 +4,7 @@
 
 #include "cc/resource_update_controller.h"
 
+#include "cc/prioritized_resource_manager.h"
 #include "cc/single_thread_proxy.h" // For DebugScopedSetImplThread
 #include "cc/test/fake_output_surface.h"
 #include "cc/test/fake_proxy.h"
Index: src/cc/layer_impl_unittest.cc
===================================================================
--- src/cc/layer_impl_unittest.cc	(revision 184497)
+++ src/cc/layer_impl_unittest.cc	(working copy)
@@ -4,14 +4,16 @@
 
 #include "cc/layer_impl.h"
 
+#include "cc/layer_tree_impl.h"
 #include "cc/single_thread_proxy.h"
 #include "cc/test/fake_impl_proxy.h"
 #include "cc/test/fake_layer_tree_host_impl.h"
+#include "cc/test/fake_output_surface.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperation.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "third_party/skia/include/effects/SkBlurImageFilter.h"
-#include <public/WebFilterOperation.h>
-#include <public/WebFilterOperations.h>
 
 using namespace WebKit;
 
@@ -53,15 +55,17 @@
 
 #define VERIFY_NEEDS_UPDATE_DRAW_PROPERTIES(codeToTest)                 \
     root->resetAllChangeTrackingForSubtree();                           \
-    hostImpl.resetNeedsUpdateDrawPropertiesForTesting();                \
+    hostImpl.forcePrepareToDraw();                                      \
+    EXPECT_FALSE(hostImpl.activeTree()->needs_update_draw_properties());\
     codeToTest;                                                         \
-    EXPECT_TRUE(hostImpl.needsUpdateDrawProperties());
+    EXPECT_TRUE(hostImpl.activeTree()->needs_update_draw_properties());
 
 #define VERIFY_NO_NEEDS_UPDATE_DRAW_PROPERTIES(codeToTest)              \
     root->resetAllChangeTrackingForSubtree();                           \
-    hostImpl.resetNeedsUpdateDrawPropertiesForTesting();                \
+    hostImpl.forcePrepareToDraw();                                      \
+    EXPECT_FALSE(hostImpl.activeTree()->needs_update_draw_properties());\
     codeToTest;                                                         \
-    EXPECT_FALSE(hostImpl.needsUpdateDrawProperties());
+    EXPECT_FALSE(hostImpl.activeTree()->needs_update_draw_properties());
 
 TEST(LayerImplTest, verifyLayerChangesAreTrackedProperly)
 {
@@ -73,6 +77,7 @@
     // Create a simple LayerImpl tree:
     FakeImplProxy proxy;
     FakeLayerTreeHostImpl hostImpl(&proxy);
+    EXPECT_TRUE(hostImpl.initializeRenderer(createFakeOutputSurface()));
     scoped_ptr<LayerImpl> root = LayerImpl::create(hostImpl.activeTree(), 1);
     root->addChild(LayerImpl::create(hostImpl.activeTree(), 2));
     LayerImpl* child = root->children()[0];
@@ -169,6 +174,7 @@
 {
     FakeImplProxy proxy;
     FakeLayerTreeHostImpl hostImpl(&proxy);
+    EXPECT_TRUE(hostImpl.initializeRenderer(createFakeOutputSurface()));
     scoped_ptr<LayerImpl> root = LayerImpl::create(hostImpl.activeTree(), 1);
 
     gfx::PointF arbitraryPointF = gfx::PointF(0.125f, 0.25f);
@@ -199,7 +205,7 @@
     VERIFY_NEEDS_UPDATE_DRAW_PROPERTIES(root->scrollBy(arbitraryVector2d));
     VERIFY_NO_NEEDS_UPDATE_DRAW_PROPERTIES(root->scrollBy(gfx::Vector2d()));
     root->setScrollDelta(gfx::Vector2d(0, 0));
-    hostImpl.resetNeedsUpdateDrawPropertiesForTesting();
+    hostImpl.forcePrepareToDraw();
     VERIFY_NEEDS_UPDATE_DRAW_PROPERTIES(root->setScrollDelta(arbitraryVector2d));
     VERIFY_NO_NEEDS_UPDATE_DRAW_PROPERTIES(root->setScrollDelta(arbitraryVector2d));
     VERIFY_NEEDS_UPDATE_DRAW_PROPERTIES(root->setScrollOffset(arbitraryVector2d));
Index: src/cc/layer_tree_debug_state.cc
===================================================================
--- src/cc/layer_tree_debug_state.cc	(revision 184497)
+++ src/cc/layer_tree_debug_state.cc	(working copy)
@@ -12,19 +12,21 @@
   : showFPSCounter(false)
   , showPlatformLayerTree(false)
   , showDebugBorders(false)
+  , continuousPainting(false)
   , showPaintRects(false)
   , showPropertyChangedRects(false)
   , showSurfaceDamageRects(false)
   , showScreenSpaceRects(false)
   , showReplicaScreenSpaceRects(false)
   , showOccludingRects(false)
-  , showNonOccludingRects(false) { }
+  , showNonOccludingRects(false)
+  , slowDownRasterScaleFactor(0) { }
 
 LayerTreeDebugState::~LayerTreeDebugState() {
 }
 
 bool LayerTreeDebugState::showHudInfo() const {
-    return showFPSCounter || showPlatformLayerTree || showHudRects();
+    return showFPSCounter || showPlatformLayerTree || continuousPainting || showHudRects();
 }
 
 bool LayerTreeDebugState::showHudRects() const {
@@ -32,7 +34,7 @@
 }
 
 bool LayerTreeDebugState::hudNeedsFont() const {
-    return showFPSCounter || showPlatformLayerTree;
+    return showFPSCounter || showPlatformLayerTree || continuousPainting;
 }
 
 bool LayerTreeDebugState::equal(const LayerTreeDebugState& a, const LayerTreeDebugState& b) {
@@ -45,6 +47,7 @@
     r.showFPSCounter |= b.showFPSCounter;
     r.showPlatformLayerTree |= b.showPlatformLayerTree;
     r.showDebugBorders |= b.showDebugBorders;
+    r.continuousPainting |= b.continuousPainting;
 
     r.showPaintRects |= b.showPaintRects;
     r.showPropertyChangedRects |= b.showPropertyChangedRects;
@@ -54,6 +57,9 @@
     r.showOccludingRects |= b.showOccludingRects;
     r.showNonOccludingRects |= b.showNonOccludingRects;
 
+    if (b.slowDownRasterScaleFactor)
+      r.slowDownRasterScaleFactor = b.slowDownRasterScaleFactor;
+
     return r;
 }
 
Index: src/cc/layer_updater.h
===================================================================
--- src/cc/layer_updater.h	(revision 184497)
+++ src/cc/layer_updater.h	(working copy)
@@ -6,20 +6,22 @@
 #define CC_LAYER_UPDATER_H_
 
 #include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
-#include "cc/prioritized_resource.h"
-#include "third_party/khronos/GLES2/gl2.h"
 
 namespace gfx {
 class Rect;
+class Size;
 class Vector2d;
 }
 
 namespace cc {
 
+class PrioritizedResource;
+class PrioritizedResourceManager;
+class ResourceUpdateQueue;
 class TextureManager;
 struct RenderingStats;
-class ResourceUpdateQueue;
 
 class CC_EXPORT LayerUpdater : public base::RefCounted<LayerUpdater> {
 public:
@@ -29,7 +31,7 @@
         virtual ~Resource();
 
         PrioritizedResource* texture() { return m_texture.get(); }
-        void swapTextureWith(scoped_ptr<PrioritizedResource>& texture) { m_texture.swap(texture); }
+        void swapTextureWith(scoped_ptr<PrioritizedResource>& texture);
         // TODO(reveman): partialUpdate should be a property of this class
         // instead of an argument passed to update().
         virtual void update(ResourceUpdateQueue&, const gfx::Rect& sourceRect, const gfx::Vector2d& destOffset, bool partialUpdate, RenderingStats&) = 0;
@@ -38,6 +40,8 @@
 
     private:
         scoped_ptr<PrioritizedResource> m_texture;
+
+        DISALLOW_COPY_AND_ASSIGN(Resource);
     };
 
     LayerUpdater() { }
Index: src/cc/image_layer_updater.h
===================================================================
--- src/cc/image_layer_updater.h	(revision 184497)
+++ src/cc/image_layer_updater.h	(working copy)
@@ -6,6 +6,7 @@
 #define CC_IMAGE_LAYER_UPDATER_H_
 
 #include "cc/layer_updater.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 
 namespace cc {
 
@@ -15,11 +16,8 @@
 public:
     class Resource : public LayerUpdater::Resource {
     public:
-        Resource(ImageLayerUpdater* updater, scoped_ptr<PrioritizedResource> texture)
-            : LayerUpdater::Resource(texture.Pass())
-            , m_updater(updater)
-        {
-        }
+        Resource(ImageLayerUpdater* updater, scoped_ptr<PrioritizedResource> texture);
+        virtual ~Resource();
 
         virtual void update(ResourceUpdateQueue&, const gfx::Rect& sourceRect, const gfx::Vector2d& destOffset, bool partialUpdate, RenderingStats&) OVERRIDE;
 
Index: src/cc/scheduler_state_machine.h
===================================================================
--- src/cc/scheduler_state_machine.h	(revision 184497)
+++ src/cc/scheduler_state_machine.h	(working copy)
@@ -9,6 +9,7 @@
 
 #include "base/basictypes.h"
 #include "cc/cc_export.h"
+#include "cc/scheduler_settings.h"
 
 namespace cc {
 
@@ -24,7 +25,8 @@
 // make testing cleaner.
 class CC_EXPORT SchedulerStateMachine {
 public:
-    SchedulerStateMachine();
+    // settings must be valid for the lifetime of this class.
+    SchedulerStateMachine(const SchedulerSettings& settings);
 
     enum CommitState {
         COMMIT_STATE_IDLE,
@@ -58,6 +60,8 @@
         ACTION_NONE,
         ACTION_BEGIN_FRAME,
         ACTION_COMMIT,
+        ACTION_CHECK_FOR_COMPLETED_TILE_UPLOADS,
+        ACTION_ACTIVATE_PENDING_TREE_IF_NEEDED,
         ACTION_DRAW_IF_POSSIBLE,
         ACTION_DRAW_FORCED,
         ACTION_BEGIN_OUTPUT_SURFACE_RECREATION,
@@ -86,6 +90,10 @@
     // we are not visible.
     void setNeedsForcedRedraw();
 
+    // Indicates that a redraw is required because we are currently rendering
+    // with a low resolution or checkerboarded tile.
+    void didSwapUseIncompleteTile();
+
     // Indicates whether ACTION_DRAW_IF_POSSIBLE drew to the screen or not.
     void didDrawIfPossibleCompleted(bool success);
 
@@ -120,8 +128,16 @@
     // Indicates whether drawing would, at this time, make sense.
     // canDraw can be used to supress flashes or checkerboarding
     // when such behavior would be undesirable.
-    void setCanDraw(bool can) { m_canDraw = can; }
+    void setCanDraw(bool can);
 
+    // Indicates whether or not there is a pending tree.  This influences
+    // whether or not we can succesfully commit at this time.  If the
+    // last commit is still being processed (but not blocking), it may not
+    // be possible to take another commit yet.  This overrides force commit,
+    // as a commit is already still in flight.
+    void setHasPendingTree(bool hasPendingTree);
+    bool hasPendingTree() const { return m_hasPendingTree; }
+
     void didLoseOutputSurface();
     void didRecreateOutputSurface();
 
@@ -135,16 +151,25 @@
     bool drawSuspendedUntilCommit() const;
     bool scheduledToDraw() const;
     bool shouldDraw() const;
+    bool shouldAttemptTreeActivation() const;
     bool shouldAcquireLayerTexturesForMainThread() const;
+    bool shouldCheckForCompletedTileUploads() const;
     bool hasDrawnThisFrame() const;
+    bool hasAttemptedTreeActivationThisFrame() const;
+    bool hasCheckedForCompletedTileUploadsThisFrame() const;
 
+    const SchedulerSettings m_settings;
+
     CommitState m_commitState;
 
     int m_currentFrameNumber;
     int m_lastFrameNumberWhereDrawWasCalled;
+    int m_lastFrameNumberWhereTreeActivationAttempted;
+    int m_lastFrameNumberWhereCheckForCompletedTileUploadsCalled;
     int m_consecutiveFailedDraws;
     int m_maximumNumberOfFailedDrawsBeforeDrawIsForced;
     bool m_needsRedraw;
+    bool m_swapUsedIncompleteTile;
     bool m_needsForcedRedraw;
     bool m_needsForcedRedrawAfterNextCommit;
     bool m_needsCommit;
@@ -155,6 +180,7 @@
     bool m_visible;
     bool m_canBeginFrame;
     bool m_canDraw;
+    bool m_hasPendingTree;
     bool m_drawIfPossibleFailed;
     TextureState m_textureState;
     OutputSurfaceState m_outputSurfaceState;
Index: src/cc/frame_rate_counter.h
===================================================================
--- src/cc/frame_rate_counter.h	(revision 184497)
+++ src/cc/frame_rate_counter.h	(working copy)
@@ -8,6 +8,7 @@
 #include "base/basictypes.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/time.h"
+#include "cc/ring_buffer.h"
 
 namespace cc {
 
@@ -17,29 +18,27 @@
 public:
     static scoped_ptr<FrameRateCounter> create(bool hasImplThread);
 
-    void markBeginningOfFrame(base::TimeTicks timestamp);
-    void markEndOfFrame();
-    int currentFrameNumber() const { return m_currentFrameNumber; }
-    double getAverageFPS() const;
-    int timeStampHistorySize() const { return kTimeStampHistorySize; }
+    int currentFrameNumber() const { return m_ringBuffer.CurrentIndex(); }
+    int droppedFrameCount() const { return m_droppedFrameCount; }
+    size_t timeStampHistorySize() const { return m_ringBuffer.BufferSize(); }
 
+    void saveTimeStamp(base::TimeTicks timestamp);
+
     // n = 0 returns the oldest frame retained in the history,
     // while n = timeStampHistorySize() - 1 returns the timestamp most recent frame.
-    // FIXME: Returns most recent timestamp for n = 0 when called between markBeginningOfFrame and markEndOfFrame calls.
-    base::TimeTicks timeStampOfRecentFrame(int n) const;
+    base::TimeTicks timeStampOfRecentFrame(size_t n) const;
 
     // This is a heuristic that can be used to ignore frames in a reasonable way. Returns
     // true if the given frame interval is too fast or too slow, based on constant thresholds.
     bool isBadFrameInterval(base::TimeDelta intervalBetweenConsecutiveFrames) const;
 
-    int droppedFrameCount() const { return m_droppedFrameCount; }
+    void getMinAndMaxFPS(double& minFPS, double& maxFPS) const;
+    double getAverageFPS() const;
 
 private:
     explicit FrameRateCounter(bool hasImplThread);
 
-    base::TimeDelta frameInterval(int frameNumber) const;
-    int frameIndex(int frameNumber) const;
-    bool isBadFrame(int frameNumber) const;
+    base::TimeDelta recentFrameInterval(size_t n) const;
 
     // Two thresholds (measured in seconds) that describe what is considered to be a "no-op frame" that should not be counted.
     // - if the frame is too fast, then given our compositor implementation, the frame probably was a no-op and did not draw.
@@ -52,13 +51,9 @@
     // FIXME: Determine this threshold based on monitor refresh rate, crbug.com/138642.
     static const double kDroppedFrameTime;
 
-    static const int kTimeStampHistorySize = 130;
+    RingBuffer<base::TimeTicks, 130> m_ringBuffer;
 
     bool m_hasImplThread;
-
-    int m_currentFrameNumber;
-    base::TimeTicks m_timeStampHistory[kTimeStampHistorySize];
-
     int m_droppedFrameCount;
 
     DISALLOW_COPY_AND_ASSIGN(FrameRateCounter);
Index: src/cc/scoped_thread_proxy.h
===================================================================
--- src/cc/scoped_thread_proxy.h	(revision 184497)
+++ src/cc/scoped_thread_proxy.h	(working copy)
@@ -1,54 +0,0 @@
-// Copyright 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CC_SCOPED_THREAD_PROXY_H_
-#define CC_SCOPED_THREAD_PROXY_H_
-
-#include "base/memory/ref_counted.h"
-#include "base/callback.h"
-#include "cc/cc_export.h"
-#include "cc/thread.h"
-#include "base/location.h"
-#include "base/logging.h"
-
-namespace cc {
-
-// This class is a proxy used to post tasks to an target thread from any other thread. The proxy may be shut down at
-// any point from the target thread after which no more tasks posted to the proxy will run. In other words, all
-// tasks posted via a proxy are scoped to the lifecycle of the proxy. Use this when posting tasks to an object that
-// might die with tasks in flight.
-//
-// The proxy must be created and shut down from the target thread, tasks may be posted from any thread.
-//
-// Implementation note: Unlike ScopedRunnableMethodFactory in Chromium, pending tasks are not cancelled by actually
-// destroying the proxy. Instead each pending task holds a reference to the proxy to avoid maintaining an explicit
-// list of outstanding tasks.
-class CC_EXPORT ScopedThreadProxy : public base::RefCountedThreadSafe<ScopedThreadProxy> {
-public:
-    static scoped_refptr<ScopedThreadProxy> create(cc::Thread* targetThread)
-    {
-        DCHECK(targetThread->belongsToCurrentThread());
-        return make_scoped_refptr(new ScopedThreadProxy(targetThread));
-    }
-
-    // Can be called from any thread. Posts a task to the target thread that runs unless
-    // shutdown() is called before it runs.
-    void postTask(const tracked_objects::Location& location, base::Closure cb);
-
-    void shutdown();
-
-private:
-    explicit ScopedThreadProxy(cc::Thread* targetThread);
-    friend class base::RefCountedThreadSafe<ScopedThreadProxy>;
-    ~ScopedThreadProxy();
-
-    void runTaskIfNotShutdown(base::Closure cb);
-
-    cc::Thread* m_targetThread;
-    bool m_shutdown; // Only accessed on the target thread
-};
-
-}  // namespace cc
-
-#endif  // CC_SCOPED_THREAD_PROXY_H_
Index: src/cc/picture_layer_tiling.h
===================================================================
--- src/cc/picture_layer_tiling.h	(revision 184497)
+++ src/cc/picture_layer_tiling.h	(working copy)
@@ -12,6 +12,7 @@
 #include "cc/hash_pair.h"
 #include "cc/region.h"
 #include "cc/tile.h"
+#include "cc/tile_priority.h"
 #include "cc/tiling_data.h"
 #include "ui/gfx/rect.h"
 
@@ -20,28 +21,61 @@
 class PictureLayerTiling;
 
 class PictureLayerTilingClient {
-  public:
-   virtual scoped_refptr<Tile> CreateTile(PictureLayerTiling*, gfx::Rect) = 0;
+ public:
+  // Create a tile at the given content_rect (in the contents scale of the
+  // tiling) This might return null if the client cannot create such a tile.
+  virtual scoped_refptr<Tile> CreateTile(
+    PictureLayerTiling* tiling,
+    gfx::Rect content_rect) = 0;
+  virtual void UpdatePile(Tile* tile) = 0;
+  virtual gfx::Size CalculateTileSize(
+    gfx::Size current_tile_size,
+    gfx::Size content_bounds) = 0;
 };
 
 class CC_EXPORT PictureLayerTiling {
  public:
   ~PictureLayerTiling();
 
-  static scoped_ptr<PictureLayerTiling> Create(float contents_scale,
-                                               gfx::Size tile_size);
+  // Create a tiling with no tiles.  CreateTiles must be called to add some.
+  static scoped_ptr<PictureLayerTiling> Create(float contents_scale);
   scoped_ptr<PictureLayerTiling> Clone() const;
 
-  const PictureLayerTiling& operator=(const PictureLayerTiling&);
-
+  gfx::Size layer_bounds() const { return layer_bounds_; }
   void SetLayerBounds(gfx::Size layer_bounds);
   void Invalidate(const Region& layer_invalidation);
 
+  // Add any tiles that intersect with |layer_rect|.  If any tiles already
+  // exist, then this leaves them as-is.
+  void CreateTilesFromLayerRect(gfx::Rect layer_rect);
+
   void SetClient(PictureLayerTilingClient* client);
+  void set_resolution(TileResolution resolution) { resolution_ = resolution; }
+  TileResolution resolution() const { return resolution_; }
 
   gfx::Rect ContentRect() const;
+  gfx::SizeF ContentSizeF() const;
   float contents_scale() const { return contents_scale_; }
 
+  std::vector<Tile*> AllTilesForTesting() const {
+    std::vector<Tile*> all_tiles;
+    for (TileMap::const_iterator it = tiles_.begin();
+         it != tiles_.end(); ++it)
+      all_tiles.push_back(it->second);
+    return all_tiles;
+  }
+
+  enum LayerDeviceAlignment {
+    LayerDeviceAlignmentUnknown,
+    LayerAlignedToDevice,
+    LayerNotAlignedToDevice,
+  };
+
+  static gfx::Rect ExpandRectEquallyToAreaBoundedBy(
+      gfx::Rect starting_rect,
+      int64 target_area,
+      gfx::Rect bounding_rect);
+
   // Iterate over all tiles to fill content_rect.  Even if tiles are invalid
   // (i.e. no valid resource) this tiling should still iterate over them.
   // The union of all geometry_rect calls for each element iterated over should
@@ -49,7 +83,10 @@
   class CC_EXPORT Iterator {
    public:
     Iterator();
-    Iterator(PictureLayerTiling* tiling, float dest_scale, gfx::Rect rect);
+    Iterator(const PictureLayerTiling* tiling,
+        float dest_scale,
+        gfx::Rect rect,
+        LayerDeviceAlignment layerDeviceAlignment);
     ~Iterator();
 
     // Visible rect (no borders), always in the space of content_rect,
@@ -59,6 +96,10 @@
     gfx::RectF texture_rect() const;
     gfx::Size texture_size() const;
 
+    // Full rect (including borders) of the current tile, always in the space
+    // of content_rect, regardless of the contents scale of the tiling.
+    gfx::Rect full_tile_geometry_rect() const;
+
     Tile* operator->() const { return current_tile_; }
     Tile* operator*() const { return current_tile_; }
 
@@ -66,9 +107,10 @@
     operator bool() const { return tile_j_ <= bottom_; }
 
    private:
-    PictureLayerTiling* tiling_;
+    const PictureLayerTiling* tiling_;
     gfx::Rect dest_rect_;
-    float dest_to_content_scale_;
+    float dest_to_content_scale_x_;
+    float dest_to_content_scale_y_;
 
     Tile* current_tile_;
     gfx::Rect current_geometry_rect_;
@@ -86,26 +128,45 @@
 
   void Reset() { return tiles_.clear(); }
 
-  void UpdateTilePriorities(const gfx::Size& device_viewport,
-                            float layer_content_scale_x,
-                            float layer_content_scale_y,
-                            const gfx::Transform& last_screen_transform,
-                            const gfx::Transform& current_screen_transform,
-                            double time_delta);
+  void UpdateTilePriorities(
+      WhichTree tree,
+      gfx::Size device_viewport,
+      const gfx::RectF& viewport_in_layer_space,
+      gfx::Size last_layer_bounds,
+      gfx::Size current_layer_bounds,
+      gfx::Size last_layer_content_bounds,
+      gfx::Size current_layer_content_bounds,
+      float last_layer_contents_scale,
+      float current_layer_contents_scale,
+      const gfx::Transform& last_screen_transform,
+      const gfx::Transform& current_screen_transform,
+      int current_source_frame_number,
+      double current_frame_time);
 
+  // Copies the src_tree priority into the dst_tree priority for all tiles.
+  // The src_tree priority is reset to the lowest priority possible.  This
+  // also updates the pile on each tile to be the current client's pile.
+  void DidBecomeActive();
+
  protected:
   typedef std::pair<int, int> TileMapKey;
   typedef base::hash_map<TileMapKey, scoped_refptr<Tile> > TileMap;
 
-  PictureLayerTiling(float contents_scale, gfx::Size tileSize);
+  PictureLayerTiling(float contents_scale);
   Tile* TileAt(int, int) const;
+  void CreateTilesFromContentRect(gfx::Rect layer_rect);
   void CreateTile(int i, int j);
 
   PictureLayerTilingClient* client_;
   float contents_scale_;
   gfx::Size layer_bounds_;
+  gfx::Rect last_prioritized_rect_;
+  // It is not legal to have a NULL tile in the tiles_ map.
   TileMap tiles_;
   TilingData tiling_data_;
+  TileResolution resolution_;
+  int last_source_frame_number_;
+  double last_impl_frame_time_;
 
   friend class Iterator;
 };
Index: src/cc/tile_draw_quad.cc
===================================================================
--- src/cc/tile_draw_quad.cc	(revision 184497)
+++ src/cc/tile_draw_quad.cc	(working copy)
@@ -75,6 +75,11 @@
   this->bottom_edge_aa = bottom_edge_aa;
 }
 
+void TileDrawQuad::AppendResources(
+    ResourceProvider::ResourceIdArray* resources) {
+  resources->push_back(resource_id);
+}
+
 const TileDrawQuad* TileDrawQuad::MaterialCast(
     const DrawQuad* quad) {
   DCHECK(quad->material == DrawQuad::TILED_CONTENT);
Index: src/cc/render_surface_unittest.cc
===================================================================
--- src/cc/render_surface_unittest.cc	(revision 184497)
+++ src/cc/render_surface_unittest.cc	(working copy)
@@ -115,7 +115,7 @@
 
 class TestRenderPassSink : public RenderPassSink {
 public:
-    virtual void appendRenderPass(scoped_ptr<RenderPass> renderPass) OVERRIDE { m_renderPasses.append(renderPass.Pass()); }
+    virtual void appendRenderPass(scoped_ptr<RenderPass> renderPass) OVERRIDE { m_renderPasses.push_back(renderPass.Pass()); }
 
     const ScopedPtrVector<RenderPass>& renderPasses() const { return m_renderPasses; }
 
Index: src/cc/tile_manager.cc
===================================================================
--- src/cc/tile_manager.cc	(revision 184497)
+++ src/cc/tile_manager.cc	(working copy)
@@ -5,149 +5,106 @@
 #include "cc/tile_manager.h"
 
 #include <algorithm>
-#include <set>
 
 #include "base/bind.h"
-#include "base/command_line.h"
 #include "base/debug/trace_event.h"
+#include "base/json/json_writer.h"
 #include "base/logging.h"
-#include "base/stringprintf.h"
-#include "base/threading/thread.h"
 #include "cc/platform_color.h"
-#include "cc/rendering_stats.h"
+#include "cc/raster_worker_pool.h"
 #include "cc/resource_pool.h"
-#include "cc/switches.h"
 #include "cc/tile.h"
 #include "third_party/skia/include/core/SkDevice.h"
 
+namespace cc {
+
 namespace {
 
-const char* kRasterThreadNamePrefix = "CompositorRaster";
+// If we raster too fast we become upload bound, and pending
+// uploads consume memory. For maximum upload throughput, we would
+// want to allow for upload_throughput * pipeline_time of pending
+// uploads, after which we are just wasting memory. Since we don't
+// know our upload throughput yet, this just caps our memory usage.
+#if defined(OS_ANDROID)
+// For reference, the Nexus10 can upload 1MB in about 2.5ms.
+// Assuming a three frame deep pipeline this implies ~20MB.
+const int kMaxPendingUploadBytes = 20 * 1024 * 1024;
+// TODO(epenner): We should remove this upload limit (crbug.com/176197)
+const int kMaxPendingUploads = 72;
+#else
+const int kMaxPendingUploadBytes = 100 * 1024 * 1024;
+const int kMaxPendingUploads = 1000;
+#endif
 
-const int kMaxRasterThreads = 64;
-const int kDefaultNumberOfRasterThreads = 1;
-
-// Allow two pending raster tasks per thread. This keeps resource usage
-// low while making sure raster threads aren't unnecessarily idle.
-const int kNumPendingRasterTasksPerThread = 2;
-
 // Determine bin based on three categories of tiles: things we need now,
 // things we need soon, and eventually.
-cc::TileManagerBin BinFromTilePriority(const cc::TilePriority& prio) {
+inline TileManagerBin BinFromTilePriority(const TilePriority& prio) {
+  if (!prio.is_live)
+    return NEVER_BIN;
 
   // The amount of time for which we want to have prepainting coverage.
   const double prepainting_window_time_seconds = 1.0;
   const double backfling_guard_distance_pixels = 314.0;
 
-  if (prio.time_to_needed_in_seconds() == std::numeric_limits<float>::max())
-    return cc::NEVER_BIN;
+  // Explicitly limit how far ahead we will prepaint to limit memory usage.
+  if (prio.distance_to_visible_in_pixels >
+      TilePriority::kMaxDistanceInContentSpace)
+    return NEVER_BIN;
 
-  if (prio.resolution == cc::NON_IDEAL_RESOLUTION)
-    return cc::EVENTUALLY_BIN;
-
-  if (prio.time_to_needed_in_seconds() == 0 ||
+  if (prio.time_to_visible_in_seconds == 0 ||
       prio.distance_to_visible_in_pixels < backfling_guard_distance_pixels)
-    return cc::NOW_BIN;
+    return NOW_BIN;
 
-  if (prio.time_to_needed_in_seconds() < prepainting_window_time_seconds)
-    return cc::SOON_BIN;
+  if (prio.resolution == NON_IDEAL_RESOLUTION)
+    return EVENTUALLY_BIN;
 
-  return cc::EVENTUALLY_BIN;
+  if (prio.time_to_visible_in_seconds < prepainting_window_time_seconds)
+    return SOON_BIN;
+
+  return EVENTUALLY_BIN;
 }
 
+std::string ValueToString(scoped_ptr<base::Value> value)
+{
+  std::string str;
+  base::JSONWriter::Write(value.get(), &str);
+  return str;
+}
+
 }  // namespace
 
-namespace cc {
-
-class RasterThread : public base::Thread {
- public:
-  RasterThread(const std::string name)
-      : base::Thread(name.c_str()),
-        num_pending_tasks_(0) {
-    Start();
+scoped_ptr<base::Value> TileManagerBinAsValue(TileManagerBin bin) {
+  switch (bin) {
+  case NOW_BIN:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "NOW_BIN"));
+  case SOON_BIN:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "SOON_BIN"));
+  case EVENTUALLY_BIN:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "EVENTUALLY_BIN"));
+  case NEVER_BIN:
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "NEVER_BIN"));
+  default:
+      DCHECK(false) << "Unrecognized TileManagerBin value";
+      return scoped_ptr<base::Value>(base::Value::CreateStringValue(
+          "<unknown TileManagerBin value>"));
   }
-  virtual ~RasterThread() {
-    Stop();
-  }
+}
 
-  int num_pending_tasks() { return num_pending_tasks_; }
-
-  void PostRasterTaskAndReply(const tracked_objects::Location& from_here,
-                              PicturePileImpl* picture_pile,
-                              uint8_t* mapped_buffer,
-                              const gfx::Rect& rect,
-                              float contents_scale,
-                              RenderingStats* stats,
-                              const base::Closure& reply) {
-    ++num_pending_tasks_;
-    message_loop_proxy()->PostTaskAndReply(
-        from_here,
-        base::Bind(&RunRasterTask,
-                   base::Unretained(picture_pile),
-                   mapped_buffer,
-                   rect,
-                   contents_scale,
-                   stats),
-        base::Bind(&RasterThread::RunReply, base::Unretained(this), reply));
-  }
-
-  void PostImageDecodingTaskAndReply(const tracked_objects::Location& from_here,
-                                     skia::LazyPixelRef* pixel_ref,
-                                     RenderingStats* stats,
-                                     const base::Closure& reply) {
-    ++num_pending_tasks_;
-    message_loop_proxy()->PostTaskAndReply(
-        from_here,
-        base::Bind(&RunImageDecodeTask, pixel_ref, stats),
-        base::Bind(&RasterThread::RunReply, base::Unretained(this), reply));
-  }
-
- private:
-  static void RunRasterTask(PicturePileImpl* picture_pile,
-                            uint8_t* mapped_buffer,
-                            const gfx::Rect& rect,
-                            float contents_scale,
-                            RenderingStats* stats) {
-    TRACE_EVENT0("cc", "RasterThread::RunRasterTask");
-    DCHECK(picture_pile);
-    DCHECK(mapped_buffer);
-    SkBitmap bitmap;
-    bitmap.setConfig(SkBitmap::kARGB_8888_Config, rect.width(), rect.height());
-    bitmap.setPixels(mapped_buffer);
-    SkDevice device(bitmap);
-    SkCanvas canvas(&device);
-    picture_pile->Raster(
-        &canvas,
-        rect,
-        contents_scale,
-        stats);
-  }
-
-  static void RunImageDecodeTask(skia::LazyPixelRef* pixel_ref,
-                                 RenderingStats* stats) {
-    TRACE_EVENT0("cc", "RasterThread::RunImageDecodeTask");
-    base::TimeTicks decodeBeginTime = base::TimeTicks::Now();
-    pixel_ref->Decode();
-    stats->totalDeferredImageDecodeTimeInSeconds +=
-        (base::TimeTicks::Now() - decodeBeginTime).InSecondsF();
-  }
-
-  void RunReply(const base::Closure& reply) {
-    --num_pending_tasks_;
-    reply.Run();
-  }
-
-  int num_pending_tasks_;
-
-  DISALLOW_COPY_AND_ASSIGN(RasterThread);
-};
-
 ManagedTileState::ManagedTileState()
     : can_use_gpu_memory(false),
       can_be_freed(true),
       resource_is_being_initialized(false),
       contents_swizzled(false),
-      need_to_gather_pixel_refs(true) {
+      need_to_gather_pixel_refs(true),
+      gpu_memmgr_stats_bin(NEVER_BIN),
+      raster_state(IDLE_STATE),
+      distance_to_visible_in_pixels(std::numeric_limits<float>::infinity()) {
+  for (int i = 0; i < NUM_TREES; ++i)
+    tree_bin[i] = NEVER_BIN;
 }
 
 ManagedTileState::~ManagedTileState() {
@@ -161,20 +118,18 @@
     size_t num_raster_threads)
     : client_(client),
       resource_pool_(ResourcePool::Create(resource_provider)),
+      raster_worker_pool_(RasterWorkerPool::Create(this, num_raster_threads)),
       manage_tiles_pending_(false),
       manage_tiles_call_count_(0),
-      check_for_completed_set_pixels_pending_(false) {
-  // Initialize all threads.
-  const std::string thread_name_prefix = kRasterThreadNamePrefix;
-  while (raster_threads_.size() < num_raster_threads) {
-    int thread_number = raster_threads_.size() + 1;
-    scoped_ptr<RasterThread> thread = make_scoped_ptr(
-        new RasterThread(thread_name_prefix +
-                         StringPrintf("Worker%d", thread_number).c_str()));
-    raster_threads_.append(thread.Pass());
+      bytes_pending_set_pixels_(0),
+      has_performed_uploads_since_last_flush_(false),
+      ever_exceeded_memory_budget_(false) {
+  for (int i = 0; i < NUM_STATES; ++i) {
+    for (int j = 0; j < NUM_TREES; ++j) {
+      for (int k = 0; k < NUM_BINS; ++k)
+        raster_state_count_[i][j][k] = 0;
+    }
   }
-
-  ResetBinCounts();
 }
 
 TileManager::~TileManager() {
@@ -182,21 +137,29 @@
   // our memory usage to drop to zero.
   global_state_ = GlobalStateThatImpactsTilePriority();
   AssignGpuMemoryToTiles();
-  // This should finish all pending raster tasks and release any
-  // uninitialized resources.
-  raster_threads_.clear();
-  ManageTiles();
-  DCHECK(tiles_.size() == 0);
+  // This should finish all pending tasks and release any uninitialized
+  // resources.
+  raster_worker_pool_.reset();
+  AbortPendingTileUploads();
+  DCHECK_EQ(tiles_with_pending_set_pixels_.size(), 0);
+  DCHECK_EQ(all_tiles_.size(), 0);
+  DCHECK_EQ(live_or_allocated_tiles_.size(), 0);
 }
 
-void TileManager::SetGlobalState(const GlobalStateThatImpactsTilePriority& global_state) {
+void TileManager::SetGlobalState(
+    const GlobalStateThatImpactsTilePriority& global_state) {
   global_state_ = global_state;
   resource_pool_->SetMaxMemoryUsageBytes(global_state_.memory_limit_in_bytes);
   ScheduleManageTiles();
 }
 
 void TileManager::RegisterTile(Tile* tile) {
-  tiles_.push_back(tile);
+  all_tiles_.insert(tile);
+
+  const ManagedTileState& mts = tile->managed_state();
+  for (int i = 0; i < NUM_TREES; ++i)
+    ++raster_state_count_[mts.raster_state][i][mts.tree_bin[i]];
+
   ScheduleManageTiles();
 }
 
@@ -205,7 +168,7 @@
        it != tiles_with_image_decoding_tasks_.end(); it++) {
     if (*it == tile) {
       tiles_with_image_decoding_tasks_.erase(it);
-      break;;
+      break;
     }
   }
   for (TileVector::iterator it = tiles_that_need_to_be_rasterized_.begin();
@@ -215,79 +178,67 @@
       break;
     }
   }
-  for (TileVector::iterator it = tiles_.begin(); it != tiles_.end(); it++) {
+  for (TileVector::iterator it = live_or_allocated_tiles_.begin();
+       it != live_or_allocated_tiles_.end(); it++) {
     if (*it == tile) {
-      FreeResourcesForTile(tile);
-      tiles_.erase(it);
-      return;
+      live_or_allocated_tiles_.erase(it);
+      break;
     }
   }
-  DCHECK(false) << "Could not find tile version.";
+  TileSet::iterator it = all_tiles_.find(tile);
+  DCHECK(it != all_tiles_.end());
+  const ManagedTileState& mts = tile->managed_state();
+  for (int i = 0; i < NUM_TREES; ++i)
+    --raster_state_count_[mts.raster_state][i][mts.tree_bin[i]];
+  FreeResourcesForTile(tile);
+  all_tiles_.erase(it);
 }
 
-void TileManager::WillModifyTilePriority(Tile*, WhichTree tree, const TilePriority& new_priority) {
-  // TODO(nduca): Do something smarter if reprioritization turns out to be
-  // costly.
-  ScheduleManageTiles();
-}
-
-void TileManager::ScheduleManageTiles() {
-  if (manage_tiles_pending_)
-    return;
-  client_->ScheduleManageTiles();
-  manage_tiles_pending_ = true;
-}
-
-void TileManager::ScheduleCheckForCompletedSetPixels() {
-  if (check_for_completed_set_pixels_pending_)
-    return;
-  client_->ScheduleCheckForCompletedSetPixels();
-  check_for_completed_set_pixels_pending_ = true;
-}
-
 class BinComparator {
 public:
   bool operator() (const Tile* a, const Tile* b) const {
     const ManagedTileState& ams = a->managed_state();
     const ManagedTileState& bms = b->managed_state();
-    if (ams.raster_bin != bms.raster_bin)
-      return ams.raster_bin < bms.raster_bin;
+    if (ams.bin[HIGH_PRIORITY_BIN] != bms.bin[HIGH_PRIORITY_BIN])
+      return ams.bin[HIGH_PRIORITY_BIN] < bms.bin[HIGH_PRIORITY_BIN];
 
+    if (ams.bin[LOW_PRIORITY_BIN] != bms.bin[LOW_PRIORITY_BIN])
+      return ams.bin[LOW_PRIORITY_BIN] < bms.bin[LOW_PRIORITY_BIN];
+
     if (ams.resolution != bms.resolution)
-      return ams.resolution < ams.resolution;
+      return ams.resolution < bms.resolution;
 
-    return
-      ams.time_to_needed_in_seconds <
-      bms.time_to_needed_in_seconds;
+    if (ams.time_to_needed_in_seconds !=  bms.time_to_needed_in_seconds)
+      return ams.time_to_needed_in_seconds < bms.time_to_needed_in_seconds;
+
+    if (ams.distance_to_visible_in_pixels != bms.distance_to_visible_in_pixels)
+      return ams.distance_to_visible_in_pixels < bms.distance_to_visible_in_pixels;
+
+    gfx::Rect a_rect = a->content_rect();
+    gfx::Rect b_rect = b->content_rect();
+    if (a_rect.y() != b_rect.y())
+      return a_rect.y() < b_rect.y();
+    return a_rect.x() < b_rect.x();
   }
 };
 
+void TileManager::SortTiles() {
+  TRACE_EVENT0("cc", "TileManager::SortTiles");
+  TRACE_COUNTER_ID1("cc", "LiveTileCount", this, live_or_allocated_tiles_.size());
+
+  // Sort by bin, resolution and time until needed.
+  std::sort(live_or_allocated_tiles_.begin(),
+            live_or_allocated_tiles_.end(), BinComparator());
+}
+
 void TileManager::ManageTiles() {
   TRACE_EVENT0("cc", "TileManager::ManageTiles");
   manage_tiles_pending_ = false;
   ++manage_tiles_call_count_;
 
-  const bool smoothness_takes_priority =
-      global_state_.smoothness_takes_priority;
+  const TreePriority tree_priority = global_state_.tree_priority;
+  TRACE_COUNTER_ID1("cc", "TileCount", this, all_tiles_.size());
 
-  // For each tree, bin into different categories of tiles.
-  for (TileVector::iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
-    Tile* tile = *it;
-    ManagedTileState& mts = tile->managed_state();
-    mts.bin[ACTIVE_TREE] = BinFromTilePriority(tile->priority(ACTIVE_TREE));
-    mts.bin[PENDING_TREE] = BinFromTilePriority(tile->priority(PENDING_TREE));
-
-    TilePriority prio;
-    if (smoothness_takes_priority)
-      prio = tile->priority(ACTIVE_TREE);
-    else
-      prio = tile->combined_priority();
-
-    mts.resolution = prio.resolution;
-    mts.time_to_needed_in_seconds = prio.time_to_needed_in_seconds();
-    mts.raster_bin = BinFromTilePriority(prio);
-  }
-
   // Memory limit policy works by mapping some bin states to the NEVER bin.
   TileManagerBin bin_map[NUM_BINS];
   if (global_state_.memory_limit_policy == ALLOW_NOTHING) {
@@ -311,42 +262,76 @@
     bin_map[EVENTUALLY_BIN] = EVENTUALLY_BIN;
     bin_map[NEVER_BIN] = NEVER_BIN;
   }
-  for (TileVector::iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
-    Tile* tile = *it;
-    ManagedTileState& mts = tile->managed_state();
-    mts.bin[ACTIVE_TREE] = bin_map[mts.bin[ACTIVE_TREE]];
-    mts.bin[PENDING_TREE] = bin_map[mts.bin[PENDING_TREE]];
-    mts.raster_bin = bin_map[mts.raster_bin];
-  }
 
-  // Update bin counts.
-  ResetBinCounts();
-  for (TileVector::iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
+  live_or_allocated_tiles_.clear();
+  // For each tree, bin into different categories of tiles.
+  for (TileSet::iterator it = all_tiles_.begin();
+       it != all_tiles_.end(); ++it) {
     Tile* tile = *it;
     ManagedTileState& mts = tile->managed_state();
-    for (int i = 0; i < NUM_TREES; ++i)
-      tiles_in_bin_count_[mts.bin[i]][i]++;
 
-    // Increment drawable count if GetResourceId() doesn't return 0.
-    if (tile->GetResourceId()) {
-      for (int i = 0; i < NUM_TREES; ++i)
-        drawable_tiles_in_bin_count_[mts.bin[i]][i]++;
+    TilePriority prio[NUM_BIN_PRIORITIES];
+    switch (tree_priority) {
+      case SAME_PRIORITY_FOR_BOTH_TREES:
+        prio[HIGH_PRIORITY_BIN] = prio[LOW_PRIORITY_BIN] =
+            tile->combined_priority();
+        break;
+      case SMOOTHNESS_TAKES_PRIORITY:
+        prio[HIGH_PRIORITY_BIN] = tile->priority(ACTIVE_TREE);
+        prio[LOW_PRIORITY_BIN] = tile->priority(PENDING_TREE);
+        break;
+      case NEW_CONTENT_TAKES_PRIORITY:
+        prio[HIGH_PRIORITY_BIN] = tile->priority(PENDING_TREE);
+        prio[LOW_PRIORITY_BIN] = tile->priority(ACTIVE_TREE);
+        break;
     }
+
+    mts.resolution = prio[HIGH_PRIORITY_BIN].resolution;
+    mts.time_to_needed_in_seconds =
+        prio[HIGH_PRIORITY_BIN].time_to_visible_in_seconds;
+    mts.distance_to_visible_in_pixels =
+        prio[HIGH_PRIORITY_BIN].distance_to_visible_in_pixels;
+    mts.bin[HIGH_PRIORITY_BIN] = BinFromTilePriority(prio[HIGH_PRIORITY_BIN]);
+    mts.bin[LOW_PRIORITY_BIN] = BinFromTilePriority(prio[LOW_PRIORITY_BIN]);
+    mts.gpu_memmgr_stats_bin = BinFromTilePriority(tile->combined_priority());
+
+    DidTileTreeBinChange(tile,
+                         BinFromTilePriority(tile->priority(ACTIVE_TREE)),
+                         ACTIVE_TREE);
+    DidTileTreeBinChange(tile,
+                         BinFromTilePriority(tile->priority(PENDING_TREE)),
+                         PENDING_TREE);
+
+    for (int i = 0; i < NUM_BIN_PRIORITIES; ++i)
+      mts.bin[i] = bin_map[mts.bin[i]];
+
+    DidTileTreeBinChange(tile, bin_map[mts.tree_bin[ACTIVE_TREE]],
+                         ACTIVE_TREE);
+    DidTileTreeBinChange(tile, bin_map[mts.tree_bin[PENDING_TREE]],
+                         PENDING_TREE);
+
+    if (tile->priority(ACTIVE_TREE).is_live ||
+        tile->priority(PENDING_TREE).is_live ||
+        tile->managed_state().resource ||
+        tile->managed_state().resource_is_being_initialized) {
+      live_or_allocated_tiles_.push_back(tile);
+    }
   }
+  TRACE_COUNTER_ID1("cc", "LiveOrAllocatedTileCount", this,
+                    live_or_allocated_tiles_.size());
 
-  // Sort by bin.
-  std::sort(tiles_.begin(), tiles_.end(), BinComparator());
+  SortTiles();
 
   // Assign gpu memory and determine what tiles need to be rasterized.
   AssignGpuMemoryToTiles();
 
+  TRACE_EVENT_INSTANT1("cc", "DidManage", "state", ValueToString(AsValue()));
+
   // Finally, kick the rasterizer.
   DispatchMoreTasks();
 }
 
-void TileManager::CheckForCompletedSetPixels() {
-  check_for_completed_set_pixels_pending_ = false;
-
+void TileManager::CheckForCompletedTileUploads() {
   while (!tiles_with_pending_set_pixels_.empty()) {
     Tile* tile = tiles_with_pending_set_pixels_.front();
     DCHECK(tile->managed_state().resource);
@@ -354,102 +339,215 @@
     // Set pixel tasks complete in the order they are posted.
     if (!resource_pool_->resource_provider()->didSetPixelsComplete(
           tile->managed_state().resource->id())) {
-      ScheduleCheckForCompletedSetPixels();
       break;
     }
 
+    if (tile->priority(ACTIVE_TREE).distance_to_visible_in_pixels == 0 &&
+        tile->priority(ACTIVE_TREE).resolution == HIGH_RESOLUTION)
+      client_->DidUploadVisibleHighResolutionTile();
+
     // It's now safe to release the pixel buffer.
     resource_pool_->resource_provider()->releasePixelBuffer(
         tile->managed_state().resource->id());
 
     DidFinishTileInitialization(tile);
+
+    bytes_pending_set_pixels_ -= tile->bytes_consumed_if_allocated();
+    DidTileRasterStateChange(tile, IDLE_STATE);
     tiles_with_pending_set_pixels_.pop();
   }
+
+  DispatchMoreTasks();
 }
 
+void TileManager::AbortPendingTileUploads() {
+  while (!tiles_with_pending_set_pixels_.empty()) {
+    Tile* tile = tiles_with_pending_set_pixels_.front();
+    ManagedTileState& managed_tile_state = tile->managed_state();
+    DCHECK(managed_tile_state.resource);
+
+    resource_pool_->resource_provider()->abortSetPixels(
+        managed_tile_state.resource->id());
+    resource_pool_->resource_provider()->releasePixelBuffer(
+        managed_tile_state.resource->id());
+
+    managed_tile_state.resource_is_being_initialized = false;
+    managed_tile_state.can_be_freed = true;
+    managed_tile_state.can_use_gpu_memory = false;
+    FreeResourcesForTile(tile);
+
+    bytes_pending_set_pixels_ -= tile->bytes_consumed_if_allocated();
+    DidTileRasterStateChange(tile, IDLE_STATE);
+    tiles_with_pending_set_pixels_.pop();
+  }
+}
+
+void TileManager::GetMemoryStats(
+    size_t* memoryRequiredBytes,
+    size_t* memoryNiceToHaveBytes,
+    size_t* memoryUsedBytes) const {
+  *memoryRequiredBytes = 0;
+  *memoryNiceToHaveBytes = 0;
+  *memoryUsedBytes = 0;
+  for (size_t i = 0; i < live_or_allocated_tiles_.size(); i++) {
+    const Tile* tile = live_or_allocated_tiles_[i];
+    const ManagedTileState& mts = tile->managed_state();
+    size_t tile_bytes = tile->bytes_consumed_if_allocated();
+    if (mts.gpu_memmgr_stats_bin == NOW_BIN)
+      *memoryRequiredBytes += tile_bytes;
+    if (mts.gpu_memmgr_stats_bin != NEVER_BIN)
+      *memoryNiceToHaveBytes += tile_bytes;
+    if (mts.can_use_gpu_memory)
+      *memoryUsedBytes += tile_bytes;
+  }
+}
+
+scoped_ptr<base::Value> TileManager::AsValue() const {
+    scoped_ptr<base::DictionaryValue> state(new base::DictionaryValue());
+    state->SetInteger("tile_count", all_tiles_.size());
+
+    state->Set("global_state", global_state_.AsValue().release());
+
+    state->Set("memory_requirements", GetMemoryRequirementsAsValue().release());
+    return state.PassAs<base::Value>();
+}
+
+scoped_ptr<base::Value> TileManager::GetMemoryRequirementsAsValue() const {
+  scoped_ptr<base::DictionaryValue> requirements(
+      new base::DictionaryValue());
+
+  size_t memoryRequiredBytes;
+  size_t memoryNiceToHaveBytes;
+  size_t memoryUsedBytes;
+  GetMemoryStats(&memoryRequiredBytes,
+                 &memoryNiceToHaveBytes,
+                 &memoryUsedBytes);
+  requirements->SetInteger("memory_required_bytes", memoryRequiredBytes);
+  requirements->SetInteger("memory_nice_to_have_bytes", memoryNiceToHaveBytes);
+  requirements->SetInteger("memory_used_bytes", memoryUsedBytes);
+  return requirements.PassAs<base::Value>();
+}
+
 void TileManager::GetRenderingStats(RenderingStats* stats) {
-  stats->totalRasterizeTimeInSeconds =
-      rendering_stats_.totalRasterizeTimeInSeconds;
-  stats->totalPixelsRasterized = rendering_stats_.totalPixelsRasterized;
-  stats->totalDeferredImageDecodeCount =
-      rendering_stats_.totalDeferredImageDecodeCount;
+  raster_worker_pool_->GetRenderingStats(stats);
   stats->totalDeferredImageCacheHitCount =
       rendering_stats_.totalDeferredImageCacheHitCount;
   stats->totalImageGatheringCount = rendering_stats_.totalImageGatheringCount;
-  stats->totalDeferredImageDecodeTimeInSeconds =
-      rendering_stats_.totalDeferredImageDecodeTimeInSeconds;
-  stats->totalImageGatheringTimeInSeconds =
-      rendering_stats_.totalImageGatheringTimeInSeconds;
+  stats->totalImageGatheringTime =
+      rendering_stats_.totalImageGatheringTime;
 }
 
-int TileManager::GetTilesInBinCount(TileManagerBin bin, WhichTree tree) {
-  DCHECK(bin >= 0);
-  DCHECK(bin < NUM_BINS);
-  DCHECK(tree >= 0);
-  DCHECK(tree < NUM_TREES);
-  return tiles_in_bin_count_[bin][tree];
-}
+bool TileManager::HasPendingWorkScheduled(WhichTree tree) const {
+  // Always true when ManageTiles() call is pending.
+  if (manage_tiles_pending_)
+    return true;
 
-int TileManager::GetDrawableTilesInBinCount(
-    TileManagerBin bin, WhichTree tree) {
-  DCHECK(bin >= 0);
-  DCHECK(bin < NUM_BINS);
-  DCHECK(tree >= 0);
-  DCHECK(tree < NUM_TREES);
-  return drawable_tiles_in_bin_count_[bin][tree];
+  for (int i = 0; i < NUM_STATES; ++i) {
+    switch (i) {
+      case WAITING_FOR_RASTER_STATE:
+      case RASTER_STATE:
+      case SET_PIXELS_STATE:
+        for (int j = 0; j < NEVER_BIN; ++j) {
+          if (raster_state_count_[i][tree][j])
+            return true;
+        }
+        break;
+      case IDLE_STATE:
+        break;
+      default:
+        NOTREACHED();
+    }
+  }
+
+  return false;
 }
 
-void TileManager::ResetBinCounts() {
-  for (int i = 0; i < NUM_BINS; ++i)
-    for (int j = 0; j < NUM_TREES; ++j)
-      tiles_in_bin_count_[i][j] = drawable_tiles_in_bin_count_[i][j] = 0;
+void TileManager::DidFinishDispatchingWorkerPoolCompletionCallbacks() {
+  // If a flush is needed, do it now before starting to dispatch more tasks.
+  if (has_performed_uploads_since_last_flush_) {
+    resource_pool_->resource_provider()->shallowFlushIfSupported();
+    has_performed_uploads_since_last_flush_ = false;
+  }
+
+  DispatchMoreTasks();
 }
 
 void TileManager::AssignGpuMemoryToTiles() {
   TRACE_EVENT0("cc", "TileManager::AssignGpuMemoryToTiles");
-  // Some memory cannot be released. Figure out which.
   size_t unreleasable_bytes = 0;
-  for (TileVector::iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
-    Tile* tile = *it;
-    if (!tile->managed_state().can_be_freed)
-      unreleasable_bytes += tile->bytes_consumed_if_allocated();
-  }
 
   // Now give memory out to the tiles until we're out, and build
   // the needs-to-be-rasterized queue.
-  tiles_that_need_to_be_rasterized_.erase(
-      tiles_that_need_to_be_rasterized_.begin(),
-      tiles_that_need_to_be_rasterized_.end());
+  tiles_that_need_to_be_rasterized_.clear();
 
   // Reset the image decoding list so that we don't mess up with tile
   // priorities. Tiles will be added to the image decoding list again
   // when DispatchMoreTasks() is called.
   tiles_with_image_decoding_tasks_.clear();
 
-  size_t bytes_left = global_state_.memory_limit_in_bytes - unreleasable_bytes;
-  for (TileVector::iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
+  // By clearing the tiles_that_need_to_be_rasterized_ vector and
+  // tiles_with_image_decoding_tasks_ list above we move all tiles
+  // currently waiting for raster to idle state.
+  // Call DidTileRasterStateChange() for each of these tiles to
+  // have this state change take effect.
+  // Some memory cannot be released. We figure out how much in this
+  // loop as well.
+  for (TileVector::iterator it = live_or_allocated_tiles_.begin();
+       it != live_or_allocated_tiles_.end(); ++it) {
     Tile* tile = *it;
+    if (!tile->managed_state().can_be_freed)
+      unreleasable_bytes += tile->bytes_consumed_if_allocated();
+    if (tile->managed_state().raster_state == WAITING_FOR_RASTER_STATE)
+      DidTileRasterStateChange(tile, IDLE_STATE);
+  }
+
+  size_t bytes_allocatable = global_state_.memory_limit_in_bytes - unreleasable_bytes;
+  size_t bytes_that_exceeded_memory_budget_in_now_bin = 0;
+  size_t bytes_left = bytes_allocatable;
+  for (TileVector::iterator it = live_or_allocated_tiles_.begin(); it != live_or_allocated_tiles_.end(); ++it) {
+    Tile* tile = *it;
     size_t tile_bytes = tile->bytes_consumed_if_allocated();
     ManagedTileState& managed_tile_state = tile->managed_state();
     if (!managed_tile_state.can_be_freed)
       continue;
-    if (managed_tile_state.raster_bin == NEVER_BIN) {
+    if (managed_tile_state.bin[HIGH_PRIORITY_BIN] == NEVER_BIN &&
+        managed_tile_state.bin[LOW_PRIORITY_BIN] == NEVER_BIN) {
       managed_tile_state.can_use_gpu_memory = false;
       FreeResourcesForTile(tile);
       continue;
     }
     if (tile_bytes > bytes_left) {
       managed_tile_state.can_use_gpu_memory = false;
+      if (managed_tile_state.bin[HIGH_PRIORITY_BIN] == NOW_BIN ||
+          managed_tile_state.bin[LOW_PRIORITY_BIN] == NOW_BIN)
+          bytes_that_exceeded_memory_budget_in_now_bin += tile_bytes;
       FreeResourcesForTile(tile);
       continue;
     }
     bytes_left -= tile_bytes;
     managed_tile_state.can_use_gpu_memory = true;
     if (!managed_tile_state.resource &&
-        !managed_tile_state.resource_is_being_initialized)
+        !managed_tile_state.resource_is_being_initialized) {
       tiles_that_need_to_be_rasterized_.push_back(tile);
+      DidTileRasterStateChange(tile, WAITING_FOR_RASTER_STATE);
+    }
   }
 
+  ever_exceeded_memory_budget_ |=
+      bytes_that_exceeded_memory_budget_in_now_bin > 0;
+  if (ever_exceeded_memory_budget_) {
+      TRACE_COUNTER_ID2("cc", "over_memory_budget", this,
+                        "budget", global_state_.memory_limit_in_bytes,
+                        "over", bytes_that_exceeded_memory_budget_in_now_bin);
+  }
+  memory_stats_from_last_assign_.total_budget_in_bytes =
+      global_state_.memory_limit_in_bytes;
+  memory_stats_from_last_assign_.bytes_allocated =
+      bytes_allocatable - bytes_left;
+  memory_stats_from_last_assign_.bytes_unreleasable = unreleasable_bytes;
+  memory_stats_from_last_assign_.bytes_over =
+      bytes_that_exceeded_memory_budget_in_now_bin;
+
   // Reverse two tiles_that_need_* vectors such that pop_back gets
   // the highest priority tile.
   std::reverse(
@@ -464,32 +562,27 @@
     resource_pool_->ReleaseResource(managed_tile_state.resource.Pass());
 }
 
-RasterThread* TileManager::GetFreeRasterThread() {
-  RasterThread* thread = 0;
-  for (RasterThreadVector::iterator it = raster_threads_.begin();
-       it != raster_threads_.end(); ++it) {
-    if ((*it)->num_pending_tasks() == kNumPendingRasterTasksPerThread)
-      continue;
-    // Check if this is the best thread we've found so far.
-    if (!thread || (*it)->num_pending_tasks() < thread->num_pending_tasks())
-      thread = *it;
-  }
-  return thread;
+bool TileManager::CanDispatchRasterTask(Tile* tile) {
+  if (raster_worker_pool_->IsBusy())
+    return false;
+  size_t new_bytes_pending = bytes_pending_set_pixels_;
+  new_bytes_pending += tile->bytes_consumed_if_allocated();
+  return new_bytes_pending <= kMaxPendingUploadBytes &&
+         tiles_with_pending_set_pixels_.size() < kMaxPendingUploads;
 }
 
 void TileManager::DispatchMoreTasks() {
   // Because tiles in the image decoding list have higher priorities, we
   // need to process those tiles first before we start to handle the tiles
   // in the need_to_be_rasterized queue.
-  std::list<Tile*>::iterator it = tiles_with_image_decoding_tasks_.begin();
-  while (it != tiles_with_image_decoding_tasks_.end()) {
-    DispatchImageDecodingTasksForTile(*it);
+  for(TileList::iterator it = tiles_with_image_decoding_tasks_.begin();
+      it != tiles_with_image_decoding_tasks_.end(); ) {
+    DispatchImageDecodeTasksForTile(*it);
     ManagedTileState& managed_state = (*it)->managed_state();
     if (managed_state.pending_pixel_refs.empty()) {
-      RasterThread* thread = GetFreeRasterThread();
-      if (!thread)
+      if (!CanDispatchRasterTask(*it))
         return;
-      DispatchOneRasterTask(thread, *it);
+      DispatchOneRasterTask(*it);
       tiles_with_image_decoding_tasks_.erase(it++);
     } else {
       ++it;
@@ -500,15 +593,14 @@
   // image decoding tasks, put it to the back of the image decoding list.
   while (!tiles_that_need_to_be_rasterized_.empty()) {
     Tile* tile = tiles_that_need_to_be_rasterized_.back();
-    DispatchImageDecodingTasksForTile(tile);
+    DispatchImageDecodeTasksForTile(tile);
     ManagedTileState& managed_state = tile->managed_state();
     if (!managed_state.pending_pixel_refs.empty()) {
       tiles_with_image_decoding_tasks_.push_back(tile);
     } else {
-      RasterThread* thread = GetFreeRasterThread();
-      if (!thread)
+      if (!CanDispatchRasterTask(tile))
         return;
-      DispatchOneRasterTask(thread, tile);
+      DispatchOneRasterTask(tile);
     }
     tiles_that_need_to_be_rasterized_.pop_back();
   }
@@ -519,16 +611,18 @@
   ManagedTileState& managed_state = tile->managed_state();
   if (managed_state.need_to_gather_pixel_refs) {
     base::TimeTicks gather_begin_time = base::TimeTicks::Now();
-    const_cast<PicturePileImpl *>(tile->picture_pile())->GatherPixelRefs(
-        tile->content_rect_, managed_state.pending_pixel_refs);
+    tile->picture_pile()->GatherPixelRefs(
+        tile->content_rect_,
+        tile->contents_scale_,
+        managed_state.pending_pixel_refs);
     rendering_stats_.totalImageGatheringCount++;
-    rendering_stats_.totalImageGatheringTimeInSeconds +=
-        (base::TimeTicks::Now() - gather_begin_time).InSecondsF();
+    rendering_stats_.totalImageGatheringTime +=
+        base::TimeTicks::Now() - gather_begin_time;
     managed_state.need_to_gather_pixel_refs = false;
   }
 }
 
-void TileManager::DispatchImageDecodingTasksForTile(Tile* tile) {
+void TileManager::DispatchImageDecodeTasksForTile(Tile* tile) {
   GatherPixelRefsForTile(tile);
   std::list<skia::LazyPixelRef*>& pending_pixel_refs =
       tile->managed_state().pending_pixel_refs;
@@ -544,45 +638,35 @@
       rendering_stats_.totalDeferredImageCacheHitCount++;
       pending_pixel_refs.erase(it++);
     } else {
-      RasterThread* thread = GetFreeRasterThread();
-      if (!thread)
+      if (raster_worker_pool_->IsBusy())
         return;
-      DispatchOneImageDecodingTask(thread, tile, *it);
+      DispatchOneImageDecodeTask(tile, *it);
       ++it;
     }
   }
 }
 
-void TileManager::DispatchOneImageDecodingTask(RasterThread* thread,
-                                               scoped_refptr<Tile> tile,
-                                               skia::LazyPixelRef* pixel_ref) {
-  TRACE_EVENT0("cc", "TileManager::DispatchOneImageDecodingTask");
+void TileManager::DispatchOneImageDecodeTask(
+    scoped_refptr<Tile> tile, skia::LazyPixelRef* pixel_ref) {
+  TRACE_EVENT0("cc", "TileManager::DispatchOneImageDecodeTask");
   uint32_t pixel_ref_id = pixel_ref->getGenerationID();
   DCHECK(pending_decode_tasks_.end() ==
       pending_decode_tasks_.find(pixel_ref_id));
   pending_decode_tasks_[pixel_ref_id] = pixel_ref;
-  RenderingStats* stats = new RenderingStats();
 
-  thread->PostImageDecodingTaskAndReply(
-          FROM_HERE,
-          pixel_ref,
-          stats,
-          base::Bind(&TileManager::OnImageDecodingTaskCompleted,
-                     base::Unretained(this),
-                     tile,
-                     pixel_ref_id,
-                     stats));
+  raster_worker_pool_->PostTaskAndReply(
+      base::Bind(&TileManager::RunImageDecodeTask, pixel_ref),
+      base::Bind(&TileManager::OnImageDecodeTaskCompleted,
+                 base::Unretained(this),
+                 tile,
+                 pixel_ref_id));
 }
 
-void TileManager::OnImageDecodingTaskCompleted(scoped_refptr<Tile> tile,
-                                               uint32_t pixel_ref_id,
-                                               RenderingStats* stats) {
-  TRACE_EVENT0("cc", "TileManager::OnImageDecoded");
+void TileManager::OnImageDecodeTaskCompleted(
+    scoped_refptr<Tile> tile, uint32_t pixel_ref_id) {
+  TRACE_EVENT0("cc", "TileManager::OnImageDecodeTaskCompleted");
   pending_decode_tasks_.erase(pixel_ref_id);
-  rendering_stats_.totalDeferredImageDecodeTimeInSeconds +=
-      stats->totalDeferredImageDecodeTimeInSeconds;
-  rendering_stats_.totalDeferredImageDecodeCount++;
-  delete stats;
+
   for (TileList::iterator it = tiles_with_image_decoding_tasks_.begin();
       it != tiles_with_image_decoding_tasks_.end(); ++it) {
     std::list<skia::LazyPixelRef*>& pixel_refs =
@@ -595,11 +679,9 @@
       }
     }
   }
-  DispatchMoreTasks();
 }
 
-void TileManager::DispatchOneRasterTask(
-    RasterThread* thread, scoped_refptr<Tile> tile) {
+void TileManager::DispatchOneRasterTask(scoped_refptr<Tile> tile) {
   TRACE_EVENT0("cc", "TileManager::DispatchOneRasterTask");
   ManagedTileState& managed_tile_state = tile->managed_state();
   DCHECK(managed_tile_state.can_use_gpu_memory);
@@ -610,38 +692,29 @@
   managed_tile_state.resource_is_being_initialized = true;
   managed_tile_state.can_be_freed = false;
 
+  DidTileRasterStateChange(tile, RASTER_STATE);
+
   ResourceProvider::ResourceId resource_id = resource->id();
-  scoped_refptr<PicturePileImpl> picture_pile_clone =
-      tile->picture_pile()->GetCloneForDrawingOnThread(thread);
-  RenderingStats* stats = new RenderingStats();
 
-  thread->PostRasterTaskAndReply(
-      FROM_HERE,
-      picture_pile_clone.get(),
-      resource_pool_->resource_provider()->mapPixelBuffer(resource_id),
-      tile->content_rect_,
-      tile->contents_scale(),
-      stats,
+  raster_worker_pool_->PostRasterTaskAndReply(
+      tile->picture_pile(),
+      base::Bind(&TileManager::RunRasterTask,
+                 resource_pool_->resource_provider()->mapPixelBuffer(
+                     resource_id),
+                 tile->content_rect_,
+                 tile->contents_scale()),
       base::Bind(&TileManager::OnRasterTaskCompleted,
                  base::Unretained(this),
                  tile,
                  base::Passed(&resource),
-                 picture_pile_clone,
-                 manage_tiles_call_count_,
-                 stats));
+                 manage_tiles_call_count_));
 }
 
 void TileManager::OnRasterTaskCompleted(
     scoped_refptr<Tile> tile,
     scoped_ptr<ResourcePool::Resource> resource,
-    scoped_refptr<PicturePileImpl> picture_pile_clone,
-    int manage_tiles_call_count_when_dispatched,
-    RenderingStats* stats) {
+    int manage_tiles_call_count_when_dispatched) {
   TRACE_EVENT0("cc", "TileManager::OnRasterTaskCompleted");
-  rendering_stats_.totalRasterizeTimeInSeconds +=
-    stats->totalRasterizeTimeInSeconds;
-  rendering_stats_.totalPixelsRasterized += stats->totalPixelsRasterized;
-  delete stats;
 
   // Release raster resources.
   resource_pool_->resource_provider()->unmapPixelBuffer(resource->id());
@@ -670,16 +743,19 @@
     managed_tile_state.can_be_freed = false;
 
     resource_pool_->resource_provider()->beginSetPixels(resource->id());
+    has_performed_uploads_since_last_flush_ = true;
+
     managed_tile_state.resource = resource.Pass();
+
+    bytes_pending_set_pixels_ += tile->bytes_consumed_if_allocated();
+    DidTileRasterStateChange(tile, SET_PIXELS_STATE);
     tiles_with_pending_set_pixels_.push(tile);
-
-    ScheduleCheckForCompletedSetPixels();
   } else {
     resource_pool_->resource_provider()->releasePixelBuffer(resource->id());
     resource_pool_->ReleaseResource(resource.Pass());
     managed_tile_state.resource_is_being_initialized = false;
+    DidTileRasterStateChange(tile, IDLE_STATE);
   }
-  DispatchMoreTasks();
 }
 
 void TileManager::DidFinishTileInitialization(Tile* tile) {
@@ -687,8 +763,65 @@
   DCHECK(managed_tile_state.resource);
   managed_tile_state.resource_is_being_initialized = false;
   managed_tile_state.can_be_freed = true;
-  for (int i = 0; i < NUM_TREES; ++i)
-    drawable_tiles_in_bin_count_[managed_tile_state.bin[i]][i]++;
 }
 
+void TileManager::DidTileRasterStateChange(Tile* tile, TileRasterState state) {
+  ManagedTileState& mts = tile->managed_state();
+  DCHECK_LT(state, NUM_STATES);
+
+  for (int i = 0; i < NUM_TREES; ++i) {
+    // Decrement count for current state.
+    --raster_state_count_[mts.raster_state][i][mts.tree_bin[i]];
+    DCHECK_GE(raster_state_count_[mts.raster_state][i][mts.tree_bin[i]], 0);
+
+    // Increment count for new state.
+    ++raster_state_count_[state][i][mts.tree_bin[i]];
+  }
+
+  mts.raster_state = state;
 }
+
+void TileManager::DidTileTreeBinChange(Tile* tile,
+                                       TileManagerBin new_tree_bin,
+                                       WhichTree tree) {
+  ManagedTileState& mts = tile->managed_state();
+
+  // Decrement count for current bin.
+  --raster_state_count_[mts.raster_state][tree][mts.tree_bin[tree]];
+  DCHECK_GE(raster_state_count_[mts.raster_state][tree][mts.tree_bin[tree]], 0);
+
+  // Increment count for new bin.
+  ++raster_state_count_[mts.raster_state][tree][new_tree_bin];
+
+  mts.tree_bin[tree] = new_tree_bin;
+}
+
+// static
+void TileManager::RunRasterTask(uint8* buffer,
+                                const gfx::Rect& rect,
+                                float contents_scale,
+                                PicturePileImpl* picture_pile,
+                                RenderingStats* stats) {
+  TRACE_EVENT0("cc", "TileManager::RunRasterTask");
+  DCHECK(picture_pile);
+  DCHECK(buffer);
+  SkBitmap bitmap;
+  bitmap.setConfig(SkBitmap::kARGB_8888_Config, rect.width(), rect.height());
+  bitmap.setPixels(buffer);
+  SkDevice device(bitmap);
+  SkCanvas canvas(&device);
+  picture_pile->Raster(&canvas, rect, contents_scale, stats);
+}
+
+// static
+void TileManager::RunImageDecodeTask(skia::LazyPixelRef* pixel_ref,
+                                     RenderingStats* stats) {
+  TRACE_EVENT0("cc", "TileManager::RunImageDecodeTask");
+  base::TimeTicks decode_begin_time = base::TimeTicks::Now();
+  pixel_ref->Decode();
+  stats->totalDeferredImageDecodeCount++;
+  stats->totalDeferredImageDecodeTime +=
+      base::TimeTicks::Now() - decode_begin_time;
+}
+
+}  // namespace cc
Index: src/cc/math_util.h
===================================================================
--- src/cc/math_util.h	(revision 184497)
+++ src/cc/math_util.h	(working copy)
@@ -104,8 +104,6 @@
     static gfx::QuadF projectQuad(const gfx::Transform&, const gfx::QuadF&, bool& clipped);
     static gfx::PointF projectPoint(const gfx::Transform&, const gfx::PointF&, bool& clipped);
 
-    static void flattenTransformTo2d(gfx::Transform&);
-
     static gfx::Vector2dF computeTransform2dScaleComponents(const gfx::Transform&, float fallbackValue);
 
     // Returns the smallest angle between the given two vectors in degrees. Neither vector is
@@ -114,22 +112,6 @@
 
     // Projects the |source| vector onto |destination|. Neither vector is assumed to be normalized.
     static gfx::Vector2dF projectVector(gfx::Vector2dF source, gfx::Vector2dF destination);
-
-    // Temporary API to ease migration from gfx::Transform
-    // to gfx::Transform.
-    //
-    // TODO(shawnsingh, vollick) we should phase out as much as possible of
-    // these temporary functions, putting functionality into gfx::Transform.
-    static void rotateEulerAngles(gfx::Transform*, double eulerX, double eulerY, double eulerZ);
-    static gfx::Transform to2dTransform(const gfx::Transform&);
-    // Note carefully: the args here are labeled as per Webcore indexing conventions.
-    static gfx::Transform createGfxTransform(double m11, double m12, double m13, double m14,
-                                             double m21, double m22, double m23, double m24,
-                                             double m31, double m32, double m33, double m34,
-                                             double m41, double m42, double m43, double m44);
-
-    static gfx::Transform createGfxTransform(double a, double b, double c,
-                                             double d, double e, double f);
 };
 
 } // namespace cc
Index: src/cc/tile_manager.h
===================================================================
--- src/cc/tile_manager.h	(revision 184497)
+++ src/cc/tile_manager.h	(working copy)
@@ -7,26 +7,28 @@
 
 #include <list>
 #include <queue>
+#include <set>
 #include <vector>
 
 #include "base/hash_tables.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/values.h"
+#include "cc/memory_history.h"
+#include "cc/rendering_stats.h"
 #include "cc/resource_pool.h"
 #include "cc/tile_priority.h"
+#include "cc/worker_pool.h"
 
 namespace cc {
-
-class RasterThread;
+class RasterWorkerPool;
 class ResourceProvider;
 class Tile;
 class TileVersion;
-struct RenderingStats;
 
 class CC_EXPORT TileManagerClient {
  public:
   virtual void ScheduleManageTiles() = 0;
-  virtual void ScheduleCheckForCompletedSetPixels() = 0;
+  virtual void DidUploadVisibleHighResolutionTile() = 0;
 
  protected:
   virtual ~TileManagerClient() {}
@@ -40,8 +42,25 @@
   EVENTUALLY_BIN = 2, // Nice to have, if we've got memory and time.
   NEVER_BIN = 3, // Dont bother.
   NUM_BINS = 4
+  // Be sure to update TileManagerBinAsValue when adding new fields.
 };
+scoped_ptr<base::Value> TileManagerBinAsValue(
+    TileManagerBin bin);
 
+enum TileManagerBinPriority {
+  HIGH_PRIORITY_BIN = 0,
+  LOW_PRIORITY_BIN = 1,
+  NUM_BIN_PRIORITIES = 2
+};
+
+enum TileRasterState {
+  IDLE_STATE = 0,
+  WAITING_FOR_RASTER_STATE = 1,
+  RASTER_STATE = 2,
+  SET_PIXELS_STATE = 3,
+  NUM_STATES = 4
+};
+
 // This is state that is specific to a tile that is
 // managed by the TileManager.
 class CC_EXPORT ManagedTileState {
@@ -57,81 +76,116 @@
   bool contents_swizzled;
   bool need_to_gather_pixel_refs;
   std::list<skia::LazyPixelRef*> pending_pixel_refs;
+  TileRasterState raster_state;
 
   // Ephemeral state, valid only during Manage.
-  TileManagerBin bin[NUM_TREES];
-  // Bin used to determine raster priority.
-  TileManagerBin raster_bin;
+  TileManagerBin bin[NUM_BIN_PRIORITIES];
+  TileManagerBin tree_bin[NUM_TREES];
+  // The bin that the tile would have if the GPU memory manager had a maximally permissive policy,
+  // send to the GPU memory manager to determine policy.
+  TileManagerBin gpu_memmgr_stats_bin;
   TileResolution resolution;
   float time_to_needed_in_seconds;
+  float distance_to_visible_in_pixels;
 };
 
 // This class manages tiles, deciding which should get rasterized and which
 // should no longer have any memory assigned to them. Tile objects are "owned"
 // by layers; they automatically register with the manager when they are
 // created, and unregister from the manager when they are deleted.
-class CC_EXPORT TileManager {
+class CC_EXPORT TileManager : public WorkerPoolClient {
  public:
   TileManager(TileManagerClient* client,
               ResourceProvider *resource_provider,
               size_t num_raster_threads);
   virtual ~TileManager();
 
-  const GlobalStateThatImpactsTilePriority& GlobalState() const { return global_state_; }
+  const GlobalStateThatImpactsTilePriority& GlobalState() const {
+      return global_state_;
+  }
   void SetGlobalState(const GlobalStateThatImpactsTilePriority& state);
 
   void ManageTiles();
-  void CheckForCompletedSetPixels();
+  void CheckForCompletedTileUploads();
+  void AbortPendingTileUploads();
 
+  scoped_ptr<base::Value> AsValue() const;
+  void GetMemoryStats(size_t* memoryRequiredBytes,
+                      size_t* memoryNiceToHaveBytes,
+                      size_t* memoryUsedBytes) const;
   void GetRenderingStats(RenderingStats* stats);
+  bool HasPendingWorkScheduled(WhichTree tree) const;
 
-  int GetTilesInBinCount(TileManagerBin bin, WhichTree tree);
-  int GetDrawableTilesInBinCount(TileManagerBin bin, WhichTree tree);
+  const MemoryHistory::Entry& memory_stats_from_last_assign() const {
+    return memory_stats_from_last_assign_;
+  }
 
+  // Overridden from WorkerPoolClient:
+  virtual void DidFinishDispatchingWorkerPoolCompletionCallbacks() OVERRIDE;
+
  protected:
   // Methods called by Tile
   friend class Tile;
-  void RegisterTile(Tile*);
-  void UnregisterTile(Tile*);
-  void WillModifyTilePriority(Tile*, WhichTree, const TilePriority& new_priority);
+  void RegisterTile(Tile* tile);
+  void UnregisterTile(Tile* tile);
+  void WillModifyTilePriority(
+      Tile* tile, WhichTree tree, const TilePriority& new_priority) {
+    // TODO(nduca): Do something smarter if reprioritization turns out to be
+    // costly.
+    ScheduleManageTiles();
+  }
 
  private:
-  void ResetBinCounts();
+  void SortTiles();
   void AssignGpuMemoryToTiles();
-  void FreeResourcesForTile(Tile*);
-  void ScheduleManageTiles();
-  void ScheduleCheckForCompletedSetPixels();
+  void FreeResourcesForTile(Tile* tile);
+  void ScheduleManageTiles() {
+    if (manage_tiles_pending_)
+      return;
+    client_->ScheduleManageTiles();
+    manage_tiles_pending_ = true;
+  }
   void DispatchMoreTasks();
-  void DispatchOneRasterTask(RasterThread*, scoped_refptr<Tile>);
+  void GatherPixelRefsForTile(Tile* tile);
+  void DispatchImageDecodeTasksForTile(Tile* tile);
+  void DispatchOneImageDecodeTask(
+      scoped_refptr<Tile> tile, skia::LazyPixelRef* pixel_ref);
+  void OnImageDecodeTaskCompleted(
+      scoped_refptr<Tile> tile,
+      uint32_t pixel_ref_id);
+  bool CanDispatchRasterTask(Tile* tile);
+  void DispatchOneRasterTask(scoped_refptr<Tile> tile);
   void OnRasterTaskCompleted(
-      scoped_refptr<Tile>,
-      scoped_ptr<ResourcePool::Resource>,
-      scoped_refptr<PicturePileImpl>,
-      int manage_tiles_call_count_when_dispatched,
-      RenderingStats*);
-  void DidFinishTileInitialization(Tile*);
-  void DispatchImageDecodingTasksForTile(Tile*);
-  void OnImageDecodingTaskCompleted(scoped_refptr<Tile>,
-                                    uint32_t,
-                                    RenderingStats*);
-  void DispatchOneImageDecodingTask(
-      RasterThread*, scoped_refptr<Tile>, skia::LazyPixelRef*);
-  void GatherPixelRefsForTile(Tile*);
-  RasterThread* GetFreeRasterThread();
+      scoped_refptr<Tile> tile,
+      scoped_ptr<ResourcePool::Resource> resource,
+      int manage_tiles_call_count_when_dispatched);
+  void DidFinishTileInitialization(Tile* tile);
+  void DidTileRasterStateChange(Tile* tile, TileRasterState state);
+  void DidTileTreeBinChange(Tile* tile,
+                            TileManagerBin new_tree_bin,
+                            WhichTree tree);
+  scoped_ptr<Value> GetMemoryRequirementsAsValue() const;
 
+  static void RunRasterTask(uint8* buffer,
+                            const gfx::Rect& rect,
+                            float contents_scale,
+                            PicturePileImpl* picture_pile,
+                            RenderingStats* stats);
+  static void RunImageDecodeTask(skia::LazyPixelRef* pixel_ref,
+                                 RenderingStats* stats);
+
   TileManagerClient* client_;
   scoped_ptr<ResourcePool> resource_pool_;
+  scoped_ptr<RasterWorkerPool> raster_worker_pool_;
   bool manage_tiles_pending_;
   int manage_tiles_call_count_;
-  bool check_for_completed_set_pixels_pending_;
 
   GlobalStateThatImpactsTilePriority global_state_;
 
-  int tiles_in_bin_count_[NUM_BINS][NUM_TREES];
-  int drawable_tiles_in_bin_count_[NUM_BINS][NUM_TREES];
-
   typedef std::vector<Tile*> TileVector;
-  TileVector tiles_;
+  typedef std::set<Tile*> TileSet;
+  TileSet all_tiles_;
+  TileVector live_or_allocated_tiles_;
   TileVector tiles_that_need_to_be_rasterized_;
 
   typedef std::list<Tile*> TileList;
@@ -144,12 +198,15 @@
 
   typedef std::queue<scoped_refptr<Tile> > TileQueue;
   TileQueue tiles_with_pending_set_pixels_;
+  size_t bytes_pending_set_pixels_;
+  bool has_performed_uploads_since_last_flush_;
+  bool ever_exceeded_memory_budget_;
+  MemoryHistory::Entry memory_stats_from_last_assign_;
 
-  typedef ScopedPtrVector<RasterThread> RasterThreadVector;
-  RasterThreadVector raster_threads_;
-
   RenderingStats rendering_stats_;
 
+  int raster_state_count_[NUM_STATES][NUM_TREES][NUM_BINS];
+
   DISALLOW_COPY_AND_ASSIGN(TileManager);
 };
 
Index: src/cc/switches.cc
===================================================================
--- src/cc/switches.cc	(revision 184497)
+++ src/cc/switches.cc	(working copy)
@@ -24,6 +24,15 @@
 
 const char kEnablePerTilePainting[]         = "enable-per-tile-painting";
 
+// Try to finish display pipeline before vsync tick
+const char kEnableRightAlignedScheduling[] = "enable-right-aligned-scheduling";
+
+const char kEnableTopControlsPositionCalculation[] =
+    "enable-top-controls-position-calculation";
+
+// The height of the movable top controls in screen pixels.
+const char kTopControlsHeight[] = "top-controls-height";
+
 // Number of worker threads used to rasterize content.
 const char kNumRasterThreads[] = "num-raster-threads";
 
@@ -54,5 +63,14 @@
 // of pixels culled, and the number of pixels drawn, for each frame.
 const char kTraceOverdraw[] = "trace-overdraw";
 
+// Re-rasters everything multiple times to simulate a much slower machine.
+// Give a scale factor to cause raster to take that many times longer to
+// complete, such as --slow-down-raster-scale-factor=25.
+const char kSlowDownRasterScaleFactor[] = "slow-down-raster-scale-factor";
+
+// The scale factor for low resolution tile contents.
+const char kLowResolutionContentsScaleFactor[] =
+    "low-resolution-contents-scale-factor";
+
 }  // namespace switches
 }  // namespace cc
Index: src/cc/font_atlas.h
===================================================================
--- src/cc/font_atlas.h	(revision 184497)
+++ src/cc/font_atlas.h	(working copy)
@@ -39,12 +39,15 @@
     //   outside that range will be displayed as a default rectangle glyph.
     // - gfx::Size clip is used to avoid wasting time drawing things that are outside the
     //   target canvas bounds.
-    // - Should only be called only on the impl thread.
-    void drawText(SkCanvas*, const SkPaint&, const std::string& text, const gfx::Point& destPosition, const gfx::Size& clip) const;
+    // - Should only be called on the impl thread.
+    void drawText(SkCanvas*, SkPaint*, const std::string& text, const gfx::Point& destPosition, const gfx::Size& clip) const;
 
     // Gives a text's width and height on the canvas.
     gfx::Size textSize(const std::string& text);
 
+    // Sets the text's color.
+    void setColor(const SkColor& color) { m_color = color; }
+
     // Draws the entire atlas at the specified position, just for debugging purposes.
     void drawDebugAtlas(SkCanvas*, const gfx::Point& destPosition) const;
 
@@ -60,6 +63,7 @@
     gfx::Rect m_asciiToRectTable[128];
 
     int m_fontHeight;
+    SkColor m_color;
 
     DISALLOW_COPY_AND_ASSIGN(FontAtlas);
 };
Index: src/cc/tiled_layer.cc
===================================================================
--- src/cc/tiled_layer.cc	(revision 184497)
+++ src/cc/tiled_layer.cc	(working copy)
@@ -9,13 +9,14 @@
 #include "build/build_config.h"
 #include "cc/layer_impl.h"
 #include "cc/layer_tree_host.h"
+#include "cc/layer_updater.h"
 #include "cc/overdraw_metrics.h"
+#include "cc/prioritized_resource.h"
+#include "cc/priority_calculator.h"
 #include "cc/tiled_layer_impl.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "ui/gfx/rect_conversions.h"
 
-using namespace std;
-
 namespace cc {
 
 // Maximum predictive expansion of the visible area.
@@ -110,7 +111,7 @@
     int layerWidth = contentBounds().width();
     int layerHeight = contentBounds().height();
 
-    gfx::Size tileSize(min(defaultTileSize.width(), layerWidth), min(defaultTileSize.height(), layerHeight));
+    gfx::Size tileSize(std::min(defaultTileSize.width(), layerWidth), std::min(defaultTileSize.height(), layerHeight));
 
     // Tile if both dimensions large, or any one dimension large and the other
     // extends into a second tile but the total layer area isn't larger than that
@@ -232,6 +233,14 @@
     return layerTreeHost()->contentsTextureManager();
 }
 
+const PrioritizedResource* TiledLayer::resourceAtForTesting(int i, int j) const
+{
+    UpdatableTile* tile = tileAt(i, j);
+    if (!tile)
+        return 0;
+    return tile->managedResource();
+}
+
 void TiledLayer::setLayerTreeHost(LayerTreeHost* host)
 {
     if (host && host != layerTreeHost()) {
@@ -343,7 +352,7 @@
                 continue;
             DCHECK(!tile->occluded); // Did resetUpdateState get skipped? Are we doing more than one occlusion pass?
             gfx::Rect visibleTileRect = gfx::IntersectRects(m_tiler->tileBounds(i, j), visibleContentRect());
-            if (occlusion && occlusion->occluded(renderTarget(), visibleTileRect, drawTransform(), drawTransformIsAnimating(), drawableContentRect())) {
+            if (occlusion && occlusion->occluded(renderTarget(), visibleTileRect, drawTransform(), drawTransformIsAnimating(), isClipped(), clipRect())) {
                 tile->occluded = true;
                 occludedTileCount++;
             } else {
Index: src/cc/input_handler.h
===================================================================
--- src/cc/input_handler.h	(revision 184497)
+++ src/cc/input_handler.h	(working copy)
@@ -28,7 +28,7 @@
 class CC_EXPORT InputHandlerClient {
 public:
     enum ScrollStatus { ScrollOnMainThread, ScrollStarted, ScrollIgnored };
-    enum ScrollInputType { Gesture, Wheel };
+    enum ScrollInputType { Gesture, Wheel, NonBubblingGesture };
 
     // Selects a layer to be scrolled at a given point in viewport (logical
     // pixel) coordinates. Returns ScrollStarted if the layer at the coordinates
Index: src/cc/cc.gyp
===================================================================
--- src/cc/cc.gyp	(revision 184497)
+++ src/cc/cc.gyp	(working copy)
@@ -5,11 +5,13 @@
 {
   'variables': {
     'cc_source_files': [
-      'active_animation.cc',
-      'active_animation.h',
+      'animation.cc',
+      'animation.h',
       'animation_curve.cc',
       'animation_curve.h',
       'animation_events.h',
+      'animation_registrar.cc',
+      'animation_registrar.h',
       'append_quads_data.h',
       'bitmap_content_layer_updater.cc',
       'bitmap_content_layer_updater.h',
@@ -92,7 +94,8 @@
       'layer.h',
       'layer_animation_controller.cc',
       'layer_animation_controller.h',
-      'layer_animation_observer.h',
+      'layer_animation_event_observer.h',
+      'layer_animation_value_observer.h',
       'layer_impl.cc',
       'layer_impl.h',
       'layer_iterator.cc',
@@ -123,6 +126,8 @@
       'managed_memory_policy.h',
       'math_util.cc',
       'math_util.h',
+      'memory_history.cc',
+      'memory_history.h',
       'nine_patch_layer.cc',
       'nine_patch_layer.h',
       'nine_patch_layer_impl.cc',
@@ -135,10 +140,14 @@
       'overdraw_metrics.h',
       'page_scale_animation.cc',
       'page_scale_animation.h',
+      'paint_time_counter.cc',
+      'paint_time_counter.h',
       'picture.cc',
       'picture.h',
       'picture_image_layer.cc',
       'picture_image_layer.h',
+      'picture_image_layer_impl.cc',
+      'picture_image_layer_impl.h',
       'picture_layer.cc',
       'picture_layer.h',
       'picture_layer_impl.cc',
@@ -149,6 +158,8 @@
       'picture_layer_tiling_set.h',
       'picture_pile.cc',
       'picture_pile.h',
+      'picture_pile_base.cc',
+      'picture_pile_base.h',
       'picture_pile_impl.cc',
       'picture_pile_impl.h',
       'platform_color.h',
@@ -165,6 +176,8 @@
       'quad_culler.cc',
       'quad_culler.h',
       'quad_sink.h',
+      'raster_worker_pool.cc',
+      'raster_worker_pool.h',
       'rate_limiter.cc',
       'rate_limiter.h',
       'region.cc',
@@ -196,18 +209,19 @@
       'resource_update_controller.h',
       'resource_update_queue.cc',
       'resource_update_queue.h',
+      'ring_buffer.h',
       'scheduler.cc',
       'scheduler.h',
+      'scheduler_settings.cc',
+      'scheduler_settings.h',
       'scheduler_state_machine.cc',
       'scheduler_state_machine.h',
+      'scoped_ptr_algorithm.h',
       'scoped_ptr_deque.h',
       'scoped_ptr_hash_map.h',
       'scoped_ptr_vector.h',
       'scoped_resource.cc',
       'scoped_resource.h',
-      'scoped_thread_proxy.cc',
-      'scoped_thread_proxy.h',
-      'scrollbar_animation_controller.cc',
       'scrollbar_animation_controller.h',
       'scrollbar_animation_controller_linear_fade.cc',
       'scrollbar_animation_controller_linear_fade.h',
@@ -250,6 +264,8 @@
       'texture_layer_client.h',
       'texture_layer_impl.cc',
       'texture_layer_impl.h',
+      'texture_mailbox.cc',
+      'texture_mailbox.h',
       'texture_uploader.cc',
       'texture_uploader.h',
       'thread.h',
@@ -274,26 +290,51 @@
       'time_source.h',
       'timing_function.cc',
       'timing_function.h',
+      'top_controls_manager.cc',
+      'top_controls_manager.h',
+      'top_controls_manager_client.h',
       'transferable_resource.cc',
       'transferable_resource.h',
+      'transform_operation.cc',
+      'transform_operation.h',
+      'transform_operations.cc',
+      'transform_operations.h',
       'tree_synchronizer.cc',
       'tree_synchronizer.h',
       'util.h',
+      'video_frame_provider.h',
+      'video_frame_provider_client_impl.cc',
+      'video_frame_provider_client_impl.h',
       'video_layer.cc',
       'video_layer.h',
       'video_layer_impl.cc',
       'video_layer_impl.h',
+      'vsync_time_source.cc',
+      'vsync_time_source.h',
+      'worker_pool.cc',
+      'worker_pool.h',
       'yuv_video_draw_quad.cc',
       'yuv_video_draw_quad.h',
     ],
+    'conditions': [
+      ['inside_chromium_build==1', {
+        'webkit_src_dir': '<(DEPTH)/third_party/WebKit',
+      }, {
+        'webkit_src_dir': '<(DEPTH)/../../..',
+      }],
+    ],
   },
+  'conditions': [
+    ['inside_chromium_build==0', {
+      'defines': [
+        'INSIDE_WEBKIT_BUILD=1',
+      ],
+    }],
+  ],
   'targets': [
     {
       'target_name': 'cc',
       'type': '<(component)',
-      'includes': [
-        'cc.gypi',
-      ],
       'dependencies': [
         '<(DEPTH)/base/base.gyp:base',
         '<(DEPTH)/base/third_party/dynamic_annotations/dynamic_annotations.gyp:dynamic_annotations',
@@ -306,19 +347,17 @@
       'defines': [
         'CC_IMPLEMENTATION=1',
       ],
-      'include_dirs': [
-        '<(webkit_src_dir)/Source/Platform/chromium',
-        '<@(cc_stubs_dirs)',
-      ],
       'sources': [
         '<@(cc_source_files)',
       ],
       'all_dependent_settings': {
         'include_dirs': [
-          # Needed for <public/WebTransformationMatrix.h> in layer.h
-          '<(webkit_src_dir)/Source/Platform/chromium',
-        ],
-      }
+          # TODO(jamesr): Remove once https://webkit.org/b/105259 lands + rolls
+          '<(webkit_src_dir)/Source/Platform/chromium'
+        ]
+      },
+      # TODO(jschuh): crbug.com/167187 fix size_t to int truncations.
+      'msvs_disabled_warnings': [ 4267, ],
     },
   ],
 }
Index: src/cc/layer_tree_host_common_unittest.cc
===================================================================
--- src/cc/layer_tree_host_common_unittest.cc	(revision 184497)
+++ src/cc/layer_tree_host_common_unittest.cc	(working copy)
@@ -6,9 +6,11 @@
 
 #include "cc/content_layer.h"
 #include "cc/content_layer_client.h"
+#include "cc/heads_up_display_layer_impl.h"
 #include "cc/layer.h"
 #include "cc/layer_animation_controller.h"
 #include "cc/layer_impl.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/math_util.h"
 #include "cc/proxy.h"
 #include "cc/single_thread_proxy.h"
@@ -70,7 +72,7 @@
 
     // We are probably not testing what is intended if the rootLayer bounds are empty.
     DCHECK(!rootLayer->bounds().IsEmpty());
-    LayerTreeHostCommon::calculateDrawProperties(rootLayer, deviceViewportSize, deviceScaleFactor, pageScaleFactor, dummyMaxTextureSize, canUseLCDText, dummyRenderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(rootLayer, deviceViewportSize, deviceScaleFactor, pageScaleFactor, dummyMaxTextureSize, canUseLCDText, dummyRenderSurfaceLayerList, false);
 }
 
 scoped_ptr<LayerImpl> createTreeForFixedPositionTests(LayerTreeHostImpl* hostImpl)
@@ -103,7 +105,7 @@
     {
     }
 
-    virtual bool drawsContent() const OVERRIDE { return true; }
+    virtual bool drawsContent() const OVERRIDE;
 
 private:
     virtual ~LayerWithForcedDrawsContent()
@@ -111,6 +113,37 @@
     }
 };
 
+class LayerCanClipSelf : public Layer {
+public:
+    LayerCanClipSelf()
+        : Layer()
+    {
+    }
+
+    virtual bool drawsContent() const OVERRIDE;
+    virtual bool canClipSelf() const OVERRIDE;
+
+private:
+    virtual ~LayerCanClipSelf()
+    {
+    }
+};
+
+bool LayerWithForcedDrawsContent::drawsContent() const
+{
+    return true;
+}
+
+bool LayerCanClipSelf::drawsContent() const
+{
+    return true;
+}
+
+bool LayerCanClipSelf::canClipSelf() const
+{
+    return true;
+}
+
 class MockContentLayerClient : public ContentLayerClient {
 public:
     MockContentLayerClient() { }
@@ -287,7 +320,8 @@
     // Sublayer matrix is applied to the center of the parent layer.
     parentCompositeTransform = parentTranslationToAnchor * parentLayerTransform * inverse(parentTranslationToAnchor)
             * parentTranslationToCenter * parentSublayerMatrix * inverse(parentTranslationToCenter);
-    gfx::Transform flattenedCompositeTransform = MathUtil::to2dTransform(parentCompositeTransform);
+    gfx::Transform flattenedCompositeTransform = parentCompositeTransform;
+    flattenedCompositeTransform.FlattenTo2d();
     setLayerPropertiesForTesting(parent.get(), parentLayerTransform, parentSublayerMatrix, gfx::PointF(0.25, 0.25), gfx::PointF(0, 0), gfx::Size(10, 12), false);
     setLayerPropertiesForTesting(child.get(), identityMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(16, 18), false);
     setLayerPropertiesForTesting(grandChild.get(), identityMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(76, 78), false);
@@ -333,11 +367,12 @@
     parentTranslationToAnchor.Translate(25, 30);
     gfx::Transform parentSublayerMatrix;
     parentSublayerMatrix.Scale3d(0.9, 1, 3.3);
+
     gfx::Transform parentTranslationToCenter;
     parentTranslationToCenter.Translate(50, 60);
     gfx::Transform parentCompositeTransform = parentTranslationToAnchor * parentLayerTransform * inverse(parentTranslationToAnchor)
             * parentTranslationToCenter * parentSublayerMatrix * inverse(parentTranslationToCenter);
-    gfx::Vector2dF parentCompositeScale = MathUtil::computeTransform2dScaleComponents(parentCompositeTransform, 1.f);
+    gfx::Vector2dF parentCompositeScale = MathUtil::computeTransform2dScaleComponents(parentCompositeTransform, 1.0f);
     gfx::Transform surfaceSublayerTransform;
     surfaceSublayerTransform.Scale(parentCompositeScale.x(), parentCompositeScale.y());
     gfx::Transform surfaceSublayerCompositeTransform = parentCompositeTransform * inverse(surfaceSublayerTransform);
@@ -367,6 +402,91 @@
     EXPECT_TRANSFORMATION_MATRIX_EQ(surfaceSublayerCompositeTransform, child->renderTarget()->renderSurface()->screenSpaceTransform());
 }
 
+TEST(LayerTreeHostCommonTest, verifySeparateRenderTargetRequirementWithClipping)
+{
+    scoped_refptr<Layer> root = Layer::create();
+    scoped_refptr<Layer> parent = Layer::create();
+    scoped_refptr<Layer> child = Layer::create();
+    scoped_refptr<Layer> grandChild = make_scoped_refptr(new LayerCanClipSelf());
+    root->addChild(parent);
+    parent->addChild(child);
+    child->addChild(grandChild);
+    parent->setMasksToBounds(true);
+    child->setMasksToBounds(true);
+
+    gfx::Transform identityMatrix;
+    gfx::Transform parentLayerTransform;
+    gfx::Transform parentSublayerMatrix;
+    gfx::Transform childLayerMatrix;
+
+    // No render surface should exist yet.
+    EXPECT_FALSE(root->renderSurface());
+    EXPECT_FALSE(parent->renderSurface());
+    EXPECT_FALSE(child->renderSurface());
+    EXPECT_FALSE(grandChild->renderSurface());
+
+    // One-time setup of root layer
+    parentLayerTransform.Scale3d(1, 0.9, 1);
+    parentSublayerMatrix.Scale3d(0.9, 1, 3.3);
+    childLayerMatrix.Rotate(20);
+
+    setLayerPropertiesForTesting(root.get(), identityMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(1, 2), false);
+    setLayerPropertiesForTesting(parent.get(), parentLayerTransform, parentSublayerMatrix, gfx::PointF(0.25, 0.25), gfx::PointF(0, 0), gfx::Size(100, 120), false);
+    setLayerPropertiesForTesting(child.get(), childLayerMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(16, 18), false);
+    setLayerPropertiesForTesting(grandChild.get(), identityMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(8, 10), false);
+
+    executeCalculateDrawProperties(root.get());
+
+    // Render surfaces should have been created according to clipping rules now (grandchild can clip self).
+    EXPECT_TRUE(root->renderSurface());
+    EXPECT_FALSE(parent->renderSurface());
+    EXPECT_FALSE(child->renderSurface());
+    EXPECT_FALSE(grandChild->renderSurface());
+}
+
+TEST(LayerTreeHostCommonTest, verifySeparateRenderTargetRequirementWithoutClipping)
+{
+    scoped_refptr<Layer> root = Layer::create();
+    scoped_refptr<Layer> parent = Layer::create();
+    scoped_refptr<Layer> child = Layer::create();
+    // This layer cannot clip itself, a feature we are testing here.
+    scoped_refptr<Layer> grandChild = make_scoped_refptr(new LayerWithForcedDrawsContent());
+    root->addChild(parent);
+    parent->addChild(child);
+    child->addChild(grandChild);
+    parent->setMasksToBounds(true);
+    child->setMasksToBounds(true);
+
+    gfx::Transform identityMatrix;
+    gfx::Transform parentLayerTransform;
+    gfx::Transform parentSublayerMatrix;
+    gfx::Transform childLayerMatrix;
+
+    // No render surface should exist yet.
+    EXPECT_FALSE(root->renderSurface());
+    EXPECT_FALSE(parent->renderSurface());
+    EXPECT_FALSE(child->renderSurface());
+    EXPECT_FALSE(grandChild->renderSurface());
+
+    // One-time setup of root layer
+    parentLayerTransform.Scale3d(1, 0.9, 1);
+    parentSublayerMatrix.Scale3d(0.9, 1, 3.3);
+    childLayerMatrix.Rotate(20);
+
+    setLayerPropertiesForTesting(root.get(), identityMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(1, 2), false);
+    setLayerPropertiesForTesting(parent.get(), parentLayerTransform, parentSublayerMatrix, gfx::PointF(0.25, 0.25), gfx::PointF(0, 0), gfx::Size(100, 120), false);
+    setLayerPropertiesForTesting(child.get(), childLayerMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(16, 18), false);
+    setLayerPropertiesForTesting(grandChild.get(), identityMatrix, identityMatrix, gfx::PointF(0, 0), gfx::PointF(0, 0), gfx::Size(8, 10), false);
+
+    executeCalculateDrawProperties(root.get());
+
+    // Render surfaces should have been created according to clipping rules now (grandchild can't clip self).
+    EXPECT_TRUE(root->renderSurface());
+    EXPECT_FALSE(parent->renderSurface());
+    EXPECT_TRUE(child->renderSurface());
+    EXPECT_FALSE(grandChild->renderSurface());
+}
+
 TEST(LayerTreeHostCommonTest, verifyTransformsForReplica)
 {
     scoped_refptr<Layer> root = Layer::create();
@@ -616,7 +736,7 @@
     scoped_refptr<LayerWithForcedDrawsContent> grandChild = make_scoped_refptr(new LayerWithForcedDrawsContent());
 
     gfx::Transform rotationAboutYAxis;
-    MathUtil::rotateEulerAngles(&rotationAboutYAxis, 0, 30, 0);
+    rotationAboutYAxis.RotateAboutYAxis(30);
 
     const gfx::Transform identityMatrix;
     setLayerPropertiesForTesting(root.get(), identityMatrix, identityMatrix, gfx::PointF(), gfx::PointF(), gfx::Size(100, 100), false);
@@ -635,7 +755,9 @@
     gfx::Transform expectedChildDrawTransform = rotationAboutYAxis;
     gfx::Transform expectedChildScreenSpaceTransform = rotationAboutYAxis;
     gfx::Transform expectedGrandChildDrawTransform = rotationAboutYAxis; // draws onto child's renderSurface
-    gfx::Transform expectedGrandChildScreenSpaceTransform = MathUtil::to2dTransform(rotationAboutYAxis) * rotationAboutYAxis;
+    gfx::Transform flattenedRotationAboutY = rotationAboutYAxis;
+    flattenedRotationAboutY.FlattenTo2d();
+    gfx::Transform expectedGrandChildScreenSpaceTransform = flattenedRotationAboutY * rotationAboutYAxis;
 
     executeCalculateDrawProperties(root.get());
 
@@ -911,7 +1033,7 @@
     LayerImpl* greatGrandChild = grandChild->children()[0];
 
     gfx::Transform rotationAboutZ;
-    MathUtil::rotateEulerAngles(&rotationAboutZ, 0, 0, 90);
+    rotationAboutZ.RotateAboutZAxis(90);
 
     child->setIsContainerForFixedPositionLayers(true);
     child->setTransform(rotationAboutZ);
@@ -973,7 +1095,7 @@
     LayerImpl* greatGrandChild = grandChild->children()[0];
 
     gfx::Transform rotationAboutZ;
-    MathUtil::rotateEulerAngles(&rotationAboutZ, 0, 0, 90);
+    rotationAboutZ.RotateAboutZAxis(90);
 
     child->setIsContainerForFixedPositionLayers(true);
     child->setTransform(rotationAboutZ);
@@ -1041,7 +1163,7 @@
     greatGrandChild->setDrawsContent(true);
 
     gfx::Transform rotationAboutZ;
-    MathUtil::rotateEulerAngles(&rotationAboutZ, 0, 0, 90);
+    rotationAboutZ.RotateAboutZAxis(90);
     grandChild->setTransform(rotationAboutZ);
 
     // Case 1: scrollDelta of 0, 0
@@ -1131,7 +1253,7 @@
     // clip away layers that we want to test.
     gfx::Transform rotationAboutZ;
     rotationAboutZ.Translate(50, 50);
-    MathUtil::rotateEulerAngles(&rotationAboutZ, 0, 0, 90);
+    rotationAboutZ.RotateAboutZAxis(90);
     rotationAboutZ.Translate(-50, -50);
     grandChild->setTransform(rotationAboutZ);
     greatGrandChild->setTransform(rotationAboutZ);
@@ -1302,7 +1424,7 @@
     LayerImpl* grandChild = child->children()[0];
 
     gfx::Transform rotationByZ;
-    MathUtil::rotateEulerAngles(&rotationByZ, 0, 0, 90);
+    rotationByZ.RotateAboutZAxis(90);
 
     root->setTransform(rotationByZ);
     grandChild->setFixedToContainerLayer(true);
@@ -1700,24 +1822,11 @@
     renderSurface1->setForceRenderSurface(true);
     renderSurface2->setForceRenderSurface(true);
 
-    // Put an animated opacity on the render surface.
-    addOpacityTransitionToController(*renderSurface1->layerAnimationController(), 10, 1, 0, false);
-
-    // Also put an animated opacity on a layer without descendants.
-    addOpacityTransitionToController(*grandChildOfRoot->layerAnimationController(), 10, 1, 0, false);
-
     gfx::Transform layerTransform;
     layerTransform.Translate(1, 1);
     gfx::Transform sublayerTransform;
     sublayerTransform.Scale3d(10, 1, 1);
 
-    // Put a transform animation on the render surface.
-    addAnimatedTransformToController(*renderSurface2->layerAnimationController(), 10, 30, 0);
-
-    // Also put transform animations on grandChildOfRoot, and grandChildOfRS2
-    addAnimatedTransformToController(*grandChildOfRoot->layerAnimationController(), 10, 30, 0);
-    addAnimatedTransformToController(*grandChildOfRS2->layerAnimationController(), 10, 30, 0);
-
     setLayerPropertiesForTesting(parent.get(), layerTransform, sublayerTransform, gfx::PointF(0.25, 0), gfx::PointF(2.5, 0), gfx::Size(10, 10), false);
     setLayerPropertiesForTesting(renderSurface1.get(), layerTransform, sublayerTransform, gfx::PointF(0.25, 0), gfx::PointF(2.5, 0), gfx::Size(10, 10), false);
     setLayerPropertiesForTesting(renderSurface2.get(), layerTransform, sublayerTransform, gfx::PointF(0.25, 0), gfx::PointF(2.5, 0), gfx::Size(10, 10), false);
@@ -1728,6 +1837,19 @@
     setLayerPropertiesForTesting(grandChildOfRS1.get(), layerTransform, sublayerTransform, gfx::PointF(0.25, 0), gfx::PointF(2.5, 0), gfx::Size(10, 10), false);
     setLayerPropertiesForTesting(grandChildOfRS2.get(), layerTransform, sublayerTransform, gfx::PointF(0.25, 0), gfx::PointF(2.5, 0), gfx::Size(10, 10), false);
 
+    // Put an animated opacity on the render surface.
+    addOpacityTransitionToController(*renderSurface1->layerAnimationController(), 10, 1, 0, false);
+
+    // Also put an animated opacity on a layer without descendants.
+    addOpacityTransitionToController(*grandChildOfRoot->layerAnimationController(), 10, 1, 0, false);
+
+    // Put a transform animation on the render surface.
+    addAnimatedTransformToController(*renderSurface2->layerAnimationController(), 10, 30, 0);
+
+    // Also put transform animations on grandChildOfRoot, and grandChildOfRS2
+    addAnimatedTransformToController(*grandChildOfRoot->layerAnimationController(), 10, 30, 0);
+    addAnimatedTransformToController(*grandChildOfRS2->layerAnimationController(), 10, 30, 0);
+
     executeCalculateDrawProperties(parent.get());
 
     // Only layers that are associated with render surfaces should have an actual renderSurface() value.
@@ -1929,7 +2051,7 @@
 
     // Case 1: Orthographic projection of a layer rotated about y-axis by 45 degrees, should be fully contained in the renderSurface.
     layerToSurfaceTransform.MakeIdentity();
-    MathUtil::rotateEulerAngles(&layerToSurfaceTransform, 0, 45, 0);
+    layerToSurfaceTransform.RotateAboutYAxis(45);
     gfx::Rect expected = gfx::Rect(gfx::Point(0, 0), gfx::Size(100, 100));
     gfx::Rect actual = LayerTreeHostCommon::calculateVisibleRect(targetSurfaceRect, layerContentRect, layerToSurfaceTransform);
     EXPECT_RECT_EQ(expected, actual);
@@ -1940,7 +2062,7 @@
     double halfWidthOfRotatedLayer = (100 / sqrt(2.0)) * 0.5; // 100 is the un-rotated layer width; divided by sqrt(2) is the rotated width.
     layerToSurfaceTransform.MakeIdentity();
     layerToSurfaceTransform.Translate(-halfWidthOfRotatedLayer, 0);
-    MathUtil::rotateEulerAngles(&layerToSurfaceTransform, 0, 45, 0); // rotates about the left edge of the layer
+    layerToSurfaceTransform.RotateAboutYAxis(45); // rotates about the left edge of the layer
     expected = gfx::Rect(gfx::Point(50, 0), gfx::Size(50, 100)); // right half of the layer.
     actual = LayerTreeHostCommon::calculateVisibleRect(targetSurfaceRect, layerContentRect, layerToSurfaceTransform);
     EXPECT_RECT_EQ(expected, actual);
@@ -2001,7 +2123,7 @@
     // center of the layer.
     layerToSurfaceTransform.MakeIdentity();
     layerToSurfaceTransform.Translate(50, 0);
-    MathUtil::rotateEulerAngles(&layerToSurfaceTransform, 0, 45, 0);
+    layerToSurfaceTransform.RotateAboutYAxis(45);
     layerToSurfaceTransform.Translate(-50, 0);
 
     gfx::Rect expected = gfx::Rect(gfx::Point(0, 0), gfx::Size(100, 100));
@@ -2028,7 +2150,7 @@
     layerToSurfaceTransform.MakeIdentity();
     layerToSurfaceTransform.ApplyPerspectiveDepth(1);
     layerToSurfaceTransform.Translate3d(-2, 0, 1);
-    MathUtil::rotateEulerAngles(&layerToSurfaceTransform, 0, 45, 0);
+    layerToSurfaceTransform.RotateAboutYAxis(45);
 
     // Sanity check that this transform does indeed cause w < 0 when applying the
     // transform, otherwise this code is not testing the intended scenario.
@@ -2057,8 +2179,8 @@
     layerToSurfaceTransform.MakeIdentity();
     layerToSurfaceTransform.ApplyPerspectiveDepth(1);
     layerToSurfaceTransform.Translate3d(0, 0, -5);
-    MathUtil::rotateEulerAngles(&layerToSurfaceTransform, 0, 45, 0);
-    MathUtil::rotateEulerAngles(&layerToSurfaceTransform, 80, 0, 0);
+    layerToSurfaceTransform.RotateAboutYAxis(45);
+    layerToSurfaceTransform.RotateAboutXAxis(80);
 
     // Sanity check that un-projection does indeed cause w < 0, otherwise this code is not
     // testing the intended scenario.
@@ -2796,7 +2918,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -2823,6 +2945,57 @@
     EXPECT_EQ(12345, resultLayer->id());
 }
 
+TEST(LayerTreeHostCommonTest, verifyHitTestingForSingleLayerAndHud)
+{
+    FakeImplProxy proxy;
+    FakeLayerTreeHostImpl hostImpl(&proxy);
+    scoped_ptr<LayerImpl> root = LayerImpl::create(hostImpl.activeTree(), 12345);
+    scoped_ptr<HeadsUpDisplayLayerImpl> hud = HeadsUpDisplayLayerImpl::create(hostImpl.activeTree(), 11111);
+
+    gfx::Transform identityMatrix;
+    gfx::PointF anchor(0.f, 0.f);
+    gfx::PointF position(0.f, 0.f);
+    gfx::Size bounds(100, 100);
+    setLayerPropertiesForTesting(root.get(), identityMatrix, identityMatrix, anchor, position, bounds, false);
+    root->setDrawsContent(true);
+
+    // Create hud and add it as a child of root.
+    gfx::Size hudBounds(200, 200);
+    setLayerPropertiesForTesting(hud.get(), identityMatrix, identityMatrix, anchor, position, hudBounds, false);
+    hud->setDrawsContent(true);
+
+    hostImpl.activeTree()->set_hud_layer(hud.get());
+    root->addChild(hud.PassAs<LayerImpl>());
+
+    std::vector<LayerImpl*> renderSurfaceLayerList;
+    int dummyMaxTextureSize = 512;
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), hudBounds, 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
+
+    // Sanity check the scenario we just created.
+    ASSERT_EQ(1u, renderSurfaceLayerList.size());
+    ASSERT_EQ(2u, root->renderSurface()->layerList().size());
+
+    // Hit testing for a point inside HUD, but outside root should return null
+    gfx::Point testPoint(101, 101);
+    LayerImpl* resultLayer = LayerTreeHostCommon::findLayerThatIsHitByPoint(testPoint, renderSurfaceLayerList);
+    EXPECT_FALSE(resultLayer);
+
+    testPoint = gfx::Point(-1, -1);
+    resultLayer = LayerTreeHostCommon::findLayerThatIsHitByPoint(testPoint, renderSurfaceLayerList);
+    EXPECT_FALSE(resultLayer);
+
+    // Hit testing for a point inside should return the root layer, never the HUD layer.
+    testPoint = gfx::Point(1, 1);
+    resultLayer = LayerTreeHostCommon::findLayerThatIsHitByPoint(testPoint, renderSurfaceLayerList);
+    ASSERT_TRUE(resultLayer);
+    EXPECT_EQ(12345, resultLayer->id());
+
+    testPoint = gfx::Point(99, 99);
+    resultLayer = LayerTreeHostCommon::findLayerThatIsHitByPoint(testPoint, renderSurfaceLayerList);
+    ASSERT_TRUE(resultLayer);
+    EXPECT_EQ(12345, resultLayer->id());
+}
+
 TEST(LayerTreeHostCommonTest, verifyHitTestingForUninvertibleTransform)
 {
     FakeImplProxy proxy;
@@ -2845,7 +3018,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -2899,7 +3072,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -2936,7 +3109,7 @@
     gfx::Transform identityMatrix;
     gfx::Transform rotation45DegreesAboutCenter;
     rotation45DegreesAboutCenter.Translate(50, 50);
-    MathUtil::rotateEulerAngles(&rotation45DegreesAboutCenter, 0, 0, 45);
+    rotation45DegreesAboutCenter.RotateAboutZAxis(45);
     rotation45DegreesAboutCenter.Translate(-50, -50);
     gfx::PointF anchor(0, 0);
     gfx::PointF position(0, 0);
@@ -2946,7 +3119,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3002,7 +3175,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3067,7 +3240,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     // The visibleContentRect for testLayer is actually 100x100, even though its layout size is 50x50, positioned at 25x25.
@@ -3131,7 +3304,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3195,7 +3368,7 @@
         child->setMasksToBounds(true);
 
         gfx::Transform rotation45DegreesAboutCorner;
-        MathUtil::rotateEulerAngles(&rotation45DegreesAboutCorner, 0, 0, 45);
+        rotation45DegreesAboutCorner.RotateAboutZAxis(45);
 
         position = gfx::PointF(0, 0); // remember, positioned with respect to its parent which is already at 10, 10
         bounds = gfx::Size(200, 200); // to ensure it covers at least sqrt(2) * 100.
@@ -3205,9 +3378,9 @@
         // Rotates about the center of the layer
         gfx::Transform rotatedLeafTransform;
         rotatedLeafTransform.Translate(-10, -10); // cancel out the grandParent's position
-        MathUtil::rotateEulerAngles(&rotatedLeafTransform, 0, 0, -45); // cancel out the corner 45-degree rotation of the parent.
+        rotatedLeafTransform.RotateAboutZAxis(-45); // cancel out the corner 45-degree rotation of the parent.
         rotatedLeafTransform.Translate(50, 50);
-        MathUtil::rotateEulerAngles(&rotatedLeafTransform, 0, 0, 45);
+        rotatedLeafTransform.RotateAboutZAxis(45);
         rotatedLeafTransform.Translate(-50, -50);
         position = gfx::PointF(0, 0);
         bounds = gfx::Size(100, 100);
@@ -3221,7 +3394,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     // The grandChild is expected to create a renderSurface because it masksToBounds and is not axis aligned.
@@ -3303,7 +3476,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3383,7 +3556,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_TRUE(child1);
@@ -3491,7 +3664,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_TRUE(child1);
@@ -3577,7 +3750,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3643,7 +3816,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3699,7 +3872,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3771,7 +3944,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     // The visibleContentRect for testLayer is actually 100x100, even though its layout size is 50x50, positioned at 25x25.
@@ -3847,7 +4020,7 @@
     pageScaleTransform.Scale(pageScaleFactor, pageScaleFactor);
     root->setImplTransform(pageScaleTransform); // Applying the pageScaleFactor through implTransform.
     gfx::Size scaledBoundsForRoot = gfx::ToCeiledSize(gfx::ScaleSize(root->bounds(), deviceScaleFactor * pageScaleFactor));
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), scaledBoundsForRoot, deviceScaleFactor, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), scaledBoundsForRoot, deviceScaleFactor, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     // The visibleContentRect for testLayer is actually 100x100, even though its layout size is 50x50, positioned at 25x25.
@@ -3931,7 +4104,7 @@
 
     std::vector<LayerImpl*> renderSurfaceLayerList;
     int dummyMaxTextureSize = 512;
-    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root.get(), root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 
     // Sanity check the scenario we just created.
     ASSERT_EQ(1u, renderSurfaceLayerList.size());
@@ -3972,12 +4145,15 @@
 
     virtual void calculateContentsScale(
         float idealContentsScale,
+        bool animatingTransformToScreen,
         float* contentsScaleX,
         float* contentsScaleY,
         gfx::Size* contentBounds) OVERRIDE
     {
-      Layer::calculateContentsScale(
+        // Skip over the ContentLayer to the base Layer class.
+        Layer::calculateContentsScale(
             idealContentsScale,
+            animatingTransformToScreen,
             contentsScaleX,
             contentsScaleY,
             contentBounds);
Index: src/cc/render_pass_unittest.cc
===================================================================
--- src/cc/render_pass_unittest.cc	(revision 184497)
+++ src/cc/render_pass_unittest.cc	(working copy)
@@ -4,18 +4,15 @@
 
 #include "cc/render_pass.h"
 
-#include <public/WebFilterOperations.h>
-
 #include "cc/checkerboard_draw_quad.h"
 #include "cc/math_util.h"
 #include "cc/test/geometry_test_utils.h"
 #include "cc/test/render_pass_test_common.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "third_party/skia/include/effects/SkBlurImageFilter.h"
 #include "ui/gfx/transform.h"
 
-using WebKit::WebFilterOperation;
-using WebKit::WebFilterOperations;
 using cc::TestRenderPass;
 
 namespace cc {
@@ -31,45 +28,33 @@
     gfx::RectF m_damageRect;
     bool m_hasTransparentBackground;
     bool m_hasOcclusionFromOutsideTargetSurface;
-    WebKit::WebFilterOperations m_filters;
-    WebKit::WebFilterOperations m_backgroundFilters;
-    SkImageFilter* m_filter;
 };
 
 TEST(RenderPassTest, copyShouldBeIdenticalExceptIdAndQuads)
 {
     RenderPass::Id id(3, 2);
     gfx::Rect outputRect(45, 22, 120, 13);
-    gfx::Transform transformToRoot = MathUtil::createGfxTransform(1, 0.5, 0.5, -0.5, -1, 0);
+    gfx::Transform transformToRoot = gfx::Transform(1.0, 0.5, 0.5, -0.5, -1.0, 0.0);
     gfx::Rect damageRect(56, 123, 19, 43);
     bool hasTransparentBackground = true;
     bool hasOcclusionFromOutsideTargetSurface = true;
-    WebFilterOperations filters;
-    WebFilterOperations backgroundFilters;
 
-    filters.append(WebFilterOperation::createGrayscaleFilter(0.2f));
-    backgroundFilters.append(WebFilterOperation::createInvertFilter(0.2f));
-    skia::RefPtr<SkImageFilter> filter = skia::AdoptRef(new SkBlurImageFilter(SK_Scalar1, SK_Scalar1));
-
     scoped_ptr<TestRenderPass> pass = TestRenderPass::Create();
     pass->SetAll(id,
                  outputRect,
                  damageRect,
                  transformToRoot,
                  hasTransparentBackground,
-                 hasOcclusionFromOutsideTargetSurface,
-                 filters,
-                 filter,
-                 backgroundFilters);
+                 hasOcclusionFromOutsideTargetSurface);
 
     // Stick a quad in the pass, this should not get copied.
     scoped_ptr<SharedQuadState> sharedState = SharedQuadState::Create();
-    sharedState->SetAll(gfx::Transform(), gfx::Rect(), gfx::Rect(), gfx::Rect(), false, 1);
+    sharedState->SetAll(gfx::Transform(), gfx::Rect(), gfx::Rect(), false, 1);
     pass->AppendSharedQuadState(sharedState.Pass());
 
     scoped_ptr<CheckerboardDrawQuad> checkerboardQuad = CheckerboardDrawQuad::Create();
-    checkerboardQuad->SetNew(pass->shared_quad_state_list.last(), gfx::Rect(), SkColor());
-    pass->quad_list.append(checkerboardQuad.PassAs<DrawQuad>());
+    checkerboardQuad->SetNew(pass->shared_quad_state_list.back(), gfx::Rect(), SkColor());
+    pass->quad_list.push_back(checkerboardQuad.PassAs<DrawQuad>());
 
     RenderPass::Id newId(63, 4);
 
@@ -80,9 +65,6 @@
     EXPECT_RECT_EQ(pass->damage_rect, copy->damage_rect);
     EXPECT_EQ(pass->has_transparent_background, copy->has_transparent_background);
     EXPECT_EQ(pass->has_occlusion_from_outside_target_surface, copy->has_occlusion_from_outside_target_surface);
-    EXPECT_EQ(pass->filters, copy->filters);
-    EXPECT_EQ(pass->filter, copy->filter);
-    EXPECT_EQ(pass->background_filters, copy->background_filters);
     EXPECT_EQ(0u, copy->quad_list.size());
 
     EXPECT_EQ(sizeof(RenderPassSize), sizeof(RenderPass));
Index: src/cc/active_animation_unittest.cc
===================================================================
--- src/cc/active_animation_unittest.cc	(revision 184497)
+++ src/cc/active_animation_unittest.cc	(working copy)
@@ -1,218 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "cc/active_animation.h"
-
-#include "cc/test/animation_test_common.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace cc {
-namespace {
-
-scoped_ptr<ActiveAnimation> createActiveAnimation(int iterations, double duration)
-{
-    scoped_ptr<ActiveAnimation> toReturn(ActiveAnimation::create(make_scoped_ptr(new FakeFloatAnimationCurve(duration)).PassAs<AnimationCurve>(), 0, 1, ActiveAnimation::Opacity));
-    toReturn->setIterations(iterations);
-    return toReturn.Pass();
-}
-
-scoped_ptr<ActiveAnimation> createActiveAnimation(int iterations)
-{
-    return createActiveAnimation(iterations, 1);
-}
-
-TEST(ActiveAnimationTest, TrimTimeZeroIterations)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(0));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(-1));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(1));
-}
-
-TEST(ActiveAnimationTest, TrimTimeOneIteration)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(-1));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(2));
-}
-
-TEST(ActiveAnimationTest, TrimTimeInfiniteIterations)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(-1));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(1));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1.5));
-}
-
-TEST(ActiveAnimationTest, TrimTimeAlternating)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(-1));
-    anim->setAlternatesDirection(true);
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
-    EXPECT_EQ(0.75, anim->trimTimeToCurrentIteration(1.25));
-}
-
-TEST(ActiveAnimationTest, TrimTimeStartTime)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setStartTime(4);
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(4));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(4.5));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(5));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(6));
-}
-
-TEST(ActiveAnimationTest, TrimTimeTimeOffset)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setTimeOffset(4);
-    anim->setStartTime(4);
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
-}
-
-TEST(ActiveAnimationTest, TrimTimePauseResume)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
-    anim->setRunState(ActiveAnimation::Paused, 0.5);
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
-    anim->setRunState(ActiveAnimation::Running, 1024);
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1024.5));
-}
-
-TEST(ActiveAnimationTest, TrimTimeSuspendResume)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
-    anim->suspend(0.5);
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
-    anim->resume(1024);
-    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
-    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1024.5));
-}
-
-TEST(ActiveAnimationTest, TrimTimeZeroDuration)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(0, 0));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(-1));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
-    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(1));
-}
-
-TEST(ActiveAnimationTest, IsFinishedAtZeroIterations)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(0));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_FALSE(anim->isFinishedAt(-1));
-    EXPECT_TRUE(anim->isFinishedAt(0));
-    EXPECT_TRUE(anim->isFinishedAt(1));
-}
-
-TEST(ActiveAnimationTest, IsFinishedAtOneIteration)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_FALSE(anim->isFinishedAt(-1));
-    EXPECT_FALSE(anim->isFinishedAt(0));
-    EXPECT_TRUE(anim->isFinishedAt(1));
-    EXPECT_TRUE(anim->isFinishedAt(2));
-}
-
-TEST(ActiveAnimationTest, IsFinishedAtInfiniteIterations)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(-1));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_FALSE(anim->isFinishedAt(0));
-    EXPECT_FALSE(anim->isFinishedAt(0.5));
-    EXPECT_FALSE(anim->isFinishedAt(1));
-    EXPECT_FALSE(anim->isFinishedAt(1.5));
-}
-
-TEST(ActiveAnimationTest, IsFinishedAtNotRunning)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(0));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_TRUE(anim->isFinishedAt(0));
-    anim->setRunState(ActiveAnimation::Paused, 0);
-    EXPECT_FALSE(anim->isFinishedAt(0));
-    anim->setRunState(ActiveAnimation::WaitingForNextTick, 0);
-    EXPECT_FALSE(anim->isFinishedAt(0));
-    anim->setRunState(ActiveAnimation::WaitingForTargetAvailability, 0);
-    EXPECT_FALSE(anim->isFinishedAt(0));
-    anim->setRunState(ActiveAnimation::WaitingForStartTime, 0);
-    EXPECT_FALSE(anim->isFinishedAt(0));
-    anim->setRunState(ActiveAnimation::Finished, 0);
-    EXPECT_TRUE(anim->isFinishedAt(0));
-    anim->setRunState(ActiveAnimation::Aborted, 0);
-    EXPECT_TRUE(anim->isFinishedAt(0));
-}
-
-TEST(ActiveAnimationTest, IsFinished)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::Paused, 0);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::WaitingForNextTick, 0);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::WaitingForTargetAvailability, 0);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::WaitingForStartTime, 0);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::Finished, 0);
-    EXPECT_TRUE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::Aborted, 0);
-    EXPECT_TRUE(anim->isFinished());
-}
-
-TEST(ActiveAnimationTest, IsFinishedNeedsSynchronizedStartTime)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->setRunState(ActiveAnimation::Running, 2);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::Paused, 2);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::WaitingForNextTick, 2);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::WaitingForTargetAvailability, 2);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::WaitingForStartTime, 2);
-    EXPECT_FALSE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::Finished, 0);
-    EXPECT_TRUE(anim->isFinished());
-    anim->setRunState(ActiveAnimation::Aborted, 0);
-    EXPECT_TRUE(anim->isFinished());
-}
-
-TEST(ActiveAnimationTest, RunStateChangesIgnoredWhileSuspended)
-{
-    scoped_ptr<ActiveAnimation> anim(createActiveAnimation(1));
-    anim->suspend(0);
-    EXPECT_EQ(ActiveAnimation::Paused, anim->runState());
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_EQ(ActiveAnimation::Paused, anim->runState());
-    anim->resume(0);
-    anim->setRunState(ActiveAnimation::Running, 0);
-    EXPECT_EQ(ActiveAnimation::Running, anim->runState());
-}
-
-}  // namespace
-}  // namespace cc
Index: src/cc/keyframed_animation_curve.cc
===================================================================
--- src/cc/keyframed_animation_curve.cc	(revision 184497)
+++ src/cc/keyframed_animation_curve.cc	(working copy)
@@ -4,8 +4,6 @@
 
 #include "cc/keyframed_animation_curve.h"
 
-using WebKit::WebTransformationMatrix;
-
 namespace cc {
 
 namespace {
@@ -15,16 +13,16 @@
 {
     // Usually, the keyframes will be added in order, so this loop would be unnecessary and
     // we should skip it if possible.
-    if (!keyframes.isEmpty() && keyframe->time() < keyframes.last()->time()) {
+    if (!keyframes.empty() && keyframe->time() < keyframes.back()->time()) {
         for (size_t i = 0; i < keyframes.size(); ++i) {
             if (keyframe->time() < keyframes[i]->time()) {
-                keyframes.insert(i, keyframe.Pass());
+                keyframes.insert(keyframes.begin() + i, keyframe.Pass());
                 return;
             }
         }
     }
 
-    keyframes.append(keyframe.Pass());
+    keyframes.push_back(keyframe.Pass());
 }
 
 scoped_ptr<TimingFunction> cloneTimingFunction(const TimingFunction* timingFunction)
@@ -84,12 +82,12 @@
     return FloatKeyframe::create(time(), value(), func.Pass());
 }
 
-scoped_ptr<TransformKeyframe> TransformKeyframe::create(double time, const WebKit::WebTransformOperations& value, scoped_ptr<TimingFunction> timingFunction)
+scoped_ptr<TransformKeyframe> TransformKeyframe::create(double time, const TransformOperations& value, scoped_ptr<TimingFunction> timingFunction)
 {
     return make_scoped_ptr(new TransformKeyframe(time, value, timingFunction.Pass()));
 }
 
-TransformKeyframe::TransformKeyframe(double time, const WebKit::WebTransformOperations& value, scoped_ptr<TimingFunction> timingFunction)
+TransformKeyframe::TransformKeyframe(double time, const TransformOperations& value, scoped_ptr<TimingFunction> timingFunction)
     : Keyframe(time, timingFunction.Pass())
     , m_value(value)
 {
@@ -99,7 +97,7 @@
 {
 }
 
-const WebKit::WebTransformOperations& TransformKeyframe::value() const
+const TransformOperations& TransformKeyframe::value() const
 {
     return m_value;
 }
@@ -132,7 +130,7 @@
 
 double KeyframedFloatAnimationCurve::duration() const
 {
-    return m_keyframes.last()->time() - m_keyframes.first()->time();
+    return m_keyframes.back()->time() - m_keyframes.front()->time();
 }
 
 scoped_ptr<AnimationCurve> KeyframedFloatAnimationCurve::clone() const
@@ -145,11 +143,11 @@
 
 float KeyframedFloatAnimationCurve::getValue(double t) const
 {
-    if (t <= m_keyframes.first()->time())
-        return m_keyframes.first()->value();
+    if (t <= m_keyframes.front()->time())
+        return m_keyframes.front()->value();
 
-    if (t >= m_keyframes.last()->time())
-        return m_keyframes.last()->value();
+    if (t >= m_keyframes.back()->time())
+        return m_keyframes.back()->value();
 
     size_t i = 0;
     for (; i < m_keyframes.size() - 1; ++i) {
@@ -185,7 +183,7 @@
 
 double KeyframedTransformAnimationCurve::duration() const
 {
-    return m_keyframes.last()->time() - m_keyframes.first()->time();
+    return m_keyframes.back()->time() - m_keyframes.front()->time();
 }
 
 scoped_ptr<AnimationCurve> KeyframedTransformAnimationCurve::clone() const
@@ -196,13 +194,13 @@
     return toReturn.PassAs<AnimationCurve>();
 }
 
-WebTransformationMatrix KeyframedTransformAnimationCurve::getValue(double t) const
+gfx::Transform KeyframedTransformAnimationCurve::getValue(double t) const
 {
-    if (t <= m_keyframes.first()->time())
-        return m_keyframes.first()->value().apply();
+    if (t <= m_keyframes.front()->time())
+        return m_keyframes.front()->value().Apply();
 
-    if (t >= m_keyframes.last()->time())
-        return m_keyframes.last()->value().apply();
+    if (t >= m_keyframes.back()->time())
+        return m_keyframes.back()->value().Apply();
 
     size_t i = 0;
     for (; i < m_keyframes.size() - 1; ++i) {
@@ -215,7 +213,7 @@
     if (m_keyframes[i]->timingFunction())
         progress = m_keyframes[i]->timingFunction()->getValue(progress);
 
-    return m_keyframes[i+1]->value().blend(m_keyframes[i]->value(), progress);
+    return m_keyframes[i+1]->value().Blend(m_keyframes[i]->value(), progress);
 }
 
 }  // namespace cc
Index: src/cc/tree_synchronizer_unittest.cc
===================================================================
--- src/cc/tree_synchronizer_unittest.cc	(revision 184497)
+++ src/cc/tree_synchronizer_unittest.cc	(working copy)
@@ -76,20 +76,21 @@
 
 class FakeLayerAnimationController : public LayerAnimationController {
 public:
-    static scoped_ptr<FakeLayerAnimationController> create(LayerAnimationControllerClient* client)
+    static scoped_refptr<LayerAnimationController> create()
     {
-        return make_scoped_ptr(new FakeLayerAnimationController(client));
+        return static_cast<LayerAnimationController*>(new FakeLayerAnimationController);
     }
 
     bool synchronizedAnimations() const { return m_synchronizedAnimations; }
 
 private:
-    explicit FakeLayerAnimationController(LayerAnimationControllerClient* client)
-        : LayerAnimationController(client)
+    FakeLayerAnimationController()
+        : LayerAnimationController(1)
         , m_synchronizedAnimations(false)
-    {
-    }
+    { }
 
+    virtual ~FakeLayerAnimationController() { }
+
     virtual void pushAnimationUpdatesTo(LayerAnimationController* controllerImpl)
     {
         LayerAnimationController::pushAnimationUpdatesTo(controllerImpl);
@@ -142,7 +143,7 @@
 // return a null tree.
 TEST_F(TreeSynchronizerTest, syncNullTree)
 {
-    scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(0, scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
+    scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(static_cast<Layer*>(NULL), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
 
     EXPECT_TRUE(!layerImplTreeRoot.get());
 }
@@ -171,6 +172,9 @@
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
     expectTreesAreIdentical(layerTreeRoot.get(), layerImplTreeRoot.get(), m_hostImpl.activeTree());
 
+    // We have to push properties to pick up the destruction list pointer.
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
+
     // Add a new layer to the Layer side
     layerTreeRoot->children()[0]->addChild(MockLayer::create(&layerImplDestructionList));
     // Remove one.
@@ -198,6 +202,10 @@
     layerTreeRoot->addChild(child2);
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
     expectTreesAreIdentical(layerTreeRoot.get(), layerImplTreeRoot.get(), m_hostImpl.activeTree());
+
+    // We have to push properties to pick up the destruction list pointer.
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
+
     layerImplTreeRoot->resetAllChangeTrackingForSubtree();
 
     // re-insert the layer and sync again.
@@ -206,6 +214,8 @@
     layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), layerImplTreeRoot.Pass(), m_hostImpl.activeTree());
     expectTreesAreIdentical(layerTreeRoot.get(), layerImplTreeRoot.get(), m_hostImpl.activeTree());
 
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
+
     // Check that the impl thread properly tracked the change.
     EXPECT_FALSE(layerImplTreeRoot->layerPropertyChanged());
     EXPECT_FALSE(layerImplTreeRoot->children()[0]->layerPropertyChanged());
@@ -231,6 +241,8 @@
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
     expectTreesAreIdentical(layerTreeRoot.get(), layerImplTreeRoot.get(), m_hostImpl.activeTree());
 
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
+
     // Check that the property values we set on the Layer tree are reflected in the LayerImpl tree.
     gfx::PointF rootLayerImplPosition = layerImplTreeRoot->position();
     EXPECT_EQ(rootPosition.x(), rootLayerImplPosition.x());
@@ -267,6 +279,9 @@
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
     expectTreesAreIdentical(layerTreeRoot.get(), layerImplTreeRoot.get(), m_hostImpl.activeTree());
 
+    // We have to push properties to pick up the destruction list pointer.
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
+
     // Now restructure the tree to look like this:
     // root --- D ---+--- A
     //               |
@@ -304,6 +319,9 @@
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(oldLayerTreeRoot.get(), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
     expectTreesAreIdentical(oldLayerTreeRoot.get(), layerImplTreeRoot.get(), m_hostImpl.activeTree());
 
+    // We have to push properties to pick up the destruction list pointer.
+    TreeSynchronizer::pushProperties(oldLayerTreeRoot.get(), layerImplTreeRoot.get());
+
     // Remove all children on the Layer side.
     oldLayerTreeRoot->removeAllChildren();
 
@@ -370,12 +388,12 @@
 
     scoped_refptr<Layer> layerTreeRoot = Layer::create();
 
-    FakeLayerAnimationControllerClient dummy;
-    layerTreeRoot->setLayerAnimationController(FakeLayerAnimationController::create(&dummy).PassAs<LayerAnimationController>());
+    layerTreeRoot->setLayerAnimationController(FakeLayerAnimationController::create());
 
     EXPECT_FALSE(static_cast<FakeLayerAnimationController*>(layerTreeRoot->layerAnimationController())->synchronizedAnimations());
 
     scoped_ptr<LayerImpl> layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), scoped_ptr<LayerImpl>(), m_hostImpl.activeTree());
+    TreeSynchronizer::pushProperties(layerTreeRoot.get(), layerImplTreeRoot.get());
     layerImplTreeRoot = TreeSynchronizer::synchronizeTrees(layerTreeRoot.get(), layerImplTreeRoot.Pass(), m_hostImpl.activeTree());
 
     EXPECT_TRUE(static_cast<FakeLayerAnimationController*>(layerTreeRoot->layerAnimationController())->synchronizedAnimations());
Index: src/cc/geometry_binding.cc
===================================================================
--- src/cc/geometry_binding.cc	(revision 184497)
+++ src/cc/geometry_binding.cc	(working copy)
@@ -5,9 +5,9 @@
 #include "cc/geometry_binding.h"
 
 #include "cc/gl_renderer.h" // For the GLC() macro.
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "ui/gfx/rect_f.h"
-#include <public/WebGraphicsContext3D.h>
 
 namespace cc {
 
Index: src/cc/video_layer_impl.h
===================================================================
--- src/cc/video_layer_impl.h	(revision 184497)
+++ src/cc/video_layer_impl.h	(working copy)
@@ -5,55 +5,42 @@
 #ifndef CC_VIDEO_LAYER_IMPL_H_
 #define CC_VIDEO_LAYER_IMPL_H_
 
-#include <public/WebVideoFrameProvider.h>
-
 #include "base/callback.h"
 #include "base/synchronization/lock.h"
 #include "cc/cc_export.h"
 #include "cc/layer_impl.h"
+#include "cc/video_frame_provider.h"
 #include "media/base/video_frame.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "ui/gfx/size.h"
 #include "ui/gfx/transform.h"
 
-namespace WebKit {
-class WebVideoFrame;
-}
-
 namespace media {
 class SkCanvasVideoRenderer;
 }
 
 namespace cc {
-
 class LayerTreeHostImpl;
-class VideoLayerImpl;
+class VideoFrameProviderClientImpl;
 
-class CC_EXPORT VideoLayerImpl : public LayerImpl
-                               , public WebKit::WebVideoFrameProvider::Client {
+class CC_EXPORT VideoLayerImpl : public LayerImpl {
 public:
-    typedef base::Callback<media::VideoFrame* (WebKit::WebVideoFrame*)> FrameUnwrapper;
-
-    static scoped_ptr<VideoLayerImpl> create(LayerTreeImpl* treeImpl, int id, WebKit::WebVideoFrameProvider* provider,
-                                             const FrameUnwrapper& unwrapper)
-    {
-        return make_scoped_ptr(new VideoLayerImpl(treeImpl, id, provider, unwrapper));
-    }
+    static scoped_ptr<VideoLayerImpl> create(LayerTreeImpl* treeImpl, int id, VideoFrameProvider* provider);
     virtual ~VideoLayerImpl();
 
+    // LayerImpl implementation.
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
     virtual void willDraw(ResourceProvider*) OVERRIDE;
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
     virtual void didDraw(ResourceProvider*) OVERRIDE;
-
-    // WebKit::WebVideoFrameProvider::Client implementation.
-    virtual void stopUsingProvider(); // Callable on any thread.
-    virtual void didReceiveFrame(); // Callable on impl thread.
-    virtual void didUpdateMatrix(const float*); // Callable on impl thread.
-
+    virtual void didBecomeActive() OVERRIDE;
     virtual void didLoseOutputSurface() OVERRIDE;
 
     void setNeedsRedraw();
 
+    void setProviderClientImpl(scoped_refptr<VideoFrameProviderClientImpl>);
+
     struct FramePlane {
         ResourceProvider::ResourceId resourceId;
         gfx::Size size;
@@ -66,7 +53,7 @@
     };
 
 private:
-    VideoLayerImpl(LayerTreeImpl*, int, WebKit::WebVideoFrameProvider*, const FrameUnwrapper&);
+    VideoLayerImpl(LayerTreeImpl*, int);
 
     virtual const char* layerTypeAsString() const OVERRIDE;
 
@@ -77,14 +64,8 @@
     void freeUnusedPlaneData(ResourceProvider*);
     size_t numPlanes() const;
 
-    // Guards the destruction of m_provider and the frame that it provides
-    base::Lock m_providerLock;
-    WebKit::WebVideoFrameProvider* m_provider;
+    scoped_refptr<VideoFrameProviderClientImpl> m_providerClientImpl;
 
-    gfx::Transform m_streamTextureMatrix;
-
-    FrameUnwrapper m_unwrapper;
-    WebKit::WebVideoFrame *m_webFrame;
     media::VideoFrame* m_frame;
     GLenum m_format;
     bool m_convertYUV;
Index: src/cc/heads_up_display_layer_impl.cc
===================================================================
--- src/cc/heads_up_display_layer_impl.cc	(revision 184497)
+++ src/cc/heads_up_display_layer_impl.cc	(working copy)
@@ -4,17 +4,18 @@
 
 #include "cc/heads_up_display_layer_impl.h"
 
-#include <limits>
-
 #include "base/stringprintf.h"
 #include "cc/debug_colors.h"
 #include "cc/debug_rect_history.h"
 #include "cc/font_atlas.h"
 #include "cc/frame_rate_counter.h"
 #include "cc/layer_tree_impl.h"
+#include "cc/memory_history.h"
+#include "cc/paint_time_counter.h"
 #include "cc/quad_sink.h"
 #include "cc/renderer.h"
 #include "cc/texture_draw_quad.h"
+#include "cc/tile_manager.h"
 #include "skia/ext/platform_canvas.h"
 #include "skia/ext/platform_canvas.h"
 #include "third_party/khronos/GLES2/gl2.h"
@@ -29,6 +30,8 @@
 
 static inline SkPaint createPaint()
 {
+    SkPaint paint;
+#if (SK_R32_SHIFT || SK_B32_SHIFT != 16)
     // The SkCanvas is in RGBA but the shader is expecting BGRA, so we need to
     // swizzle our colors when drawing to the SkCanvas.
     SkColorMatrix swizzleMatrix;
@@ -39,19 +42,34 @@
     swizzleMatrix.fMat[2 + 5 * 0] = 1;
     swizzleMatrix.fMat[3 + 5 * 3] = 1;
 
-    SkPaint paint;
     skia::RefPtr<SkColorMatrixFilter> filter =
         skia::AdoptRef(new SkColorMatrixFilter(swizzleMatrix));
     paint.setColorFilter(filter.get());
-
+#endif
     return paint;
 }
 
+HeadsUpDisplayLayerImpl::Graph::Graph(double indicatorValue, double startUpperBound)
+    : value(0)
+    , min(0)
+    , max(0)
+    , currentUpperBound(startUpperBound)
+    , defaultUpperBound(startUpperBound)
+    , indicator(indicatorValue)
+{
+}
+
+double HeadsUpDisplayLayerImpl::Graph::updateUpperBound(Graph* graph)
+{
+    double targetUpperBound = std::max(graph->max, graph->defaultUpperBound);
+    graph->currentUpperBound += (targetUpperBound - graph->currentUpperBound) * 0.5;
+    return graph->currentUpperBound;
+}
+
 HeadsUpDisplayLayerImpl::HeadsUpDisplayLayerImpl(LayerTreeImpl* treeImpl, int id)
     : LayerImpl(treeImpl, id)
-    , m_averageFPS(0)
-    , m_minFPS(0)
-    , m_maxFPS(0)
+    , m_fpsGraph(60.0, 80.0)
+    , m_paintTimeGraph(16.0, 48.0)
 {
 }
 
@@ -59,6 +77,22 @@
 {
 }
 
+scoped_ptr<LayerImpl> HeadsUpDisplayLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return HeadsUpDisplayLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+void HeadsUpDisplayLayerImpl::pushPropertiesTo(LayerImpl* layerImpl)
+{
+    LayerImpl::pushPropertiesTo(layerImpl);
+
+    if (!m_fontAtlas)
+        return;
+
+    HeadsUpDisplayLayerImpl* hudLayerImpl = static_cast<HeadsUpDisplayLayerImpl*>(layerImpl);
+    hudLayerImpl->setFontAtlas(m_fontAtlas.Pass());
+}
+
 void HeadsUpDisplayLayerImpl::setFontAtlas(scoped_ptr<FontAtlas> fontAtlas)
 {
     m_fontAtlas = fontAtlas.Pass();
@@ -71,13 +105,20 @@
     if (!m_hudTexture)
         m_hudTexture = ScopedResource::create(resourceProvider);
 
-    // FIXME: Scale the HUD by deviceScale to make it more friendly under high DPI.
+    // TODO(danakj): Scale the HUD by deviceScale to make it more friendly under high DPI.
 
-    if (m_hudTexture->size() != bounds())
+    // TODO(danakj): The HUD could swap between two textures instead of creating a texture every frame in ubercompositor.
+    if (m_hudTexture->size() != bounds() || resourceProvider->inUseByConsumer(m_hudTexture->id()))
         m_hudTexture->Free();
 
-    if (!m_hudTexture->id())
+    if (!m_hudTexture->id()) {
         m_hudTexture->Allocate(bounds(), GL_RGBA, ResourceProvider::TextureUsageAny);
+        // TODO(epenner): This texture was being used before setPixels was called,
+        // which is now not allowed (it's an uninitialized read). This should be fixed
+        // and this allocateForTesting() removed.
+        // http://crbug.com/166784
+        resourceProvider->allocateForTesting(m_hudTexture->id());
+    }
 }
 
 void HeadsUpDisplayLayerImpl::appendQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData)
@@ -90,11 +131,12 @@
     gfx::Rect quadRect(gfx::Point(), bounds());
     gfx::Rect opaqueRect(contentsOpaque() ? quadRect : gfx::Rect());
     bool premultipliedAlpha = true;
-    gfx::RectF uvRect(0, 0, 1, 1);
-    const float vertex_opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
+    gfx::PointF uv_top_left(0.f, 0.f);
+    gfx::PointF uv_bottom_right(1.f, 1.f);
+    const float vertex_opacity[] = {1.f, 1.f, 1.f, 1.f};
     bool flipped = false;
     scoped_ptr<TextureDrawQuad> quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_hudTexture->id(), premultipliedAlpha, uvRect, vertex_opacity, flipped);
+    quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_hudTexture->id(), premultipliedAlpha, uv_top_left, uv_bottom_right, vertex_opacity, flipped);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 }
 
@@ -150,34 +192,106 @@
 {
     const LayerTreeDebugState& debugState = layerTreeImpl()->debug_state();
 
+    FrameRateCounter* fpsCounter = layerTreeImpl()->frame_rate_counter();
+    MemoryHistory* memoryHistory = layerTreeImpl()->memory_history();
+    PaintTimeCounter* paintTimeCounter = layerTreeImpl()->paint_time_counter();
+
     if (debugState.showPlatformLayerTree) {
         SkPaint paint = createPaint();
-        paint.setColor(SkColorSetARGB(192, 0, 0, 0));
-        canvas->drawRect(SkRect::MakeXYWH(0, 0, bounds().width(), bounds().height()), paint);
+        drawGraphBackground(canvas, &paint, SkRect::MakeXYWH(0, 0, bounds().width(), bounds().height()));
     }
 
-    int platformLayerTreeTop = 0;
+    int top = 2;
 
-    if (debugState.showFPSCounter)
-        platformLayerTreeTop = drawFPSCounter(canvas, layerTreeImpl()->frame_rate_counter());
+    if (debugState.continuousPainting || debugState.showFPSCounter) {
+        // Update numbers not every frame so text is readable
+        base::TimeTicks now = base::TimeTicks::Now();
+        if (base::TimeDelta(now - m_timeOfLastGraphUpdate).InSecondsF() > 0.25) {
+            m_fpsGraph.value = fpsCounter->getAverageFPS();
+            fpsCounter->getMinAndMaxFPS(m_fpsGraph.min, m_fpsGraph.max);
 
+            base::TimeDelta latest, min, max;
+            latest = paintTimeCounter->GetPaintTimeOfRecentFrame(paintTimeCounter->HistorySize() - 1);
+            paintTimeCounter->GetMinAndMaxPaintTime(&min, &max);
+
+            m_paintTimeGraph.value = latest.InMillisecondsF();
+            m_paintTimeGraph.min = min.InMillisecondsF();
+            m_paintTimeGraph.max = max.InMillisecondsF();
+
+            m_timeOfLastGraphUpdate = now;
+        }
+
+        if (debugState.continuousPainting)
+            top = drawPaintTimeDisplay(canvas, paintTimeCounter, top);
+        // Don't show the FPS display when continuous painting is enabled, because it would show misleading numbers.
+        else if (debugState.showFPSCounter) {
+            top = drawFPSDisplay(canvas, fpsCounter, top);
+        }
+        if (debugState.continuousPainting ||
+            debugState.showFPSCounter) {
+            top = drawMemoryDisplay(canvas, memoryHistory, top);
+        }
+    }
+
     if (debugState.showPlatformLayerTree && m_fontAtlas) {
         std::string layerTree = layerTreeImpl()->layer_tree_as_text();
-        m_fontAtlas->drawText(canvas, createPaint(), layerTree, gfx::Point(2, platformLayerTreeTop), bounds());
+        SkPaint paint = createPaint();
+        m_fontAtlas->setColor(DebugColors::PlatformLayerTreeTextColor());
+        m_fontAtlas->drawText(canvas, &paint, layerTree, gfx::Point(2, top), bounds());
     }
 
     if (debugState.showHudRects())
         drawDebugRects(canvas, layerTreeImpl()->debug_rect_history());
 }
 
-int HeadsUpDisplayLayerImpl::drawFPSCounter(SkCanvas* canvas, FrameRateCounter* fpsCounter)
+void HeadsUpDisplayLayerImpl::drawTextLeftAligned(SkCanvas* canvas, SkPaint* paint, const SkRect& bounds, const std::string& text)
 {
+    if (!m_fontAtlas)
+        return;
+
+    m_fontAtlas->drawText(canvas, paint, text, gfx::Point(bounds.left(), bounds.top()), gfx::Size(bounds.width(), bounds.height()));
+}
+
+void HeadsUpDisplayLayerImpl::drawTextRightAligned(SkCanvas* canvas, SkPaint* paint, const SkRect& bounds, const std::string& text)
+{
+    if (!m_fontAtlas)
+        return;
+
+    int textWidth = m_fontAtlas->textSize(text).width();
+
+    gfx::Point textPosition(bounds.right() - textWidth, bounds.top());
+    gfx::Size textArea(bounds.width(), bounds.height());
+
+    m_fontAtlas->drawText(canvas, paint, text, textPosition, textArea);
+}
+
+void HeadsUpDisplayLayerImpl::drawGraphBackground(SkCanvas* canvas, SkPaint* paint, const SkRect& bounds)
+{
+    paint->setColor(SkColorSetARGB(215, 17, 17, 17));
+    canvas->drawRect(bounds, *paint);
+}
+
+void HeadsUpDisplayLayerImpl::drawGraphLines(SkCanvas* canvas, SkPaint* paint, const SkRect& bounds, const Graph& graph)
+{
+    // Draw top and bottom line.
+    paint->setColor(SkColorSetRGB(130, 130, 130));
+    canvas->drawLine(bounds.left(), bounds.top() - 1, bounds.right(), bounds.top() - 1, *paint);
+    canvas->drawLine(bounds.left(), bounds.bottom(), bounds.right(), bounds.bottom(), *paint);
+
+    // Draw indicator line.
+    paint->setColor(SkColorSetRGB(100, 100, 100));
+    const double indicatorTop = bounds.height() * (1 - graph.indicator / graph.currentUpperBound) - 1;
+    canvas->drawLine(bounds.left(), bounds.top() + indicatorTop, bounds.right(), bounds.top() + indicatorTop, *paint);
+}
+
+int HeadsUpDisplayLayerImpl::drawFPSDisplay(SkCanvas* canvas, FrameRateCounter* fpsCounter, const int& top)
+{
     const int padding = 4;
     const int gap = 6;
 
     const int fontHeight = m_fontAtlas.get() ? m_fontAtlas->fontHeight() : 0;
 
-    const int graphWidth = fpsCounter->timeStampHistorySize() - 3;
+    const int graphWidth = fpsCounter->timeStampHistorySize() - 2;
     const int graphHeight = 40;
 
     const int histogramWidth = 37;
@@ -186,73 +300,32 @@
     const int height = fontHeight + graphHeight + 4 * padding + 2;
 
     const int left = bounds().width() - width - 2;
-    const int top = 2;
 
     SkPaint paint = createPaint();
+    drawGraphBackground(canvas, &paint, SkRect::MakeXYWH(left, top, width, height));
 
-    // Draw background.
-    paint.setColor(SkColorSetARGB(215, 17, 17, 17));
-    canvas->drawRect(SkRect::MakeXYWH(left, top, width, height), paint);
-
     SkRect textBounds = SkRect::MakeXYWH(left + padding, top + padding, graphWidth + histogramWidth + gap + 2, fontHeight);
     SkRect graphBounds = SkRect::MakeXYWH(left + padding, textBounds.bottom() + 2 * padding, graphWidth, graphHeight);
     SkRect histogramBounds = SkRect::MakeXYWH(graphBounds.right() + gap, graphBounds.top(), histogramWidth, graphHeight);
 
-    drawFPSCounterText(canvas, paint, fpsCounter, textBounds);
-    drawFPSCounterGraphAndHistogram(canvas, paint, fpsCounter, graphBounds, histogramBounds);
+    if (m_fontAtlas.get())
+        m_fontAtlas->setColor(DebugColors::FPSDisplayTextAndGraphColor());
 
-    return top + height;
-}
+    drawTextLeftAligned(canvas, &paint, textBounds, base::StringPrintf("FPS:%5.1f", m_fpsGraph.value));
+    drawTextRightAligned(canvas, &paint, textBounds, base::StringPrintf("%.0f-%.0f", m_fpsGraph.min, m_fpsGraph.max));
 
-void HeadsUpDisplayLayerImpl::drawFPSCounterText(SkCanvas* canvas, SkPaint& paint, FrameRateCounter* fpsCounter, SkRect bounds)
-{
-    // Update FPS text - not every frame so text is readable
-    if (base::TimeDelta(fpsCounter->timeStampOfRecentFrame(0) - textUpdateTime).InSecondsF() > 0.25) {
-        m_averageFPS = fpsCounter->getAverageFPS();
-        textUpdateTime = fpsCounter->timeStampOfRecentFrame(0);
-    }
+    const double upperBound = Graph::updateUpperBound(&m_fpsGraph);
+    drawGraphLines(canvas, &paint, graphBounds, m_fpsGraph);
 
-    // Draw FPS text.
-    if (m_fontAtlas.get()) {
-        std::string fpsText = base::StringPrintf("FPS:%5.1f", m_averageFPS);
-        std::string minMaxText = base::StringPrintf("%.0f-%.0f", std::min( m_minFPS, m_maxFPS), m_maxFPS);
-
-        int minMaxWidth = m_fontAtlas->textSize(minMaxText).width();
-        gfx::Size textArea(bounds.width(), bounds.height());
-
-        paint.setColor(SK_ColorRED);
-        m_fontAtlas->drawText(canvas, paint, fpsText, gfx::Point(bounds.left(), bounds.top()), textArea);
-        m_fontAtlas->drawText(canvas, paint, minMaxText, gfx::Point(bounds.right() - minMaxWidth, bounds.top()), textArea);
-    }
-}
-
-void HeadsUpDisplayLayerImpl::drawFPSCounterGraphAndHistogram(SkCanvas* canvas, SkPaint& paint, FrameRateCounter* fpsCounter, SkRect graphBounds, SkRect histogramBounds)
-{
-    const double loFPS = 0;
-    const double hiFPS = std::max(m_maxFPS + 10.0, 80.0);
-
-    // Draw top and bottom line.
-    paint.setColor(SkColorSetRGB(130, 130, 130));
-    canvas->drawLine(graphBounds.left(), graphBounds.top() - 1, graphBounds.right(), graphBounds.top() - 1, paint);
-    canvas->drawLine(graphBounds.left(), graphBounds.bottom(), graphBounds.right(), graphBounds.bottom(), paint);
-
-    // Draw 60fps line.
-    const double top60 = graphBounds.top() + graphBounds.height() * (1 - ((60 - loFPS) / (hiFPS - loFPS))) - 1;
-    paint.setColor(SkColorSetRGB(100, 100, 100));
-    canvas->drawLine(graphBounds.left(), top60, graphBounds.right(), top60, paint);
-
     // Collect graph and histogram data.
     int x = 0;
     SkPath path;
 
-    m_minFPS = std::numeric_limits<double>::max();
-    m_maxFPS = 0;
-
     const int histogramSize = 20;
     double histogram[histogramSize] = {0};
     double maxBucketValue = 0;
 
-    for (int i = 1; i < fpsCounter->timeStampHistorySize() - 1; ++i) {
+    for (size_t i = 0; i < fpsCounter->timeStampHistorySize() - 1; ++i) {
         base::TimeDelta delta = fpsCounter->timeStampOfRecentFrame(i + 1) - fpsCounter->timeStampOfRecentFrame(i);
 
         // Skip this particular instantaneous frame rate if it is not likely to have been valid.
@@ -260,13 +333,8 @@
 
             double fps = 1.0 / delta.InSecondsF();
 
-            m_minFPS = std::min(fps, m_minFPS);
-            m_maxFPS = std::max(fps, m_maxFPS);
-
             // Clamp the FPS to the range we want to plot visually.
-            double p = (fps - loFPS) / (hiFPS - loFPS);
-            if (p < 0)
-                p = 0;
+            double p = fps / upperBound;
             if (p > 1)
                 p = 1;
 
@@ -293,7 +361,7 @@
     canvas->drawLine(histogramBounds.left() - 1, histogramBounds.top() - 1, histogramBounds.left() - 1, histogramBounds.bottom() + 1, paint);
     canvas->drawLine(histogramBounds.right() + 1, histogramBounds.top() - 1, histogramBounds.right() + 1, histogramBounds.bottom() + 1, paint);
 
-    paint.setColor(SK_ColorRED);
+    paint.setColor(DebugColors::FPSDisplayTextAndGraphColor());
     const double barHeight = histogramBounds.height() / histogramSize;
 
     for (int i = histogramSize - 1; i >= 0; --i) {
@@ -309,8 +377,103 @@
     paint.setStrokeWidth(1);
 
     canvas->drawPath(path, paint);
+
+    return top + height + 2;
 }
 
+int HeadsUpDisplayLayerImpl::drawMemoryDisplay(SkCanvas* canvas, MemoryHistory* memoryHistory, const int& initial_top)
+{
+    // Move up by 2 to create no gap between us and previous counter.
+    int top = initial_top - 2;
+    const int padding = 4;
+    const int fontHeight = m_fontAtlas.get() ? m_fontAtlas->fontHeight() : 0;
+
+    const int width = 181;
+    const int height = 2 * fontHeight + 3 * padding;
+
+    const int left = bounds().width() - width - 2;
+    const double megabyte = static_cast<double>(1024*1024);
+
+    SkPaint paint = createPaint();
+    drawGraphBackground(canvas, &paint, SkRect::MakeXYWH(left, top, width, height));
+
+    SkRect textRun1 = SkRect::MakeXYWH(left + padding, top + padding, width, fontHeight);
+    SkRect textRun2 = SkRect::MakeXYWH(left + padding, top + 2*padding + fontHeight, width, fontHeight);
+
+    if (m_fontAtlas.get())
+        m_fontAtlas->setColor(DebugColors::FPSDisplayTextAndGraphColor());
+
+    std::string text;
+    MemoryHistory::Entry curEntry = memoryHistory->GetEntry(
+        memoryHistory->HistorySize() - 1);
+
+    double curMB = curEntry.bytes_total() / megabyte;
+
+    text = base::StringPrintf(
+        "%6.1f MB GPU memory used",
+        (curEntry.bytes_unreleasable + curEntry.bytes_allocated) / megabyte);
+    drawTextLeftAligned(canvas, &paint, textRun1, text);
+
+    if (curEntry.bytes_over) {
+      text = base::StringPrintf(
+          "%6.1f MB over",
+          (curEntry.bytes_over) / megabyte);
+    } else {
+      text = base::StringPrintf(
+          "%6.1f MB maximum",
+          (curEntry.total_budget_in_bytes) / megabyte);
+    }
+    drawTextLeftAligned(canvas, &paint, textRun2, text);
+
+    return top + height + 2;
+}
+
+int HeadsUpDisplayLayerImpl::drawPaintTimeDisplay(SkCanvas* canvas, PaintTimeCounter* paintTimeCounter, const int& top)
+{
+    const int padding = 4;
+    const int fontHeight = m_fontAtlas.get() ? m_fontAtlas->fontHeight() : 0;
+
+    const int graphWidth = paintTimeCounter->HistorySize() * 2 - 1;
+    const int graphHeight = 40;
+
+    const int width = graphWidth + 2 * padding;
+    const int height = fontHeight + graphHeight + 4 * padding + 2 + fontHeight + padding;
+
+    const int left = bounds().width() - width - 2;
+
+    SkPaint paint = createPaint();
+    drawGraphBackground(canvas, &paint, SkRect::MakeXYWH(left, top, width, height));
+
+    SkRect textBounds = SkRect::MakeXYWH(left + padding, top + padding, graphWidth, fontHeight);
+    SkRect textBounds2 = SkRect::MakeXYWH(left + padding, textBounds.bottom() + padding, graphWidth, fontHeight);
+    SkRect graphBounds = SkRect::MakeXYWH(left + padding, textBounds2.bottom() + 2 * padding, graphWidth, graphHeight);
+
+    if (m_fontAtlas.get())
+        m_fontAtlas->setColor(DebugColors::PaintTimeDisplayTextAndGraphColor());
+    drawTextLeftAligned(canvas, &paint, textBounds, "Page paint time (ms)");
+    drawTextLeftAligned(canvas, &paint, textBounds2, base::StringPrintf("%5.1f", m_paintTimeGraph.value));
+    drawTextRightAligned(canvas, &paint, textBounds2, base::StringPrintf("%.1f-%.1f", m_paintTimeGraph.min, m_paintTimeGraph.max));
+
+    const double upperBound = Graph::updateUpperBound(&m_paintTimeGraph);
+    drawGraphLines(canvas, &paint, graphBounds, m_paintTimeGraph);
+
+    paint.setColor(DebugColors::PaintTimeDisplayTextAndGraphColor());
+    for (size_t i = 0; i < paintTimeCounter->HistorySize(); ++i) {
+        double pt = paintTimeCounter->GetPaintTimeOfRecentFrame(i).InMillisecondsF();
+
+        if (pt == 0.0)
+            continue;
+
+        double p = pt / upperBound;
+        if (p > 1)
+            p = 1;
+
+        canvas->drawRect(SkRect::MakeXYWH(graphBounds.left() + i * 2, graphBounds.bottom() - p * graphBounds.height(), 1, p * graphBounds.height()), paint);
+    }
+
+    return top + height + 2;
+}
+
 void HeadsUpDisplayLayerImpl::drawDebugRects(SkCanvas* canvas, DebugRectHistory* debugRectHistory)
 {
     const std::vector<DebugRect>& debugRects = debugRectHistory->debugRects();
Index: src/cc/test/compositor_fake_web_graphics_context_3d.h
===================================================================
--- src/cc/test/compositor_fake_web_graphics_context_3d.h	(revision 184497)
+++ src/cc/test/compositor_fake_web_graphics_context_3d.h	(working copy)
@@ -1,36 +0,0 @@
-// Copyright 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CC_TEST_COMPOSITOR_FAKE_WEB_GRAPHICS_CONTEXT_3D_H_
-#define CC_TEST_COMPOSITOR_FAKE_WEB_GRAPHICS_CONTEXT_3D_H_
-
-#include "base/memory/scoped_ptr.h"
-#include "cc/test/fake_web_graphics_context_3d.h"
-
-namespace cc {
-
-// Test stub for WebGraphicsContext3D. Returns canned values needed for compositor initialization.
-class CompositorFakeWebGraphicsContext3D : public FakeWebGraphicsContext3D {
-public:
-    static scoped_ptr<CompositorFakeWebGraphicsContext3D> create(Attributes attrs)
-    {
-        return make_scoped_ptr(new CompositorFakeWebGraphicsContext3D(attrs));
-    }
-
-    virtual bool makeContextCurrent();
-    virtual WebKit::WebGLId createProgram();
-    virtual WebKit::WebGLId createShader(WebKit::WGC3Denum);
-    virtual void getShaderiv(WebKit::WebGLId, WebKit::WGC3Denum, WebKit::WGC3Dint* value);
-    virtual void getProgramiv(WebKit::WebGLId, WebKit::WGC3Denum, WebKit::WGC3Dint* value);
-
-protected:
-    explicit CompositorFakeWebGraphicsContext3D(Attributes attrs)
-    {
-        m_attrs = attrs;
-    }
-};
-
-}  // namespace cc
-
-#endif  // CC_TEST_COMPOSITOR_FAKE_WEB_GRAPHICS_CONTEXT_3D_H_
Index: src/cc/test/fake_layer_tree_host_impl_client.cc
===================================================================
--- src/cc/test/fake_layer_tree_host_impl_client.cc	(revision 184497)
+++ src/cc/test/fake_layer_tree_host_impl_client.cc	(working copy)
@@ -12,4 +12,8 @@
   return false;
 }
 
+bool FakeLayerTreeHostImplClient::isInsideDraw() {
+  return false;
+}
+
 }  // namespace cc
Index: src/cc/test/fake_output_surface.cc
===================================================================
--- src/cc/test/fake_output_surface.cc	(revision 184497)
+++ src/cc/test/fake_output_surface.cc	(working copy)
@@ -7,13 +7,15 @@
 namespace cc {
 
 FakeOutputSurface::FakeOutputSurface(
-    scoped_ptr<WebKit::WebGraphicsContext3D> context3d, bool has_parent) {
+    scoped_ptr<WebKit::WebGraphicsContext3D> context3d, bool has_parent)
+    : num_sent_frames_(0) {
   context3d_ = context3d.Pass();
   capabilities_.has_parent_compositor = has_parent;
 }
 
 FakeOutputSurface::FakeOutputSurface(
-    scoped_ptr<SoftwareOutputDevice> software_device, bool has_parent) {
+    scoped_ptr<SoftwareOutputDevice> software_device, bool has_parent)
+    : num_sent_frames_(0) {
   software_device_ = software_device.Pass();
   capabilities_.has_parent_compositor = has_parent;
 }
@@ -43,6 +45,10 @@
   return software_device_.get();
 }
 
-void FakeOutputSurface::SendFrameToParentCompositor(const CompositorFrame&) {}
+void FakeOutputSurface::SendFrameToParentCompositor(
+    CompositorFrame* frame) {
+  frame->AssignTo(&last_sent_frame_);
+  ++num_sent_frames_;
+}
 
 }  // namespace cc
Index: src/cc/test/fake_layer_tree_host_impl.cc
===================================================================
--- src/cc/test/fake_layer_tree_host_impl.cc	(revision 184497)
+++ src/cc/test/fake_layer_tree_host_impl.cc	(working copy)
@@ -7,12 +7,21 @@
 namespace cc {
 
 FakeLayerTreeHostImpl::FakeLayerTreeHostImpl(Proxy* proxy)
-    : LayerTreeHostImpl(settings_, &client_, proxy)
+    : LayerTreeHostImpl(LayerTreeSettings(), &client_, proxy)
 {
-    // Explicitly clear all debug settings.
-    setDebugState(LayerTreeDebugState());
+  // Explicitly clear all debug settings.
+  setDebugState(LayerTreeDebugState());
 }
 
+FakeLayerTreeHostImpl::FakeLayerTreeHostImpl(
+    const LayerTreeSettings& settings,
+    Proxy* proxy)
+    : LayerTreeHostImpl(settings, &client_, proxy)
+{
+  // Explicitly clear all debug settings.
+  setDebugState(LayerTreeDebugState());
+}
+
 FakeLayerTreeHostImpl::~FakeLayerTreeHostImpl()
 {
 }
Index: src/cc/test/fake_output_surface.h
===================================================================
--- src/cc/test/fake_output_surface.h	(revision 184497)
+++ src/cc/test/fake_output_surface.h	(working copy)
@@ -7,9 +7,10 @@
 
 #include "base/logging.h"
 #include "base/memory/scoped_ptr.h"
+#include "cc/compositor_frame.h"
 #include "cc/output_surface.h"
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
 #include "cc/test/fake_software_output_device.h"
+#include "cc/test/fake_web_graphics_context_3d.h"
 #include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 
 namespace cc {
@@ -23,6 +24,14 @@
     return make_scoped_ptr(new FakeOutputSurface(context3d.Pass(), false));
   }
 
+  static inline scoped_ptr<FakeOutputSurface> Create3d() {
+    scoped_ptr<WebKit::WebGraphicsContext3D> context3d =
+        FakeWebGraphicsContext3D::Create(
+            WebKit::WebGraphicsContext3D::Attributes())
+        .PassAs<WebKit::WebGraphicsContext3D>();
+    return make_scoped_ptr(new FakeOutputSurface(context3d.Pass(), false));
+  }
+
   static inline scoped_ptr<FakeOutputSurface> CreateSoftware(
       scoped_ptr<SoftwareOutputDevice> software_device) {
     return make_scoped_ptr(
@@ -34,6 +43,14 @@
     return make_scoped_ptr(new FakeOutputSurface(context3d.Pass(), true));
   }
 
+  static inline scoped_ptr<FakeOutputSurface> CreateDelegating3d() {
+    scoped_ptr<WebKit::WebGraphicsContext3D> context3d =
+        FakeWebGraphicsContext3D::Create(
+            WebKit::WebGraphicsContext3D::Attributes())
+        .PassAs<WebKit::WebGraphicsContext3D>();
+    return make_scoped_ptr(new FakeOutputSurface(context3d.Pass(), true));
+  }
+
   static inline scoped_ptr<FakeOutputSurface> CreateDelegatingSoftware(
       scoped_ptr<SoftwareOutputDevice> software_device) {
     return make_scoped_ptr(
@@ -47,8 +64,11 @@
   virtual WebKit::WebGraphicsContext3D* Context3D() const OVERRIDE;
   virtual SoftwareOutputDevice* SoftwareDevice() const OVERRIDE;
 
-  virtual void SendFrameToParentCompositor(const CompositorFrame&) OVERRIDE;
+  virtual void SendFrameToParentCompositor(CompositorFrame*) OVERRIDE;
 
+  CompositorFrame& last_sent_frame() { return last_sent_frame_; }
+  size_t num_sent_frames() { return num_sent_frames_; }
+
 private:
   explicit FakeOutputSurface(
       scoped_ptr<WebKit::WebGraphicsContext3D> context3d, bool has_parent);
@@ -59,12 +79,14 @@
   scoped_ptr<SoftwareOutputDevice> software_device_;
   struct Capabilities capabilities_;
   OutputSurfaceClient* client_;
+  CompositorFrame last_sent_frame_;
+  size_t num_sent_frames_;
 };
 
 static inline scoped_ptr<cc::OutputSurface> createFakeOutputSurface()
 {
     return FakeOutputSurface::Create3d(
-        CompositorFakeWebGraphicsContext3D::create(
+        FakeWebGraphicsContext3D::Create(
             WebKit::WebGraphicsContext3D::Attributes())
         .PassAs<WebKit::WebGraphicsContext3D>())
         .PassAs<cc::OutputSurface>();
Index: src/cc/test/fake_picture_layer_tiling_client.h
===================================================================
--- src/cc/test/fake_picture_layer_tiling_client.h	(revision 184497)
+++ src/cc/test/fake_picture_layer_tiling_client.h	(working copy)
@@ -22,6 +22,10 @@
   // PictureLayerTilingClient implementation.
   virtual scoped_refptr<Tile> CreateTile(
       PictureLayerTiling* tiling, gfx::Rect rect) OVERRIDE;
+  virtual void UpdatePile(Tile* tile) OVERRIDE {}
+  virtual gfx::Size CalculateTileSize(
+      gfx::Size current_tile_size,
+      gfx::Size content_bounds) OVERRIDE;
 
   void SetTileSize(gfx::Size tile_size);
   gfx::Size TileSize() const { return tile_size_; }
Index: src/cc/test/fake_web_scrollbar_theme_geometry.cc
===================================================================
--- src/cc/test/fake_web_scrollbar_theme_geometry.cc	(revision 184497)
+++ src/cc/test/fake_web_scrollbar_theme_geometry.cc	(working copy)
@@ -4,19 +4,25 @@
 
 #include "cc/test/fake_web_scrollbar_theme_geometry.h"
 
+using WebKit::WebRect;
+
 namespace cc {
 
 WebKit::WebScrollbarThemeGeometry*
     FakeWebScrollbarThemeGeometry::clone() const {
-  return new FakeWebScrollbarThemeGeometry();
+  return new FakeWebScrollbarThemeGeometry(m_hasThumb);
 }
 
 int FakeWebScrollbarThemeGeometry::thumbPosition(WebKit::WebScrollbar*) {
-  return 0;
+  if (!m_hasThumb)
+    return 0;
+  return 5;
 }
 
 int FakeWebScrollbarThemeGeometry::thumbLength(WebKit::WebScrollbar*) {
-  return 0;
+  if (!m_hasThumb)
+    return 0;
+  return 2;
 }
 
 int FakeWebScrollbarThemeGeometry::trackPosition(WebKit::WebScrollbar*) {
@@ -24,7 +30,7 @@
 }
 
 int FakeWebScrollbarThemeGeometry::trackLength(WebKit::WebScrollbar*) {
-  return 0;
+  return 10;
 }
 
 bool FakeWebScrollbarThemeGeometry::hasButtons(WebKit::WebScrollbar*) {
@@ -32,15 +38,17 @@
 }
 
 bool FakeWebScrollbarThemeGeometry::hasThumb(WebKit::WebScrollbar*) {
-  return false;
+  return m_hasThumb;
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::trackRect(WebKit::WebScrollbar*) {
-  return WebKit::WebRect();
+WebRect FakeWebScrollbarThemeGeometry::trackRect(WebKit::WebScrollbar*) {
+  return WebRect(0, 0, 10, 10);
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::thumbRect(WebKit::WebScrollbar*) {
-  return WebKit::WebRect();
+WebRect FakeWebScrollbarThemeGeometry::thumbRect(WebKit::WebScrollbar*) {
+  if (!m_hasThumb)
+    return WebRect(0, 0, 0, 0);
+  return WebRect(0, 5, 5, 2);
 }
 
 int FakeWebScrollbarThemeGeometry::minimumThumbLength(WebKit::WebScrollbar*) {
@@ -51,41 +59,47 @@
   return 0;
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::backButtonStartRect(
+WebRect FakeWebScrollbarThemeGeometry::backButtonStartRect(
     WebKit::WebScrollbar*) {
-  return WebKit::WebRect();
+  return WebRect();
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::backButtonEndRect(
+WebRect FakeWebScrollbarThemeGeometry::backButtonEndRect(
     WebKit::WebScrollbar*) {
-  return WebKit::WebRect();
+  return WebRect();
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::forwardButtonStartRect(
+WebRect FakeWebScrollbarThemeGeometry::forwardButtonStartRect(
     WebKit::WebScrollbar*) {
-  return WebKit::WebRect();
+  return WebRect();
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::forwardButtonEndRect(
+WebRect FakeWebScrollbarThemeGeometry::forwardButtonEndRect(
     WebKit::WebScrollbar*) {
-  return WebKit::WebRect();
+  return WebRect();
 }
 
-WebKit::WebRect FakeWebScrollbarThemeGeometry::constrainTrackRectToTrackPieces(
+WebRect FakeWebScrollbarThemeGeometry::constrainTrackRectToTrackPieces(
    WebKit::WebScrollbar*,
-   const WebKit::WebRect&) {
-  return WebKit::WebRect();
+   const WebRect&) {
+  return WebRect();
 }
 
 void FakeWebScrollbarThemeGeometry::splitTrack(
     WebKit::WebScrollbar*,
-    const WebKit::WebRect& track,
-    WebKit::WebRect& startTrack,
-    WebKit::WebRect& thumb,
-    WebKit::WebRect& endTrack) {
-  startTrack = WebKit::WebRect();
-  thumb = WebKit::WebRect();
-  endTrack = WebKit::WebRect();
+    const WebRect& track,
+    WebRect& startTrack,
+    WebRect& thumb,
+    WebRect& endTrack) {
+  if (!m_hasThumb) {
+    thumb = WebRect(0, 0, 0, 0);
+    startTrack = WebRect(0, 0, 10, 10);
+    endTrack = WebRect(0, 10, 10, 0);
+  } else {
+    thumb = WebRect(0, 5, 5, 2);
+    startTrack = WebRect(0, 5, 0, 5);
+    endTrack = WebRect(0, 0, 0, 5);
+  }
 }
 
 }  // namespace cc
Index: src/cc/test/tiled_layer_test_common.cc
===================================================================
--- src/cc/test/tiled_layer_test_common.cc	(revision 184497)
+++ src/cc/test/tiled_layer_test_common.cc	(working copy)
@@ -138,6 +138,7 @@
 {
     calculateContentsScale(
         idealContentsScale,
+        false,  // animating_transform_to_screen
         &drawProperties().contents_scale_x,
         &drawProperties().contents_scale_y,
         &drawProperties().content_bounds);
@@ -156,6 +157,7 @@
 
 void FakeTiledLayerWithScaledBounds::calculateContentsScale(
     float idealContentsScale,
+    bool animatingTransformToScreen,
     float* contentsScaleX,
     float* contentsScaleY,
     gfx::Size* contentBounds)
Index: src/cc/test/tiled_layer_test_common.h
===================================================================
--- src/cc/test/tiled_layer_test_common.h	(revision 184497)
+++ src/cc/test/tiled_layer_test_common.h	(working copy)
@@ -120,6 +120,7 @@
     void setContentBounds(const gfx::Size& contentBounds);
     virtual void calculateContentsScale(
         float idealContentsScale,
+        bool animatingTransformToScreen,
         float* contentsScaleX,
         float* contentsScaleY,
         gfx::Size* contentBounds) OVERRIDE;
Index: src/cc/test/fake_proxy.h
===================================================================
--- src/cc/test/fake_proxy.h	(revision 184497)
+++ src/cc/test/fake_proxy.h	(working copy)
@@ -30,7 +30,6 @@
     virtual void setNeedsCommit() OVERRIDE { }
     virtual void setNeedsRedraw() OVERRIDE { }
     virtual void setDeferCommits(bool) OVERRIDE { }
-    virtual void didAddAnimation() OVERRIDE { }
     virtual void mainThreadHasStoppedFlinging() OVERRIDE { }
     virtual bool commitRequested() const OVERRIDE;
     virtual void start() OVERRIDE { }
@@ -38,8 +37,8 @@
     virtual void forceSerializeOnSwapBuffers() OVERRIDE { }
     virtual size_t maxPartialTextureUpdates() const OVERRIDE;
     virtual void acquireLayerTextures() OVERRIDE { }
-    virtual void loseOutputSurface() OVERRIDE { }
     virtual bool commitPendingForTesting() OVERRIDE;
+    virtual skia::RefPtr<SkPicture> capturePicture() OVERRIDE;
 
     virtual RendererCapabilities& rendererCapabilities();
     void setMaxPartialTextureUpdates(size_t);
Index: src/cc/test/mock_quad_culler.cc
===================================================================
--- src/cc/test/mock_quad_culler.cc	(revision 184497)
+++ src/cc/test/mock_quad_culler.cc	(working copy)
@@ -4,6 +4,8 @@
 
 #include "cc/test/mock_quad_culler.h"
 
+#include "cc/draw_quad.h"
+
 namespace cc {
 
 MockQuadCuller::MockQuadCuller()
@@ -25,7 +27,7 @@
 bool MockQuadCuller::append(scoped_ptr<DrawQuad> drawQuad, AppendQuadsData&)
 {
     if (!drawQuad->rect.IsEmpty()) {
-        m_activeQuadList.append(drawQuad.Pass());
+        m_activeQuadList.push_back(drawQuad.Pass());
         return true;
     }
     return false;
@@ -34,7 +36,7 @@
 SharedQuadState* MockQuadCuller::useSharedQuadState(scoped_ptr<SharedQuadState> sharedQuadState)
 {
     SharedQuadState* rawPtr = sharedQuadState.get();
-    m_activeSharedQuadStateList.append(sharedQuadState.Pass());
+    m_activeSharedQuadStateList.push_back(sharedQuadState.Pass());
     return rawPtr;
 }
 
Index: src/cc/test/fake_layer_tree_host_client.cc
===================================================================
--- src/cc/test/fake_layer_tree_host_client.cc	(revision 184497)
+++ src/cc/test/fake_layer_tree_host_client.cc	(working copy)
@@ -17,9 +17,9 @@
 
     WebKit::WebGraphicsContext3D::Attributes attrs;
     if (m_useDelegatingRenderer)
-        return FakeOutputSurface::CreateDelegating3d(CompositorFakeWebGraphicsContext3D::create(attrs).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
+        return FakeOutputSurface::CreateDelegating3d(FakeWebGraphicsContext3D::Create(attrs).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
 
-    return FakeOutputSurface::Create3d(CompositorFakeWebGraphicsContext3D::create(attrs).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
+    return FakeOutputSurface::Create3d(FakeWebGraphicsContext3D::Create(attrs).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
 }
 
 scoped_ptr<InputHandler> FakeLayerImplTreeHostClient::createInputHandler()
Index: src/cc/test/fake_web_graphics_context_3d.cc
===================================================================
--- src/cc/test/fake_web_graphics_context_3d.cc	(revision 184497)
+++ src/cc/test/fake_web_graphics_context_3d.cc	(working copy)
@@ -4,20 +4,87 @@
 
 #include "cc/test/fake_web_graphics_context_3d.h"
 
+#include <algorithm>
+#include <string>
+
+#include "base/logging.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/khronos/GLES2/gl2ext.h"
+
+using WebKit::WGC3Dboolean;
+using WebKit::WGC3Denum;
+using WebKit::WebGLId;
+using WebKit::WebGraphicsContext3D;
+
 namespace cc {
 
+static const WebGLId kBufferId = 1;
+static const WebGLId kFramebufferId = 2;
+static const WebGLId kProgramId = 3;
+static const WebGLId kRenderbufferId = 4;
+static const WebGLId kShaderId = 5;
+
+static unsigned s_context_id = 1;
+
+const WebGLId FakeWebGraphicsContext3D::kExternalTextureId = 1337;
+
+FakeWebGraphicsContext3D::FakeWebGraphicsContext3D()
+    : context_id_(s_context_id++),
+      next_texture_id_(1),
+      have_extension_io_surface_(false),
+      have_extension_egl_image_(false),
+      times_make_current_succeeds_(-1),
+      times_bind_texture_succeeds_(-1),
+      times_end_query_succeeds_(-1),
+      context_lost_(false),
+      context_lost_callback_(NULL),
+      width_(0),
+      height_(0) {
+}
+
+FakeWebGraphicsContext3D::FakeWebGraphicsContext3D(
+    const WebGraphicsContext3D::Attributes& attributes)
+    : context_id_(s_context_id++),
+      next_texture_id_(1),
+      attributes_(attributes),
+      have_extension_io_surface_(false),
+      have_extension_egl_image_(false),
+      times_make_current_succeeds_(-1),
+      times_bind_texture_succeeds_(-1),
+      times_end_query_succeeds_(-1),
+      context_lost_(false),
+      context_lost_callback_(NULL),
+      width_(0),
+      height_(0) {
+}
+
+FakeWebGraphicsContext3D::~FakeWebGraphicsContext3D() {
+}
+
 bool FakeWebGraphicsContext3D::makeContextCurrent() {
-  return true;
+  if (times_make_current_succeeds_ >= 0) {
+    if (!times_make_current_succeeds_) {
+      loseContextCHROMIUM(GL_GUILTY_CONTEXT_RESET_ARB,
+                          GL_INNOCENT_CONTEXT_RESET_ARB);
+    }
+    --times_make_current_succeeds_;
+  }
+  return !context_lost_;
 }
 
 int FakeWebGraphicsContext3D::width() {
-  return 0;
+  return width_;
 }
 
 int FakeWebGraphicsContext3D::height() {
-  return 0;
+  return height_;
 }
 
+void FakeWebGraphicsContext3D::reshape(int width, int height) {
+  width_ = width;
+  height_ = height;
+}
+
 bool FakeWebGraphicsContext3D::isGLES2Compliant() {
   return false;
 }
@@ -25,38 +92,42 @@
 bool FakeWebGraphicsContext3D::readBackFramebuffer(
     unsigned char* pixels,
     size_t bufferSize,
-    WebKit::WebGLId framebuffer,
+    WebGLId framebuffer,
     int width,
     int height) {
   return false;
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::getPlatformTextureId() {
+WebGLId FakeWebGraphicsContext3D::getPlatformTextureId() {
   return 0;
 }
 
 bool FakeWebGraphicsContext3D::isContextLost() {
-  return false;
+  return context_lost_;
 }
 
+WGC3Denum FakeWebGraphicsContext3D::getGraphicsResetStatusARB() {
+  return context_lost_ ? GL_UNKNOWN_CONTEXT_RESET_ARB : GL_NO_ERROR;
+}
+
 void* FakeWebGraphicsContext3D::mapBufferSubDataCHROMIUM(
-    WebKit::WGC3Denum target,
+    WGC3Denum target,
     WebKit::WGC3Dintptr offset,
     WebKit::WGC3Dsizeiptr size,
-    WebKit::WGC3Denum access) {
+    WGC3Denum access) {
   return 0;
 }
 
 void* FakeWebGraphicsContext3D::mapTexSubImage2DCHROMIUM(
-    WebKit::WGC3Denum target,
+    WGC3Denum target,
     WebKit::WGC3Dint level,
     WebKit::WGC3Dint xoffset,
     WebKit::WGC3Dint yoffset,
     WebKit::WGC3Dsizei width,
     WebKit::WGC3Dsizei height,
-    WebKit::WGC3Denum format,
-    WebKit::WGC3Denum type,
-    WebKit::WGC3Denum access) {
+    WGC3Denum format,
+    WGC3Denum type,
+    WGC3Denum access) {
   return 0;
 }
 
@@ -64,159 +135,289 @@
   return WebKit::WebString();
 }
 
-WebKit::WGC3Denum FakeWebGraphicsContext3D::checkFramebufferStatus(
-    WebKit::WGC3Denum target) {
+WGC3Denum FakeWebGraphicsContext3D::checkFramebufferStatus(
+    WGC3Denum target) {
+  if (context_lost_)
+    return GL_FRAMEBUFFER_UNDEFINED_OES;
   return GL_FRAMEBUFFER_COMPLETE;
 }
 
 bool FakeWebGraphicsContext3D::getActiveAttrib(
-    WebKit::WebGLId program,
+    WebGLId program,
     WebKit::WGC3Duint index,
     ActiveInfo&) {
   return false;
 }
 
 bool FakeWebGraphicsContext3D::getActiveUniform(
-    WebKit::WebGLId program,
+    WebGLId program,
     WebKit::WGC3Duint index,
     ActiveInfo&) {
   return false;
 }
 
 WebKit::WGC3Dint FakeWebGraphicsContext3D::getAttribLocation(
-    WebKit::WebGLId program,
+    WebGLId program,
     const WebKit::WGC3Dchar* name) {
   return 0;
 }
 
-WebKit::WebGraphicsContext3D::Attributes
+WebGraphicsContext3D::Attributes
     FakeWebGraphicsContext3D::getContextAttributes() {
-  return m_attrs;
+  return attributes_;
 }
 
-WebKit::WGC3Denum FakeWebGraphicsContext3D::getError() {
+WGC3Denum FakeWebGraphicsContext3D::getError() {
   return 0;
 }
 
 void FakeWebGraphicsContext3D::getIntegerv(
-    WebKit::WGC3Denum pname,
+    WGC3Denum pname,
     WebKit::WGC3Dint* value) {
   if (pname == GL_MAX_TEXTURE_SIZE)
     *value = 1024;
 }
 
 void FakeWebGraphicsContext3D::getProgramiv(
-    WebKit::WebGLId program,
-    WebKit::WGC3Denum pname,
+    WebGLId program,
+    WGC3Denum pname,
     WebKit::WGC3Dint* value) {
   if (pname == GL_LINK_STATUS)
     *value = 1;
 }
 
 WebKit::WebString FakeWebGraphicsContext3D::getProgramInfoLog(
-    WebKit::WebGLId program) {
+    WebGLId program) {
   return WebKit::WebString();
 }
 
 void FakeWebGraphicsContext3D::getShaderiv(
-    WebKit::WebGLId shader,
-    WebKit::WGC3Denum pname,
+    WebGLId shader,
+    WGC3Denum pname,
     WebKit::WGC3Dint* value) {
   if (pname == GL_COMPILE_STATUS)
     *value = 1;
 }
 
 WebKit::WebString FakeWebGraphicsContext3D::getShaderInfoLog(
-    WebKit::WebGLId shader) {
+    WebGLId shader) {
   return WebKit::WebString();
 }
 
 WebKit::WebString FakeWebGraphicsContext3D::getShaderSource(
-    WebKit::WebGLId shader) {
+    WebGLId shader) {
   return WebKit::WebString();
 }
 
-WebKit::WebString FakeWebGraphicsContext3D::getString(WebKit::WGC3Denum name) {
-  return WebKit::WebString();
+WebKit::WebString FakeWebGraphicsContext3D::getString(WGC3Denum name) {
+  std::string string;
+
+  if (name == GL_EXTENSIONS) {
+    if (have_extension_io_surface_)
+      string += "GL_CHROMIUM_iosurface GL_ARB_texture_rectangle ";
+    if (have_extension_egl_image_)
+      string += "GL_OES_EGL_image_external";
+  }
+
+  return WebKit::WebString::fromUTF8(string.c_str());
 }
 
 WebKit::WGC3Dint FakeWebGraphicsContext3D::getUniformLocation(
-    WebKit::WebGLId program,
+    WebGLId program,
     const WebKit::WGC3Dchar* name) {
   return 0;
 }
 
 WebKit::WGC3Dsizeiptr FakeWebGraphicsContext3D::getVertexAttribOffset(
     WebKit::WGC3Duint index,
-    WebKit::WGC3Denum pname) {
+    WGC3Denum pname) {
   return 0;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isBuffer(
-    WebKit::WebGLId buffer) {
+WGC3Dboolean FakeWebGraphicsContext3D::isBuffer(
+    WebGLId buffer) {
   return false;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isEnabled(
-    WebKit::WGC3Denum cap) {
+WGC3Dboolean FakeWebGraphicsContext3D::isEnabled(
+    WGC3Denum cap) {
   return false;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isFramebuffer(
-    WebKit::WebGLId framebuffer) {
+WGC3Dboolean FakeWebGraphicsContext3D::isFramebuffer(
+    WebGLId framebuffer) {
   return false;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isProgram(
-    WebKit::WebGLId program) {
+WGC3Dboolean FakeWebGraphicsContext3D::isProgram(
+    WebGLId program) {
   return false;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isRenderbuffer(
-    WebKit::WebGLId renderbuffer) {
+WGC3Dboolean FakeWebGraphicsContext3D::isRenderbuffer(
+    WebGLId renderbuffer) {
   return false;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isShader(
-    WebKit::WebGLId shader) {
+WGC3Dboolean FakeWebGraphicsContext3D::isShader(
+    WebGLId shader) {
   return false;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isTexture(
-    WebKit::WebGLId texture) {
+WGC3Dboolean FakeWebGraphicsContext3D::isTexture(
+    WebGLId texture) {
   return false;
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createBuffer() {
-  return 1;
+WebGLId FakeWebGraphicsContext3D::createBuffer() {
+  return kBufferId | context_id_ << 16;
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createFramebuffer() {
-  return 1;
+void FakeWebGraphicsContext3D::deleteBuffer(WebKit::WebGLId id) {
+  EXPECT_EQ(kBufferId | context_id_ << 16, id);
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createProgram() {
-  return 1;
+WebGLId FakeWebGraphicsContext3D::createFramebuffer() {
+  return kFramebufferId | context_id_ << 16;
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createRenderbuffer() {
-  return 1;
+void FakeWebGraphicsContext3D::deleteFramebuffer(WebKit::WebGLId id) {
+  EXPECT_EQ(kFramebufferId | context_id_ << 16, id);
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createShader(WebKit::WGC3Denum) {
-  return 1;
+WebGLId FakeWebGraphicsContext3D::createProgram() {
+  return kProgramId | context_id_ << 16;
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createTexture() {
-  return m_nextTextureId++;
+void FakeWebGraphicsContext3D::deleteProgram(WebKit::WebGLId id) {
+  EXPECT_EQ(kProgramId | context_id_ << 16, id);
 }
 
-WebKit::WebGLId FakeWebGraphicsContext3D::createQueryEXT() {
+WebGLId FakeWebGraphicsContext3D::createRenderbuffer() {
+  return kRenderbufferId | context_id_ << 16;
+}
+
+void FakeWebGraphicsContext3D::deleteRenderbuffer(WebKit::WebGLId id) {
+  EXPECT_EQ(kRenderbufferId | context_id_ << 16, id);
+}
+
+WebGLId FakeWebGraphicsContext3D::createShader(WGC3Denum) {
+  return kShaderId | context_id_ << 16;
+}
+
+void FakeWebGraphicsContext3D::deleteShader(WebKit::WebGLId id) {
+  EXPECT_EQ(kShaderId | context_id_ << 16, id);
+}
+
+WebGLId FakeWebGraphicsContext3D::createTexture() {
+  WebGLId texture_id = NextTextureId();
+  DCHECK_NE(texture_id, kExternalTextureId);
+  textures_.push_back(texture_id);
+  return texture_id;
+}
+
+void FakeWebGraphicsContext3D::deleteTexture(WebGLId texture_id) {
+  DCHECK(std::find(textures_.begin(), textures_.end(), texture_id) !=
+         textures_.end());
+  textures_.erase(std::find(textures_.begin(), textures_.end(), texture_id));
+}
+
+void FakeWebGraphicsContext3D::attachShader(WebGLId program, WebGLId shader) {
+  EXPECT_EQ(kProgramId | context_id_ << 16, program);
+  EXPECT_EQ(kShaderId | context_id_ << 16, shader);
+}
+
+void FakeWebGraphicsContext3D::useProgram(WebGLId program) {
+  if (!program)
+    return;
+  EXPECT_EQ(kProgramId | context_id_ << 16, program);
+}
+
+void FakeWebGraphicsContext3D::bindBuffer(WGC3Denum target, WebGLId buffer) {
+  if (!buffer)
+    return;
+  EXPECT_EQ(kBufferId | context_id_ << 16, buffer);
+}
+
+void FakeWebGraphicsContext3D::bindFramebuffer(
+    WGC3Denum target, WebGLId framebuffer) {
+  if (!framebuffer)
+    return;
+  EXPECT_EQ(kFramebufferId | context_id_ << 16, framebuffer);
+}
+
+void FakeWebGraphicsContext3D::bindRenderbuffer(
+      WGC3Denum target, WebGLId renderbuffer) { 
+  if (!renderbuffer)
+    return;
+ EXPECT_EQ(kRenderbufferId | context_id_ << 16, renderbuffer);
+}
+
+void FakeWebGraphicsContext3D::bindTexture(
+    WGC3Denum target, WebGLId texture_id) {
+  if (times_bind_texture_succeeds_ >= 0) {
+    if (!times_bind_texture_succeeds_) {
+      loseContextCHROMIUM(GL_GUILTY_CONTEXT_RESET_ARB,
+                          GL_INNOCENT_CONTEXT_RESET_ARB);
+    }
+    --times_bind_texture_succeeds_;
+  }
+
+  if (!texture_id)
+    return;
+  if (texture_id == kExternalTextureId)
+    return;
+  DCHECK(std::find(textures_.begin(), textures_.end(), texture_id) !=
+         textures_.end());
+  used_textures_.insert(texture_id);
+}
+
+WebGLId FakeWebGraphicsContext3D::createQueryEXT() {
   return 1;
 }
 
-WebKit::WGC3Dboolean FakeWebGraphicsContext3D::isQueryEXT(WebKit::WebGLId) {
+WGC3Dboolean FakeWebGraphicsContext3D::isQueryEXT(WebGLId query) {
   return true;
 }
 
+void FakeWebGraphicsContext3D::endQueryEXT(WebKit::WGC3Denum target) {
+  if (times_end_query_succeeds_ >= 0) {
+    if (!times_end_query_succeeds_) {
+      loseContextCHROMIUM(GL_GUILTY_CONTEXT_RESET_ARB,
+                          GL_INNOCENT_CONTEXT_RESET_ARB);
+    }
+    --times_end_query_succeeds_;
+  }
+}
+
+void FakeWebGraphicsContext3D::getQueryObjectuivEXT(
+    WebKit::WebGLId query,
+    WebKit::WGC3Denum pname,
+    WebKit::WGC3Duint* params) {
+  // If the context is lost, behave as if result is available.
+  if (pname == GL_QUERY_RESULT_AVAILABLE_EXT)
+    *params = 1;
+}
+
+void FakeWebGraphicsContext3D::setContextLostCallback(
+    WebGraphicsContextLostCallback* callback) {
+  context_lost_callback_ = callback;
+}
+
+void FakeWebGraphicsContext3D::loseContextCHROMIUM(WGC3Denum current,
+                                                   WGC3Denum other) {
+  if (context_lost_)
+    return;
+  context_lost_ = true;
+  if (context_lost_callback_)
+    context_lost_callback_->onContextLost();
+}
+
+WebKit::WebGLId FakeWebGraphicsContext3D::NextTextureId() {
+  WebGLId texture_id = next_texture_id_++;
+  DCHECK(texture_id < (1 << 16));
+  texture_id |= context_id_ << 16;
+  return texture_id;
+}
+
 }  // namespace cc
Index: src/cc/test/fake_tile_manager_client.h
===================================================================
--- src/cc/test/fake_tile_manager_client.h	(revision 184497)
+++ src/cc/test/fake_tile_manager_client.h	(working copy)
@@ -15,7 +15,7 @@
 
   // TileManagerClient implementation.
   virtual void ScheduleManageTiles() OVERRIDE {}
-  virtual void ScheduleCheckForCompletedSetPixels() OVERRIDE {}
+  virtual void DidUploadVisibleHighResolutionTile() OVERRIDE {}
 };
 
 }  // namespace cc
Index: src/cc/test/fake_layer_tree_host_client.h
===================================================================
--- src/cc/test/fake_layer_tree_host_client.h	(revision 184497)
+++ src/cc/test/fake_layer_tree_host_client.h	(working copy)
@@ -9,7 +9,6 @@
 #include "cc/font_atlas.h"
 #include "cc/input_handler.h"
 #include "cc/layer_tree_host.h"
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
 #include "cc/test/fake_output_surface.h"
 
 namespace cc {
Index: src/cc/test/render_pass_test_utils.cc
===================================================================
--- src/cc/test/render_pass_test_utils.cc	(revision 184497)
+++ src/cc/test/render_pass_test_utils.cc	(working copy)
@@ -15,14 +15,14 @@
 
 namespace cc {
 
-TestRenderPass* addRenderPass(ScopedPtrVector<RenderPass>& passList,
+TestRenderPass* addRenderPass(RenderPassList& passList,
                               RenderPass::Id id,
                               const gfx::Rect& outputRect,
                               const gfx::Transform& rootTransform) {
   scoped_ptr<TestRenderPass> pass(TestRenderPass::Create());
   pass->SetNew(id, outputRect, outputRect, rootTransform);
   TestRenderPass* saved = pass.get();
-  passList.append(pass.PassAs<RenderPass>());
+  passList.push_back(pass.PassAs<RenderPass>());
   return saved;
 }
 
@@ -33,7 +33,7 @@
   AppendQuadsData data(pass->id);
   SharedQuadState* sharedState =
       quadSink.useSharedQuadState(SharedQuadState::Create());
-  sharedState->SetAll(gfx::Transform(), rect, rect, rect, false, 1);
+  sharedState->SetAll(gfx::Transform(), rect, rect, false, 1);
   scoped_ptr<SolidColorDrawQuad> quad = SolidColorDrawQuad::Create();
   quad->SetNew(sharedState, rect, color);
   SolidColorDrawQuad* quadPtr = quad.get();
@@ -48,11 +48,11 @@
   gfx::Rect outputRect = contributingPass->output_rect;
   SharedQuadState* sharedState =
       quadSink.useSharedQuadState(SharedQuadState::Create());
-  sharedState->SetAll(gfx::Transform(), outputRect, outputRect, outputRect,
-                      false, 1);
+  sharedState->SetAll(gfx::Transform(), outputRect, outputRect, false, 1);
   scoped_ptr<RenderPassDrawQuad> quad = RenderPassDrawQuad::Create();
   quad->SetNew(sharedState, outputRect, contributingPass->id, false, 0,
-               outputRect, gfx::RectF());
+               outputRect, gfx::RectF(), WebKit::WebFilterOperations(),
+               skia::RefPtr<SkImageFilter>(), WebKit::WebFilterOperations());
   quadSink.append(quad.PassAs<DrawQuad>(), data);
 }
 
Index: src/cc/test/data/10_10_layer_tree.json
===================================================================
--- src/cc/test/data/10_10_layer_tree.json	(revision 184497)
+++ src/cc/test/data/10_10_layer_tree.json	(working copy)
@@ -18,6 +18,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, -55.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -27,6 +28,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -54,6 +56,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 7.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -63,6 +66,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 0, 0, 0, 0 ],
+               "ImageBounds": [ 1, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 0.0, 0.0 ]
@@ -110,6 +114,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, -47.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -119,6 +124,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -138,6 +144,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 15.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -147,6 +154,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 859.8399658203125, 23.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -202,6 +210,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, -5.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -211,6 +220,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -230,6 +240,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 57.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -239,6 +250,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 859.8399658203125, 65.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -294,6 +306,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 132.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -303,6 +316,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -322,6 +336,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 194.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -331,6 +346,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 859.8399658203125, 202.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -386,6 +402,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 356.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -395,6 +412,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -414,6 +432,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 418.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -423,6 +442,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 859.8399658203125, 426.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -478,6 +498,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 625.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -487,6 +508,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -506,6 +528,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 687.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -515,6 +538,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 859.8399658203125, 695.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -570,6 +594,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 894.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -579,6 +604,7 @@
             "DrawTransform": [ 1.024660587310791, 0.0, 0.0, 0.0, 0.0, 1.024660587310791, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 118.47874069213867, 149.62063217163086, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 17, 35, 2, 1 ],
+            "ImageBounds": [ 20, 37 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -598,6 +624,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 956.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -607,6 +634,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 859.8399658203125, 964.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -662,6 +690,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 952.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -671,6 +700,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -690,6 +720,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 1014.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -699,6 +730,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 384.8399658203125, 1001.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -746,6 +778,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 960.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -755,6 +788,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -774,6 +808,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 1022.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -783,6 +818,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 384.8399658203125, 951.828857421875, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -830,6 +866,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 568.0, 968.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -839,6 +876,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -866,6 +904,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 620.0, 1030.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -875,6 +914,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 0, 0, 0, 0 ],
+               "ImageBounds": [ 1, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 0.0, 0.0 ]
@@ -922,6 +962,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, -55.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -931,6 +972,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -958,6 +1000,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 7.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -967,6 +1010,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 15.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1014,6 +1058,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, -47.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1023,6 +1068,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1042,6 +1088,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 15.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1051,6 +1098,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 23.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1106,6 +1154,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, -25.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1115,6 +1164,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1134,6 +1184,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 37.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1143,6 +1194,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 45.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1198,6 +1250,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 91.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1207,6 +1260,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1226,6 +1280,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 153.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1235,6 +1290,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 161.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1290,6 +1346,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 295.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1299,6 +1356,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1318,6 +1376,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 357.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1327,6 +1386,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 365.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1382,6 +1442,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 561.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1391,6 +1452,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1410,6 +1472,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 623.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1419,6 +1482,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 631.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1474,6 +1538,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 830.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1483,6 +1548,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1518,6 +1584,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 892.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1527,6 +1594,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 900.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1582,6 +1650,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 952.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1591,6 +1660,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1610,6 +1680,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 1014.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1619,6 +1690,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 261.8399658203125, 1012.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 38, 0, 0, 0 ],
+               "ImageBounds": [ 39, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 231.8399658203125, 0.0 ]
@@ -1666,6 +1738,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 960.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1675,6 +1748,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1694,6 +1768,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 1022.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1703,6 +1778,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 0, 0, 0, 0 ],
+               "ImageBounds": [ 1, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 0.0, 0.0 ]
@@ -1750,6 +1826,7 @@
             "DrawTransform": [ 3.125, 0.0, 0.0, 0.0, 0.0, 3.125, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -30.0, 968.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 32, 32, 0, 0 ],
+            "ImageBounds": [ 33, 33 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.5,
             "Position": [ -60.0, -70.0 ]
@@ -1759,6 +1836,7 @@
             "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
             "DrawsContent": true,
             "ImageAperture": [ 0, 0, 0, 0 ],
+            "ImageBounds": [ 1, 1 ],
             "LayerType": "NinePatchLayer",
             "Opacity": 0.0,
             "Position": [ -8.0, -8.0 ]
@@ -1778,6 +1856,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 22.0, 1030.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 17, 35, 2, 1 ],
+               "ImageBounds": [ 20, 37 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 1.0,
                "Position": [ -8.0, -8.0 ]
@@ -1787,6 +1866,7 @@
                "DrawTransform": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
                "DrawsContent": true,
                "ImageAperture": [ 0, 0, 0, 0 ],
+               "ImageBounds": [ 1, 1 ],
                "LayerType": "NinePatchLayer",
                "Opacity": 0.0,
                "Position": [ 0.0, 0.0 ]
Index: src/cc/test/animation_test_common.cc
===================================================================
--- src/cc/test/animation_test_common.cc	(revision 184497)
+++ src/cc/test/animation_test_common.cc	(working copy)
@@ -8,9 +8,9 @@
 #include "cc/layer.h"
 #include "cc/layer_animation_controller.h"
 #include "cc/layer_impl.h"
-#include <public/WebTransformOperations.h>
+#include "cc/transform_operations.h"
 
-using cc::ActiveAnimation;
+using cc::Animation;
 using cc::AnimationCurve;
 using cc::EaseTimingFunction;
 using cc::FloatKeyframe;
@@ -37,7 +37,7 @@
 
     int id = nextAnimationId++;
 
-    scoped_ptr<ActiveAnimation> animation(ActiveAnimation::create(curve.PassAs<AnimationCurve>(), id, 0, ActiveAnimation::Opacity));
+    scoped_ptr<Animation> animation(Animation::create(curve.PassAs<AnimationCurve>(), id, 0, Animation::Opacity));
     animation->setNeedsSynchronizedStartTime(true);
 
     target.addAnimation(animation.Pass());
@@ -50,18 +50,18 @@
     scoped_ptr<KeyframedTransformAnimationCurve> curve(KeyframedTransformAnimationCurve::create());
 
     if (duration > 0) {
-        WebKit::WebTransformOperations startOperations;
-        startOperations.appendTranslate(deltaX, deltaY, 0);
+        TransformOperations startOperations;
+        startOperations.AppendTranslate(deltaX, deltaY, 0);
         curve->addKeyframe(TransformKeyframe::create(0, startOperations, scoped_ptr<cc::TimingFunction>()));
     }
 
-    WebKit::WebTransformOperations operations;
-    operations.appendTranslate(deltaX, deltaY, 0);
+    TransformOperations operations;
+    operations.AppendTranslate(deltaX, deltaY, 0);
     curve->addKeyframe(TransformKeyframe::create(duration, operations, scoped_ptr<cc::TimingFunction>()));
 
     int id = nextAnimationId++;
 
-    scoped_ptr<ActiveAnimation> animation(ActiveAnimation::create(curve.PassAs<AnimationCurve>(), id, 0, ActiveAnimation::Transform));
+    scoped_ptr<Animation> animation(Animation::create(curve.PassAs<AnimationCurve>(), id, 0, Animation::Transform));
     animation->setNeedsSynchronizedStartTime(true);
 
     target.addAnimation(animation.Pass());
@@ -111,9 +111,9 @@
     return m_duration;
 }
 
-WebKit::WebTransformationMatrix FakeTransformTransition::getValue(double time) const
+gfx::Transform FakeTransformTransition::getValue(double time) const
 {
-    return WebKit::WebTransformationMatrix();
+    return gfx::Transform();
 }
 
 scoped_ptr<cc::AnimationCurve> FakeTransformTransition::clone() const
@@ -146,38 +146,28 @@
     return (1 - time) * m_from + time * m_to;
 }
 
-FakeLayerAnimationControllerClient::FakeLayerAnimationControllerClient()
+FakeLayerAnimationValueObserver::FakeLayerAnimationValueObserver()
     : m_opacity(0)
 {
 }
 
-FakeLayerAnimationControllerClient::~FakeLayerAnimationControllerClient()
+FakeLayerAnimationValueObserver::~FakeLayerAnimationValueObserver()
 {
 }
 
-int FakeLayerAnimationControllerClient::id() const
+void FakeLayerAnimationValueObserver::OnOpacityAnimated(float opacity)
 {
-    return 0;
-}
-
-void FakeLayerAnimationControllerClient::setOpacityFromAnimation(float opacity)
-{
     m_opacity = opacity;
 }
 
-float FakeLayerAnimationControllerClient::opacity() const
+void FakeLayerAnimationValueObserver::OnTransformAnimated(const gfx::Transform& transform)
 {
-    return m_opacity;
-}
-
-void FakeLayerAnimationControllerClient::setTransformFromAnimation(const gfx::Transform& transform)
-{
     m_transform = transform;
 }
 
-const gfx::Transform& FakeLayerAnimationControllerClient::transform() const
+bool FakeLayerAnimationValueObserver::IsActive() const
 {
-    return m_transform;
+    return true;
 }
 
 scoped_ptr<cc::AnimationCurve> FakeFloatTransition::clone() const
Index: src/cc/test/render_pass_test_utils.h
===================================================================
--- src/cc/test/render_pass_test_utils.h	(revision 184497)
+++ src/cc/test/render_pass_test_utils.h	(working copy)
@@ -22,7 +22,7 @@
 // Adds a new render pass with the provided properties to the given
 // render pass list.
 TestRenderPass* addRenderPass(
-    ScopedPtrVector<RenderPass>& passList,
+    RenderPassList& passList,
     RenderPass::Id id,
     const gfx::Rect& outputRect,
     const gfx::Transform& rootTransform);
Index: src/cc/test/animation_test_common.h
===================================================================
--- src/cc/test/animation_test_common.h	(revision 184497)
+++ src/cc/test/animation_test_common.h	(working copy)
@@ -5,9 +5,10 @@
 #ifndef CC_TEST_ANIMATION_TEST_COMMON_H_
 #define CC_TEST_ANIMATION_TEST_COMMON_H_
 
-#include "cc/active_animation.h"
+#include "cc/animation.h"
 #include "cc/animation_curve.h"
 #include "cc/layer_animation_controller.h"
+#include "cc/layer_animation_value_observer.h"
 
 namespace cc {
 class LayerImpl;
@@ -36,7 +37,7 @@
     virtual ~FakeTransformTransition();
 
     virtual double duration() const OVERRIDE;
-    virtual WebKit::WebTransformationMatrix getValue(double time) const OVERRIDE;
+    virtual gfx::Transform getValue(double time) const OVERRIDE;
 
     virtual scoped_ptr<cc::AnimationCurve> clone() const OVERRIDE;
 
@@ -60,18 +61,19 @@
     float m_to;
 };
 
-class FakeLayerAnimationControllerClient : public cc::LayerAnimationControllerClient {
+class FakeLayerAnimationValueObserver : public cc::LayerAnimationValueObserver {
 public:
-    FakeLayerAnimationControllerClient();
-    virtual ~FakeLayerAnimationControllerClient();
+    FakeLayerAnimationValueObserver();
+    virtual ~FakeLayerAnimationValueObserver();
 
-    // LayerAnimationControllerClient implementation
-    virtual int id() const OVERRIDE;
-    virtual void setOpacityFromAnimation(float) OVERRIDE;
-    virtual float opacity() const OVERRIDE;
-    virtual void setTransformFromAnimation(const gfx::Transform&) OVERRIDE;
-    virtual const gfx::Transform& transform() const OVERRIDE;
+    // LayerAnimationValueObserver implementation
+    virtual void OnOpacityAnimated(float) OVERRIDE;
+    virtual void OnTransformAnimated(const gfx::Transform&) OVERRIDE;
+    virtual bool IsActive() const OVERRIDE;
 
+    float opacity() const  { return m_opacity; }
+    const gfx::Transform& transform() const { return m_transform; }
+
 private:
     float m_opacity;
     gfx::Transform m_transform;
Index: src/cc/test/compositor_fake_web_graphics_context_3d.cc
===================================================================
--- src/cc/test/compositor_fake_web_graphics_context_3d.cc	(revision 184497)
+++ src/cc/test/compositor_fake_web_graphics_context_3d.cc	(working copy)
@@ -1,36 +0,0 @@
-// Copyright 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
-
-namespace cc {
-
-bool CompositorFakeWebGraphicsContext3D::makeContextCurrent() {
-  return true;
-}
-
-WebKit::WebGLId CompositorFakeWebGraphicsContext3D::createProgram() {
-  return 1;
-}
-
-WebKit::WebGLId CompositorFakeWebGraphicsContext3D::createShader(
-    WebKit::WGC3Denum) {
-  return 1;
-}
-
-void CompositorFakeWebGraphicsContext3D::getShaderiv(
-    WebKit::WebGLId,
-    WebKit::WGC3Denum,
-    WebKit::WGC3Dint* value) {
-  *value = 1;
-}
-
-void CompositorFakeWebGraphicsContext3D::getProgramiv(
-    WebKit::WebGLId,
-    WebKit::WGC3Denum,
-    WebKit::WGC3Dint* value) {
-  *value = 1;
-}
-
-}  // namespace cc
Index: src/cc/test/fake_layer_tree_host_impl_client.h
===================================================================
--- src/cc/test/fake_layer_tree_host_impl_client.h	(revision 184497)
+++ src/cc/test/fake_layer_tree_host_impl_client.h	(working copy)
@@ -18,14 +18,19 @@
       base::TimeTicks,
       base::TimeDelta) OVERRIDE { }
   virtual void onCanDrawStateChanged(bool) OVERRIDE { }
+  virtual void onHasPendingTreeStateChanged(bool) OVERRIDE { }
   virtual void setNeedsRedrawOnImplThread() OVERRIDE { }
+  virtual void didUploadVisibleHighResolutionTileOnImplThread() OVERRIDE { }
   virtual void setNeedsCommitOnImplThread() OVERRIDE { }
   virtual void setNeedsManageTilesOnImplThread() OVERRIDE { }
   virtual void postAnimationEventsToMainThreadOnImplThread(
       scoped_ptr<AnimationEventsVector>,
       base::Time) OVERRIDE { }
   virtual bool reduceContentsTextureMemoryOnImplThread(size_t, int) OVERRIDE;
+  virtual void reduceWastedContentsTextureMemoryOnImplThread() OVERRIDE { }
   virtual void sendManagedMemoryStats() OVERRIDE { }
+  virtual bool isInsideDraw() OVERRIDE;
+  virtual void renewTreePriority() OVERRIDE { }
 };
 
 }  // namespace cc
Index: src/cc/test/fake_picture_layer_tiling_client.cc
===================================================================
--- src/cc/test/fake_picture_layer_tiling_client.cc	(revision 184497)
+++ src/cc/test/fake_picture_layer_tiling_client.cc	(working copy)
@@ -22,11 +22,18 @@
                                      tile_size_,
                                      GL_RGBA,
                                      rect,
+                                     gfx::Rect(),
                                      1));
 }
 
 void FakePictureLayerTilingClient::SetTileSize(gfx::Size tile_size) {
-    tile_size_ = tile_size;
+  tile_size_ = tile_size;
 }
 
+gfx::Size FakePictureLayerTilingClient::CalculateTileSize(
+    gfx::Size /* current_tile_size */,
+    gfx::Size /* content_bounds */) {
+  return tile_size_;
+}
+
 }  // namespace cc
Index: src/cc/test/fake_layer_tree_host_impl.h
===================================================================
--- src/cc/test/fake_layer_tree_host_impl.h	(revision 184497)
+++ src/cc/test/fake_layer_tree_host_impl.h	(working copy)
@@ -14,13 +14,19 @@
 class FakeLayerTreeHostImpl : public LayerTreeHostImpl {
  public:
   FakeLayerTreeHostImpl(Proxy* proxy);
+  FakeLayerTreeHostImpl(const LayerTreeSettings& settings, Proxy* proxy);
   virtual ~FakeLayerTreeHostImpl();
 
-  using LayerTreeHostImpl::resetNeedsUpdateDrawPropertiesForTesting;
+  void forcePrepareToDraw() {
+    LayerTreeHostImpl::FrameData frameData;
+    prepareToDraw(frameData);
+    didDrawAllLayers(frameData);
+  }
 
+  using LayerTreeHostImpl::activatePendingTree;
+
  private:
   FakeLayerTreeHostImplClient client_;
-  LayerTreeSettings settings_;
 };
 
 }  // namespace cc
Index: src/cc/test/layer_tree_test_common.cc
===================================================================
--- src/cc/test/layer_tree_test_common.cc	(revision 184497)
+++ src/cc/test/layer_tree_test_common.cc	(working copy)
@@ -4,8 +4,8 @@
 
 #include "cc/test/layer_tree_test_common.h"
 
-#include "base/stl_util.h"
-#include "cc/active_animation.h"
+#include "cc/animation.h"
+#include "cc/animation_registrar.h"
 #include "cc/content_layer.h"
 #include "cc/font_atlas.h"
 #include "cc/input_handler.h"
@@ -13,75 +13,35 @@
 #include "cc/layer_animation_controller.h"
 #include "cc/layer_impl.h"
 #include "cc/layer_tree_host_impl.h"
-#include "cc/scoped_thread_proxy.h"
 #include "cc/single_thread_proxy.h"
 #include "cc/thread_impl.h"
 #include "cc/test/animation_test_common.h"
 #include "cc/test/fake_output_surface.h"
-#include "cc/test/fake_web_graphics_context_3d.h"
 #include "cc/test/occlusion_tracker_test_common.h"
 #include "cc/test/tiled_layer_test_common.h"
 #include "cc/timing_function.h"
 #include "testing/gmock/include/gmock/gmock.h"
-#include <public/WebFilterOperation.h>
-#include <public/WebFilterOperations.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperation.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
+#include "ui/gfx/size_conversions.h"
 
 using namespace WebKit;
 
 namespace cc {
 
-scoped_ptr<CompositorFakeWebGraphicsContext3DWithTextureTracking> CompositorFakeWebGraphicsContext3DWithTextureTracking::create(Attributes attrs)
+bool TestHooks::prepareToDrawOnThread(cc::LayerTreeHostImpl*, LayerTreeHostImpl::FrameData&, bool)
 {
-    return make_scoped_ptr(new CompositorFakeWebGraphicsContext3DWithTextureTracking(attrs));
+    return true;
 }
 
-WebKit::WebGLId CompositorFakeWebGraphicsContext3DWithTextureTracking::createTexture()
+bool TestHooks::canActivatePendingTree()
 {
-    WebKit::WebGLId texture = m_textures.size() + 1;
-    m_textures.push_back(texture);
-    return texture;
-}
-
-void CompositorFakeWebGraphicsContext3DWithTextureTracking::deleteTexture(WebKit::WebGLId texture)
-{
-    std::vector<WebKit::WebGLId>::iterator i(std::find(m_textures.begin(), m_textures.end(), texture));
-    if (i != m_textures.end())
-      m_textures.erase(i);
-}
-
-void CompositorFakeWebGraphicsContext3DWithTextureTracking::bindTexture(WebKit::WGC3Denum /* target */, WebKit::WebGLId texture)
-{
-    m_usedTextures.insert(texture);
-}
-
-int CompositorFakeWebGraphicsContext3DWithTextureTracking::numTextures() const { return static_cast<int>(m_textures.size()); }
-int CompositorFakeWebGraphicsContext3DWithTextureTracking::texture(int i) const { return m_textures[i]; }
-void CompositorFakeWebGraphicsContext3DWithTextureTracking::resetTextures() { m_textures.clear(); }
-
-int CompositorFakeWebGraphicsContext3DWithTextureTracking::numUsedTextures() const { return static_cast<int>(m_usedTextures.size()); }
-bool CompositorFakeWebGraphicsContext3DWithTextureTracking::usedTexture(int texture) const
-{
-  return ContainsKey(m_usedTextures, texture);
-}
-
-void CompositorFakeWebGraphicsContext3DWithTextureTracking::resetUsedTextures() { m_usedTextures.clear(); }
-
-CompositorFakeWebGraphicsContext3DWithTextureTracking::CompositorFakeWebGraphicsContext3DWithTextureTracking(Attributes attrs) : CompositorFakeWebGraphicsContext3D(attrs)
-{
-}
-
-CompositorFakeWebGraphicsContext3DWithTextureTracking::~CompositorFakeWebGraphicsContext3DWithTextureTracking()
-{
-}
-
-bool TestHooks::prepareToDrawOnThread(cc::LayerTreeHostImpl*)
-{
     return true;
 }
 
 scoped_ptr<OutputSurface> TestHooks::createOutputSurface()
 {
-    return FakeOutputSurface::Create3d(CompositorFakeWebGraphicsContext3DWithTextureTracking::create(WebGraphicsContext3D::Attributes()).PassAs<WebKit::WebGraphicsContext3D>()).PassAs<OutputSurface>();
+    return createFakeOutputSurface();
 }
 
 scoped_ptr<MockLayerTreeHostImpl> MockLayerTreeHostImpl::create(TestHooks* testHooks, const LayerTreeSettings& settings, LayerTreeHostImplClient* client, Proxy* proxy)
@@ -104,7 +64,7 @@
 bool MockLayerTreeHostImpl::prepareToDraw(FrameData& frame)
 {
     bool result = LayerTreeHostImpl::prepareToDraw(frame);
-    if (!m_testHooks->prepareToDrawOnThread(this))
+    if (!m_testHooks->prepareToDrawOnThread(this, frame, result))
         result = false;
     return result;
 }
@@ -115,11 +75,28 @@
     m_testHooks->drawLayersOnThread(this);
 }
 
+void MockLayerTreeHostImpl::activatePendingTreeIfNeeded()
+{
+    if (!pendingTree())
+        return;
+
+    if (m_testHooks->canActivatePendingTree())
+        activatePendingTree();
+}
+
 void MockLayerTreeHostImpl::animateLayers(base::TimeTicks monotonicTime, base::Time wallClockTime)
 {
     m_testHooks->willAnimateLayers(this, monotonicTime);
     LayerTreeHostImpl::animateLayers(monotonicTime, wallClockTime);
-    m_testHooks->animateLayers(this, monotonicTime);
+    bool hasUnfinishedAnimation = false;
+    AnimationRegistrar::AnimationControllerMap::const_iterator iter = activeAnimationControllers().begin();
+    for (; iter != activeAnimationControllers().end(); ++iter) {
+        if (iter->second->hasActiveAnimation()) {
+            hasUnfinishedAnimation = true;
+            break;
+        }
+    }
+    m_testHooks->animateLayers(this, monotonicTime, hasUnfinishedAnimation);
 }
 
 base::TimeDelta MockLayerTreeHostImpl::lowFrequencyAnimationInterval() const
@@ -136,18 +113,11 @@
 // Adapts LayerTreeHost for test. Injects MockLayerTreeHostImpl.
 class MockLayerTreeHost : public cc::LayerTreeHost {
 public:
-    static scoped_ptr<MockLayerTreeHost> create(TestHooks* testHooks, cc::LayerTreeHostClient* client, scoped_refptr<cc::Layer> rootLayer, const cc::LayerTreeSettings& settings, scoped_ptr<cc::Thread> implThread)
+    static scoped_ptr<MockLayerTreeHost> create(TestHooks* testHooks, cc::LayerTreeHostClient* client, const cc::LayerTreeSettings& settings, scoped_ptr<cc::Thread> implThread)
     {
         scoped_ptr<MockLayerTreeHost> layerTreeHost(new MockLayerTreeHost(testHooks, client, settings));
         bool success = layerTreeHost->initialize(implThread.Pass());
         EXPECT_TRUE(success);
-        layerTreeHost->setRootLayer(rootLayer);
-
-        // LayerTreeHostImpl won't draw if it has 1x1 viewport.
-        layerTreeHost->setViewportSize(gfx::Size(1, 1), gfx::Size(1, 1));
-
-        layerTreeHost->rootLayer()->setLayerAnimationDelegate(testHooks);
-
         return layerTreeHost.Pass();
     }
 
@@ -156,12 +126,6 @@
         return MockLayerTreeHostImpl::create(m_testHooks, settings(), client, proxy()).PassAs<cc::LayerTreeHostImpl>();
     }
 
-    virtual void didAddAnimation() OVERRIDE
-    {
-        LayerTreeHost::didAddAnimation();
-        m_testHooks->didAddAnimation();
-    }
-
     virtual void setNeedsCommit() OVERRIDE
     {
         if (!m_testStarted)
@@ -275,7 +239,9 @@
     , m_scheduled(false)
     , m_started(false)
     , m_implThread(0)
+    , m_weakFactory(ALLOW_THIS_IN_INITIALIZER_LIST(this))
 {
+    m_mainThreadWeakPtr = m_weakFactory.GetWeakPtr();
 }
 
 ThreadedTest::~ThreadedTest()
@@ -289,80 +255,85 @@
     if (m_beginning)
         m_endWhenBeginReturns = true;
     else
-        m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::realEndTest, base::Unretained(this)));
+        proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::realEndTest, m_mainThreadWeakPtr));
 }
 
 void ThreadedTest::endTestAfterDelay(int delayMilliseconds)
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::endTest, base::Unretained(this)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::endTest, m_mainThreadWeakPtr));
 }
 
-void ThreadedTest::postSetNeedsAnimateToMainThread()
-{
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchSetNeedsAnimate, base::Unretained(this)));
-}
-
 void ThreadedTest::postAddAnimationToMainThread(Layer* layerToReceiveAnimation)
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchAddAnimation, base::Unretained(this), base::Unretained(layerToReceiveAnimation)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchAddAnimation, m_mainThreadWeakPtr, base::Unretained(layerToReceiveAnimation)));
 }
 
 void ThreadedTest::postAddInstantAnimationToMainThread()
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchAddInstantAnimation, base::Unretained(this)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchAddInstantAnimation, m_mainThreadWeakPtr));
 }
 
 void ThreadedTest::postSetNeedsCommitToMainThread()
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchSetNeedsCommit, base::Unretained(this)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchSetNeedsCommit, m_mainThreadWeakPtr));
 }
 
 void ThreadedTest::postAcquireLayerTextures()
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchAcquireLayerTextures, base::Unretained(this)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchAcquireLayerTextures, m_mainThreadWeakPtr));
 }
 
 void ThreadedTest::postSetNeedsRedrawToMainThread()
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchSetNeedsRedraw, base::Unretained(this)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchSetNeedsRedraw, m_mainThreadWeakPtr));
 }
 
 void ThreadedTest::postSetVisibleToMainThread(bool visible)
 {
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchSetVisible, base::Unretained(this), visible));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchSetVisible, m_mainThreadWeakPtr, visible));
 }
 
-void ThreadedTest::postDidAddAnimationToMainThread()
-{
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchDidAddAnimation, base::Unretained(this)));
-}
-
 void ThreadedTest::doBeginTest()
 {
     m_client = ThreadedMockLayerTreeHostClient::create(this);
 
-    scoped_refptr<Layer> rootLayer = Layer::create();
     scoped_ptr<cc::Thread> implCCThread(NULL);
     if (m_implThread)
         implCCThread = cc::ThreadImpl::createForDifferentThread(m_implThread->message_loop_proxy());
-    m_layerTreeHost = MockLayerTreeHost::create(this, m_client.get(), rootLayer, m_settings, implCCThread.Pass());
+    m_layerTreeHost = MockLayerTreeHost::create(this, m_client.get(), m_settings, implCCThread.Pass());
     ASSERT_TRUE(m_layerTreeHost.get());
-    rootLayer->setLayerTreeHost(m_layerTreeHost.get());
-    m_layerTreeHost->setSurfaceReady();
 
     m_started = true;
     m_beginning = true;
+    setupTree();
+    m_layerTreeHost->setSurfaceReady();
     beginTest();
     m_beginning = false;
     if (m_endWhenBeginReturns)
         realEndTest();
 
+    LayerTreeHost::setNeedsFilterContext(false);
+
     // Allow commits to happen once beginTest() has had a chance to post tasks
     // so that those tasks will happen before the first commit.
     if (m_layerTreeHost)
         static_cast<MockLayerTreeHost*>(m_layerTreeHost.get())->setTestStarted(true);
 }
 
+void ThreadedTest::setupTree()
+{
+    if (!m_layerTreeHost->rootLayer()) {
+        scoped_refptr<Layer> rootLayer = Layer::create();
+        rootLayer->setBounds(gfx::Size(1, 1));
+        m_layerTreeHost->setRootLayer(rootLayer);
+    }
+
+    gfx::Size rootBounds = m_layerTreeHost->rootLayer()->bounds();
+    gfx::Size deviceRootBounds = gfx::ToCeiledSize(
+        gfx::ScaleSize(rootBounds, m_layerTreeHost->deviceScaleFactor()));
+    m_layerTreeHost->setViewportSize(rootBounds, deviceRootBounds);
+}
+
 void ThreadedTest::timeout()
 {
     m_timedOut = true;
@@ -374,27 +345,19 @@
     if (!m_started || m_scheduled)
         return;
     m_scheduled = true;
-    m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::dispatchComposite, base::Unretained(this)));
+    proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::dispatchComposite, m_mainThreadWeakPtr));
 }
 
 void ThreadedTest::realEndTest()
 {
-    if (m_layerTreeHost && m_layerTreeHost->proxy()->commitPendingForTesting()) {
-        m_mainThreadProxy->postTask(FROM_HERE, base::Bind(&ThreadedTest::realEndTest, base::Unretained(this)));
+    if (m_layerTreeHost && proxy()->commitPendingForTesting()) {
+        proxy()->mainThread()->postTask(base::Bind(&ThreadedTest::realEndTest, m_mainThreadWeakPtr));
         return;
     }
         
     MessageLoop::current()->Quit();
 }
 
-void ThreadedTest::dispatchSetNeedsAnimate()
-{
-    DCHECK(!proxy() || proxy()->isMainThread());
-
-    if (m_layerTreeHost.get())
-        m_layerTreeHost->setNeedsAnimate();
-}
-
 void ThreadedTest::dispatchAddInstantAnimation()
 {
     DCHECK(!proxy() || proxy()->isMainThread());
@@ -450,14 +413,6 @@
         m_layerTreeHost->composite();
 }
 
-void ThreadedTest::dispatchDidAddAnimation()
-{
-    DCHECK(!proxy() || proxy()->isMainThread());
-
-    if (m_layerTreeHost.get())
-        m_layerTreeHost->didAddAnimation();
-}
-
 void ThreadedTest::runTest(bool threaded)
 {
     if (threaded) {
@@ -466,7 +421,6 @@
     }
 
     m_mainCCThread = cc::ThreadImpl::createForCurrentThread();
-    m_mainThreadProxy = ScopedThreadProxy::create(m_mainCCThread.get());
 
     initializeSettings(m_settings);
 
Index: src/cc/test/layer_tree_test_common.h
===================================================================
--- src/cc/test/layer_tree_test_common.h	(revision 184497)
+++ src/cc/test/layer_tree_test_common.h	(working copy)
@@ -5,32 +5,29 @@
 #ifndef CC_TEST_LAYER_TREE_TEST_COMMON_H_
 #define CC_TEST_LAYER_TREE_TEST_COMMON_H_
 
-#include "base/hash_tables.h"
 #include "base/memory/ref_counted.h"
 #include "base/threading/thread.h"
 #include "cc/layer_tree_host.h"
 #include "cc/layer_tree_host_impl.h"
-#include "cc/scoped_thread_proxy.h"
-#include "cc/test/compositor_fake_web_graphics_context_3d.h"
+#include "cc/thread.h"
 #include "testing/gtest/include/gtest/gtest.h"
-#include <public/WebAnimationDelegate.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebAnimationDelegate.h"
 
 namespace cc {
 class LayerImpl;
 class LayerTreeHost;
 class LayerTreeHostClient;
 class LayerTreeHostImpl;
-class Thread;
 
-
 // Used by test stubs to notify the test when something interesting happens.
 class TestHooks : public WebKit::WebAnimationDelegate {
 public:
     virtual void beginCommitOnThread(LayerTreeHostImpl*) { }
     virtual void commitCompleteOnThread(LayerTreeHostImpl*) { }
-    virtual bool prepareToDrawOnThread(LayerTreeHostImpl*);
+    virtual bool prepareToDrawOnThread(
+        LayerTreeHostImpl*, LayerTreeHostImpl::FrameData&, bool result);
     virtual void drawLayersOnThread(LayerTreeHostImpl*) { }
-    virtual void animateLayers(LayerTreeHostImpl*, base::TimeTicks monotonicTime) { }
+    virtual void animateLayers(LayerTreeHostImpl*, base::TimeTicks monotonicTime, bool hasUnfinishedAnimation) { }
     virtual void willAnimateLayers(LayerTreeHostImpl*, base::TimeTicks monotonicTime) { }
     virtual void applyScrollAndScale(gfx::Vector2d, float) { }
     virtual void animate(base::TimeTicks monotonicTime) { }
@@ -41,6 +38,7 @@
     virtual void didCommitAndDrawFrame() { }
     virtual void scheduleComposite() { }
     virtual void didDeferCommit() { }
+    virtual bool canActivatePendingTree();
 
     // Implementation of WebAnimationDelegate
     virtual void notifyAnimationStarted(double time) OVERRIDE { }
@@ -71,18 +69,17 @@
 
     virtual void afterTest() = 0;
     virtual void beginTest() = 0;
+    virtual void setupTree();
 
     void endTest();
     void endTestAfterDelay(int delayMilliseconds);
 
-    void postSetNeedsAnimateToMainThread();
     void postAddAnimationToMainThread(Layer*);
     void postAddInstantAnimationToMainThread();
     void postSetNeedsCommitToMainThread();
     void postAcquireLayerTextures();
     void postSetNeedsRedrawToMainThread();
     void postSetVisibleToMainThread(bool visible);
-    void postDidAddAnimationToMainThread();
 
     void doBeginTest();
     void timeout();
@@ -98,7 +95,6 @@
 
     void realEndTest();
 
-    void dispatchSetNeedsAnimate();
     void dispatchAddInstantAnimation();
     void dispatchAddAnimation(Layer*);
     void dispatchSetNeedsCommit();
@@ -117,9 +113,6 @@
     scoped_ptr<MockLayerImplTreeHostClient> m_client;
     scoped_ptr<LayerTreeHost> m_layerTreeHost;
 
-protected:
-    scoped_refptr<ScopedThreadProxy> m_mainThreadProxy;
-
 private:
     bool m_beginning;
     bool m_endWhenBeginReturns;
@@ -130,6 +123,8 @@
     scoped_ptr<Thread> m_mainCCThread;
     scoped_ptr<base::Thread> m_implThread;
     base::CancelableClosure m_timeout;
+    base::WeakPtr<ThreadedTest> m_mainThreadWeakPtr;
+    base::WeakPtrFactory<ThreadedTest> m_weakFactory;
 };
 
 class ThreadedTestThreadOnly : public ThreadedTest {
@@ -149,10 +144,10 @@
     virtual void commitComplete() OVERRIDE;
     virtual bool prepareToDraw(FrameData&) OVERRIDE;
     virtual void drawLayers(FrameData&) OVERRIDE;
+    virtual void activatePendingTreeIfNeeded() OVERRIDE;
 
     // Make these public.
     typedef std::vector<LayerImpl*> LayerList;
-    using LayerTreeHostImpl::calculateRenderSurfaceLayerList;
 
 protected:
     virtual void animateLayers(base::TimeTicks monotonicTime, base::Time wallClockTime) OVERRIDE;
@@ -164,42 +159,22 @@
     TestHooks* m_testHooks;
 };
 
-class CompositorFakeWebGraphicsContext3DWithTextureTracking : public CompositorFakeWebGraphicsContext3D {
-public:
-    static scoped_ptr<CompositorFakeWebGraphicsContext3DWithTextureTracking> create(Attributes);
-    virtual ~CompositorFakeWebGraphicsContext3DWithTextureTracking();
+} // namespace cc
 
-    virtual WebKit::WebGLId createTexture();
+#define SINGLE_THREAD_TEST_F(TEST_FIXTURE_NAME) \
+    TEST_F(TEST_FIXTURE_NAME, runSingleThread) \
+    { \
+        runTest(false); \
+    }
 
-    virtual void deleteTexture(WebKit::WebGLId texture);
+#define MULTI_THREAD_TEST_F(TEST_FIXTURE_NAME) \
+    TEST_F(TEST_FIXTURE_NAME, runMultiThread) \
+    { \
+        runTest(true); \
+    }
 
-    virtual void bindTexture(WebKit::WGC3Denum target, WebKit::WebGLId texture);
-
-    int numTextures() const;
-    int texture(int texture) const;
-    void resetTextures();
-
-    int numUsedTextures() const;
-    bool usedTexture(int texture) const;
-    void resetUsedTextures();
-
-private:
-    explicit CompositorFakeWebGraphicsContext3DWithTextureTracking(Attributes attrs);
-
-    std::vector<WebKit::WebGLId> m_textures;
-    base::hash_set<WebKit::WebGLId> m_usedTextures;
-};
-
-} // namespace cc
-
 #define SINGLE_AND_MULTI_THREAD_TEST_F(TEST_FIXTURE_NAME) \
-    TEST_F(TEST_FIXTURE_NAME, runSingleThread)            \
-    {                                                     \
-        runTest(false);                                   \
-    }                                                     \
-    TEST_F(TEST_FIXTURE_NAME, runMultiThread)             \
-    {                                                     \
-        runTest(true);                                    \
-    }
+    SINGLE_THREAD_TEST_F(TEST_FIXTURE_NAME) \
+    MULTI_THREAD_TEST_F(TEST_FIXTURE_NAME)
 
 #endif  // CC_TEST_LAYER_TREE_TEST_COMMON_H_
Index: src/cc/test/fake_web_scrollbar_theme_geometry.h
===================================================================
--- src/cc/test/fake_web_scrollbar_theme_geometry.h	(revision 184497)
+++ src/cc/test/fake_web_scrollbar_theme_geometry.h	(working copy)
@@ -6,13 +6,13 @@
 #define CC_TEST_FAKE_WEB_SCROLLBAR_THEME_GEOMETRY_H_
 
 #include "base/memory/scoped_ptr.h"
-#include <public/WebScrollbarThemeGeometry.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbarThemeGeometry.h"
 
 namespace cc {
 
 class FakeWebScrollbarThemeGeometry : public WebKit::WebScrollbarThemeGeometry {
 public:
-    static scoped_ptr<WebKit::WebScrollbarThemeGeometry> create() { return scoped_ptr<WebKit::WebScrollbarThemeGeometry>(new FakeWebScrollbarThemeGeometry()); }
+    static scoped_ptr<WebKit::WebScrollbarThemeGeometry> create(bool hasThumb) { return scoped_ptr<WebKit::WebScrollbarThemeGeometry>(new FakeWebScrollbarThemeGeometry(hasThumb)); }
 
     virtual WebKit::WebScrollbarThemeGeometry* clone() const OVERRIDE;
 
@@ -32,6 +32,10 @@
     virtual WebKit::WebRect forwardButtonEndRect(WebKit::WebScrollbar*) OVERRIDE;
     virtual WebKit::WebRect constrainTrackRectToTrackPieces(WebKit::WebScrollbar*, const WebKit::WebRect&) OVERRIDE;
     virtual void splitTrack(WebKit::WebScrollbar*, const WebKit::WebRect& track, WebKit::WebRect& startTrack, WebKit::WebRect& thumb, WebKit::WebRect& endTrack) OVERRIDE;
+
+protected:
+    FakeWebScrollbarThemeGeometry(bool hasThumb) : m_hasThumb(hasThumb) { }
+    bool m_hasThumb;
 };
 
 }  // namespace cc
Index: src/cc/test/fake_proxy.cc
===================================================================
--- src/cc/test/fake_proxy.cc	(revision 184497)
+++ src/cc/test/fake_proxy.cc	(working copy)
@@ -61,4 +61,9 @@
     return false;
 }
 
+skia::RefPtr<SkPicture> FakeProxy::capturePicture()
+{
+    return skia::RefPtr<SkPicture>();
+}
+
 }  // namespace cc
Index: src/cc/test/pixel_test_output_surface.h
===================================================================
--- src/cc/test/pixel_test_output_surface.h	(revision 184497)
+++ src/cc/test/pixel_test_output_surface.h	(working copy)
@@ -24,7 +24,7 @@
       OVERRIDE;
   virtual WebKit::WebGraphicsContext3D* Context3D() const OVERRIDE;
   virtual SoftwareOutputDevice* SoftwareDevice() const OVERRIDE;
-  virtual void SendFrameToParentCompositor(const CompositorFrame&) OVERRIDE {}
+  virtual void SendFrameToParentCompositor(CompositorFrame*) OVERRIDE {}
 
  private:
   PixelTestOutputSurface();
Index: src/cc/test/geometry_test_utils.cc
===================================================================
--- src/cc/test/geometry_test_utils.cc	(revision 184497)
+++ src/cc/test/geometry_test_utils.cc	(working copy)
@@ -4,8 +4,6 @@
 
 #include "cc/test/geometry_test_utils.h"
 
-#include <public/WebTransformationMatrix.h>
-
 #include "base/logging.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/transform.h"
@@ -16,27 +14,6 @@
 // for equality within single-precision error bounds because many transforms
 // originate from single-precision data types such as quads/rects/etc.
 
-void ExpectTransformationMatrixEq(const WebKit::WebTransformationMatrix& expected,
-                                  const WebKit::WebTransformationMatrix& actual)
-{
-    EXPECT_FLOAT_EQ((expected).m11(), (actual).m11());
-    EXPECT_FLOAT_EQ((expected).m12(), (actual).m12());
-    EXPECT_FLOAT_EQ((expected).m13(), (actual).m13());
-    EXPECT_FLOAT_EQ((expected).m14(), (actual).m14());
-    EXPECT_FLOAT_EQ((expected).m21(), (actual).m21());
-    EXPECT_FLOAT_EQ((expected).m22(), (actual).m22());
-    EXPECT_FLOAT_EQ((expected).m23(), (actual).m23());
-    EXPECT_FLOAT_EQ((expected).m24(), (actual).m24());
-    EXPECT_FLOAT_EQ((expected).m31(), (actual).m31());
-    EXPECT_FLOAT_EQ((expected).m32(), (actual).m32());
-    EXPECT_FLOAT_EQ((expected).m33(), (actual).m33());
-    EXPECT_FLOAT_EQ((expected).m34(), (actual).m34());
-    EXPECT_FLOAT_EQ((expected).m41(), (actual).m41());
-    EXPECT_FLOAT_EQ((expected).m42(), (actual).m42());
-    EXPECT_FLOAT_EQ((expected).m43(), (actual).m43());
-    EXPECT_FLOAT_EQ((expected).m44(), (actual).m44());
-}
-
 void ExpectTransformationMatrixEq(const gfx::Transform& expected,
                                   const gfx::Transform& actual)
 {
Index: src/cc/test/geometry_test_utils.h
===================================================================
--- src/cc/test/geometry_test_utils.h	(revision 184497)
+++ src/cc/test/geometry_test_utils.h	(working copy)
@@ -9,10 +9,6 @@
 class Transform;
 }
 
-namespace WebKit {
-class WebTransformationMatrix;
-}
-
 namespace cc {
 
 // These are macros instead of functions so that we get useful line numbers where a test failed.
@@ -44,6 +40,13 @@
     EXPECT_EQ((expected).y(), (actual).y()); \
 } while (false)
 
+#define EXPECT_POINT3F_EQ(expected, actual) \
+do { \
+    EXPECT_FLOAT_EQ((expected).x(), (actual).x()); \
+    EXPECT_FLOAT_EQ((expected).y(), (actual).y()); \
+    EXPECT_FLOAT_EQ((expected).z(), (actual).z()); \
+} while (false)
+
 #define EXPECT_VECTOR_EQ(expected, actual) \
 do { \
     EXPECT_EQ((expected).x(), (actual).x()); \
@@ -64,9 +67,6 @@
 void ExpectTransformationMatrixEq(const gfx::Transform& expected,
                                   const gfx::Transform& actual);
 
-void ExpectTransformationMatrixEq(const WebKit::WebTransformationMatrix& expected,
-                                  const WebKit::WebTransformationMatrix& actual);
-
 #define EXPECT_TRANSFORMATION_MATRIX_EQ(expected, actual)            \
     {                                                                \
         SCOPED_TRACE("");                                            \
Index: src/cc/test/render_pass_test_common.cc
===================================================================
--- src/cc/test/render_pass_test_common.cc	(revision 184497)
+++ src/cc/test/render_pass_test_common.cc	(working copy)
@@ -19,17 +19,63 @@
 
 namespace cc {
 
-void TestRenderPass::AppendOneOfEveryQuadType(cc::ResourceProvider* resourceProvider) {
+void TestRenderPass::AppendQuad(scoped_ptr<cc::DrawQuad> quad) {
+  quad_list.push_back(quad.Pass());
+}
+
+void TestRenderPass::AppendSharedQuadState(
+    scoped_ptr<cc::SharedQuadState> state) {
+  shared_quad_state_list.push_back(state.Pass());
+}
+
+void TestRenderPass::AppendOneOfEveryQuadType(
+    cc::ResourceProvider* resourceProvider, RenderPass::Id child_pass) {
   gfx::Rect rect(0, 0, 100, 100);
   gfx::Rect opaque_rect(10, 10, 80, 80);
   const float vertex_opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
   cc::ResourceProvider::ResourceId texture_resource =
-      resourceProvider->createResourceFromExternalTexture(1);
+      resourceProvider->createResource(
+          gfx::Size(20, 12),
+          resourceProvider->bestTextureFormat(),
+          ResourceProvider::TextureUsageAny);
+  resourceProvider->allocateForTesting(texture_resource);
+  unsigned texture_id = ResourceProvider::ScopedReadLockGL(
+      resourceProvider, texture_resource).textureId();
+  cc::ResourceProvider::ResourceId resource1 =
+      resourceProvider->createResource(
+          gfx::Size(45, 5),
+          resourceProvider->bestTextureFormat(),
+          ResourceProvider::TextureUsageAny);
+  resourceProvider->allocateForTesting(resource1);
+  cc::ResourceProvider::ResourceId resource2 =
+      resourceProvider->createResource(
+          gfx::Size(346, 61),
+          resourceProvider->bestTextureFormat(),
+          ResourceProvider::TextureUsageAny);
+  resourceProvider->allocateForTesting(resource2);
+  cc::ResourceProvider::ResourceId resource3 =
+      resourceProvider->createResource(
+          gfx::Size(12, 134),
+          resourceProvider->bestTextureFormat(),
+          ResourceProvider::TextureUsageAny);
+  resourceProvider->allocateForTesting(resource3);
+  cc::ResourceProvider::ResourceId resource4 =
+      resourceProvider->createResource(
+          gfx::Size(56, 12),
+          resourceProvider->bestTextureFormat(),
+          ResourceProvider::TextureUsageAny);
+  resourceProvider->allocateForTesting(resource4);
+  cc::ResourceProvider::ResourceId resource5 =
+      resourceProvider->createResource(
+          gfx::Size(73, 26),
+          resourceProvider->bestTextureFormat(),
+          ResourceProvider::TextureUsageAny);
+  resourceProvider->allocateForTesting(resource5);
+
   scoped_ptr<cc::SharedQuadState> shared_state = cc::SharedQuadState::Create();
   shared_state->SetAll(gfx::Transform(),
                        rect,
                        rect,
-                       rect,
                        false,
                        1);
 
@@ -54,21 +100,40 @@
                           rect,
                           opaque_rect,
                           gfx::Size(50, 50),
-                          1,
+                          texture_id,
                           cc::IOSurfaceDrawQuad::FLIPPED);
   AppendQuad(io_surface_quad.PassAs<DrawQuad>());
 
-  scoped_ptr<cc::RenderPassDrawQuad> render_pass_quad =
-      cc::RenderPassDrawQuad::Create();
-  render_pass_quad->SetNew(shared_state.get(),
-                           rect,
-                           cc::RenderPass::Id(1, 1),
-                           false,
-                           0,
-                           rect,
-                           gfx::RectF());
-  AppendQuad(render_pass_quad.PassAs<DrawQuad>());
+  if (child_pass.layer_id) {
+    scoped_ptr<cc::RenderPassDrawQuad> render_pass_quad =
+        cc::RenderPassDrawQuad::Create();
+    render_pass_quad->SetNew(shared_state.get(),
+                             rect,
+                             child_pass,
+                             false,
+                             resource5,
+                             rect,
+                             gfx::RectF(),
+                             WebKit::WebFilterOperations(),
+                             skia::RefPtr<SkImageFilter>(),
+                             WebKit::WebFilterOperations());
+    AppendQuad(render_pass_quad.PassAs<DrawQuad>());
 
+    scoped_ptr<cc::RenderPassDrawQuad> render_pass_replica_quad =
+        cc::RenderPassDrawQuad::Create();
+    render_pass_replica_quad->SetNew(shared_state.get(),
+                                     rect,
+                                     child_pass,
+                                     true,
+                                     resource5,
+                                     rect,
+                                     gfx::RectF(),
+                                     WebKit::WebFilterOperations(),
+                                     skia::RefPtr<SkImageFilter>(),
+                                     WebKit::WebFilterOperations());
+    AppendQuad(render_pass_replica_quad.PassAs<DrawQuad>());
+  }
+
   scoped_ptr<cc::SolidColorDrawQuad> solid_color_quad =
       cc::SolidColorDrawQuad::Create();
   solid_color_quad->SetNew(shared_state.get(),
@@ -81,7 +146,7 @@
   stream_video_quad->SetNew(shared_state.get(),
                             rect,
                             opaque_rect,
-                            1,
+                            texture_id,
                             gfx::Transform());
   AppendQuad(stream_video_quad.PassAs<DrawQuad>());
 
@@ -90,9 +155,10 @@
   texture_quad->SetNew(shared_state.get(),
                        rect,
                        opaque_rect,
-                       texture_resource,
+                       resource1,
                        false,
-                       rect,
+                       gfx::PointF(0.f, 0.f),
+                       gfx::PointF(1.f, 1.f),
                        vertex_opacity,
                        false);
   AppendQuad(texture_quad.PassAs<DrawQuad>());
@@ -100,16 +166,16 @@
   scoped_ptr<cc::TileDrawQuad> scaled_tile_quad =
       cc::TileDrawQuad::Create();
   scaled_tile_quad->SetNew(shared_state.get(),
-                    rect,
-                    opaque_rect,
-                    texture_resource,
-                    gfx::RectF(0, 0, 50, 50),
-                    gfx::Size(50, 50),
-                    false,
-                    false,
-                    false,
-                    false,
-                    false);
+                           rect,
+                           opaque_rect,
+                           resource2,
+                           gfx::RectF(0, 0, 50, 50),
+                           gfx::Size(50, 50),
+                           false,
+                           false,
+                           false,
+                           false,
+                           false);
   AppendQuad(scaled_tile_quad.PassAs<DrawQuad>());
 
   scoped_ptr<cc::SharedQuadState> transformed_state = shared_state->Copy();
@@ -119,16 +185,16 @@
   scoped_ptr<cc::TileDrawQuad> transformed_tile_quad =
       cc::TileDrawQuad::Create();
   transformed_tile_quad->SetNew(transformed_state.get(),
-                    rect,
-                    opaque_rect,
-                    texture_resource,
-                    gfx::RectF(0, 0, 100, 100),
-                    gfx::Size(100, 100),
-                    false,
-                    false,
-                    false,
-                    false,
-                    false);
+                                rect,
+                                opaque_rect,
+                                resource3,
+                                gfx::RectF(0, 0, 100, 100),
+                                gfx::Size(100, 100),
+                                false,
+                                false,
+                                false,
+                                false,
+                                false);
   AppendQuad(transformed_tile_quad.PassAs<DrawQuad>());
 
   scoped_ptr<cc::TileDrawQuad> tile_quad =
@@ -136,7 +202,7 @@
   tile_quad->SetNew(shared_state.get(),
                     rect,
                     opaque_rect,
-                    texture_resource,
+                    resource4,
                     gfx::RectF(0, 0, 100, 100),
                     gfx::Size(100, 100),
                     false,
@@ -149,7 +215,11 @@
   cc::VideoLayerImpl::FramePlane planes[3];
   for (int i = 0; i < 3; ++i) {
     planes[i].resourceId =
-        resourceProvider->createResourceFromExternalTexture(1);
+        resourceProvider->createResource(
+            gfx::Size(20, 12),
+            resourceProvider->bestTextureFormat(),
+            ResourceProvider::TextureUsageAny);
+    resourceProvider->allocateForTesting(planes[i].resourceId);
     planes[i].size = gfx::Size(100, 100);
     planes[i].format = GL_LUMINANCE;
   }
Index: src/cc/test/render_pass_test_common.h
===================================================================
--- src/cc/test/render_pass_test_common.h	(revision 184497)
+++ src/cc/test/render_pass_test_common.h	(working copy)
@@ -19,14 +19,11 @@
     return make_scoped_ptr(new TestRenderPass);
   }
 
-  void AppendQuad(scoped_ptr<cc::DrawQuad> quad) {
-    quad_list.append(quad.Pass());
-  }
-  void AppendSharedQuadState(scoped_ptr<cc::SharedQuadState> state) {
-    shared_quad_state_list.append(state.Pass());
-  }
+  void AppendQuad(scoped_ptr<cc::DrawQuad> quad);
+  void AppendSharedQuadState(scoped_ptr<cc::SharedQuadState> state);
 
-  void AppendOneOfEveryQuadType(cc::ResourceProvider*);
+  void AppendOneOfEveryQuadType(
+      cc::ResourceProvider*, RenderPass::Id child_pass);
 
  protected:
   TestRenderPass() : RenderPass() {}
Index: src/cc/test/fake_web_graphics_context_3d.h
===================================================================
--- src/cc/test/fake_web_graphics_context_3d.h	(revision 184497)
+++ src/cc/test/fake_web_graphics_context_3d.h	(working copy)
@@ -5,240 +5,642 @@
 #ifndef CC_TEST_FAKE_WEB_GRAPHICS_CONTEXT_3D_H_
 #define CC_TEST_FAKE_WEB_GRAPHICS_CONTEXT_3D_H_
 
+#include <vector>
+
+#include "base/hash_tables.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/stl_util.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
-#include <public/WebGraphicsContext3D.h>
 
 namespace cc {
 
 // WebGraphicsContext3D base class for use in WebKit unit tests.
 // All operations are no-ops (returning 0 if necessary).
 class FakeWebGraphicsContext3D : public WebKit::WebGraphicsContext3D {
-public:
-    FakeWebGraphicsContext3D()
-        : m_nextTextureId(1)
-    {
-    }
+ public:
+  static scoped_ptr<FakeWebGraphicsContext3D> Create() {
+    return make_scoped_ptr(new FakeWebGraphicsContext3D());
+  }
+  static scoped_ptr<FakeWebGraphicsContext3D> Create(
+      const WebKit::WebGraphicsContext3D::Attributes& attributes) {
+    return make_scoped_ptr(new FakeWebGraphicsContext3D(attributes));
+  }
+  virtual ~FakeWebGraphicsContext3D();
 
-    virtual bool makeContextCurrent();
+  virtual bool makeContextCurrent();
 
-    virtual int width();
-    virtual int height();
+  virtual int width();
+  virtual int height();
 
-    virtual void reshape(int width, int height) { }
+  virtual void reshape(int width, int height);
 
-    virtual bool isGLES2Compliant();
+  virtual bool isGLES2Compliant();
 
-    virtual bool readBackFramebuffer(unsigned char* pixels, size_t bufferSize, WebKit::WebGLId framebuffer, int width, int height);
+  virtual bool readBackFramebuffer(
+      unsigned char* pixels,
+      size_t buffer_size,
+      WebKit::WebGLId framebuffer,
+      int width,
+      int height);
 
-    virtual WebKit::WebGLId getPlatformTextureId();
+  virtual WebKit::WebGLId getPlatformTextureId();
 
-    virtual void prepareTexture() { }
+  virtual void prepareTexture() {}
 
-    virtual void postSubBufferCHROMIUM(int x, int y, int width, int height) { }
+  virtual void postSubBufferCHROMIUM(int x, int y, int width, int height) {}
 
-    virtual void synthesizeGLError(WebKit::WGC3Denum) { }
+  virtual void synthesizeGLError(WebKit::WGC3Denum) {}
 
-    virtual bool isContextLost();
+  virtual bool isContextLost();
+  virtual WebKit::WGC3Denum getGraphicsResetStatusARB();
 
-    virtual void* mapBufferSubDataCHROMIUM(WebKit::WGC3Denum target, WebKit::WGC3Dintptr offset, WebKit::WGC3Dsizeiptr size, WebKit::WGC3Denum access);
+  virtual void* mapBufferSubDataCHROMIUM(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dintptr offset,
+      WebKit::WGC3Dsizeiptr size,
+      WebKit::WGC3Denum access);
 
-    virtual void unmapBufferSubDataCHROMIUM(const void*) { }
-    virtual void* mapTexSubImage2DCHROMIUM(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Dint xoffset, WebKit::WGC3Dint yoffset, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Denum format, WebKit::WGC3Denum type, WebKit::WGC3Denum access);
-    virtual void unmapTexSubImage2DCHROMIUM(const void*) { }
+  virtual void unmapBufferSubDataCHROMIUM(const void*) {}
+  virtual void* mapTexSubImage2DCHROMIUM(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Dint xoffset,
+      WebKit::WGC3Dint yoffset,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Denum format,
+      WebKit::WGC3Denum type,
+      WebKit::WGC3Denum access);
+  virtual void unmapTexSubImage2DCHROMIUM(const void*) {}
 
-    virtual void setVisibilityCHROMIUM(bool visible) { }
+  virtual void setVisibilityCHROMIUM(bool visible) {}
 
-    virtual void discardFramebufferEXT(WebKit::WGC3Denum target, WebKit::WGC3Dsizei numAttachments, const WebKit::WGC3Denum* attachments) { }
-    virtual void ensureFramebufferCHROMIUM() { }
+  virtual void discardFramebufferEXT(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dsizei num_attachments,
+      const WebKit::WGC3Denum* attachments) {}
+  virtual void ensureFramebufferCHROMIUM() {}
 
-    virtual void setMemoryAllocationChangedCallbackCHROMIUM(WebGraphicsMemoryAllocationChangedCallbackCHROMIUM* callback) { }
+  virtual void setMemoryAllocationChangedCallbackCHROMIUM(
+      WebGraphicsMemoryAllocationChangedCallbackCHROMIUM* callback) {}
 
-    virtual WebKit::WebString getRequestableExtensionsCHROMIUM();
-    virtual void requestExtensionCHROMIUM(const char*) { }
+  virtual WebKit::WebString getRequestableExtensionsCHROMIUM();
+  virtual void requestExtensionCHROMIUM(const char*) {}
 
-    virtual void blitFramebufferCHROMIUM(WebKit::WGC3Dint srcX0, WebKit::WGC3Dint srcY0, WebKit::WGC3Dint srcX1, WebKit::WGC3Dint srcY1, WebKit::WGC3Dint dstX0, WebKit::WGC3Dint dstY0, WebKit::WGC3Dint dstX1, WebKit::WGC3Dint dstY1, WebKit::WGC3Dbitfield mask, WebKit::WGC3Denum filter) { }
-    virtual void renderbufferStorageMultisampleCHROMIUM(WebKit::WGC3Denum target, WebKit::WGC3Dsizei samples, WebKit::WGC3Denum internalformat, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height) { }
+  virtual void blitFramebufferCHROMIUM(
+      WebKit::WGC3Dint srcX0, WebKit::WGC3Dint srcY0,
+      WebKit::WGC3Dint srcX1, WebKit::WGC3Dint srcY1,
+      WebKit::WGC3Dint dstX0, WebKit::WGC3Dint dstY0,
+      WebKit::WGC3Dint dstX1, WebKit::WGC3Dint dstY1,
+      WebKit::WGC3Dbitfield mask,
+      WebKit::WGC3Denum filter) {}
+  virtual void renderbufferStorageMultisampleCHROMIUM(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dsizei samples,
+      WebKit::WGC3Denum internalformat,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height) {}
 
-    virtual void activeTexture(WebKit::WGC3Denum texture) { }
-    virtual void attachShader(WebKit::WebGLId program, WebKit::WebGLId shader) { }
-    virtual void bindAttribLocation(WebKit::WebGLId program, WebKit::WGC3Duint index, const WebKit::WGC3Dchar* name) { }
-    virtual void bindBuffer(WebKit::WGC3Denum target, WebKit::WebGLId buffer) { }
-    virtual void bindFramebuffer(WebKit::WGC3Denum target, WebKit::WebGLId framebuffer) { }
-    virtual void bindRenderbuffer(WebKit::WGC3Denum target, WebKit::WebGLId renderbuffer) { }
-    virtual void bindTexture(WebKit::WGC3Denum target, WebKit::WebGLId texture) { }
-    virtual void blendColor(WebKit::WGC3Dclampf red, WebKit::WGC3Dclampf green, WebKit::WGC3Dclampf blue, WebKit::WGC3Dclampf alpha) { }
-    virtual void blendEquation(WebKit::WGC3Denum mode) { }
-    virtual void blendEquationSeparate(WebKit::WGC3Denum modeRGB, WebKit::WGC3Denum modeAlpha) { }
-    virtual void blendFunc(WebKit::WGC3Denum sfactor, WebKit::WGC3Denum dfactor) { }
-    virtual void blendFuncSeparate(WebKit::WGC3Denum srcRGB, WebKit::WGC3Denum dstRGB, WebKit::WGC3Denum srcAlpha, WebKit::WGC3Denum dstAlpha) { }
+  virtual void activeTexture(WebKit::WGC3Denum texture) {}
+  virtual void attachShader(WebKit::WebGLId program, WebKit::WebGLId shader);
+  virtual void bindAttribLocation(
+      WebKit::WebGLId program,
+      WebKit::WGC3Duint index,
+      const WebKit::WGC3Dchar* name) {}
+  virtual void bindBuffer(WebKit::WGC3Denum target, WebKit::WebGLId buffer);
+  virtual void bindFramebuffer(
+      WebKit::WGC3Denum target, WebKit::WebGLId framebuffer);
+  virtual void bindRenderbuffer(
+      WebKit::WGC3Denum target, WebKit::WebGLId renderbuffer);
+  virtual void bindTexture(
+      WebKit::WGC3Denum target,
+      WebKit::WebGLId texture_id);
+  virtual void blendColor(
+      WebKit::WGC3Dclampf red,
+      WebKit::WGC3Dclampf green,
+      WebKit::WGC3Dclampf blue,
+      WebKit::WGC3Dclampf alpha) {}
+  virtual void blendEquation(WebKit::WGC3Denum mode) {}
+  virtual void blendEquationSeparate(
+      WebKit::WGC3Denum mode_rgb,
+      WebKit::WGC3Denum mode_alpha) {}
+  virtual void blendFunc(
+      WebKit::WGC3Denum sfactor,
+      WebKit::WGC3Denum dfactor) {}
+  virtual void blendFuncSeparate(
+      WebKit::WGC3Denum src_rgb,
+      WebKit::WGC3Denum dst_rgb,
+      WebKit::WGC3Denum src_alpha,
+      WebKit::WGC3Denum dst_alpha) {}
 
-    virtual void bufferData(WebKit::WGC3Denum target, WebKit::WGC3Dsizeiptr size, const void* data, WebKit::WGC3Denum usage) { }
-    virtual void bufferSubData(WebKit::WGC3Denum target, WebKit::WGC3Dintptr offset, WebKit::WGC3Dsizeiptr size, const void* data) { }
+  virtual void bufferData(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dsizeiptr size,
+      const void* data,
+      WebKit::WGC3Denum usage) {}
+  virtual void bufferSubData(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dintptr offset,
+      WebKit::WGC3Dsizeiptr size,
+      const void* data) {}
 
-    virtual WebKit::WGC3Denum checkFramebufferStatus(WebKit::WGC3Denum target);
+  virtual WebKit::WGC3Denum checkFramebufferStatus(WebKit::WGC3Denum target);
 
-    virtual void clear(WebKit::WGC3Dbitfield mask) { }
-    virtual void clearColor(WebKit::WGC3Dclampf red, WebKit::WGC3Dclampf green, WebKit::WGC3Dclampf blue, WebKit::WGC3Dclampf alpha) { }
-    virtual void clearDepth(WebKit::WGC3Dclampf depth) { }
-    virtual void clearStencil(WebKit::WGC3Dint s) { }
-    virtual void colorMask(WebKit::WGC3Dboolean red, WebKit::WGC3Dboolean green, WebKit::WGC3Dboolean blue, WebKit::WGC3Dboolean alpha) { }
-    virtual void compileShader(WebKit::WebGLId shader) { }
+  virtual void clear(WebKit::WGC3Dbitfield mask) {}
+  virtual void clearColor(
+      WebKit::WGC3Dclampf red,
+      WebKit::WGC3Dclampf green,
+      WebKit::WGC3Dclampf blue,
+      WebKit::WGC3Dclampf alpha) {}
+  virtual void clearDepth(WebKit::WGC3Dclampf depth) {}
+  virtual void clearStencil(WebKit::WGC3Dint s) {}
+  virtual void colorMask(
+      WebKit::WGC3Dboolean red,
+      WebKit::WGC3Dboolean green,
+      WebKit::WGC3Dboolean blue,
+      WebKit::WGC3Dboolean alpha) {}
+  virtual void compileShader(WebKit::WebGLId shader) {}
 
-    virtual void compressedTexImage2D(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Denum internalformat, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Dint border, WebKit::WGC3Dsizei imageSize, const void* data) { }
-    virtual void compressedTexSubImage2D(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Dint xoffset, WebKit::WGC3Dint yoffset, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Denum format, WebKit::WGC3Dsizei imageSize, const void* data) { }
-    virtual void copyTexImage2D(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Denum internalformat, WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Dint border) { }
-    virtual void copyTexSubImage2D(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Dint xoffset, WebKit::WGC3Dint yoffset, WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height) { }
-    virtual void cullFace(WebKit::WGC3Denum mode) { }
-    virtual void depthFunc(WebKit::WGC3Denum func) { }
-    virtual void depthMask(WebKit::WGC3Dboolean flag) { }
-    virtual void depthRange(WebKit::WGC3Dclampf zNear, WebKit::WGC3Dclampf zFar) { }
-    virtual void detachShader(WebKit::WebGLId program, WebKit::WebGLId shader) { }
-    virtual void disable(WebKit::WGC3Denum cap) { }
-    virtual void disableVertexAttribArray(WebKit::WGC3Duint index) { }
-    virtual void drawArrays(WebKit::WGC3Denum mode, WebKit::WGC3Dint first, WebKit::WGC3Dsizei count) { }
-    virtual void drawElements(WebKit::WGC3Denum mode, WebKit::WGC3Dsizei count, WebKit::WGC3Denum type, WebKit::WGC3Dintptr offset) { }
+  virtual void compressedTexImage2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Denum internal_format,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Dint border,
+      WebKit::WGC3Dsizei imageSize,
+      const void* data) {}
+  virtual void compressedTexSubImage2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Dint xoffset,
+      WebKit::WGC3Dint yoffset,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Denum format,
+      WebKit::WGC3Dsizei imageSize,
+      const void* data) {}
+  virtual void copyTexImage2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Denum internalformat,
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Dint border) {}
+  virtual void copyTexSubImage2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Dint xoffset,
+      WebKit::WGC3Dint yoffset,
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height) {}
+  virtual void cullFace(WebKit::WGC3Denum mode) {}
+  virtual void depthFunc(WebKit::WGC3Denum func) {}
+  virtual void depthMask(WebKit::WGC3Dboolean flag) {}
+  virtual void depthRange(
+      WebKit::WGC3Dclampf zNear,
+      WebKit::WGC3Dclampf zFar) {}
+  virtual void detachShader(WebKit::WebGLId program, WebKit::WebGLId shader) {}
+  virtual void disable(WebKit::WGC3Denum cap) {}
+  virtual void disableVertexAttribArray(WebKit::WGC3Duint index) {}
+  virtual void drawArrays(
+      WebKit::WGC3Denum mode,
+      WebKit::WGC3Dint first,
+      WebKit::WGC3Dsizei count) {}
+  virtual void drawElements(
+      WebKit::WGC3Denum mode,
+      WebKit::WGC3Dsizei count,
+      WebKit::WGC3Denum type,
+      WebKit::WGC3Dintptr offset) {}
 
-    virtual void enable(WebKit::WGC3Denum cap) { }
-    virtual void enableVertexAttribArray(WebKit::WGC3Duint index) { }
-    virtual void finish() { }
-    virtual void flush() { }
-    virtual void framebufferRenderbuffer(WebKit::WGC3Denum target, WebKit::WGC3Denum attachment, WebKit::WGC3Denum renderbuffertarget, WebKit::WebGLId renderbuffer) { }
-    virtual void framebufferTexture2D(WebKit::WGC3Denum target, WebKit::WGC3Denum attachment, WebKit::WGC3Denum textarget, WebKit::WebGLId texture, WebKit::WGC3Dint level) { }
-    virtual void frontFace(WebKit::WGC3Denum mode) { }
-    virtual void generateMipmap(WebKit::WGC3Denum target) { }
+  virtual void enable(WebKit::WGC3Denum cap) {}
+  virtual void enableVertexAttribArray(WebKit::WGC3Duint index) {}
+  virtual void finish() {}
+  virtual void flush() {}
+  virtual void framebufferRenderbuffer(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum attachment,
+      WebKit::WGC3Denum renderbuffertarget,
+      WebKit::WebGLId renderbuffer) {}
+  virtual void framebufferTexture2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum attachment,
+      WebKit::WGC3Denum textarget,
+      WebKit::WebGLId texture,
+      WebKit::WGC3Dint level) {}
+  virtual void frontFace(WebKit::WGC3Denum mode) {}
+  virtual void generateMipmap(WebKit::WGC3Denum target) {}
 
-    virtual bool getActiveAttrib(WebKit::WebGLId program, WebKit::WGC3Duint index, ActiveInfo&);
-    virtual bool getActiveUniform(WebKit::WebGLId program, WebKit::WGC3Duint index, ActiveInfo&);
-    virtual void getAttachedShaders(WebKit::WebGLId program, WebKit::WGC3Dsizei maxCount, WebKit::WGC3Dsizei* count, WebKit::WebGLId* shaders) { }
-    virtual WebKit::WGC3Dint getAttribLocation(WebKit::WebGLId program, const WebKit::WGC3Dchar* name);
-    virtual void getBooleanv(WebKit::WGC3Denum pname, WebKit::WGC3Dboolean* value) { }
-    virtual void getBufferParameteriv(WebKit::WGC3Denum target, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value) { }
-    virtual Attributes getContextAttributes();
-    virtual WebKit::WGC3Denum getError();
-    virtual void getFloatv(WebKit::WGC3Denum pname, WebKit::WGC3Dfloat* value) { }
-    virtual void getFramebufferAttachmentParameteriv(WebKit::WGC3Denum target, WebKit::WGC3Denum attachment, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value) { }
+  virtual bool getActiveAttrib(
+      WebKit::WebGLId program,
+      WebKit::WGC3Duint index, ActiveInfo&);
+  virtual bool getActiveUniform(
+      WebKit::WebGLId program,
+      WebKit::WGC3Duint index,
+      ActiveInfo&);
+  virtual void getAttachedShaders(
+      WebKit::WebGLId program,
+      WebKit::WGC3Dsizei maxCount,
+      WebKit::WGC3Dsizei* count,
+      WebKit::WebGLId* shaders) {}
+  virtual WebKit::WGC3Dint getAttribLocation(
+      WebKit::WebGLId program,
+      const WebKit::WGC3Dchar* name);
+  virtual void getBooleanv(
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dboolean* value) {}
+  virtual void getBufferParameteriv(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value) {}
+  virtual Attributes getContextAttributes();
+  virtual WebKit::WGC3Denum getError();
+  virtual void getFloatv(
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dfloat* value) {}
+  virtual void getFramebufferAttachmentParameteriv(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum attachment,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value) {}
 
-    virtual void getIntegerv(WebKit::WGC3Denum pname, WebKit::WGC3Dint* value);
+  virtual void getIntegerv(
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value);
 
-    virtual void getProgramiv(WebKit::WebGLId program, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value);
+  virtual void getProgramiv(
+      WebKit::WebGLId program,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value);
 
-    virtual WebKit::WebString getProgramInfoLog(WebKit::WebGLId program);
-    virtual void getRenderbufferParameteriv(WebKit::WGC3Denum target, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value) { }
+  virtual WebKit::WebString getProgramInfoLog(WebKit::WebGLId program);
+  virtual void getRenderbufferParameteriv(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value) {}
 
-    virtual void getShaderiv(WebKit::WebGLId shader, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value);
+  virtual void getShaderiv(
+      WebKit::WebGLId shader,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value);
 
-    virtual WebKit::WebString getShaderInfoLog(WebKit::WebGLId shader);
-    virtual void getShaderPrecisionFormat(WebKit::WGC3Denum shadertype, WebKit::WGC3Denum precisiontype, WebKit::WGC3Dint* range, WebKit::WGC3Dint* precision) { }
-    virtual WebKit::WebString getShaderSource(WebKit::WebGLId shader);
-    virtual WebKit::WebString getString(WebKit::WGC3Denum name);
-    virtual void getTexParameterfv(WebKit::WGC3Denum target, WebKit::WGC3Denum pname, WebKit::WGC3Dfloat* value) { }
-    virtual void getTexParameteriv(WebKit::WGC3Denum target, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value) { }
-    virtual void getUniformfv(WebKit::WebGLId program, WebKit::WGC3Dint location, WebKit::WGC3Dfloat* value) { }
-    virtual void getUniformiv(WebKit::WebGLId program, WebKit::WGC3Dint location, WebKit::WGC3Dint* value) { }
-    virtual WebKit::WGC3Dint getUniformLocation(WebKit::WebGLId program, const WebKit::WGC3Dchar* name);
-    virtual void getVertexAttribfv(WebKit::WGC3Duint index, WebKit::WGC3Denum pname, WebKit::WGC3Dfloat* value) { }
-    virtual void getVertexAttribiv(WebKit::WGC3Duint index, WebKit::WGC3Denum pname, WebKit::WGC3Dint* value) { }
-    virtual WebKit::WGC3Dsizeiptr getVertexAttribOffset(WebKit::WGC3Duint index, WebKit::WGC3Denum pname);
+  virtual WebKit::WebString getShaderInfoLog(WebKit::WebGLId shader);
+  virtual void getShaderPrecisionFormat(
+      WebKit::WGC3Denum shadertype,
+      WebKit::WGC3Denum precisiontype,
+      WebKit::WGC3Dint* range,
+      WebKit::WGC3Dint* precision) {}
+  virtual WebKit::WebString getShaderSource(WebKit::WebGLId shader);
+  virtual WebKit::WebString getString(WebKit::WGC3Denum name);
+  virtual void getTexParameterfv(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dfloat* value) {}
+  virtual void getTexParameteriv(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value) {}
+  virtual void getUniformfv(
+      WebKit::WebGLId program,
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dfloat* value) {}
+  virtual void getUniformiv(
+      WebKit::WebGLId program,
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dint* value) {}
+  virtual WebKit::WGC3Dint getUniformLocation(
+      WebKit::WebGLId program,
+      const WebKit::WGC3Dchar* name);
+  virtual void getVertexAttribfv(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dfloat* value) {}
+  virtual void getVertexAttribiv(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* value) {}
+  virtual WebKit::WGC3Dsizeiptr getVertexAttribOffset(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Denum pname);
 
-    virtual void hint(WebKit::WGC3Denum target, WebKit::WGC3Denum mode) { }
-    virtual WebKit::WGC3Dboolean isBuffer(WebKit::WebGLId buffer);
-    virtual WebKit::WGC3Dboolean isEnabled(WebKit::WGC3Denum cap);
-    virtual WebKit::WGC3Dboolean isFramebuffer(WebKit::WebGLId framebuffer);
-    virtual WebKit::WGC3Dboolean isProgram(WebKit::WebGLId program);
-    virtual WebKit::WGC3Dboolean isRenderbuffer(WebKit::WebGLId renderbuffer);
-    virtual WebKit::WGC3Dboolean isShader(WebKit::WebGLId shader);
-    virtual WebKit::WGC3Dboolean isTexture(WebKit::WebGLId texture);
-    virtual void lineWidth(WebKit::WGC3Dfloat) { }
-    virtual void linkProgram(WebKit::WebGLId program) { }
-    virtual void pixelStorei(WebKit::WGC3Denum pname, WebKit::WGC3Dint param) { }
-    virtual void polygonOffset(WebKit::WGC3Dfloat factor, WebKit::WGC3Dfloat units) { }
+  virtual void hint(WebKit::WGC3Denum target, WebKit::WGC3Denum mode) {}
+  virtual WebKit::WGC3Dboolean isBuffer(WebKit::WebGLId buffer);
+  virtual WebKit::WGC3Dboolean isEnabled(WebKit::WGC3Denum cap);
+  virtual WebKit::WGC3Dboolean isFramebuffer(WebKit::WebGLId framebuffer);
+  virtual WebKit::WGC3Dboolean isProgram(WebKit::WebGLId program);
+  virtual WebKit::WGC3Dboolean isRenderbuffer(WebKit::WebGLId renderbuffer);
+  virtual WebKit::WGC3Dboolean isShader(WebKit::WebGLId shader);
+  virtual WebKit::WGC3Dboolean isTexture(WebKit::WebGLId texture);
+  virtual void lineWidth(WebKit::WGC3Dfloat) {}
+  virtual void linkProgram(WebKit::WebGLId program) {}
+  virtual void pixelStorei(WebKit::WGC3Denum pname, WebKit::WGC3Dint param) {}
+  virtual void polygonOffset(
+      WebKit::WGC3Dfloat factor,
+      WebKit::WGC3Dfloat units) {}
 
-    virtual void readPixels(WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Denum format, WebKit::WGC3Denum type, void* pixels) { }
+  virtual void readPixels(
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Denum format,
+      WebKit::WGC3Denum type,
+      void* pixels) {}
 
-    virtual void releaseShaderCompiler() { }
+  virtual void releaseShaderCompiler() {}
 
-    virtual void renderbufferStorage(WebKit::WGC3Denum target, WebKit::WGC3Denum internalformat, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height) { }
-    virtual void sampleCoverage(WebKit::WGC3Dclampf value, WebKit::WGC3Dboolean invert) { }
-    virtual void scissor(WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height) { }
-    virtual void shaderSource(WebKit::WebGLId shader, const WebKit::WGC3Dchar* string) { }
-    virtual void stencilFunc(WebKit::WGC3Denum func, WebKit::WGC3Dint ref, WebKit::WGC3Duint mask) { }
-    virtual void stencilFuncSeparate(WebKit::WGC3Denum face, WebKit::WGC3Denum func, WebKit::WGC3Dint ref, WebKit::WGC3Duint mask) { }
-    virtual void stencilMask(WebKit::WGC3Duint mask) { }
-    virtual void stencilMaskSeparate(WebKit::WGC3Denum face, WebKit::WGC3Duint mask) { }
-    virtual void stencilOp(WebKit::WGC3Denum fail, WebKit::WGC3Denum zfail, WebKit::WGC3Denum zpass) { }
-    virtual void stencilOpSeparate(WebKit::WGC3Denum face, WebKit::WGC3Denum fail, WebKit::WGC3Denum zfail, WebKit::WGC3Denum zpass) { }
+  virtual void renderbufferStorage(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum internalformat,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height) {}
+  virtual void sampleCoverage(
+      WebKit::WGC3Dclampf value,
+      WebKit::WGC3Dboolean invert) {}
+  virtual void scissor(
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height) {}
+  virtual void shaderSource(
+      WebKit::WebGLId shader,
+      const WebKit::WGC3Dchar* string) {}
+  virtual void stencilFunc(
+      WebKit::WGC3Denum func,
+      WebKit::WGC3Dint ref,
+      WebKit::WGC3Duint mask) {}
+  virtual void stencilFuncSeparate(
+      WebKit::WGC3Denum face,
+      WebKit::WGC3Denum func,
+      WebKit::WGC3Dint ref,
+      WebKit::WGC3Duint mask) {}
+  virtual void stencilMask(WebKit::WGC3Duint mask) {}
+  virtual void stencilMaskSeparate(
+      WebKit::WGC3Denum face,
+      WebKit::WGC3Duint mask) {}
+  virtual void stencilOp(
+      WebKit::WGC3Denum fail,
+      WebKit::WGC3Denum zfail,
+      WebKit::WGC3Denum zpass) {}
+  virtual void stencilOpSeparate(
+      WebKit::WGC3Denum face,
+      WebKit::WGC3Denum fail,
+      WebKit::WGC3Denum zfail,
+      WebKit::WGC3Denum zpass) {}
 
-    virtual void texImage2D(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Denum internalformat, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Dint border, WebKit::WGC3Denum format, WebKit::WGC3Denum type, const void* pixels) { }
+  virtual void texImage2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Denum internalformat,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Dint border,
+      WebKit::WGC3Denum format,
+      WebKit::WGC3Denum type,
+      const void* pixels) {}
 
-    virtual void texParameterf(WebKit::WGC3Denum target, WebKit::WGC3Denum pname, WebKit::WGC3Dfloat param) { }
-    virtual void texParameteri(WebKit::WGC3Denum target, WebKit::WGC3Denum pname, WebKit::WGC3Dint param) { }
+  virtual void texParameterf(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dfloat param) {}
+  virtual void texParameteri(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint param) {}
 
-    virtual void texSubImage2D(WebKit::WGC3Denum target, WebKit::WGC3Dint level, WebKit::WGC3Dint xoffset, WebKit::WGC3Dint yoffset, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height, WebKit::WGC3Denum format, WebKit::WGC3Denum type, const void* pixels) { }
+  virtual void texSubImage2D(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint level,
+      WebKit::WGC3Dint xoffset,
+      WebKit::WGC3Dint yoffset,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height,
+      WebKit::WGC3Denum format,
+      WebKit::WGC3Denum type,
+      const void* pixels) {}
 
-    virtual void uniform1f(WebKit::WGC3Dint location, WebKit::WGC3Dfloat x) { }
-    virtual void uniform1fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dfloat* v) { }
-    virtual void uniform1i(WebKit::WGC3Dint location, WebKit::WGC3Dint x) { }
-    virtual void uniform1iv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dint* v) { }
-    virtual void uniform2f(WebKit::WGC3Dint location, WebKit::WGC3Dfloat x, WebKit::WGC3Dfloat y) { }
-    virtual void uniform2fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dfloat* v) { }
-    virtual void uniform2i(WebKit::WGC3Dint location, WebKit::WGC3Dint x, WebKit::WGC3Dint y) { }
-    virtual void uniform2iv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dint* v) { }
-    virtual void uniform3f(WebKit::WGC3Dint location, WebKit::WGC3Dfloat x, WebKit::WGC3Dfloat y, WebKit::WGC3Dfloat z) { }
-    virtual void uniform3fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dfloat* v) { }
-    virtual void uniform3i(WebKit::WGC3Dint location, WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dint z) { }
-    virtual void uniform3iv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dint* v) { }
-    virtual void uniform4f(WebKit::WGC3Dint location, WebKit::WGC3Dfloat x, WebKit::WGC3Dfloat y, WebKit::WGC3Dfloat z, WebKit::WGC3Dfloat w) { }
-    virtual void uniform4fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dfloat* v) { }
-    virtual void uniform4i(WebKit::WGC3Dint location, WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dint z, WebKit::WGC3Dint w) { }
-    virtual void uniform4iv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, const WebKit::WGC3Dint* v) { }
-    virtual void uniformMatrix2fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, WebKit::WGC3Dboolean transpose, const WebKit::WGC3Dfloat* value) { }
-    virtual void uniformMatrix3fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, WebKit::WGC3Dboolean transpose, const WebKit::WGC3Dfloat* value) { }
-    virtual void uniformMatrix4fv(WebKit::WGC3Dint location, WebKit::WGC3Dsizei count, WebKit::WGC3Dboolean transpose, const WebKit::WGC3Dfloat* value) { }
+  virtual void uniform1f(WebKit::WGC3Dint location, WebKit::WGC3Dfloat x) {}
+  virtual void uniform1fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dfloat* v) {}
+  virtual void uniform1i(WebKit::WGC3Dint location, WebKit::WGC3Dint x) {}
+  virtual void uniform1iv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dint* v) {}
+  virtual void uniform2f(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dfloat x,
+      WebKit::WGC3Dfloat y) {}
+  virtual void uniform2fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dfloat* v) {}
+  virtual void uniform2i(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y) {}
+  virtual void uniform2iv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dint* v) {}
+  virtual void uniform3f(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dfloat x,
+      WebKit::WGC3Dfloat y,
+      WebKit::WGC3Dfloat z) {}
+  virtual void uniform3fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dfloat* v) {}
+  virtual void uniform3i(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dint z) {}
+  virtual void uniform3iv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dint* v) {}
+  virtual void uniform4f(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dfloat x,
+      WebKit::WGC3Dfloat y,
+      WebKit::WGC3Dfloat z,
+      WebKit::WGC3Dfloat w) {}
+  virtual void uniform4fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dfloat* v) {}
+  virtual void uniform4i(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dint z,
+      WebKit::WGC3Dint w) {}
+  virtual void uniform4iv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      const WebKit::WGC3Dint* v) {}
+  virtual void uniformMatrix2fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      WebKit::WGC3Dboolean transpose,
+      const WebKit::WGC3Dfloat* value) {}
+  virtual void uniformMatrix3fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      WebKit::WGC3Dboolean transpose,
+      const WebKit::WGC3Dfloat* value) {}
+  virtual void uniformMatrix4fv(
+      WebKit::WGC3Dint location,
+      WebKit::WGC3Dsizei count,
+      WebKit::WGC3Dboolean transpose,
+      const WebKit::WGC3Dfloat* value) {}
 
-    virtual void useProgram(WebKit::WebGLId program) { }
-    virtual void validateProgram(WebKit::WebGLId program) { }
+  virtual void useProgram(WebKit::WebGLId program);
+  virtual void validateProgram(WebKit::WebGLId program) {}
 
-    virtual void vertexAttrib1f(WebKit::WGC3Duint index, WebKit::WGC3Dfloat x) { }
-    virtual void vertexAttrib1fv(WebKit::WGC3Duint index, const WebKit::WGC3Dfloat* values) { }
-    virtual void vertexAttrib2f(WebKit::WGC3Duint index, WebKit::WGC3Dfloat x, WebKit::WGC3Dfloat y) { }
-    virtual void vertexAttrib2fv(WebKit::WGC3Duint index, const WebKit::WGC3Dfloat* values) { }
-    virtual void vertexAttrib3f(WebKit::WGC3Duint index, WebKit::WGC3Dfloat x, WebKit::WGC3Dfloat y, WebKit::WGC3Dfloat z) { }
-    virtual void vertexAttrib3fv(WebKit::WGC3Duint index, const WebKit::WGC3Dfloat* values) { }
-    virtual void vertexAttrib4f(WebKit::WGC3Duint index, WebKit::WGC3Dfloat x, WebKit::WGC3Dfloat y, WebKit::WGC3Dfloat z, WebKit::WGC3Dfloat w) { }
-    virtual void vertexAttrib4fv(WebKit::WGC3Duint index, const WebKit::WGC3Dfloat* values) { }
-    virtual void vertexAttribPointer(WebKit::WGC3Duint index, WebKit::WGC3Dint size, WebKit::WGC3Denum type, WebKit::WGC3Dboolean normalized,
-                                     WebKit::WGC3Dsizei stride, WebKit::WGC3Dintptr offset) { }
+  virtual void vertexAttrib1f(WebKit::WGC3Duint index, WebKit::WGC3Dfloat x) {}
+  virtual void vertexAttrib1fv(
+      WebKit::WGC3Duint index,
+      const WebKit::WGC3Dfloat* values) {}
+  virtual void vertexAttrib2f(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Dfloat x,
+      WebKit::WGC3Dfloat y) {}
+  virtual void vertexAttrib2fv(
+      WebKit::WGC3Duint index,
+      const WebKit::WGC3Dfloat* values) {}
+  virtual void vertexAttrib3f(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Dfloat x,
+      WebKit::WGC3Dfloat y,
+      WebKit::WGC3Dfloat z) {}
+  virtual void vertexAttrib3fv(
+      WebKit::WGC3Duint index,
+      const WebKit::WGC3Dfloat* values) {}
+  virtual void vertexAttrib4f(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Dfloat x,
+      WebKit::WGC3Dfloat y,
+      WebKit::WGC3Dfloat z,
+      WebKit::WGC3Dfloat w) {}
+  virtual void vertexAttrib4fv(
+      WebKit::WGC3Duint index,
+      const WebKit::WGC3Dfloat* values) {}
+  virtual void vertexAttribPointer(
+      WebKit::WGC3Duint index,
+      WebKit::WGC3Dint size,
+      WebKit::WGC3Denum type,
+      WebKit::WGC3Dboolean normalized,
+      WebKit::WGC3Dsizei stride,
+      WebKit::WGC3Dintptr offset) {}
 
-    virtual void viewport(WebKit::WGC3Dint x, WebKit::WGC3Dint y, WebKit::WGC3Dsizei width, WebKit::WGC3Dsizei height) { }
+  virtual void viewport(
+      WebKit::WGC3Dint x,
+      WebKit::WGC3Dint y,
+      WebKit::WGC3Dsizei width,
+      WebKit::WGC3Dsizei height) {}
 
-    virtual WebKit::WebGLId createBuffer();
-    virtual WebKit::WebGLId createFramebuffer();
-    virtual WebKit::WebGLId createProgram();
-    virtual WebKit::WebGLId createRenderbuffer();
-    virtual WebKit::WebGLId createShader(WebKit::WGC3Denum);
-    virtual WebKit::WebGLId createTexture();
+  virtual WebKit::WebGLId createBuffer();
+  virtual WebKit::WebGLId createFramebuffer();
+  virtual WebKit::WebGLId createProgram();
+  virtual WebKit::WebGLId createRenderbuffer();
+  virtual WebKit::WebGLId createShader(WebKit::WGC3Denum);
+  virtual WebKit::WebGLId createTexture();
 
-    virtual void deleteBuffer(WebKit::WebGLId) { }
-    virtual void deleteFramebuffer(WebKit::WebGLId) { }
-    virtual void deleteProgram(WebKit::WebGLId) { }
-    virtual void deleteRenderbuffer(WebKit::WebGLId) { }
-    virtual void deleteShader(WebKit::WebGLId) { }
-    virtual void deleteTexture(WebKit::WebGLId) { }
+  virtual void deleteBuffer(WebKit::WebGLId id);
+  virtual void deleteFramebuffer(WebKit::WebGLId id);
+  virtual void deleteProgram(WebKit::WebGLId id);
+  virtual void deleteRenderbuffer(WebKit::WebGLId id);
+  virtual void deleteShader(WebKit::WebGLId id);
+  virtual void deleteTexture(WebKit::WebGLId texture_id);
 
-    virtual void texStorage2DEXT(WebKit::WGC3Denum target, WebKit::WGC3Dint levels, WebKit::WGC3Duint internalformat,
-                                 WebKit::WGC3Dint width, WebKit::WGC3Dint height) { }
+  virtual void texStorage2DEXT(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Dint levels,
+      WebKit::WGC3Duint internalformat,
+      WebKit::WGC3Dint width,
+      WebKit::WGC3Dint height) {}
 
-    virtual WebKit::WebGLId createQueryEXT();
-    virtual void deleteQueryEXT(WebKit::WebGLId) { }
-    virtual WebKit::WGC3Dboolean isQueryEXT(WebKit::WebGLId);
-    virtual void beginQueryEXT(WebKit::WGC3Denum, WebKit::WebGLId) { }
-    virtual void endQueryEXT(WebKit::WGC3Denum) { }
-    virtual void getQueryivEXT(WebKit::WGC3Denum, WebKit::WGC3Denum, WebKit::WGC3Dint*) { }
-    virtual void getQueryObjectuivEXT(WebKit::WebGLId, WebKit::WGC3Denum, WebKit::WGC3Duint*) { }
+  virtual WebKit::WebGLId createQueryEXT();
+  virtual void deleteQueryEXT(WebKit::WebGLId query) {}
+  virtual WebKit::WGC3Dboolean isQueryEXT(WebKit::WebGLId query);
+  virtual void beginQueryEXT(
+      WebKit::WGC3Denum target,
+      WebKit::WebGLId query) {}
+  virtual void endQueryEXT(WebKit::WGC3Denum target);
+  virtual void getQueryivEXT(
+      WebKit::WGC3Denum target,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Dint* params) {}
+  virtual void getQueryObjectuivEXT(
+      WebKit::WebGLId query,
+      WebKit::WGC3Denum pname,
+      WebKit::WGC3Duint* params);
 
-protected:
-    unsigned m_nextTextureId;
-    Attributes m_attrs;
+  virtual void setContextLostCallback(
+      WebGraphicsContextLostCallback* callback);
+
+  virtual void loseContextCHROMIUM(WebKit::WGC3Denum current,
+                                   WebKit::WGC3Denum other);
+
+  // When set, MakeCurrent() will fail after this many times.
+  void set_times_make_current_succeeds(int times) {
+    times_make_current_succeeds_ = times;
+  }
+  void set_times_bind_texture_succeeds(int times) {
+    times_bind_texture_succeeds_ = times;
+  }
+  void set_times_end_query_succeeds(int times) {
+    times_end_query_succeeds_ = times;
+  }
+
+  size_t NumTextures() const { return textures_.size(); }
+  WebKit::WebGLId TextureAt(int i) const { return textures_[i]; }
+
+  size_t NumUsedTextures() const { return used_textures_.size(); }
+  bool UsedTexture(int texture) const {
+    return ContainsKey(used_textures_, texture);
+  }
+  void ResetUsedTextures() { used_textures_.clear(); }
+
+  void set_have_extension_io_surface(bool have) {
+    have_extension_io_surface_ = have;
+  }
+  void set_have_extension_egl_image(bool have) {
+    have_extension_egl_image_ = have;
+  }
+
+  static const WebKit::WebGLId kExternalTextureId;
+  virtual WebKit::WebGLId NextTextureId();
+
+ protected:
+  FakeWebGraphicsContext3D();
+  FakeWebGraphicsContext3D(
+      const WebKit::WebGraphicsContext3D::Attributes& attributes);
+
+  unsigned context_id_;
+  unsigned next_texture_id_;
+  Attributes attributes_;
+  bool have_extension_io_surface_;
+  bool have_extension_egl_image_;
+  int times_make_current_succeeds_;
+  int times_bind_texture_succeeds_;
+  int times_end_query_succeeds_;
+  bool context_lost_;
+  WebGraphicsContextLostCallback* context_lost_callback_;
+  std::vector<WebKit::WebGLId> textures_;
+  base::hash_set<WebKit::WebGLId> used_textures_;
+  int width_;
+  int height_;
 };
 
 }  // namespace cc
Index: src/cc/rendering_stats.cc
===================================================================
--- src/cc/rendering_stats.cc	(revision 184497)
+++ src/cc/rendering_stats.cc	(working copy)
@@ -10,9 +10,6 @@
     : numAnimationFrames(0),
       numFramesSentToScreen(0),
       droppedFrameCount(0),
-      totalPaintTimeInSeconds(0),
-      totalRasterizeTimeInSeconds(0),
-      totalCommitTimeInSeconds(0),
       totalCommitCount(0),
       totalPixelsPainted(0),
       totalPixelsRasterized(0),
@@ -22,19 +19,19 @@
       numMissingTiles(0),
       totalDeferredImageDecodeCount(0),
       totalDeferredImageCacheHitCount(0),
-      totalImageGatheringCount(0),
-      totalDeferredImageDecodeTimeInSeconds(0),
-      totalImageGatheringTimeInSeconds(0) {
+      totalImageGatheringCount(0) {
 }
 
 void RenderingStats::EnumerateFields(Enumerator* enumerator) const {
     enumerator->AddInt64("numAnimationFrames", numAnimationFrames);
     enumerator->AddInt64("numFramesSentToScreen", numFramesSentToScreen);
     enumerator->AddInt64("droppedFrameCount", droppedFrameCount);
-    enumerator->AddDouble("totalPaintTimeInSeconds", totalPaintTimeInSeconds);
+    enumerator->AddDouble("totalPaintTimeInSeconds",
+                          totalPaintTime.InSecondsF());
     enumerator->AddDouble("totalRasterizeTimeInSeconds",
-                          totalRasterizeTimeInSeconds);
-    enumerator->AddDouble("totalCommitTimeInSeconds", totalCommitTimeInSeconds);
+                          totalRasterizeTime.InSecondsF());
+    enumerator->AddDouble("totalCommitTimeInSeconds",
+                          totalCommitTime.InSecondsF());
     enumerator->AddInt64("totalCommitCount", totalCommitCount);
     enumerator->AddInt64("totalPixelsPainted", totalPixelsPainted);
     enumerator->AddInt64("totalPixelsRasterized", totalPixelsRasterized);
@@ -48,9 +45,9 @@
                          totalDeferredImageCacheHitCount);
     enumerator->AddInt64("totalImageGatheringCount", totalImageGatheringCount);
     enumerator->AddDouble("totalDeferredImageDecodeTimeInSeconds",
-                          totalDeferredImageDecodeTimeInSeconds);
+                          totalDeferredImageDecodeTime.InSecondsF());
     enumerator->AddDouble("totalImageGatheringTimeInSeconds",
-                          totalImageGatheringTimeInSeconds);
+                          totalImageGatheringTime.InSecondsF());
 }
 
 }  // namespace cc
Index: src/cc/yuv_video_draw_quad.cc
===================================================================
--- src/cc/yuv_video_draw_quad.cc	(revision 184497)
+++ src/cc/yuv_video_draw_quad.cc	(working copy)
@@ -49,6 +49,13 @@
   this->v_plane = v_plane;
 }
 
+void YUVVideoDrawQuad::AppendResources(
+    ResourceProvider::ResourceIdArray* resources) {
+  resources->push_back(y_plane.resourceId);
+  resources->push_back(u_plane.resourceId);
+  resources->push_back(v_plane.resourceId);
+}
+
 const YUVVideoDrawQuad* YUVVideoDrawQuad::MaterialCast(
     const DrawQuad* quad) {
   DCHECK(quad->material == DrawQuad::YUV_VIDEO_CONTENT);
Index: src/cc/delegated_renderer_layer.h
===================================================================
--- src/cc/delegated_renderer_layer.h	(revision 184497)
+++ src/cc/delegated_renderer_layer.h	(working copy)
@@ -11,16 +11,17 @@
 namespace cc {
 
 class CC_EXPORT DelegatedRendererLayer : public Layer {
-public:
-    static scoped_refptr<DelegatedRendererLayer> create();
+ public:
+  static scoped_refptr<DelegatedRendererLayer> Create();
 
-    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
+  virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* tree_impl)
+      OVERRIDE;
 
-protected:
-    DelegatedRendererLayer();
+ protected:
+  DelegatedRendererLayer();
 
-private:
-    virtual ~DelegatedRendererLayer();
+ private:
+  virtual ~DelegatedRendererLayer();
 };
 
 }
Index: src/cc/caching_bitmap_content_layer_updater.cc
===================================================================
--- src/cc/caching_bitmap_content_layer_updater.cc	(revision 184497)
+++ src/cc/caching_bitmap_content_layer_updater.cc	(working copy)
@@ -4,6 +4,7 @@
 
 #include "caching_bitmap_content_layer_updater.h"
 
+#include "base/logging.h"
 #include "cc/layer_painter.h"
 #include "skia/ext/platform_canvas.h"
 
@@ -34,12 +35,13 @@
     float contents_height_scale,
     gfx::Rect& resulting_opaque_rect,
     RenderingStats& stats) {
-  BitmapContentLayerUpdater::prepareToUpdate(content_rect,
-                                                   tile_size,
-                                                   contents_width_scale,
-                                                   contents_height_scale,
-                                                   resulting_opaque_rect,
-                                                   stats);
+  BitmapContentLayerUpdater::prepareToUpdate(
+      content_rect,
+      tile_size,
+      contents_width_scale,
+      contents_height_scale,
+      resulting_opaque_rect,
+      stats);
 
   const SkBitmap& new_bitmap = m_canvas->getDevice()->accessBitmap(false);
   SkAutoLockPixels lock(new_bitmap);
Index: src/cc/content_layer.cc
===================================================================
--- src/cc/content_layer.cc	(revision 184497)
+++ src/cc/content_layer.cc	(working copy)
@@ -25,14 +25,17 @@
     return make_scoped_ptr(new ContentLayerPainter(client));
 }
 
-void ContentLayerPainter::paint(SkCanvas* canvas, const gfx::Rect& contentRect, gfx::RectF& opaque)
+void ContentLayerPainter::paint(SkCanvas* canvas, gfx::Rect contentRect, gfx::RectF& opaque)
 {
     base::TimeTicks paintStart = base::TimeTicks::HighResNow();
     m_client->paintContents(canvas, contentRect, opaque);
     base::TimeTicks paintEnd = base::TimeTicks::HighResNow();
     double pixelsPerSec = (contentRect.width() * contentRect.height()) / (paintEnd - paintStart).InSecondsF();
-    HISTOGRAM_CUSTOM_COUNTS("Renderer4.AccelContentPaintDurationMS", (paintEnd - paintStart).InMilliseconds(), 0, 120, 30);
-    HISTOGRAM_CUSTOM_COUNTS("Renderer4.AccelContentPaintMegapixPerSecond", pixelsPerSec / 1000000, 10, 210, 30);
+    UMA_HISTOGRAM_CUSTOM_COUNTS("Renderer4.AccelContentPaintDurationMS",
+                                (paintEnd - paintStart).InMilliseconds(),
+                                0, 120, 30);
+    UMA_HISTOGRAM_CUSTOM_COUNTS("Renderer4.AccelContentPaintMegapixPerSecond",
+                                pixelsPerSec / 1000000, 10, 210, 30);
 }
 
 scoped_refptr<ContentLayer> ContentLayer::create(ContentLayerClient* client)
@@ -98,7 +101,7 @@
         m_updater = BitmapContentLayerUpdater::create(painter.Pass());
     m_updater->setOpaque(contentsOpaque());
 
-    GLenum textureFormat = layerTreeHost()->rendererCapabilities().bestTextureFormat;
+    unsigned textureFormat = layerTreeHost()->rendererCapabilities().bestTextureFormat;
     setTextureFormat(textureFormat);
 }
 
Index: src/cc/layer_tree_settings.cc
===================================================================
--- src/cc/layer_tree_settings.cc	(revision 184497)
+++ src/cc/layer_tree_settings.cc	(working copy)
@@ -12,7 +12,29 @@
 #include "cc/switches.h"
 
 namespace cc {
+namespace {
 
+bool GetSwitchValueAsFloat(
+    const CommandLine& command_line,
+    const std::string& switch_string,
+    float min_value,
+    float max_value,
+    float* result) {
+  std::string string_value = command_line.GetSwitchValueASCII(switch_string);
+  double double_value;
+  if (base::StringToDouble(string_value, &double_value) &&
+      double_value >= min_value && double_value <= max_value) {
+    *result = static_cast<float>(double_value);
+    return true;
+  } else {
+    LOG(WARNING) << "Failed to parse switch " << switch_string  << ": " <<
+        string_value;
+    return false;
+  }
+}
+
+}  // namespace
+
 LayerTreeSettings::LayerTreeSettings()
     : acceleratePainting(false)
     , compositorFrameMessage(false)
@@ -21,22 +43,31 @@
     , perTilePaintingEnabled(false)
     , partialSwapEnabled(false)
     , cacheRenderPassContents(true)
+    , rightAlignedSchedulingEnabled(false)
     , acceleratedAnimationEnabled(true)
     , pageScalePinchZoomEnabled(false)
     , backgroundColorInsteadOfCheckerboard(false)
     , showOverdrawInTracing(false)
     , canUseLCDText(true)
     , shouldClearRootRenderPass(true)
+    , useLinearFadeScrollbarAnimator(false)
+    , solidColorScrollbars(false)
+    , solidColorScrollbarColor(SK_ColorWHITE)
+    , solidColorScrollbarThicknessDIP(-1)
+    , calculateTopControlsPosition(false)
+    , useMemoryManagement(true)
+    , minimumContentsScale(0.0625f)
+    , lowResContentsScaleFactor(0.125f)
     , refreshRate(0)
     , maxPartialTextureUpdates(std::numeric_limits<size_t>::max())
     , numRasterThreads(1)
+    , topControlsHeightPx(0)
     , defaultTileSize(gfx::Size(256, 256))
     , maxUntiledLayerSize(gfx::Size(512, 512))
     , minimumOcclusionTrackingSize(gfx::Size(160, 160))
 {
     // TODO(danakj): Move this to chromium when we don't go through the WebKit API anymore.
     compositorFrameMessage = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kEnableCompositorFrameMessage);
-    implSidePainting = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kEnableImplSidePainting);
     partialSwapEnabled = CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnablePartialSwap);
     backgroundColorInsteadOfCheckerboard = CommandLine::ForCurrentProcess()->HasSwitch(switches::kBackgroundColorInsteadOfCheckerboard);
     showOverdrawInTracing = CommandLine::ForCurrentProcess()->HasSwitch(switches::kTraceOverdraw);
@@ -45,14 +76,35 @@
 // Platforms that need to disable LCD text must explicitly set this value.
 #if defined(OS_ANDROID)
     canUseLCDText = false;
+    solidColorScrollbars = true;
+    solidColorScrollbarColor = SkColorSetARGB(128, 128, 128, 128);
+    solidColorScrollbarThicknessDIP = 3;
 #endif
 
+#if defined(OS_ANDROID)
+    // TODO(danakj): Move this out to the android code.
+    maxPartialTextureUpdates = 0;
+#endif
+
+#if defined(OS_ANDROID)
+    // TODO(danakj): Move this out to the android code.
+    useLinearFadeScrollbarAnimator = true;
+#endif
+
     initialDebugState.showPropertyChangedRects = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kShowPropertyChangedRects);
     initialDebugState.showSurfaceDamageRects = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kShowSurfaceDamageRects);
     initialDebugState.showScreenSpaceRects = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kShowScreenSpaceRects);
     initialDebugState.showReplicaScreenSpaceRects = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kShowReplicaScreenSpaceRects);
     initialDebugState.showOccludingRects = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kShowOccludingRects);
     initialDebugState.showNonOccludingRects = CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kShowNonOccludingRects);
+    if (CommandLine::ForCurrentProcess()->HasSwitch(cc::switches::kSlowDownRasterScaleFactor)) {
+      int scaleAsInt;
+      std::string value = CommandLine::ForCurrentProcess()->GetSwitchValueASCII(switches::kSlowDownRasterScaleFactor);
+      if (!base::StringToInt(value, &scaleAsInt))
+          LOG(ERROR) << "Failed to parse the slow down raster scale factor:" << value;
+      else
+          initialDebugState.slowDownRasterScaleFactor = scaleAsInt;
+    }
 
     if (CommandLine::ForCurrentProcess()->HasSwitch(
             switches::kNumRasterThreads)) {
@@ -70,12 +122,21 @@
         }
     }
 
-    // TODO(danakj): Renable surface caching when we can do it more realiably. crbug.com/170713
-    cacheRenderPassContents = false;
+    if (CommandLine::ForCurrentProcess()->HasSwitch(
+            cc::switches::kLowResolutionContentsScaleFactor)) {
+        const int kMinScaleFactor = minimumContentsScale;
+        const int kMaxScaleFactor = 1;
+        GetSwitchValueAsFloat(*CommandLine::ForCurrentProcess(),
+                              cc::switches::kLowResolutionContentsScaleFactor,
+                              kMinScaleFactor, kMaxScaleFactor,
+                              &lowResContentsScaleFactor);
+    }
 }
 
 LayerTreeSettings::~LayerTreeSettings()
 {
+    // TODO(danakj): Renable surface caching when we can do it more realiably. crbug.com/170713
+    cacheRenderPassContents = false;
 }
 
 }  // namespace cc
Index: src/cc/texture_layer_impl.cc
===================================================================
--- src/cc/texture_layer_impl.cc	(revision 184497)
+++ src/cc/texture_layer_impl.cc	(working copy)
@@ -5,19 +5,23 @@
 #include "cc/texture_layer_impl.h"
 
 #include "base/stringprintf.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/quad_sink.h"
 #include "cc/renderer.h"
 #include "cc/texture_draw_quad.h"
 
 namespace cc {
 
-TextureLayerImpl::TextureLayerImpl(LayerTreeImpl* treeImpl, int id)
+TextureLayerImpl::TextureLayerImpl(LayerTreeImpl* treeImpl, int id, bool usesMailbox)
     : LayerImpl(treeImpl, id)
     , m_textureId(0)
     , m_externalTextureResource(0)
     , m_premultipliedAlpha(true)
     , m_flipped(true)
-    , m_uvRect(0, 0, 1, 1)
+    , m_uvTopLeft(0.f, 0.f)
+    , m_uvBottomRight(1.f, 1.f)
+    , m_hasPendingMailbox(false)
+    , m_usesMailbox(usesMailbox)
 {
   m_vertexOpacity[0] = 1.0f;
   m_vertexOpacity[1] = 1.0f;
@@ -27,14 +31,72 @@
 
 TextureLayerImpl::~TextureLayerImpl()
 {
+    if (m_externalTextureResource) {
+        DCHECK(m_usesMailbox);
+        ResourceProvider* provider = layerTreeImpl()->resource_provider();
+        provider->deleteResource(m_externalTextureResource);
+    }
+    if (m_hasPendingMailbox)
+        m_pendingTextureMailbox.RunReleaseCallback(m_pendingTextureMailbox.sync_point());
 }
 
+void TextureLayerImpl::setTextureMailbox(const TextureMailbox& mailbox)
+{
+    DCHECK(m_usesMailbox);
+    // Same mailbox name was commited, nothing to do.
+    if (m_pendingTextureMailbox.Equals(mailbox))
+        return;
+    // Two commits without a draw, ack the previous mailbox.
+    if (m_hasPendingMailbox)
+        m_pendingTextureMailbox.RunReleaseCallback(m_pendingTextureMailbox.sync_point());
+
+    m_pendingTextureMailbox = mailbox;
+    m_hasPendingMailbox = true;
+}
+
+scoped_ptr<LayerImpl> TextureLayerImpl::createLayerImpl(LayerTreeImpl* treeImpl)
+{
+    return TextureLayerImpl::create(treeImpl, id(), m_usesMailbox).PassAs<LayerImpl>();
+}
+
+void TextureLayerImpl::pushPropertiesTo(LayerImpl* layer)
+{
+    LayerImpl::pushPropertiesTo(layer);
+
+    TextureLayerImpl* textureLayer = static_cast<TextureLayerImpl*>(layer);
+    textureLayer->setFlipped(m_flipped);
+    textureLayer->setUVTopLeft(m_uvTopLeft);
+    textureLayer->setUVBottomRight(m_uvBottomRight);
+    textureLayer->setVertexOpacity(m_vertexOpacity);
+    textureLayer->setPremultipliedAlpha(m_premultipliedAlpha);
+    if (m_usesMailbox) {
+        textureLayer->setTextureMailbox(m_pendingTextureMailbox);
+    } else {
+        textureLayer->setTextureId(m_textureId);
+    }
+}
+
+
 void TextureLayerImpl::willDraw(ResourceProvider* resourceProvider)
 {
-    if (!m_textureId)
+    if (!m_usesMailbox) {
+        if (!m_textureId)
+            return;
+        DCHECK(!m_externalTextureResource);
+        m_externalTextureResource = resourceProvider->createResourceFromExternalTexture(m_textureId);
         return;
-    DCHECK(!m_externalTextureResource);
-    m_externalTextureResource = resourceProvider->createResourceFromExternalTexture(m_textureId);
+    }
+
+    if (!m_hasPendingMailbox)
+        return;
+
+    if (m_externalTextureResource) {
+        resourceProvider->deleteResource(m_externalTextureResource);
+        m_externalTextureResource = 0;
+    }
+    if (!m_pendingTextureMailbox.IsEmpty())
+        m_externalTextureResource = resourceProvider->createResourceFromTextureMailbox(m_pendingTextureMailbox);
+    m_hasPendingMailbox = false;
 }
 
 void TextureLayerImpl::appendQuads(QuadSink& quadSink, AppendQuadsData& appendQuadsData)
@@ -48,7 +110,7 @@
     gfx::Rect quadRect(gfx::Point(), contentBounds());
     gfx::Rect opaqueRect(contentsOpaque() ? quadRect : gfx::Rect());
     scoped_ptr<TextureDrawQuad> quad = TextureDrawQuad::Create();
-    quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_externalTextureResource, m_premultipliedAlpha, m_uvRect, m_vertexOpacity, m_flipped);
+    quad->SetNew(sharedQuadState, quadRect, opaqueRect, m_externalTextureResource, m_premultipliedAlpha, m_uvTopLeft, m_uvBottomRight, m_vertexOpacity, m_flipped);
 
     // Perform explicit clipping on a quad to avoid setting a scissor later.
     if (sharedQuadState->is_clipped && quad->PerformClipping())
@@ -59,6 +121,8 @@
 
 void TextureLayerImpl::didDraw(ResourceProvider* resourceProvider)
 {
+    if (m_usesMailbox)
+        return;
     if (!m_externalTextureResource)
         return;
     // FIXME: the following assert will not be true when sending resources to a
@@ -94,4 +158,9 @@
     return "TextureLayer";
 }
 
+bool TextureLayerImpl::canClipSelf() const
+{
+    return true;
+}
+
 }  // namespace cc
Index: src/cc/picture.h
===================================================================
--- src/cc/picture.h	(revision 184497)
+++ src/cc/picture.h	(working copy)
@@ -23,7 +23,7 @@
 
 class CC_EXPORT Picture
     : public base::RefCountedThreadSafe<Picture> {
-public:
+ public:
   static scoped_refptr<Picture> Create(gfx::Rect layer_rect);
 
   const gfx::Rect& LayerRect() const { return layer_rect_; }
@@ -37,16 +37,16 @@
   void Record(ContentLayerClient*, RenderingStats&);
 
   // Has Record() been called yet?
-  bool HasRecording() const { return picture_.get(); }
+  bool HasRecording() const { return picture_.get() != NULL; }
 
-  // Raster this Picture's layer_rect into the given canvas.
-  // Assumes contentsScale have already been applied.
-  void Raster(SkCanvas* canvas);
+  // Apply this contents scale and raster the content rect into the canvas.
+  void Raster(SkCanvas* canvas, gfx::Rect content_rect, float contents_scale);
 
-  void GatherPixelRefs(const gfx::Rect& rect,
-                       std::list<skia::LazyPixelRef*>&);
+  void GatherPixelRefs(
+      const gfx::Rect& layer_rect,
+      std::list<skia::LazyPixelRef*>& pixel_ref_list);
 
-private:
+ private:
   Picture(gfx::Rect layer_rect);
   // This constructor assumes SkPicture is already ref'd and transfers
   // ownership to this picture.
Index: src/cc/tree_synchronizer.h
===================================================================
--- src/cc/tree_synchronizer.h	(revision 184497)
+++ src/cc/tree_synchronizer.h	(working copy)
@@ -21,19 +21,16 @@
     // Accepts a Layer tree and returns a reference to a LayerImpl tree that duplicates the structure
     // of the Layer tree, reusing the LayerImpls in the tree provided by oldLayerImplRoot if possible.
     static scoped_ptr<LayerImpl> synchronizeTrees(Layer* layerRoot, scoped_ptr<LayerImpl> oldLayerImplRoot, LayerTreeImpl*);
+    static scoped_ptr<LayerImpl> synchronizeTrees(LayerImpl* layerRoot, scoped_ptr<LayerImpl> oldLayerImplRoot, LayerTreeImpl*);
 
+    // Pushes properties from a Layer or LayerImpl tree to a structurally equivalent
+    // LayerImpl tree.
+    static void pushProperties(Layer* layerRoot, LayerImpl* layerImplRoot);
+    static void pushProperties(LayerImpl* layerRoot, LayerImpl* layerImplRoot);
+
 private:
     TreeSynchronizer(); // Not instantiable.
 
-    typedef ScopedPtrHashMap<int, LayerImpl> ScopedPtrLayerImplMap;
-    typedef base::hash_map<int, LayerImpl*> RawPtrLayerImplMap;
-
-    // Declared as static member functions so they can access functions on Layer as a friend class.
-    static scoped_ptr<LayerImpl> reuseOrCreateLayerImpl(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, Layer*, LayerTreeImpl*);
-    static void collectExistingLayerImplRecursive(ScopedPtrLayerImplMap& oldLayers, scoped_ptr<LayerImpl>);
-    static scoped_ptr<LayerImpl> synchronizeTreeRecursive(RawPtrLayerImplMap& newLayers, ScopedPtrLayerImplMap& oldLayers, Layer*, LayerTreeImpl*);
-    static void updateScrollbarLayerPointersRecursive(const RawPtrLayerImplMap& newLayers, Layer*);
-
     DISALLOW_COPY_AND_ASSIGN(TreeSynchronizer);
 };
 
Index: src/cc/tiling_data.h
===================================================================
--- src/cc/tiling_data.h	(revision 184497)
+++ src/cc/tiling_data.h	(working copy)
@@ -8,10 +8,10 @@
 #include "base/basictypes.h"
 #include "base/logging.h"
 #include "cc/cc_export.h"
+#include "ui/gfx/rect.h"
 #include "ui/gfx/size.h"
 
 namespace gfx {
-class Rect;
 class Vector2d;
 }
 
@@ -19,8 +19,15 @@
 
 class CC_EXPORT TilingData {
  public:
-  TilingData(gfx::Size max_texture_size, gfx::Size total_size, bool has_border_texels);
-  ~TilingData();
+  TilingData();
+  TilingData(
+      gfx::Size max_texture_size,
+      gfx::Size total_size,
+      bool has_border_texels);
+  TilingData(
+      gfx::Size max_texture_size,
+      gfx::Size total_size,
+      int border_texels);
 
   gfx::Size total_size() const { return total_size_; }
   void SetTotalSize(const gfx::Size total_size);
@@ -30,12 +37,20 @@
 
   int border_texels() const { return border_texels_; }
   void SetHasBorderTexels(bool has_border_texels);
+  void SetBorderTexels(int border_texels);
 
   bool has_empty_bounds() const { return !num_tiles_x_ || !num_tiles_y_; }
   int num_tiles_x() const { return num_tiles_x_; }
   int num_tiles_y() const { return num_tiles_y_; }
+  // Return the tile index whose non-border texels include src_position.
   int TileXIndexFromSrcCoord(int src_position) const;
   int TileYIndexFromSrcCoord(int src_position) const;
+  // Return the lowest tile index whose border texels include src_position.
+  int FirstBorderTileXIndexFromSrcCoord(int src_position) const;
+  int FirstBorderTileYIndexFromSrcCoord(int src_position) const;
+  // Return the highest tile index whose border texels include src_position.
+  int LastBorderTileXIndexFromSrcCoord(int src_position) const;
+  int LastBorderTileYIndexFromSrcCoord(int src_position) const;
 
   gfx::Rect TileBounds(int i, int j) const;
   gfx::Rect TileBoundsWithBorder(int i, int j) const;
@@ -47,6 +62,63 @@
   // Difference between TileBound's and TileBoundWithBorder's origin().
   gfx::Vector2d TextureOffset(int x_index, int y_index) const;
 
+  class CC_EXPORT BaseIterator {
+   public:
+    operator bool() const { return index_x_ != -1 && index_y_ != -1; }
+
+    int index_x() const { return index_x_; }
+    int index_y() const { return index_y_; }
+    std::pair<int, int> index() const {
+     return std::make_pair(index_x_, index_y_);
+    }
+
+   protected:
+    explicit BaseIterator(const TilingData* tiling_data);
+    void done() { index_x_ = -1; index_y_ = -1; }
+
+    const TilingData* tiling_data_;
+    int index_x_;
+    int index_y_;
+  };
+
+  // Iterate through all indices whose bounds + border intersect with |rect|.
+  class CC_EXPORT Iterator : public BaseIterator {
+   public:
+    Iterator(const TilingData* tiling_data, gfx::Rect rect);
+    Iterator& operator++();
+
+   private:
+    int left_;
+    int right_;
+    int bottom_;
+  };
+
+  // Iterate through all indices whose bounds + border intersect with
+  // |consider| but which also do not intersect with |ignore|.
+  class CC_EXPORT DifferenceIterator : public BaseIterator {
+   public:
+    DifferenceIterator(
+      const TilingData* tiling_data,
+      gfx::Rect consider,
+      gfx::Rect ignore);
+    DifferenceIterator& operator++();
+
+   private:
+    bool in_ignore_rect() const {
+     return index_x_ >= ignore_left_ && index_x_ <= ignore_right_ &&
+       index_y_ >= ignore_top_ && index_y_ <= ignore_bottom_;
+    }
+
+    int consider_left_;
+    int consider_top_;
+    int consider_right_;
+    int consider_bottom_;
+    int ignore_left_;
+    int ignore_top_;
+    int ignore_right_;
+    int ignore_bottom_;
+  };
+
  private:
   void AssertTile(int i, int j) const {
     DCHECK_GE(i,  0);
@@ -59,7 +131,6 @@
 
   gfx::Size max_texture_size_;
   gfx::Size total_size_;
-  // This value is always 0 or 1.
   int border_texels_;
 
   // These are computed values.
Index: src/cc/gl_renderer_unittest.cc
===================================================================
--- src/cc/gl_renderer_unittest.cc	(revision 184497)
+++ src/cc/gl_renderer_unittest.cc	(working copy)
@@ -72,8 +72,7 @@
         RenderPass::Id renderPassId = m_rootLayer->renderSurface()->renderPassId();
         scoped_ptr<RenderPass> rootRenderPass = RenderPass::Create();
         rootRenderPass->SetNew(renderPassId, gfx::Rect(), gfx::Rect(), gfx::Transform());
-        m_renderPassesInDrawOrder.push_back(rootRenderPass.get());
-        m_renderPasses.set(renderPassId, rootRenderPass.Pass());
+        m_renderPassesInDrawOrder.push_back(rootRenderPass.Pass());
     }
 
     // RendererClient methods.
@@ -95,7 +94,6 @@
 
     RenderPass* rootRenderPass() { return m_renderPassesInDrawOrder.back(); }
     RenderPassList& renderPassesInDrawOrder() { return m_renderPassesInDrawOrder; }
-    RenderPassIdHashMap& renderPasses() { return m_renderPasses; }
 
     size_t memoryAllocationLimitBytes() const { return m_memoryAllocationLimitBytes; }
 
@@ -106,7 +104,6 @@
     bool* m_lastCallWasSetVisibility;
     scoped_ptr<LayerImpl> m_rootLayer;
     RenderPassList m_renderPassesInDrawOrder;
-    RenderPassIdHashMap m_renderPasses;
     size_t m_memoryAllocationLimitBytes;
 };
 
@@ -218,7 +215,7 @@
     EXPECT_EQ(1, m_mockClient.setFullRootLayerDamageCount());
 
     m_renderer.setVisible(true);
-    m_renderer.drawFrame(m_mockClient.renderPassesInDrawOrder(), m_mockClient.renderPasses());
+    m_renderer.drawFrame(m_mockClient.renderPassesInDrawOrder());
     EXPECT_FALSE(m_renderer.isBackbufferDiscarded());
 
     swapBuffers();
@@ -233,7 +230,7 @@
     EXPECT_EQ(1, m_mockClient.setFullRootLayerDamageCount());
 
     char pixels[4];
-    m_renderer.drawFrame(m_mockClient.renderPassesInDrawOrder(), m_mockClient.renderPasses());
+    m_renderer.drawFrame(m_mockClient.renderPassesInDrawOrder());
     EXPECT_FALSE(m_renderer.isBackbufferDiscarded());
 
     m_renderer.getFramebufferPixels(pixels, gfx::Rect(0, 0, 1, 1));
@@ -251,7 +248,7 @@
     virtual WGC3Dint getAttribLocation(WebGLId program, const WGC3Dchar* name) { ADD_FAILURE(); return 0; }
     virtual void getBooleanv(WGC3Denum pname, WGC3Dboolean* value) { ADD_FAILURE(); }
     virtual void getBufferParameteriv(WGC3Denum target, WGC3Denum pname, WGC3Dint* value) { ADD_FAILURE(); }
-    virtual Attributes getContextAttributes() { ADD_FAILURE(); return m_attrs; }
+    virtual Attributes getContextAttributes() { ADD_FAILURE(); return attributes_; }
     virtual WGC3Denum getError() { ADD_FAILURE(); return 0; }
     virtual void getFloatv(WGC3Denum pname, WGC3Dfloat* value) { ADD_FAILURE(); }
     virtual void getFramebufferAttachmentParameteriv(WGC3Denum target, WGC3Denum attachment, WGC3Denum pname, WGC3Dint* value) { ADD_FAILURE(); }
@@ -412,7 +409,7 @@
 
     EXPECT_TRUE(renderer.initialize());
 
-    renderer.drawFrame(mockClient.renderPassesInDrawOrder(), mockClient.renderPasses());
+    renderer.drawFrame(mockClient.renderPassesInDrawOrder());
 
     // On DEBUG builds, render passes with opaque background clear to blue to
     // easily see regions that were not drawn on the screen.
@@ -435,7 +432,7 @@
 
     EXPECT_TRUE(renderer.initialize());
 
-    renderer.drawFrame(mockClient.renderPassesInDrawOrder(), mockClient.renderPasses());
+    renderer.drawFrame(mockClient.renderPassesInDrawOrder());
 
     EXPECT_EQ(1, context->clearCount());
 }
@@ -492,7 +489,7 @@
     context->setLastCallWasSetVisibilityPointer(&lastCallWasSetVisiblity);
     mockClient.setLastCallWasSetVisibilityPointer(&lastCallWasSetVisiblity);
     renderer.setVisible(true);
-    renderer.drawFrame(mockClient.renderPassesInDrawOrder(), mockClient.renderPasses());
+    renderer.drawFrame(mockClient.renderPassesInDrawOrder());
     renderer.setVisible(false);
     EXPECT_TRUE(lastCallWasSetVisiblity);
 }
@@ -541,7 +538,7 @@
     cc::RenderPass::Id id(1, 1);
     scoped_ptr<TestRenderPass> pass = TestRenderPass::Create();
     pass->SetNew(id, gfx::Rect(0, 0, 100, 100), gfx::Rect(0, 0, 100, 100), gfx::Transform());
-    pass->AppendOneOfEveryQuadType(resourceProvider.get());
+    pass->AppendOneOfEveryQuadType(resourceProvider.get(), RenderPass::Id(2, 1));
 
     // Set up expected texture filter state transitions that match the quads
     // created in AppendOneOfEveryQuadType().
@@ -549,7 +546,7 @@
     {
         InSequence sequence;
 
-        // yuv_quad is drawn with the default filter.
+        // yuv_quad is drawn with the default linear filter.
         EXPECT_CALL(*context, drawElements(_, _, _, _));
 
         // tile_quad is drawn with GL_NEAREST because it is not transformed or
@@ -559,8 +556,6 @@
         EXPECT_CALL(*context, drawElements(_, _, _, _));
 
         // transformed_tile_quad uses GL_LINEAR.
-        EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
-        EXPECT_CALL(*context, texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
         EXPECT_CALL(*context, drawElements(_, _, _, _));
 
         // scaled_tile_quad also uses GL_LINEAR.
@@ -605,7 +600,8 @@
     EXPECT_TRUE(renderer.initialize());
 
     gfx::Rect viewportRect(mockClient.deviceViewportSize());
-    ScopedPtrVector<RenderPass> renderPasses;
+    ScopedPtrVector<RenderPass>& renderPasses = mockClient.renderPassesInDrawOrder();
+    renderPasses.clear();
 
     RenderPass::Id rootPassId(1, 0);
     TestRenderPass* rootPass = addRenderPass(renderPasses, rootPassId, viewportRect, gfx::Transform());
@@ -617,12 +613,6 @@
 
     addRenderPassQuad(rootPass, childPass);
 
-    mockClient.renderPassesInDrawOrder().clear();
-    mockClient.renderPassesInDrawOrder().push_back(childPass);
-    mockClient.renderPassesInDrawOrder().push_back(rootPass);
-    mockClient.renderPasses().set(rootPassId, renderPasses.take(0));
-    mockClient.renderPasses().set(childPassId, renderPasses.take(1));
-
     // First render pass is not the root one, clearing should happen.
     EXPECT_CALL(*mockContext, clear(GL_COLOR_BUFFER_BIT))
         .Times(AtLeast(1));
@@ -640,7 +630,7 @@
         .After(firstRenderPass);
 
     renderer.decideRenderPassAllocationsForFrame(mockClient.renderPassesInDrawOrder());
-    renderer.drawFrame(mockClient.renderPassesInDrawOrder(), mockClient.renderPasses());
+    renderer.drawFrame(mockClient.renderPassesInDrawOrder());
 
     // In multiple render passes all but the root pass should clear the framebuffer.
     Mock::VerifyAndClearExpectations(&mockContext);
Index: src/cc/damage_tracker_unittest.cc
===================================================================
--- src/cc/damage_tracker_unittest.cc	(revision 184497)
+++ src/cc/damage_tracker_unittest.cc	(working copy)
@@ -12,10 +12,10 @@
 #include "cc/test/fake_layer_tree_host_impl.h"
 #include "cc/test/geometry_test_utils.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperation.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "third_party/skia/include/effects/SkBlurImageFilter.h"
 #include "ui/gfx/quad_f.h"
-#include <public/WebFilterOperation.h>
-#include <public/WebFilterOperations.h>
 
 using namespace WebKit;
 
@@ -32,7 +32,7 @@
     ASSERT_TRUE(root->renderSurface());
     ASSERT_FALSE(renderSurfaceLayerList.size());
 
-    LayerTreeHostCommon::calculateDrawProperties(root, root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList);
+    LayerTreeHostCommon::calculateDrawProperties(root, root->bounds(), 1, 1, dummyMaxTextureSize, false, renderSurfaceLayerList, false);
 }
 
 void clearDamageForAllSurfaces(LayerImpl* layer)
@@ -341,7 +341,7 @@
     gfx::Transform transform;
     transform.Translate3d(500, 500, 0);
     transform.ApplyPerspectiveDepth(1);
-    MathUtil::rotateEulerAngles(&transform, 0, 45, 0);
+    transform.RotateAboutYAxis(45);
     transform.Translate3d(-50, -50, 0);
 
     // Set up the child
Index: src/cc/layer_tree_host.h
===================================================================
--- src/cc/layer_tree_host.h	(revision 184497)
+++ src/cc/layer_tree_host.h	(working copy)
@@ -20,12 +20,13 @@
 #include "cc/layer_tree_settings.h"
 #include "cc/occlusion_tracker.h"
 #include "cc/output_surface.h"
-#include "cc/prioritized_resource_manager.h"
 #include "cc/proxy.h"
 #include "cc/rate_limiter.h"
 #include "cc/rendering_stats.h"
 #include "cc/scoped_ptr_vector.h"
+#include "skia/ext/refptr.h"
 #include "third_party/skia/include/core/SkColor.h"
+#include "third_party/skia/include/core/SkPicture.h"
 #include "ui/gfx/rect.h"
 
 #if defined(COMPILER_GCC)
@@ -41,10 +42,13 @@
 
 namespace cc {
 
+class AnimationRegistrar;
 class Layer;
 class LayerTreeHostImpl;
 class LayerTreeHostImplClient;
 class PrioritizedResourceManager;
+class PrioritizedResource;
+class ResourceProvider;
 class ResourceUpdateQueue;
 class HeadsUpDisplayLayer;
 class Region;
@@ -56,7 +60,7 @@
     RendererCapabilities();
     ~RendererCapabilities();
 
-    GLenum bestTextureFormat;
+    unsigned bestTextureFormat;
     bool usingPartialSwap;
     bool usingAcceleratedPainting;
     bool usingSetVisibility;
@@ -66,6 +70,7 @@
     bool usingEglImage;
     bool allowPartialTextureUpdates;
     int maxTextureSize;
+    bool avoidPow2Textures;
 };
 
 class CC_EXPORT LayerTreeHost : public RateLimiterClient {
@@ -84,7 +89,7 @@
 
     // LayerTreeHost interface to Proxy.
     void willBeginFrame() { m_client->willBeginFrame(); }
-    void didBeginFrame() { m_client->didBeginFrame(); }
+    void didBeginFrame();
     void updateAnimations(base::TimeTicks monotonicFrameBeginTime);
     void didStopFlinging();
     void layout();
@@ -135,9 +140,6 @@
 
     const RendererCapabilities& rendererCapabilities() const;
 
-    // Test only hook
-    void loseOutputSurface(int numTimes);
-
     void setNeedsAnimate();
     // virtual for testing
     virtual void setNeedsCommit();
@@ -146,7 +148,6 @@
     bool commitRequested() const;
 
     void setAnimationEvents(scoped_ptr<AnimationEventsVector>, base::Time wallClockTime);
-    virtual void didAddAnimation();
 
     Layer* rootLayer() { return m_rootLayer.get(); }
     const Layer* rootLayer() const { return m_rootLayer.get(); }
@@ -176,11 +177,6 @@
     void startPageScaleAnimation(gfx::Vector2d targetOffset, bool useAnchor, float scale, base::TimeDelta duration);
 
     void applyScrollAndScale(const ScrollAndScaleSet&);
-    // This function converts event coordinates when the deviceViewport is zoomed.
-    // Coordinates are transformed from logical pixels in the zoomed viewport to
-    // logical pixels in the un-zoomed viewport, the latter being the coordinates
-    // required for hit-testing.
-    gfx::PointF adjustEventPointForPinchZoom(const gfx::PointF& zoomedViewportPoint) const;
     void setImplTransform(const gfx::Transform&);
 
     void startRateLimiter(WebKit::WebGraphicsContext3D*);
@@ -199,6 +195,12 @@
 
     Proxy* proxy() const { return m_proxy.get(); }
 
+    AnimationRegistrar* animationRegistrar() const { return m_animationRegistrar.get(); }
+
+    skia::RefPtr<SkPicture> capturePicture();
+
+    bool blocksPendingCommit() const;
+
 protected:
     LayerTreeHost(LayerTreeHostClient*, const LayerTreeSettings&);
     bool initialize(scoped_ptr<Thread> implThread);
@@ -227,7 +229,6 @@
     void setAnimationEventsRecursive(const AnimationEventsVector&, Layer*, base::Time wallClockTime);
 
     bool m_animating;
-    bool m_needsAnimateLayers;
     bool m_needsFullTreeSync;
 
     base::CancelableClosure m_prepaintCallback;
@@ -240,7 +241,6 @@
 
     bool m_rendererInitialized;
     bool m_outputSurfaceLost;
-    int m_numTimesRecreateShouldFail;
     int m_numFailedRecreateAttempts;
 
     scoped_refptr<Layer> m_rootLayer;
@@ -272,6 +272,8 @@
     typedef ScopedPtrVector<PrioritizedResource> TextureList;
     size_t m_partialTextureUpdateRequests;
 
+    scoped_ptr<AnimationRegistrar> m_animationRegistrar;
+
     static bool s_needsFilterContext;
 
     DISALLOW_COPY_AND_ASSIGN(LayerTreeHost);
Index: src/cc/picture_layer_impl.h
===================================================================
--- src/cc/picture_layer_impl.h	(revision 184497)
+++ src/cc/picture_layer_impl.h	(working copy)
@@ -10,6 +10,8 @@
 #include "cc/picture_layer_tiling_set.h"
 #include "cc/picture_pile_impl.h"
 #include "cc/scoped_ptr_vector.h"
+#include "skia/ext/refptr.h"
+#include "third_party/skia/include/core/SkPicture.h"
 
 namespace cc {
 
@@ -27,36 +29,83 @@
 
   // LayerImpl overrides.
   virtual const char* layerTypeAsString() const OVERRIDE;
+  virtual scoped_ptr<LayerImpl> createLayerImpl(
+      LayerTreeImpl* treeImpl) OVERRIDE;
+  virtual void pushPropertiesTo(LayerImpl* layer) OVERRIDE;
   virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
   virtual void dumpLayerProperties(std::string*, int indent) const OVERRIDE;
-  virtual void didUpdateTransforms() OVERRIDE;
+  virtual void updateTilePriorities() OVERRIDE;
+  virtual void didBecomeActive() OVERRIDE;
+  virtual void didLoseOutputSurface() OVERRIDE;
+  virtual void calculateContentsScale(
+      float ideal_contents_scale,
+      bool animating_transform_to_screen,
+      float* contents_scale_x,
+      float* contents_scale_y,
+      gfx::Size* content_bounds) OVERRIDE;
+  virtual skia::RefPtr<SkPicture> getPicture() OVERRIDE;
 
-  void didUpdateBounds();
-
   // PictureLayerTilingClient overrides.
-  virtual scoped_refptr<Tile> CreateTile(PictureLayerTiling*,
-                                         gfx::Rect) OVERRIDE;
+  virtual scoped_refptr<Tile> CreateTile(PictureLayerTiling* tiling,
+                                         gfx::Rect content_rect) OVERRIDE;
+  virtual void UpdatePile(Tile* tile) OVERRIDE;
+  virtual gfx::Size CalculateTileSize(
+      gfx::Size current_tile_size,
+      gfx::Size content_bounds) OVERRIDE;
 
   // PushPropertiesTo active tree => pending tree
   void SyncFromActiveLayer();
-  void SyncTiling(const PictureLayerTiling* tiling);
+  void SyncTiling(
+      const PictureLayerTiling* tiling,
+      const Region& pending_layer_invalidation);
 
+  void CreateTilingSet();
+  void TransferTilingSet(scoped_ptr<PictureLayerTilingSet> tilings);
+
+  // Mask-related functions
+  void SetIsMask(bool is_mask);
+  virtual ResourceProvider::ResourceId contentsResourceId() const OVERRIDE;
+
+  virtual bool areVisibleResourcesReady() const OVERRIDE;
+
 protected:
   PictureLayerImpl(LayerTreeImpl* treeImpl, int id);
-  void AddTiling(float contents_scale, gfx::Size tile_size);
+  PictureLayerTiling* AddTiling(float contents_scale);
+  void RemoveTiling(float contents_scale);
   void SyncFromActiveLayer(const PictureLayerImpl* other);
+  void ManageTilings(bool animating_transform_to_screen);
+  virtual void CalculateRasterContentsScale(
+      bool animating_transform_to_screen,
+      float* raster_contents_scale,
+      float* low_res_raster_contents_scale);
+  void CleanUpTilingsOnActiveLayer(
+      std::vector<PictureLayerTiling*> used_tilings);
+  PictureLayerImpl* PendingTwin() const;
+  PictureLayerImpl* ActiveTwin() const;
 
-  PictureLayerTilingSet tilings_;
+  virtual void getDebugBorderProperties(
+      SkColor* color, float* width) const OVERRIDE;
+
+  scoped_ptr<PictureLayerTilingSet> tilings_;
   scoped_refptr<PicturePileImpl> pile_;
   Region invalidation_;
 
   gfx::Transform last_screen_space_transform_;
-  double last_update_time_;
   gfx::Size last_bounds_;
   gfx::Size last_content_bounds_;
-  float last_content_scale_x_;
-  float last_content_scale_y_;
+  float last_content_scale_;
+  float ideal_contents_scale_;
+  bool is_mask_;
 
+  float ideal_page_scale_;
+  float ideal_device_scale_;
+  float ideal_source_scale_;
+
+  float raster_page_scale_;
+  float raster_device_scale_;
+  float raster_source_scale_;
+  bool raster_source_scale_was_animating_;
+
   friend class PictureLayer;
   DISALLOW_COPY_AND_ASSIGN(PictureLayerImpl);
 };
Index: src/cc/texture_layer_unittest.cc
===================================================================
--- src/cc/texture_layer_unittest.cc	(revision 184497)
+++ src/cc/texture_layer_unittest.cc	(working copy)
@@ -4,11 +4,16 @@
 
 #include "cc/texture_layer.h"
 
+#include <string>
+
+#include "base/callback.h"
 #include "cc/layer_tree_host.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/single_thread_proxy.h"
 #include "cc/test/fake_impl_proxy.h"
 #include "cc/test/fake_layer_tree_host_client.h"
 #include "cc/test/fake_layer_tree_host_impl.h"
+#include "cc/test/layer_tree_test_common.h"
 #include "cc/texture_layer_impl.h"
 #include "cc/thread.h"
 #include "testing/gmock/include/gmock/gmock.h"
@@ -100,7 +105,7 @@
     scoped_refptr<TextureLayer> testLayer = TextureLayer::create(0);
     ASSERT_TRUE(testLayer);
     scoped_ptr<TextureLayerImpl> implLayer;
-    implLayer = TextureLayerImpl::create(m_hostImpl.activeTree(), 1);
+    implLayer = TextureLayerImpl::create(m_hostImpl.activeTree(), 1, false);
     ASSERT_TRUE(implLayer);
 
     EXPECT_CALL(*m_layerTreeHost, acquireLayerTextures()).Times(AnyNumber());
@@ -184,5 +189,221 @@
     Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
 }
 
+class MockMailboxCallback {
+public:
+    MOCK_METHOD2(Release, void(const std::string& mailbox, unsigned syncPoint));
+};
+
+struct CommonMailboxObjects {
+    CommonMailboxObjects()
+        : m_mailboxName1(64, '1')
+        , m_mailboxName2(64, '2')
+        , m_syncPoint1(1)
+        , m_syncPoint2(2)
+    {
+        m_releaseMailbox1 = base::Bind(&MockMailboxCallback::Release,
+                                       base::Unretained(&m_mockCallback),
+                                       m_mailboxName1);
+        m_releaseMailbox2 = base::Bind(&MockMailboxCallback::Release,
+                                       base::Unretained(&m_mockCallback),
+                                       m_mailboxName2);
+        Mailbox m1;
+        m1.setName(reinterpret_cast<const int8*>(m_mailboxName1.data()));
+        m_mailbox1 = TextureMailbox(m1, m_releaseMailbox1, m_syncPoint1);
+        Mailbox m2;
+        m2.setName(reinterpret_cast<const int8*>(m_mailboxName2.data()));
+        m_mailbox2 = TextureMailbox(m2, m_releaseMailbox2, m_syncPoint2);
+    }
+
+    std::string m_mailboxName1;
+    std::string m_mailboxName2;
+    MockMailboxCallback m_mockCallback;
+    TextureMailbox::ReleaseCallback m_releaseMailbox1;
+    TextureMailbox::ReleaseCallback m_releaseMailbox2;
+    TextureMailbox m_mailbox1;
+    TextureMailbox m_mailbox2;
+    unsigned m_syncPoint1;
+    unsigned m_syncPoint2;
+};
+
+class TextureLayerWithMailboxTest : public TextureLayerTest {
+protected:
+    virtual void TearDown()
+    {
+        Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+        EXPECT_CALL(m_testData.m_mockCallback,
+                    Release(m_testData.m_mailboxName1,
+                            m_testData.m_syncPoint1)).Times(1);
+        TextureLayerTest::TearDown();
+    }
+
+    CommonMailboxObjects m_testData;
+};
+
+TEST_F(TextureLayerWithMailboxTest, replaceMailboxOnMainThreadBeforeCommit)
+{
+    scoped_refptr<TextureLayer> testLayer = TextureLayer::createForMailbox();
+    ASSERT_TRUE(testLayer);
+
+    EXPECT_CALL(*m_layerTreeHost, acquireLayerTextures()).Times(0);
+    EXPECT_CALL(*m_layerTreeHost, setNeedsCommit()).Times(AnyNumber());
+    m_layerTreeHost->setRootLayer(testLayer);
+    Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
+
+    EXPECT_CALL(*m_layerTreeHost, acquireLayerTextures()).Times(0);
+    EXPECT_CALL(*m_layerTreeHost, setNeedsCommit()).Times(AtLeast(1));
+    testLayer->setTextureMailbox(m_testData.m_mailbox1);
+    Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
+
+    EXPECT_CALL(*m_layerTreeHost, acquireLayerTextures()).Times(0);
+    EXPECT_CALL(*m_layerTreeHost, setNeedsCommit()).Times(AtLeast(1));
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName1,
+                        m_testData.m_syncPoint1)).Times(1);
+    testLayer->setTextureMailbox(m_testData.m_mailbox2);
+    Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
+    Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+
+    EXPECT_CALL(*m_layerTreeHost, acquireLayerTextures()).Times(0);
+    EXPECT_CALL(*m_layerTreeHost, setNeedsCommit()).Times(AtLeast(1));
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName2,
+                        m_testData.m_syncPoint2)).Times(1);
+    testLayer->setTextureMailbox(TextureMailbox());
+    Mock::VerifyAndClearExpectations(m_layerTreeHost.get());
+    Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+
+    // Test destructor.
+    EXPECT_CALL(*m_layerTreeHost, setNeedsCommit()).Times(AtLeast(1));
+    testLayer->setTextureMailbox(m_testData.m_mailbox1);
+}
+
+class TextureLayerImplWithMailboxThreadedCallback : public ThreadedTest {
+public:
+    TextureLayerImplWithMailboxThreadedCallback()
+        : m_resetMailbox(false)
+    {
+    }
+
+    // Make sure callback is received on main and doesn't block the impl thread.
+    void releaseCallback(unsigned syncPoint) {
+        EXPECT_EQ(true, proxy()->isMainThread());
+        endTest();
+    }
+
+    virtual void beginTest() OVERRIDE
+    {
+        m_layer = TextureLayer::createForMailbox();
+        m_layer->setIsDrawable(true);
+        m_layerTreeHost->setRootLayer(m_layer);
+        TextureMailbox mailbox(
+            std::string(64, '1'),
+            base::Bind(
+                &TextureLayerImplWithMailboxThreadedCallback::releaseCallback,
+                base::Unretained(this)));
+        m_layer->setTextureMailbox(mailbox);
+        postSetNeedsCommitToMainThread();
+    }
+
+    virtual void didCommit() OVERRIDE
+    {
+        if (m_resetMailbox)
+            return;
+
+        m_layer->setTextureMailbox(TextureMailbox());
+        m_resetMailbox = true;
+    }
+
+    virtual void afterTest() OVERRIDE
+    {
+    }
+
+private:
+    bool m_resetMailbox;
+    scoped_refptr<TextureLayer> m_layer;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(TextureLayerImplWithMailboxThreadedCallback);
+
+class TextureLayerImplWithMailboxTest : public TextureLayerTest {
+protected:
+    virtual void SetUp()
+    {
+        TextureLayerTest::SetUp();
+        m_layerTreeHost.reset(new MockLayerImplTreeHost);
+        EXPECT_TRUE(m_hostImpl.initializeRenderer(createFakeOutputSurface()));
+    }
+
+    CommonMailboxObjects m_testData;
+};
+
+TEST_F(TextureLayerImplWithMailboxTest, testImplLayerCallbacks)
+{
+    scoped_ptr<TextureLayerImpl> implLayer;
+    implLayer = TextureLayerImpl::create(m_hostImpl.activeTree(), 1, true);
+    ASSERT_TRUE(implLayer);
+
+    // Test setting identical mailbox.
+    EXPECT_CALL(m_testData.m_mockCallback, Release(_, _)).Times(0);
+    implLayer->setTextureMailbox(m_testData.m_mailbox1);
+    implLayer->setTextureMailbox(m_testData.m_mailbox1);
+    Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+
+    // Test multiple commits without a draw.
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName1,
+                        m_testData.m_syncPoint1)).Times(1);
+    implLayer->setTextureMailbox(m_testData.m_mailbox2);
+    Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+
+    // Test resetting the mailbox.
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName2,
+                        m_testData.m_syncPoint2)).Times(1);
+    implLayer->setTextureMailbox(TextureMailbox());
+    Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+
+    // Test destructor.
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName1,
+                        m_testData.m_syncPoint1)).Times(1);
+    implLayer->setTextureMailbox(m_testData.m_mailbox1);
+}
+
+TEST_F(TextureLayerImplWithMailboxTest, testDestructorCallbackOnCreatedResource)
+{
+    scoped_ptr<TextureLayerImpl> implLayer;
+    implLayer = TextureLayerImpl::create(m_hostImpl.activeTree(), 1, true);
+    ASSERT_TRUE(implLayer);
+
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName1, _)).Times(1);
+    implLayer->setTextureMailbox(m_testData.m_mailbox1);
+    implLayer->willDraw(m_hostImpl.activeTree()->resource_provider());
+    implLayer->didDraw(m_hostImpl.activeTree()->resource_provider());
+    implLayer->setTextureMailbox(TextureMailbox());
+}
+
+TEST_F(TextureLayerImplWithMailboxTest, testCallbackOnInUseResource)
+{
+    ResourceProvider *provider = m_hostImpl.activeTree()->resource_provider();
+    ResourceProvider::ResourceId id =
+        provider->createResourceFromTextureMailbox(m_testData.m_mailbox1);
+    provider->allocateForTesting(id);
+
+    // Transfer some resources to the parent.
+    ResourceProvider::ResourceIdArray resourceIdsToTransfer;
+    resourceIdsToTransfer.push_back(id);
+    TransferableResourceList list;
+    provider->prepareSendToParent(resourceIdsToTransfer, &list);
+    EXPECT_TRUE(provider->inUseByConsumer(id));
+    EXPECT_CALL(m_testData.m_mockCallback, Release(_, _)).Times(0);
+    provider->deleteResource(id);
+    Mock::VerifyAndClearExpectations(&m_testData.m_mockCallback);
+    EXPECT_CALL(m_testData.m_mockCallback,
+                Release(m_testData.m_mailboxName1, _)).Times(1);
+    provider->receiveFromParent(list);
+}
+
 }  // namespace
 }  // namespace cc
Index: src/cc/scrollbar_animation_controller_linear_fade.cc
===================================================================
--- src/cc/scrollbar_animation_controller_linear_fade.cc	(revision 184497)
+++ src/cc/scrollbar_animation_controller_linear_fade.cc	(working copy)
@@ -4,7 +4,8 @@
 
 #include "cc/scrollbar_animation_controller_linear_fade.h"
 
-#include "cc/scrollbar_layer_impl.h"
+#include "base/time.h"
+#include "cc/layer_impl.h"
 
 namespace cc {
 
@@ -14,11 +15,12 @@
 }
 
 ScrollbarAnimationControllerLinearFade::ScrollbarAnimationControllerLinearFade(LayerImpl* scrollLayer, double fadeoutDelay, double fadeoutLength)
-    : ScrollbarAnimationController(scrollLayer)
-    , m_lastAwakenTime(-100000000) // arbitrary invalid timestamp
+    : ScrollbarAnimationController()
+    , m_scrollLayer(scrollLayer)
     , m_pinchGestureInEffect(false)
     , m_fadeoutDelay(fadeoutDelay)
     , m_fadeoutLength(fadeoutLength)
+    , m_currentTimeForTesting(0)
 {
 }
 
@@ -26,45 +28,39 @@
 {
 }
 
-bool ScrollbarAnimationControllerLinearFade::animate(double monotonicTime)
+bool ScrollbarAnimationControllerLinearFade::animate(base::TimeTicks now)
 {
-    float opacity = opacityAtTime(monotonicTime);
-    if (horizontalScrollbarLayer())
-        horizontalScrollbarLayer()->setOpacity(opacity);
-    if (verticalScrollbarLayer())
-        verticalScrollbarLayer()->setOpacity(opacity);
+    float opacity = opacityAtTime(now);
+    m_scrollLayer->setScrollbarOpacity(opacity);
     return opacity;
 }
 
-void ScrollbarAnimationControllerLinearFade::didPinchGestureUpdateAtTime(double)
+void ScrollbarAnimationControllerLinearFade::didPinchGestureUpdate(base::TimeTicks now)
 {
     m_pinchGestureInEffect = true;
 }
 
-void ScrollbarAnimationControllerLinearFade::didPinchGestureEndAtTime(double monotonicTime)
+void ScrollbarAnimationControllerLinearFade::didPinchGestureEnd(base::TimeTicks now)
 {
     m_pinchGestureInEffect = false;
-    m_lastAwakenTime = monotonicTime;
+    m_lastAwakenTime = now;
 }
 
-void ScrollbarAnimationControllerLinearFade::updateScrollOffsetAtTime(LayerImpl* scrollLayer, double monotonicTime)
+void ScrollbarAnimationControllerLinearFade::didUpdateScrollOffset(base::TimeTicks now)
 {
-    gfx::Vector2dF previousPos = currentOffset();
-    ScrollbarAnimationController::updateScrollOffsetAtTime(scrollLayer, monotonicTime);
-
-    if (previousPos == currentOffset())
-        return;
-
-    m_lastAwakenTime = monotonicTime;
+    m_lastAwakenTime = now;
 }
 
-float ScrollbarAnimationControllerLinearFade::opacityAtTime(double monotonicTime)
+float ScrollbarAnimationControllerLinearFade::opacityAtTime(base::TimeTicks now)
 {
     if (m_pinchGestureInEffect)
         return 1;
 
-    double delta = monotonicTime - m_lastAwakenTime;
+    if (m_lastAwakenTime.is_null())
+        return 0;
 
+    double delta = (now - m_lastAwakenTime).InSecondsF();
+
     if (delta <= m_fadeoutDelay)
         return 1;
     if (delta < m_fadeoutDelay + m_fadeoutLength)
Index: src/cc/render_pass_draw_quad.h
===================================================================
--- src/cc/render_pass_draw_quad.h	(revision 184497)
+++ src/cc/render_pass_draw_quad.h	(working copy)
@@ -11,12 +11,14 @@
 #include "cc/draw_quad.h"
 #include "cc/render_pass.h"
 #include "cc/resource_provider.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 
 namespace cc {
 
 class CC_EXPORT RenderPassDrawQuad : public DrawQuad {
  public:
   static scoped_ptr<RenderPassDrawQuad> Create();
+  virtual ~RenderPassDrawQuad();
 
   void SetNew(const SharedQuadState* shared_quad_state,
               gfx::Rect rect,
@@ -24,7 +26,10 @@
               bool is_replica,
               ResourceProvider::ResourceId mask_resource_id,
               gfx::Rect contents_changed_since_last_frame,
-              gfx::RectF mask_uv_rect);
+              gfx::RectF mask_uv_rect,
+              const WebKit::WebFilterOperations& filters,
+              skia::RefPtr<SkImageFilter> filter,
+              const WebKit::WebFilterOperations& background_filters);
 
   void SetAll(const SharedQuadState* shared_quad_state,
               gfx::Rect rect,
@@ -35,7 +40,10 @@
               bool is_replica,
               ResourceProvider::ResourceId mask_resource_id,
               gfx::Rect contents_changed_since_last_frame,
-              gfx::RectF mask_uv_rect);
+              gfx::RectF mask_uv_rect,
+              const WebKit::WebFilterOperations& filters,
+              skia::RefPtr<SkImageFilter> filter,
+              const WebKit::WebFilterOperations& background_filters);
 
   scoped_ptr<RenderPassDrawQuad> Copy(
       const SharedQuadState* copied_shared_quad_state,
@@ -47,7 +55,21 @@
   gfx::Rect contents_changed_since_last_frame;
   gfx::RectF mask_uv_rect;
 
+  // Deprecated post-processing filters, applied to the pixels in the render
+  // pass' texture.
+  WebKit::WebFilterOperations filters;
+  // Post-processing filter applied to the pixels in the render pass' texture.
+  skia::RefPtr<SkImageFilter> filter;
+
+  // Post-processing filters, applied to the pixels showing through the
+  // background of the render pass, from behind it.
+  WebKit::WebFilterOperations background_filters;
+
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources)
+      OVERRIDE;
+
   static const RenderPassDrawQuad* MaterialCast(const DrawQuad*);
+
 private:
   RenderPassDrawQuad();
 };
Index: src/cc/layer_tree_host_common.cc
===================================================================
--- src/cc/layer_tree_host_common.cc	(revision 184497)
+++ src/cc/layer_tree_host_common.cc	(working copy)
@@ -7,10 +7,12 @@
 #include <algorithm>
 
 #include "base/debug/trace_event.h"
+#include "cc/heads_up_display_layer_impl.h"
 #include "cc/layer.h"
 #include "cc/layer_impl.h"
 #include "cc/layer_iterator.h"
 #include "cc/layer_sorter.h"
+#include "cc/layer_tree_impl.h"
 #include "cc/math_util.h"
 #include "cc/render_surface.h"
 #include "cc/render_surface_impl.h"
@@ -235,12 +237,19 @@
 // Called on each layer that could be drawn after all information from
 // calcDrawProperties has been updated on that layer.  May have some false
 // positives (e.g. layers get this called on them but don't actually get drawn).
-static inline void markLayerAsUpdated(LayerImpl* layer)
+static inline void updateTilePrioritiesForLayer(LayerImpl* layer)
 {
-    layer->didUpdateTransforms();
+    layer->updateTilePriorities();
+
+    // Mask layers don't get this call, so explicitly update them so they can
+    // kick off tile rasterization.
+    if (layer->maskLayer())
+        layer->maskLayer()->updateTilePriorities();
+    if (layer->replicaLayer() && layer->replicaLayer()->maskLayer())
+      layer->replicaLayer()->maskLayer()->updateTilePriorities();
 }
 
-static inline void markLayerAsUpdated(Layer* layer)
+static inline void updateTilePrioritiesForLayer(Layer* layer)
 {
 }
 
@@ -281,7 +290,9 @@
     }
 
     // If the layer clips its descendants but it is not axis-aligned with respect to its parent.
-    if (layerClipsSubtree(layer) && !axisAlignedWithRespectToParent && numDescendantsThatDrawContent > 0) {
+    bool layerClipsExternalContent = layerClipsSubtree(layer) || layer->hasDelegatedContent();
+    if (layerClipsExternalContent && !axisAlignedWithRespectToParent && !layer->drawProperties().descendants_can_clip_selves)
+    {
         TRACE_EVENT_INSTANT0("cc", "LayerTreeHostCommon::requireSurface clipping");
         return true;
     }
@@ -291,8 +302,7 @@
     // subtree overlap. But checking layer overlaps is unnecessarily costly so
     // instead we conservatively create a surface whenever at least two layers
     // draw content for this subtree.
-    bool atLeastTwoLayersInSubtreeDrawContent = layer->hasDelegatedContent() ||
-        (numDescendantsThatDrawContent > 0 && (layer->drawsContent() || numDescendantsThatDrawContent > 1));
+    bool atLeastTwoLayersInSubtreeDrawContent = numDescendantsThatDrawContent > 0 && (layer->drawsContent() || numDescendantsThatDrawContent > 1);
 
     if (layer->opacity() != 1 && !layer->preserves3D() && atLeastTwoLayersInSubtreeDrawContent) {
         TRACE_EVENT_INSTANT0("cc", "LayerTreeHostCommon::requireSurface opacity");
@@ -396,8 +406,44 @@
     return nextScrollCompensationMatrix;
 }
 
+template<typename LayerType>
+static inline void calculateContentsScale(LayerType* layer, float contentsScale, bool animatingTransformToScreen)
+{
+    layer->calculateContentsScale(
+        contentsScale,
+        animatingTransformToScreen,
+        &layer->drawProperties().contents_scale_x,
+        &layer->drawProperties().contents_scale_y,
+        &layer->drawProperties().content_bounds);
+
+    LayerType* maskLayer = layer->maskLayer();
+    if (maskLayer)
+    {
+        maskLayer->calculateContentsScale(
+            contentsScale,
+            animatingTransformToScreen,
+            &maskLayer->drawProperties().contents_scale_x,
+            &maskLayer->drawProperties().contents_scale_y,
+            &maskLayer->drawProperties().content_bounds);
+    }
+
+    LayerType* replicaMaskLayer = layer->replicaLayer() ? layer->replicaLayer()->maskLayer() : 0;
+    if (replicaMaskLayer)
+    {
+        replicaMaskLayer->calculateContentsScale(
+            contentsScale,
+            animatingTransformToScreen,
+            &replicaMaskLayer->drawProperties().contents_scale_x,
+            &replicaMaskLayer->drawProperties().contents_scale_y,
+            &replicaMaskLayer->drawProperties().content_bounds);
+    }
+}
+
 static inline void updateLayerContentsScale(LayerImpl* layer, const gfx::Transform& combinedTransform, float deviceScaleFactor, float pageScaleFactor, bool animatingTransformToScreen)
 {
+    gfx::Vector2dF transformScale = MathUtil::computeTransform2dScaleComponents(combinedTransform, deviceScaleFactor * pageScaleFactor);
+    float contentsScale = std::max(transformScale.x(), transformScale.y());
+    calculateContentsScale(layer, contentsScale, animatingTransformToScreen);
 }
 
 static inline void updateLayerContentsScale(Layer* layer, const gfx::Transform& combinedTransform, float deviceScaleFactor, float pageScaleFactor, bool animatingTransformToScreen)
@@ -434,31 +480,8 @@
     float contentsScale = rasterScale * deviceScaleFactor;
     if (!layer->boundsContainPageScale())
         contentsScale *= pageScaleFactor;
-    layer->calculateContentsScale(
-        contentsScale,
-        &layer->drawProperties().contents_scale_x,
-        &layer->drawProperties().contents_scale_y,
-        &layer->drawProperties().content_bounds);
 
-    Layer* maskLayer = layer->maskLayer();
-    if (maskLayer)
-    {
-        maskLayer->calculateContentsScale(
-            contentsScale,
-            &maskLayer->drawProperties().contents_scale_x,
-            &maskLayer->drawProperties().contents_scale_y,
-            &maskLayer->drawProperties().content_bounds);
-    }
-
-    Layer* replicaMaskLayer = layer->replicaLayer() ? layer->replicaLayer()->maskLayer() : 0;
-    if (replicaMaskLayer)
-    {
-        replicaMaskLayer->calculateContentsScale(
-            contentsScale,
-            &replicaMaskLayer->drawProperties().contents_scale_x,
-            &replicaMaskLayer->drawProperties().contents_scale_y,
-            &replicaMaskLayer->drawProperties().content_bounds);
-    }
+    calculateContentsScale(layer, contentsScale, animatingTransformToScreen);
 }
 
 template<typename LayerType, typename LayerList>
@@ -485,16 +508,35 @@
 template<typename LayerType>
 static void preCalculateMetaInformation(LayerType* layer)
 {
+    if (layer->hasDelegatedContent()) {
+        // Layers with delegated content need to be treated as if they have as many children as the number
+        // of layers they own delegated quads for. Since we don't know this number right now, we choose
+        // one that acts like infinity for our purposes.
+        layer->drawProperties().num_descendants_that_draw_content = 1000;
+        layer->drawProperties().descendants_can_clip_selves = false;
+        return;
+    }
+
     int numDescendantsThatDrawContent = 0;
+    bool descendantsCanClipSelves = true;
+    bool sublayerTransformPreventsClip = !layer->sublayerTransform().IsPositiveScaleOrTranslation();
 
     for (size_t i = 0; i < layer->children().size(); ++i) {
         LayerType* childLayer = layer->children()[i];
         preCalculateMetaInformation<LayerType>(childLayer);
+
         numDescendantsThatDrawContent += childLayer->drawsContent() ? 1 : 0;
         numDescendantsThatDrawContent += childLayer->drawProperties().num_descendants_that_draw_content;
+
+        if ((childLayer->drawsContent() && !childLayer->canClipSelf()) ||
+            !childLayer->drawProperties().descendants_can_clip_selves ||
+            sublayerTransformPreventsClip ||
+            !childLayer->transform().IsPositiveScaleOrTranslation())
+            descendantsCanClipSelves = false;
     }
 
     layer->drawProperties().num_descendants_that_draw_content = numDescendantsThatDrawContent;
+    layer->drawProperties().descendants_can_clip_selves = descendantsCanClipSelves;
 }
 
 // Recursively walks the layer tree starting at the given node and computes all the
@@ -505,7 +547,7 @@
     const gfx::Rect& clipRectFromAncestor, const gfx::Rect& clipRectFromAncestorInDescendantSpace, bool ancestorClipsSubtree,
     RenderSurfaceType* nearestAncestorThatMovesPixels, LayerList& renderSurfaceLayerList, LayerList& layerList,
     LayerSorter* layerSorter, int maxTextureSize, float deviceScaleFactor, float pageScaleFactor, bool subtreeCanUseLCDText,
-    gfx::Rect& drawableContentRectOfSubtree)
+    gfx::Rect& drawableContentRectOfSubtree, bool updateTilePriorities)
 {
     // This function computes the new matrix transformations recursively for this
     // layer and all its descendants. It also computes the appropriate render surfaces.
@@ -671,7 +713,7 @@
     // layerScreenSpaceTransform represents the transform between root layer's "screen space" and local content space.
     layerDrawProperties.screen_space_transform = fullHierarchyMatrix;
     if (!layer->preserves3D())
-        MathUtil::flattenTransformTo2d(layerDrawProperties.screen_space_transform);
+        layerDrawProperties.screen_space_transform.FlattenTo2d();
     layerDrawProperties.screen_space_transform.PreconcatTransform(layerDrawProperties.target_space_transform);
 
     // Adjusting text AA method during animation may cause repaints, which in-turn causes jank.
@@ -825,7 +867,7 @@
 
     // Flatten to 2D if the layer doesn't preserve 3D.
     if (!layer->preserves3D())
-        MathUtil::flattenTransformTo2d(sublayerMatrix);
+        sublayerMatrix.FlattenTo2d();
 
     // Apply the sublayer transform at the center of the layer.
     if (!layer->sublayerTransform().IsIdentity()) {
@@ -851,7 +893,7 @@
         calculateDrawPropertiesInternal<LayerType, LayerList, RenderSurfaceType>(child, sublayerMatrix, nextHierarchyMatrix, nextScrollCompensationMatrix,
                                                                                  clipRectForSubtree, clipRectForSubtreeInDescendantSpace, subtreeShouldBeClipped, nearestAncestorThatMovesPixels,
                                                                                  renderSurfaceLayerList, descendants, layerSorter, maxTextureSize, deviceScaleFactor, pageScaleFactor,
-                                                                                 subtreeCanUseLCDText, drawableContentRectOfChildSubtree);
+                                                                                 subtreeCanUseLCDText, drawableContentRectOfChildSubtree, updateTilePriorities);
         if (!drawableContentRectOfChildSubtree.IsEmpty()) {
             accumulatedDrawableContentRectOfChildren.Union(drawableContentRectOfChildSubtree);
             if (child->renderSurface())
@@ -951,7 +993,8 @@
         }
     }
 
-    markLayerAsUpdated(layer);
+    if (updateTilePriorities)
+        updateTilePrioritiesForLayer(layer);
 
     // If neither this layer nor any of its children were added, early out.
     if (sortingStartIndex == descendants.size())
@@ -983,6 +1026,7 @@
     // The root layer's renderSurface should receive the deviceViewport as the initial clipRect.
     bool subtreeShouldBeClipped = true;
     gfx::Rect deviceViewportRect(gfx::Point(), deviceViewportSize);
+    bool updateTilePriorities = false;
 
     // This function should have received a root layer.
     DCHECK(isRootLayer(rootLayer));
@@ -992,7 +1036,8 @@
         rootLayer, deviceScaleTransform, identityMatrix, identityMatrix,
         deviceViewportRect, deviceViewportRect, subtreeShouldBeClipped, 0, renderSurfaceLayerList,
         dummyLayerList, 0, maxTextureSize,
-        deviceScaleFactor, pageScaleFactor, canUseLCDText, totalDrawableContentRect);
+        deviceScaleFactor, pageScaleFactor, canUseLCDText, totalDrawableContentRect,
+        updateTilePriorities);
 
     // The dummy layer list should not have been used.
     DCHECK(dummyLayerList.size() == 0);
@@ -1000,7 +1045,7 @@
     DCHECK(rootLayer->renderSurface());
 }
 
-void LayerTreeHostCommon::calculateDrawProperties(LayerImpl* rootLayer, const gfx::Size& deviceViewportSize, float deviceScaleFactor, float pageScaleFactor, int maxTextureSize, bool canUseLCDText, std::vector<LayerImpl*>& renderSurfaceLayerList)
+void LayerTreeHostCommon::calculateDrawProperties(LayerImpl* rootLayer, const gfx::Size& deviceViewportSize, float deviceScaleFactor, float pageScaleFactor, int maxTextureSize, bool canUseLCDText, std::vector<LayerImpl*>& renderSurfaceLayerList, bool updateTilePriorities)
 {
     gfx::Rect totalDrawableContentRect;
     gfx::Transform identityMatrix;
@@ -1021,7 +1066,8 @@
         rootLayer, deviceScaleTransform, identityMatrix, identityMatrix,
         deviceViewportRect, deviceViewportRect, subtreeShouldBeClipped, 0, renderSurfaceLayerList,
         dummyLayerList, &layerSorter, maxTextureSize,
-        deviceScaleFactor, pageScaleFactor, canUseLCDText, totalDrawableContentRect);
+        deviceScaleFactor, pageScaleFactor, canUseLCDText, totalDrawableContentRect,
+        updateTilePriorities);
 
     // The dummy layer list should not have been used.
     DCHECK(dummyLayerList.size() == 0);
@@ -1088,7 +1134,7 @@
     return false;
 }
 
-LayerImpl* LayerTreeHostCommon::findLayerThatIsHitByPoint(const gfx::PointF& screenSpacePoint, std::vector<LayerImpl*>& renderSurfaceLayerList)
+LayerImpl* LayerTreeHostCommon::findLayerThatIsHitByPoint(const gfx::PointF& screenSpacePoint, const std::vector<LayerImpl*>& renderSurfaceLayerList)
 {
     LayerImpl* foundLayer = 0;
 
@@ -1112,6 +1158,10 @@
         if (pointIsClippedBySurfaceOrClipRect(screenSpacePoint, currentLayer))
             continue;
 
+        // Skip the HUD layer.
+        if (currentLayer == currentLayer->layerTreeImpl()->hud_layer())
+            continue;
+
         foundLayer = currentLayer;
         break;
     }
@@ -1120,7 +1170,7 @@
     return foundLayer;
 }
 
-LayerImpl* LayerTreeHostCommon::findLayerThatIsHitByPointInTouchHandlerRegion(const gfx::PointF& screenSpacePoint, std::vector<LayerImpl*>& renderSurfaceLayerList)
+LayerImpl* LayerTreeHostCommon::findLayerThatIsHitByPointInTouchHandlerRegion(const gfx::PointF& screenSpacePoint, const std::vector<LayerImpl*>& renderSurfaceLayerList)
 {
     LayerImpl* foundLayer = 0;
 
Index: src/cc/picture_layer.cc
===================================================================
--- src/cc/picture_layer.cc	(revision 184497)
+++ src/cc/picture_layer.cc	(working copy)
@@ -15,7 +15,9 @@
 }
 
 PictureLayer::PictureLayer(ContentLayerClient* client) :
-  client_(client) {
+  client_(client),
+  pile_(make_scoped_refptr(new PicturePile())),
+  is_mask_(false) {
 }
 
 PictureLayer::~PictureLayer() {
@@ -33,40 +35,50 @@
   Layer::pushPropertiesTo(base_layer);
 
   PictureLayerImpl* layer_impl = static_cast<PictureLayerImpl*>(base_layer);
-  layer_impl->tilings_.SetLayerBounds(bounds());
+  layer_impl->SetIsMask(is_mask_);
+  layer_impl->CreateTilingSet();
   layer_impl->invalidation_.Clear();
   layer_impl->invalidation_.Swap(pile_invalidation_);
-  pile_.PushPropertiesTo(layer_impl->pile_);
+  pile_->PushPropertiesTo(layer_impl->pile_);
 
-  // TODO(enne): Remove this once syncing happens to the pending tree rather
-  // than the active one.
-  if (layer_impl->layerTreeImpl()->IsActiveTree()) {
-    layer_impl->tilings_.Invalidate(layer_impl->invalidation_);
-    return;
-  }
-
   layer_impl->SyncFromActiveLayer();
 }
 
+void PictureLayer::setLayerTreeHost(LayerTreeHost* host) {
+  Layer::setLayerTreeHost(host);
+  if (host)
+      pile_->SetMinContentsScale(host->settings().minimumContentsScale);
+}
+
 void PictureLayer::setNeedsDisplayRect(const gfx::RectF& layer_rect) {
   gfx::Rect rect = gfx::ToEnclosedRect(layer_rect);
-  pending_invalidation_.Union(rect);
+  if (!rect.IsEmpty()) {
+    // Clamp invalidation to the layer bounds.
+    rect.Intersect(gfx::Rect(bounds()));
+    pending_invalidation_.Union(rect);
+  }
   Layer::setNeedsDisplayRect(layer_rect);
 }
 
 void PictureLayer::update(ResourceUpdateQueue&, const OcclusionTracker*,
                     RenderingStats& stats) {
-  if (pile_.size() == bounds() && pending_invalidation_.IsEmpty())
-    return;
+  // Do not early-out of this function so that PicturePile::Update has a chance
+  // to record pictures due to changing visibility of this layer.
 
-  pile_.Resize(bounds());
+  pile_->Resize(bounds());
 
   // Calling paint in WebKit can sometimes cause invalidations, so save
   // off the invalidation prior to calling update.
   pile_invalidation_.Swap(pending_invalidation_);
   pending_invalidation_.Clear();
 
-  pile_.Update(client_, pile_invalidation_, stats);
+  gfx::Rect visible_layer_rect = gfx::ToEnclosingRect(
+      gfx::ScaleRect(visibleContentRect(), 1.f / contentsScaleX()));
+  pile_->Update(client_, pile_invalidation_, visible_layer_rect, stats);
 }
 
+void PictureLayer::setIsMask(bool is_mask) {
+  is_mask_ = is_mask;
+}
+
 }  // namespace cc
Index: src/cc/content_layer.h
===================================================================
--- src/cc/content_layer.h	(revision 184497)
+++ src/cc/content_layer.h	(working copy)
@@ -21,7 +21,7 @@
 public:
     static scoped_ptr<ContentLayerPainter> create(ContentLayerClient*);
 
-    virtual void paint(SkCanvas*, const gfx::Rect& contentRect, gfx::RectF& opaque) OVERRIDE;
+    virtual void paint(SkCanvas*, gfx::Rect contentRect, gfx::RectF& opaque) OVERRIDE;
 
 private:
     explicit ContentLayerPainter(ContentLayerClient*);
Index: src/cc/picture_layer.h
===================================================================
--- src/cc/picture_layer.h	(revision 184497)
+++ src/cc/picture_layer.h	(working copy)
@@ -17,8 +17,8 @@
 struct RenderingStats;
 
 class CC_EXPORT PictureLayer : public ContentsScalingLayer {
-public:
-  static scoped_refptr<PictureLayer> create(ContentLayerClient*);
+ public:
+  static scoped_refptr<PictureLayer> create(ContentLayerClient* client);
 
   void clearClient() { client_ = 0; }
 
@@ -26,22 +26,27 @@
   virtual bool drawsContent() const OVERRIDE;
   virtual scoped_ptr<LayerImpl> createLayerImpl(
       LayerTreeImpl* treeImpl) OVERRIDE;
-  virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+  virtual void setLayerTreeHost(LayerTreeHost* host) OVERRIDE;
+  virtual void pushPropertiesTo(LayerImpl* layer) OVERRIDE;
   virtual void setNeedsDisplayRect(const gfx::RectF& layerRect) OVERRIDE;
-  virtual void update(ResourceUpdateQueue&, const OcclusionTracker*,
-                      RenderingStats&) OVERRIDE;
+  virtual void update(
+      ResourceUpdateQueue& queue,
+      const OcclusionTracker* occlusion,
+      RenderingStats& stats) OVERRIDE;
+  virtual void setIsMask(bool is_mask) OVERRIDE;
 
-protected:
-  explicit PictureLayer(ContentLayerClient*);
+ protected:
+  explicit PictureLayer(ContentLayerClient* client);
   virtual ~PictureLayer();
 
-private:
+ private:
   ContentLayerClient* client_;
-  PicturePile pile_;
+  scoped_refptr<PicturePile> pile_;
   // Invalidation to use the next time update is called.
   Region pending_invalidation_;
   // Invalidation from the last time update was called.
   Region pile_invalidation_;
+  bool is_mask_;
 };
 
 }  // namespace cc
Index: src/cc/compositor_frame_metadata.h
===================================================================
--- src/cc/compositor_frame_metadata.h	(revision 184497)
+++ src/cc/compositor_frame_metadata.h	(working copy)
@@ -29,9 +29,10 @@
   float min_page_scale_factor;
   float max_page_scale_factor;
 
-  // Used to position the Android location top bar, whose precise
-  // position is computed by the renderer compositor.
+  // Used to position the Android location top bar and page content, whose
+  // precise position is computed by the renderer compositor.
   gfx::Vector2dF location_bar_offset;
+  gfx::Vector2dF location_bar_content_translation;
 };
 
 }  // namespace cc
Index: src/cc/layer.cc
===================================================================
--- src/cc/layer.cc	(revision 184497)
+++ src/cc/layer.cc	(working copy)
@@ -4,19 +4,18 @@
 
 #include "cc/layer.h"
 
-#include "cc/active_animation.h"
+#include "cc/animation.h"
 #include "cc/animation_events.h"
 #include "cc/layer_animation_controller.h"
 #include "cc/layer_impl.h"
 #include "cc/layer_tree_host.h"
+#include "cc/layer_tree_impl.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebAnimationDelegate.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayerScrollClient.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
 #include "third_party/skia/include/core/SkImageFilter.h"
 #include "ui/gfx/rect_conversions.h"
-#include <public/WebAnimationDelegate.h>
-#include <public/WebLayerScrollClient.h>
-#include <public/WebSize.h>
 
-using namespace std;
-
 namespace cc {
 
 static int s_nextLayerId = 1;
@@ -33,12 +32,9 @@
     , m_ignoreSetNeedsCommit(false)
     , m_parent(0)
     , m_layerTreeHost(0)
-    , m_layerAnimationController(LayerAnimationController::create(this))
     , m_scrollable(false)
     , m_shouldScrollOnMainThread(false)
     , m_haveWheelEventHandlers(false)
-    , m_nonFastScrollableRegionChanged(false)
-    , m_touchEventHandlerRegionChanged(false)
     , m_anchorPoint(0.5, 0.5)
     , m_backgroundColor(0)
     , m_opacity(1.0)
@@ -65,7 +61,9 @@
         m_layerId = s_nextLayerId++;
     }
 
-    addLayerAnimationObserver(m_layerAnimationController.get());
+    m_layerAnimationController = LayerAnimationController::create(m_layerId);
+    m_layerAnimationController->addObserver(this);
+    addLayerAnimationEventObserver(m_layerAnimationController.get());
 }
 
 Layer::~Layer()
@@ -74,6 +72,8 @@
     // way for us to be destroyed while we still have a parent.
     DCHECK(!parent());
 
+    m_layerAnimationController->removeObserver(this);
+
     // Remove the parent reference from all children.
     removeAllChildren();
 }
@@ -93,9 +93,10 @@
     if (m_replicaLayer)
         m_replicaLayer->setLayerTreeHost(host);
 
-    // If this layer already has active animations, the host needs to be notified.
-    if (host && m_layerAnimationController->hasActiveAnimation())
-        host->didAddAnimation();
+    m_layerAnimationController->setAnimationRegistrar(host ? host->animationRegistrar() : 0);
+
+    if (host && m_layerAnimationController->hasAnyAnimation())
+        host->setNeedsCommit();
 }
 
 void Layer::setNeedsCommit()
@@ -126,6 +127,27 @@
     return false;
 }
 
+bool Layer::canClipSelf() const
+{
+    return false;
+}
+
+bool Layer::blocksPendingCommitRecursive() const
+{
+    if (blocksPendingCommit())
+        return true;
+    if (maskLayer() && maskLayer()->blocksPendingCommitRecursive())
+        return true;
+    if (replicaLayer() && replicaLayer()->blocksPendingCommitRecursive())
+        return true;
+    for (size_t i = 0; i < m_children.size(); ++i)
+    {
+        if (m_children[i]->blocksPendingCommitRecursive())
+            return true;
+    }
+    return false;
+}
+
 void Layer::setParent(Layer* layer)
 {
     DCHECK(!layer || !layer->hasAncestor(this));
@@ -146,7 +168,7 @@
 
 void Layer::addChild(scoped_refptr<Layer> child)
 {
-    insertChild(child, numChildren());
+    insertChild(child, m_children.size());
 }
 
 void Layer::insertChild(scoped_refptr<Layer> child, size_t index)
@@ -155,9 +177,8 @@
     child->setParent(this);
     child->m_stackingOrderChanged = true;
 
-    index = min(index, m_children.size());
-    LayerList::iterator iter = m_children.begin();
-    m_children.insert(iter + index, child);
+    index = std::min(index, m_children.size());
+    m_children.insert(m_children.begin() + index, child);
     setNeedsFullTreeSync();
 }
 
@@ -205,7 +226,7 @@
 
 int Layer::indexOfChild(const Layer* reference)
 {
-    for (size_t i = 0; i < m_children.size(); i++) {
+    for (size_t i = 0; i < m_children.size(); ++i) {
         if (m_children[i] == reference)
             return i;
     }
@@ -257,11 +278,16 @@
         return;
 
     removeAllChildren();
-    size_t listSize = children.size();
-    for (size_t i = 0; i < listSize; i++)
+    for (size_t i = 0; i < children.size(); ++i)
         addChild(children[i]);
 }
 
+Layer* Layer::childAt(size_t index)
+{
+  DCHECK_LT(index, m_children.size());
+  return m_children[index].get();
+}
+
 void Layer::setAnchorPoint(const gfx::PointF& anchorPoint)
 {
     if (m_anchorPoint == anchorPoint)
@@ -288,6 +314,7 @@
 
 void Layer::calculateContentsScale(
     float idealContentsScale,
+    bool animatingTransformToScreen,
     float* contentsScaleX,
     float* contentsScaleY,
     gfx::Size* contentBounds)
@@ -363,11 +390,6 @@
         LayerTreeHost::setNeedsFilterContext(true);
 }
 
-bool Layer::needsDisplay() const
-{
-    return m_needsDisplay;
-}
-
 void Layer::setOpacity(float opacity)
 {
     if (m_opacity == opacity)
@@ -376,9 +398,14 @@
     setNeedsCommit();
 }
 
+float Layer::opacity() const
+{
+    return m_opacity;
+}
+
 bool Layer::opacityIsAnimating() const
 {
-    return m_layerAnimationController->isAnimatingProperty(ActiveAnimation::Opacity);
+    return m_layerAnimationController->isAnimatingProperty(Animation::Opacity);
 }
 
 void Layer::setContentsOpaque(bool opaque)
@@ -386,7 +413,7 @@
     if (m_contentsOpaque == opaque)
         return;
     m_contentsOpaque = opaque;
-    setNeedsDisplay();
+    setNeedsCommit();
 }
 
 void Layer::setPosition(const gfx::PointF& position)
@@ -413,9 +440,14 @@
     setNeedsCommit();
 }
 
+const gfx::Transform& Layer::transform() const
+{
+    return m_transform;
+}
+
 bool Layer::transformIsAnimating() const
 {
-    return m_layerAnimationController->isAnimatingProperty(ActiveAnimation::Transform);
+    return m_layerAnimationController->isAnimatingProperty(Animation::Transform);
 }
 
 void Layer::setScrollOffset(gfx::Vector2d scrollOffset)
@@ -425,7 +457,7 @@
     m_scrollOffset = scrollOffset;
     if (m_layerScrollClient)
         m_layerScrollClient->didScroll();
-    setNeedsFullTreeSync();
+    setNeedsCommit();
 }
 
 void Layer::setMaxScrollOffset(gfx::Vector2d maxScrollOffset)
@@ -465,7 +497,6 @@
     if (m_nonFastScrollableRegion == region)
         return;
     m_nonFastScrollableRegion = region;
-    m_nonFastScrollableRegionChanged = true;
     setNeedsCommit();
 }
 
@@ -474,7 +505,6 @@
     if (m_touchEventHandlerRegion == region)
         return;
     m_touchEventHandlerRegion = region;
-    m_touchEventHandlerRegionChanged = true;
 }
 
 void Layer::setDrawCheckerboardForMissingTiles(bool checkerboard)
@@ -521,14 +551,12 @@
 void Layer::setNeedsDisplayRect(const gfx::RectF& dirtyRect)
 {
     m_updateRect.Union(dirtyRect);
+    m_needsDisplay = true;
 
     // Simply mark the contents as dirty. For non-root layers, the call to
     // setNeedsCommit will schedule a fresh compositing pass.
     // For the root layer, setNeedsCommit has no effect.
-    if (!dirtyRect.IsEmpty())
-        m_needsDisplay = true;
-
-    if (drawsContent())
+    if (drawsContent() && !m_updateRect.IsEmpty())
         setNeedsCommit();
 }
 
@@ -580,19 +608,10 @@
     layer->setFilter(filter());
     layer->setBackgroundFilters(backgroundFilters());
     layer->setMasksToBounds(m_masksToBounds);
-    layer->setScrollable(m_scrollable);
     layer->setShouldScrollOnMainThread(m_shouldScrollOnMainThread);
     layer->setHaveWheelEventHandlers(m_haveWheelEventHandlers);
-    // Copying a Region is more expensive than most layer properties, since it involves copying two Vectors that may be
-    // arbitrarily large depending on page content, so we only push the property if it's changed.
-    if (m_nonFastScrollableRegionChanged) {
-        layer->setNonFastScrollableRegion(m_nonFastScrollableRegion);
-        m_nonFastScrollableRegionChanged = false;
-    }
-    if (m_touchEventHandlerRegionChanged) {
-        layer->setTouchEventHandlerRegion(m_touchEventHandlerRegion);
-        m_touchEventHandlerRegionChanged = false;
-    }
+    layer->setNonFastScrollableRegion(m_nonFastScrollableRegion);
+    layer->setTouchEventHandlerRegion(m_touchEventHandlerRegion);
     layer->setContentsOpaque(m_contentsOpaque);
     if (!opacityIsAnimating())
         layer->setOpacity(m_opacity);
@@ -601,28 +620,37 @@
     layer->setFixedToContainerLayer(m_fixedToContainerLayer);
     layer->setPreserves3D(preserves3D());
     layer->setUseParentBackfaceVisibility(m_useParentBackfaceVisibility);
-    layer->setScrollOffset(m_scrollOffset);
-    layer->setMaxScrollOffset(m_maxScrollOffset);
     layer->setSublayerTransform(m_sublayerTransform);
     if (!transformIsAnimating())
         layer->setTransform(m_transform);
 
+    layer->setScrollable(m_scrollable);
+    layer->setScrollOffset(m_scrollOffset);
+    layer->setMaxScrollOffset(m_maxScrollOffset);
+
     // If the main thread commits multiple times before the impl thread actually draws, then damage tracking
     // will become incorrect if we simply clobber the updateRect here. The LayerImpl's updateRect needs to
     // accumulate (i.e. union) any update changes that have occurred on the main thread.
     m_updateRect.Union(layer->updateRect());
     layer->setUpdateRect(m_updateRect);
 
-    layer->setScrollDelta(layer->scrollDelta() - layer->sentScrollDelta());
-    layer->setSentScrollDelta(gfx::Vector2d());
+    if (layer->layerTreeImpl()->settings().implSidePainting) {
+        DCHECK(layer->layerTreeImpl()->IsPendingTree());
+        LayerImpl* active_twin = layer->layerTreeImpl()->FindActiveTreeLayerById(id());
+        // Update the scroll delta from the active layer, which may have
+        // adjusted its scroll delta prior to this pending layer being created.
+        // This code is identical to that in LayerImpl::setScrollDelta.
+        if (active_twin) {
+            DCHECK(layer->sentScrollDelta().IsZero());
+            layer->setScrollDelta(active_twin->scrollDelta() - active_twin->sentScrollDelta());
+        }
+    } else {
+        layer->setScrollDelta(layer->scrollDelta() - layer->sentScrollDelta());
+        layer->setSentScrollDelta(gfx::Vector2d());
+    }
 
     layer->setStackingOrderChanged(m_stackingOrderChanged);
 
-    if (maskLayer())
-        maskLayer()->pushPropertiesTo(layer->maskLayer());
-    if (replicaLayer())
-        replicaLayer()->pushPropertiesTo(layer->replicaLayer());
-
     m_layerAnimationController->pushAnimationUpdatesTo(layer->layerAnimationController());
 
     // Reset any state that should be cleared for the next update.
@@ -679,8 +707,10 @@
 {
     if (!m_automaticallyComputeRasterScale)
         return;
+    if (!m_rasterScale)
+        return;
     m_rasterScale = 0;
-    setNeedsDisplay();
+    setNeedsCommit();
 }
 
 void Layer::setBoundsContainPageScale(bool boundsContainPageScale)
@@ -707,34 +737,29 @@
     return m_layerId;
 }
 
-float Layer::opacity() const
+void Layer::OnOpacityAnimated(float opacity)
 {
-    return m_opacity;
-}
-
-void Layer::setOpacityFromAnimation(float opacity)
-{
     // This is called due to an ongoing accelerated animation. Since this animation is
     // also being run on the impl thread, there is no need to request a commit to push
     // this value over, so set the value directly rather than calling setOpacity.
     m_opacity = opacity;
 }
 
-const gfx::Transform& Layer::transform() const
+void Layer::OnTransformAnimated(const gfx::Transform& transform)
 {
-    return m_transform;
-}
-
-void Layer::setTransformFromAnimation(const gfx::Transform& transform)
-{
     // This is called due to an ongoing accelerated animation. Since this animation is
     // also being run on the impl thread, there is no need to request a commit to push
     // this value over, so set this value directly rather than calling setTransform.
     m_transform = transform;
 }
 
-bool Layer::addAnimation(scoped_ptr <ActiveAnimation> animation)
+bool Layer::IsActive() const
 {
+    return true;
+}
+
+bool Layer::addAnimation(scoped_ptr <Animation> animation)
+{
     // WebCore currently assumes that accelerated animations will start soon
     // after the animation is added. However we cannot guarantee that if we do
     // not have a layerTreeHost that will setNeedsCommit().
@@ -752,10 +777,7 @@
 #endif
 
     m_layerAnimationController->addAnimation(animation.Pass());
-    if (m_layerTreeHost) {
-        m_layerTreeHost->didAddAnimation();
-        setNeedsCommit();
-    }
+    setNeedsCommit();
     return true;
 }
 
@@ -783,25 +805,24 @@
     setNeedsCommit();
 }
 
-void Layer::setLayerAnimationController(scoped_ptr<LayerAnimationController> layerAnimationController)
+void Layer::setLayerAnimationController(scoped_refptr<LayerAnimationController> layerAnimationController)
 {
-    if (m_layerAnimationController)
-        removeLayerAnimationObserver(m_layerAnimationController.get());
-
-    m_layerAnimationController = layerAnimationController.Pass();
-    if (m_layerAnimationController) {
-        m_layerAnimationController->setClient(this);
-        m_layerAnimationController->setForceSync();
-        addLayerAnimationObserver(m_layerAnimationController.get());
-    }
+    removeLayerAnimationEventObserver(m_layerAnimationController.get());
+    m_layerAnimationController->removeObserver(this);
+    m_layerAnimationController = layerAnimationController;
+    m_layerAnimationController->setForceSync();
+    m_layerAnimationController->addObserver(this);
+    addLayerAnimationEventObserver(m_layerAnimationController.get());
     setNeedsCommit();
 }
 
-scoped_ptr<LayerAnimationController> Layer::releaseLayerAnimationController()
+scoped_refptr<LayerAnimationController> Layer::releaseLayerAnimationController()
 {
-    scoped_ptr<LayerAnimationController> toReturn = m_layerAnimationController.Pass();
-    m_layerAnimationController = LayerAnimationController::create(this);
-    return toReturn.Pass();
+    m_layerAnimationController->removeObserver(this);
+    scoped_refptr<LayerAnimationController> toReturn = m_layerAnimationController;
+    m_layerAnimationController = LayerAnimationController::create(id());
+    m_layerAnimationController->addObserver(this);
+    return toReturn;
 }
 
 bool Layer::hasActiveAnimation() const
@@ -811,7 +832,7 @@
 
 void Layer::notifyAnimationStarted(const AnimationEvent& event, double wallClockTime)
 {
-    FOR_EACH_OBSERVER(LayerAnimationObserver, m_layerAnimationObservers,
+    FOR_EACH_OBSERVER(LayerAnimationEventObserver, m_layerAnimationObservers,
                       OnAnimationStarted(event));
     if (m_layerAnimationDelegate)
         m_layerAnimationDelegate->notifyAnimationStarted(wallClockTime);
@@ -823,13 +844,13 @@
         m_layerAnimationDelegate->notifyAnimationFinished(wallClockTime);
 }
 
-void Layer::addLayerAnimationObserver(LayerAnimationObserver* animationObserver)
+void Layer::addLayerAnimationEventObserver(LayerAnimationEventObserver* animationObserver)
 {
     if (!m_layerAnimationObservers.HasObserver(animationObserver))
         m_layerAnimationObservers.AddObserver(animationObserver);
 }
 
-void Layer::removeLayerAnimationObserver(LayerAnimationObserver* animationObserver)
+void Layer::removeLayerAnimationEventObserver(LayerAnimationEventObserver* animationObserver)
 {
     m_layerAnimationObservers.RemoveObserver(animationObserver);
 }
Index: src/cc/shared_quad_state.cc
===================================================================
--- src/cc/shared_quad_state.cc	(revision 184497)
+++ src/cc/shared_quad_state.cc	(working copy)
@@ -21,13 +21,11 @@
 void SharedQuadState::SetAll(
     const gfx::Transform& content_to_target_transform,
     const gfx::Rect& visible_content_rect,
-    const gfx::Rect& clipped_rect_in_target,
     const gfx::Rect& clip_rect,
     bool is_clipped,
     float opacity) {
   this->content_to_target_transform = content_to_target_transform;
   this->visible_content_rect = visible_content_rect;
-  this->clipped_rect_in_target = clipped_rect_in_target;
   this->clip_rect = clip_rect;
   this->is_clipped = is_clipped;
   this->opacity = opacity;
Index: src/cc/layer_animation_observer.h
===================================================================
--- src/cc/layer_animation_observer.h	(revision 184497)
+++ src/cc/layer_animation_observer.h	(working copy)
@@ -1,18 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CC_LAYER_ANIMATION_OBSERVER_H_
-#define CC_LAYER_ANIMATION_OBSERVER_H_
-
-namespace cc {
-
-class CC_EXPORT LayerAnimationObserver {
- public:
-  virtual void OnAnimationStarted(const AnimationEvent& event) = 0;
-};
-
-} // namespace cc
-
-#endif  // CC_LAYER_ANIMATION_OBSERVER_H_
-
Index: src/cc/math_util_unittest.cc
===================================================================
--- src/cc/math_util_unittest.cc	(revision 184497)
+++ src/cc/math_util_unittest.cc	(working copy)
@@ -16,70 +16,6 @@
 namespace cc {
 namespace {
 
-TEST(MathUtilTest, verifyBackfaceVisibilityBasicCases)
-{
-    gfx::Transform transform;
-
-    transform.MakeIdentity();
-    EXPECT_FALSE(transform.IsBackFaceVisible());
-
-    transform.MakeIdentity();
-    MathUtil::rotateEulerAngles(&transform, 0, 80, 0);
-    EXPECT_FALSE(transform.IsBackFaceVisible());
-
-    transform.MakeIdentity();
-    MathUtil::rotateEulerAngles(&transform, 0, 100, 0);
-    EXPECT_TRUE(transform.IsBackFaceVisible());
-
-    // Edge case, 90 degree rotation should return false.
-    transform.MakeIdentity();
-    MathUtil::rotateEulerAngles(&transform, 0, 90, 0);
-    EXPECT_FALSE(transform.IsBackFaceVisible());
-}
-
-TEST(MathUtilTest, verifyBackfaceVisibilityForPerspective)
-{
-    gfx::Transform layerSpaceToProjectionPlane;
-
-    // This tests if IsBackFaceVisible works properly under perspective transforms.
-    // Specifically, layers that may have their back face visible in orthographic
-    // projection, may not actually have back face visible under perspective projection.
-
-    // Case 1: Layer is rotated by slightly more than 90 degrees, at the center of the
-    //         prespective projection. In this case, the layer's back-side is visible to
-    //         the camera.
-    layerSpaceToProjectionPlane.MakeIdentity();
-    layerSpaceToProjectionPlane.ApplyPerspectiveDepth(1);
-    layerSpaceToProjectionPlane.Translate3d(0, 0, 0);
-    MathUtil::rotateEulerAngles(&layerSpaceToProjectionPlane, 0, 100, 0);
-    EXPECT_TRUE(layerSpaceToProjectionPlane.IsBackFaceVisible());
-
-    // Case 2: Layer is rotated by slightly more than 90 degrees, but shifted off to the
-    //         side of the camera. Because of the wide field-of-view, the layer's front
-    //         side is still visible.
-    //
-    //                       |<-- front side of layer is visible to perspective camera
-    //                    \  |            /
-    //                     \ |           /
-    //                      \|          /
-    //                       |         /
-    //                       |\       /<-- camera field of view
-    //                       | \     /
-    // back side of layer -->|  \   /
-    //                           \./ <-- camera origin
-    //
-    layerSpaceToProjectionPlane.MakeIdentity();
-    layerSpaceToProjectionPlane.ApplyPerspectiveDepth(1);
-    layerSpaceToProjectionPlane.Translate3d(-10, 0, 0);
-    MathUtil::rotateEulerAngles(&layerSpaceToProjectionPlane, 0, 100, 0);
-    EXPECT_FALSE(layerSpaceToProjectionPlane.IsBackFaceVisible());
-
-    // Case 3: Additionally rotating the layer by 180 degrees should of course show the
-    //         opposite result of case 2.
-    MathUtil::rotateEulerAngles(&layerSpaceToProjectionPlane, 0, 180, 0);
-    EXPECT_TRUE(layerSpaceToProjectionPlane.IsBackFaceVisible());
-}
-
 TEST(MathUtilTest, verifyProjectionOfPerpendicularPlane)
 {
     // In this case, the m33() element of the transform becomes zero, which could cause a
@@ -178,1068 +114,5 @@
               projectedVector.y() / targetVector.y());
 }
 
-// TODO(shawnsingh): these macros are redundant with those from
-// web_transformation_matrix_unittests, but for now they
-// are different enough to be appropriate here.
-
-#define EXPECT_ROW1_EQ(a, b, c, d, transform)                 \
-    EXPECT_FLOAT_EQ((a), (transform).matrix().getDouble(0, 0));     \
-    EXPECT_FLOAT_EQ((b), (transform).matrix().getDouble(0, 1));     \
-    EXPECT_FLOAT_EQ((c), (transform).matrix().getDouble(0, 2));     \
-    EXPECT_FLOAT_EQ((d), (transform).matrix().getDouble(0, 3));
-
-#define EXPECT_ROW2_EQ(a, b, c, d, transform)                 \
-    EXPECT_FLOAT_EQ((a), (transform).matrix().getDouble(1, 0));     \
-    EXPECT_FLOAT_EQ((b), (transform).matrix().getDouble(1, 1));     \
-    EXPECT_FLOAT_EQ((c), (transform).matrix().getDouble(1, 2));     \
-    EXPECT_FLOAT_EQ((d), (transform).matrix().getDouble(1, 3));
-
-#define EXPECT_ROW3_EQ(a, b, c, d, transform)              \
-    EXPECT_FLOAT_EQ((a), (transform).matrix().getDouble(2, 0));  \
-    EXPECT_FLOAT_EQ((b), (transform).matrix().getDouble(2, 1));  \
-    EXPECT_FLOAT_EQ((c), (transform).matrix().getDouble(2, 2));  \
-    EXPECT_FLOAT_EQ((d), (transform).matrix().getDouble(2, 3));
-
-#define EXPECT_ROW4_EQ(a, b, c, d, transform)              \
-    EXPECT_FLOAT_EQ((a), (transform).matrix().getDouble(3, 0));  \
-    EXPECT_FLOAT_EQ((b), (transform).matrix().getDouble(3, 1));  \
-    EXPECT_FLOAT_EQ((c), (transform).matrix().getDouble(3, 2));  \
-    EXPECT_FLOAT_EQ((d), (transform).matrix().getDouble(3, 3));
-
-// Checking float values for equality close to zero is not robust using EXPECT_FLOAT_EQ
-// (see gtest documentation). So, to verify rotation matrices, we must use a looser
-// absolute error threshold in some places.
-#define EXPECT_ROW1_NEAR(a, b, c, d, transform, errorThreshold)            \
-    EXPECT_NEAR((a), (transform).matrix().getDouble(0, 0), (errorThreshold));    \
-    EXPECT_NEAR((b), (transform).matrix().getDouble(0, 1), (errorThreshold));    \
-    EXPECT_NEAR((c), (transform).matrix().getDouble(0, 2), (errorThreshold));    \
-    EXPECT_NEAR((d), (transform).matrix().getDouble(0, 3), (errorThreshold));
-
-#define EXPECT_ROW2_NEAR(a, b, c, d, transform, errorThreshold)            \
-    EXPECT_NEAR((a), (transform).matrix().getDouble(1, 0), (errorThreshold));    \
-    EXPECT_NEAR((b), (transform).matrix().getDouble(1, 1), (errorThreshold));    \
-    EXPECT_NEAR((c), (transform).matrix().getDouble(1, 2), (errorThreshold));    \
-    EXPECT_NEAR((d), (transform).matrix().getDouble(1, 3), (errorThreshold));
-
-#define EXPECT_ROW3_NEAR(a, b, c, d, transform, errorThreshold)            \
-    EXPECT_NEAR((a), (transform).matrix().getDouble(2, 0), (errorThreshold));    \
-    EXPECT_NEAR((b), (transform).matrix().getDouble(2, 1), (errorThreshold));    \
-    EXPECT_NEAR((c), (transform).matrix().getDouble(2, 2), (errorThreshold));    \
-    EXPECT_NEAR((d), (transform).matrix().getDouble(2, 3), (errorThreshold));
-
-#define ERROR_THRESHOLD 1e-14
-#define LOOSE_ERROR_THRESHOLD 1e-7
-
-static void initializeTestMatrix(gfx::Transform* transform)
-{
-    SkMatrix44& matrix = transform->matrix();
-    matrix.setDouble(0, 0, 10);
-    matrix.setDouble(1, 0, 11);
-    matrix.setDouble(2, 0, 12);
-    matrix.setDouble(3, 0, 13);
-    matrix.setDouble(0, 1, 14);
-    matrix.setDouble(1, 1, 15);
-    matrix.setDouble(2, 1, 16);
-    matrix.setDouble(3, 1, 17);
-    matrix.setDouble(0, 2, 18);
-    matrix.setDouble(1, 2, 19);
-    matrix.setDouble(2, 2, 20);
-    matrix.setDouble(3, 2, 21);
-    matrix.setDouble(0, 3, 22);
-    matrix.setDouble(1, 3, 23);
-    matrix.setDouble(2, 3, 24);
-    matrix.setDouble(3, 3, 25);
-
-    // Sanity check
-    EXPECT_ROW1_EQ(10, 14, 18, 22, (*transform));
-    EXPECT_ROW2_EQ(11, 15, 19, 23, (*transform));
-    EXPECT_ROW3_EQ(12, 16, 20, 24, (*transform));
-    EXPECT_ROW4_EQ(13, 17, 21, 25, (*transform));
-}
-
-static void initializeTestMatrix2(gfx::Transform* transform)
-{
-    SkMatrix44& matrix = transform->matrix();
-    matrix.setDouble(0, 0, 30);
-    matrix.setDouble(1, 0, 31);
-    matrix.setDouble(2, 0, 32);
-    matrix.setDouble(3, 0, 33);
-    matrix.setDouble(0, 1, 34);
-    matrix.setDouble(1, 1, 35);
-    matrix.setDouble(2, 1, 36);
-    matrix.setDouble(3, 1, 37);
-    matrix.setDouble(0, 2, 38);
-    matrix.setDouble(1, 2, 39);
-    matrix.setDouble(2, 2, 40);
-    matrix.setDouble(3, 2, 41);
-    matrix.setDouble(0, 3, 42);
-    matrix.setDouble(1, 3, 43);
-    matrix.setDouble(2, 3, 44);
-    matrix.setDouble(3, 3, 45);
-
-    // Sanity check
-    EXPECT_ROW1_EQ(30, 34, 38, 42, (*transform));
-    EXPECT_ROW2_EQ(31, 35, 39, 43, (*transform));
-    EXPECT_ROW3_EQ(32, 36, 40, 44, (*transform));
-    EXPECT_ROW4_EQ(33, 37, 41, 45, (*transform));
-}
-
-TEST(MathUtilGfxTransformTest, verifyDefaultConstructorCreatesIdentityMatrix)
-{
-    gfx::Transform A;
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-    EXPECT_TRUE(A.IsIdentity());
-}
-
-TEST(MathUtilGfxTransformTest, verifyCreateGfxTransformFor2dElements)
-{
-    gfx::Transform A = MathUtil::createGfxTransform(1, 2, 3, 4, 5, 6);
-    EXPECT_ROW1_EQ(1, 3, 0, 5, A);
-    EXPECT_ROW2_EQ(2, 4, 0, 6, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyCreateGfxTransformForAllElements)
-{
-    gfx::Transform A = MathUtil::createGfxTransform(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
-    EXPECT_ROW1_EQ(1, 5,  9, 13, A);
-    EXPECT_ROW2_EQ(2, 6, 10, 14, A);
-    EXPECT_ROW3_EQ(3, 7, 11, 15, A);
-    EXPECT_ROW4_EQ(4, 8, 12, 16, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyCopyConstructor)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-
-    // Copy constructor should produce exact same elements as matrix A.
-    gfx::Transform B(A);
-    EXPECT_ROW1_EQ(10, 14, 18, 22, B);
-    EXPECT_ROW2_EQ(11, 15, 19, 23, B);
-    EXPECT_ROW3_EQ(12, 16, 20, 24, B);
-    EXPECT_ROW4_EQ(13, 17, 21, 25, B);
-}
-
-TEST(MathUtilGfxTransformTest, verifyTo2DTransform)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-
-    gfx::Transform B = MathUtil::to2dTransform(A);
-
-    EXPECT_ROW1_EQ(10, 14, 0, 22, B);
-    EXPECT_ROW2_EQ(11, 15, 0, 23, B);
-    EXPECT_ROW3_EQ(0,  0,  1, 0,  B);
-    EXPECT_ROW4_EQ(13, 17, 0, 25, B);
-
-    // Note that to2DTransform should not have changed the original matrix.
-    EXPECT_ROW1_EQ(10, 14, 18, 22, A);
-    EXPECT_ROW2_EQ(11, 15, 19, 23, A);
-    EXPECT_ROW3_EQ(12, 16, 20, 24, A);
-    EXPECT_ROW4_EQ(13, 17, 21, 25, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyAssignmentOperator)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-    gfx::Transform B;
-    initializeTestMatrix2(&B);
-    gfx::Transform C;
-    initializeTestMatrix2(&C);
-    C = B = A;
-
-    // Both B and C should now have been re-assigned to the value of A.
-    EXPECT_ROW1_EQ(10, 14, 18, 22, B);
-    EXPECT_ROW2_EQ(11, 15, 19, 23, B);
-    EXPECT_ROW3_EQ(12, 16, 20, 24, B);
-    EXPECT_ROW4_EQ(13, 17, 21, 25, B);
-
-    EXPECT_ROW1_EQ(10, 14, 18, 22, C);
-    EXPECT_ROW2_EQ(11, 15, 19, 23, C);
-    EXPECT_ROW3_EQ(12, 16, 20, 24, C);
-    EXPECT_ROW4_EQ(13, 17, 21, 25, C);
-}
-
-TEST(MathUtilGfxTransformTest, verifyEqualsBooleanOperator)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-
-    gfx::Transform B;
-    initializeTestMatrix(&B);
-    EXPECT_TRUE(A == B);
-
-    // Modifying multiple elements should cause equals operator to return false.
-    gfx::Transform C;
-    initializeTestMatrix2(&C);
-    EXPECT_FALSE(A == C);
-
-    // Modifying any one individual element should cause equals operator to return false.
-    gfx::Transform D;
-    D = A;
-    D.matrix().setDouble(0, 0, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(1, 0, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(2, 0, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(3, 0, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(0, 1, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(1, 1, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(2, 1, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(3, 1, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(0, 2, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(1, 2, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(2, 2, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(3, 2, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(0, 3, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(1, 3, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(2, 3, 0);
-    EXPECT_FALSE(A == D);
-
-    D = A;
-    D.matrix().setDouble(3, 3, 0);
-    EXPECT_FALSE(A == D);
-}
-
-TEST(MathUtilGfxTransformTest, verifyMultiplyOperator)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-
-    gfx::Transform B;
-    initializeTestMatrix2(&B);
-
-    gfx::Transform C = A * B;
-    EXPECT_ROW1_EQ(2036, 2292, 2548, 2804, C);
-    EXPECT_ROW2_EQ(2162, 2434, 2706, 2978, C);
-    EXPECT_ROW3_EQ(2288, 2576, 2864, 3152, C);
-    EXPECT_ROW4_EQ(2414, 2718, 3022, 3326, C);
-
-    // Just an additional sanity check; matrix multiplication is not commutative.
-    EXPECT_FALSE(A * B == B * A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyMultiplyAndAssignOperator)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-
-    gfx::Transform B;
-    initializeTestMatrix2(&B);
-
-    A *= B;
-    EXPECT_ROW1_EQ(2036, 2292, 2548, 2804, A);
-    EXPECT_ROW2_EQ(2162, 2434, 2706, 2978, A);
-    EXPECT_ROW3_EQ(2288, 2576, 2864, 3152, A);
-    EXPECT_ROW4_EQ(2414, 2718, 3022, 3326, A);
-
-    // Just an additional sanity check; matrix multiplication is not commutative.
-    gfx::Transform C = A;
-    C *= B;
-    gfx::Transform D = B;
-    D *= A;
-    EXPECT_FALSE(C == D);
-}
-
-TEST(MathUtilGfxTransformTest, verifyMatrixMultiplication)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-
-    gfx::Transform B;
-    initializeTestMatrix2(&B);
-
-    A.PreconcatTransform(B);
-    EXPECT_ROW1_EQ(2036, 2292, 2548, 2804, A);
-    EXPECT_ROW2_EQ(2162, 2434, 2706, 2978, A);
-    EXPECT_ROW3_EQ(2288, 2576, 2864, 3152, A);
-    EXPECT_ROW4_EQ(2414, 2718, 3022, 3326, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyMakeIdentiy)
-{
-    gfx::Transform A;
-    initializeTestMatrix(&A);
-    A.MakeIdentity();
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-    EXPECT_TRUE(A.IsIdentity());
-}
-
-TEST(MathUtilGfxTransformTest, verifyTranslate)
-{
-    gfx::Transform A;
-    A.Translate(2, 3);
-    EXPECT_ROW1_EQ(1, 0, 0, 2, A);
-    EXPECT_ROW2_EQ(0, 1, 0, 3, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that Translate() post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale(5, 5);
-    A.Translate(2, 3);
-    EXPECT_ROW1_EQ(5, 0, 0, 10, A);
-    EXPECT_ROW2_EQ(0, 5, 0, 15, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0,  A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1,  A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyTranslate3d)
-{
-    gfx::Transform A;
-    A.Translate3d(2, 3, 4);
-    EXPECT_ROW1_EQ(1, 0, 0, 2, A);
-    EXPECT_ROW2_EQ(0, 1, 0, 3, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 4, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that Translate3d() post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.Translate3d(2, 3, 4);
-    EXPECT_ROW1_EQ(6, 0, 0, 12, A);
-    EXPECT_ROW2_EQ(0, 7, 0, 21, A);
-    EXPECT_ROW3_EQ(0, 0, 8, 32, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1,  A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyScale)
-{
-    gfx::Transform A;
-    A.Scale(6, 7);
-    EXPECT_ROW1_EQ(6, 0, 0, 0, A);
-    EXPECT_ROW2_EQ(0, 7, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that Scale() post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Translate3d(2, 3, 4);
-    A.Scale(6, 7);
-    EXPECT_ROW1_EQ(6, 0, 0, 2, A);
-    EXPECT_ROW2_EQ(0, 7, 0, 3, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 4, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyScale3d)
-{
-    gfx::Transform A;
-    A.Scale3d(6, 7, 8);
-    EXPECT_ROW1_EQ(6, 0, 0, 0, A);
-    EXPECT_ROW2_EQ(0, 7, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that scale3d() post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Translate3d(2, 3, 4);
-    A.Scale3d(6, 7, 8);
-    EXPECT_ROW1_EQ(6, 0, 0, 2, A);
-    EXPECT_ROW2_EQ(0, 7, 0, 3, A);
-    EXPECT_ROW3_EQ(0, 0, 8, 4, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotate)
-{
-    gfx::Transform A;
-    A.Rotate(90);
-    EXPECT_ROW1_NEAR(0, -1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that Rotate() post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.Rotate(90);
-    EXPECT_ROW1_NEAR(0, -6, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(7, 0,  0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateEulerAngles)
-{
-    gfx::Transform A;
-
-    // Check rotation about z-axis
-    A.MakeIdentity();
-    MathUtil::rotateEulerAngles(&A, 0, 0, 90);
-    EXPECT_ROW1_NEAR(0, -1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Check rotation about x-axis
-    A.MakeIdentity();
-    MathUtil::rotateEulerAngles(&A, 90, 0, 0);
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_NEAR(0, 0, -1, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(0, 1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Check rotation about y-axis.
-    // Note carefully, the expected pattern is inverted compared to rotating about x axis or z axis.
-    A.MakeIdentity();
-    MathUtil::rotateEulerAngles(&A, 0, 90, 0);
-    EXPECT_ROW1_NEAR(0, 0, 1, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_NEAR(-1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that rotate3d(rx, ry, rz) post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    MathUtil::rotateEulerAngles(&A, 0, 0, 90);
-    EXPECT_ROW1_NEAR(0, -6, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(7, 0,  0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateEulerAnglesOrderOfCompositeRotations)
-{
-    // Rotate3d(degreesX, degreesY, degreesZ) is actually composite transform consiting of
-    // three primitive rotations. This test verifies that the ordering of those three
-    // transforms is the intended ordering.
-    //
-    // The correct ordering for this test case should be:
-    //   1. rotate by 30 degrees about z-axis
-    //   2. rotate by 20 degrees about y-axis
-    //   3. rotate by 10 degrees about x-axis
-    //
-    // Note: there are 6 possible orderings of 3 transforms. For the specific transforms
-    // used in this test, all 6 combinations produce a unique matrix that is different
-    // from the other orderings. That way, this test verifies the exact ordering.
-
-    gfx::Transform A;
-    A.MakeIdentity();
-    MathUtil::rotateEulerAngles(&A, 10, 20, 30);
-
-    EXPECT_ROW1_NEAR(0.8137976813493738026394908,
-                     -0.4409696105298823720630708,
-                     0.3785223063697923939763257,
-                     0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(0.4698463103929541584413698,
-                     0.8825641192593856043657752,
-                     0.0180283112362972230968694,
-                     0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(-0.3420201433256686573969318,
-                     0.1631759111665348205288950,
-                     0.9254165783983233639631294,
-                     0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateAboutXAxis)
-{
-    gfx::Transform A;
-    double sin45 = 0.5 * sqrt(2.0);
-    double cos45 = sin45;
-
-    A.MakeIdentity();
-    A.RotateAboutXAxis(90);
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_NEAR(0, 0, -1, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(0, 1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    A.MakeIdentity();
-    A.RotateAboutXAxis(45);
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_NEAR(0, cos45, -sin45, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(0, sin45, cos45, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that rotateAboutXAxis(angle) post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.RotateAboutXAxis(90);
-    EXPECT_ROW1_NEAR(6, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(0, 0, -7, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(0, 8, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateAboutYAxis)
-{
-    gfx::Transform A;
-    double sin45 = 0.5 * sqrt(2.0);
-    double cos45 = sin45;
-
-    // Note carefully, the expected pattern is inverted compared to rotating about x axis or z axis.
-    A.MakeIdentity();
-    A.RotateAboutYAxis(90);
-    EXPECT_ROW1_NEAR(0, 0, 1, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_NEAR(-1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    A.MakeIdentity();
-    A.RotateAboutYAxis(45);
-    EXPECT_ROW1_NEAR(cos45, 0, sin45, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_NEAR(-sin45, 0, cos45, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that rotateAboutYAxis(angle) post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.RotateAboutYAxis(90);
-    EXPECT_ROW1_NEAR(0, 0, 6, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(0, 7, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(-8, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateAboutZAxis)
-{
-    gfx::Transform A;
-    double sin45 = 0.5 * sqrt(2.0);
-    double cos45 = sin45;
-
-    A.MakeIdentity();
-    A.RotateAboutZAxis(90);
-    EXPECT_ROW1_NEAR(0, -1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    A.MakeIdentity();
-    A.RotateAboutZAxis(45);
-    EXPECT_ROW1_NEAR(cos45, -sin45, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(sin45, cos45, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that rotateAboutZAxis(angle) post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.RotateAboutZAxis(90);
-    EXPECT_ROW1_NEAR(0, -6, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(7, 0,  0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateAboutForAlignedAxes)
-{
-    gfx::Transform A;
-
-    // Check rotation about z-axis
-    A.MakeIdentity();
-    A.RotateAbout(gfx::Vector3dF(0, 0, 1), 90);
-    EXPECT_ROW1_NEAR(0, -1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Check rotation about x-axis
-    A.MakeIdentity();
-    A.RotateAbout(gfx::Vector3dF(1, 0, 0), 90);
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_NEAR(0, 0, -1, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(0, 1, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Check rotation about y-axis.
-    // Note carefully, the expected pattern is inverted compared to rotating about x axis or z axis.
-    A.MakeIdentity();
-    A.RotateAbout(gfx::Vector3dF(0, 1, 0), 90);
-    EXPECT_ROW1_NEAR(0, 0, 1, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_NEAR(-1, 0, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that rotate3d(axis, angle) post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.RotateAboutZAxis(90);
-    EXPECT_ROW1_NEAR(0, -6, 0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(7, 0,  0, 0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateAboutForArbitraryAxis)
-{
-    // Check rotation about an arbitrary non-axis-aligned vector.
-    gfx::Transform A;
-    A.RotateAbout(gfx::Vector3dF(1, 1, 1), 90);
-    EXPECT_ROW1_NEAR(0.3333333333333334258519187,
-                     -0.2440169358562924717404030,
-                     0.9106836025229592124219380,
-                     0, A, ERROR_THRESHOLD);
-    EXPECT_ROW2_NEAR(0.9106836025229592124219380,
-                     0.3333333333333334258519187,
-                     -0.2440169358562924717404030,
-                     0, A, ERROR_THRESHOLD);
-    EXPECT_ROW3_NEAR(-0.2440169358562924717404030,
-                     0.9106836025229592124219380,
-                     0.3333333333333334258519187,
-                     0, A, ERROR_THRESHOLD);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyRotateAboutForDegenerateAxis)
-{
-    // Check rotation about a degenerate zero vector.
-    // It is expected to skip applying the rotation.
-    gfx::Transform A;
-
-    A.RotateAbout(gfx::Vector3dF(0, 0, 0), 45);
-    // Verify that A remains unchanged.
-    EXPECT_TRUE(A.IsIdentity());
-
-    initializeTestMatrix(&A);
-    A.RotateAbout(gfx::Vector3dF(0, 0, 0), 35);
-
-    // Verify that A remains unchanged.
-    EXPECT_ROW1_EQ(10, 14, 18, 22, A);
-    EXPECT_ROW2_EQ(11, 15, 19, 23, A);
-    EXPECT_ROW3_EQ(12, 16, 20, 24, A);
-    EXPECT_ROW4_EQ(13, 17, 21, 25, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifySkewX)
-{
-    gfx::Transform A;
-    A.SkewX(45);
-    EXPECT_ROW1_EQ(1, 1, 0, 0, A);
-    EXPECT_ROW2_EQ(0, 1, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that skewX() post-multiplies the existing matrix.
-    // Row 1, column 2, would incorrectly have value "7" if the matrix is pre-multiplied instead of post-multiplied.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.SkewX(45);
-    EXPECT_ROW1_EQ(6, 6, 0, 0, A);
-    EXPECT_ROW2_EQ(0, 7, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifySkewY)
-{
-    gfx::Transform A;
-    A.SkewY(45);
-    EXPECT_ROW1_EQ(1, 0, 0, 0, A);
-    EXPECT_ROW2_EQ(1, 1, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-
-    // Verify that skewY() post-multiplies the existing matrix.
-    // Row 2, column 1, would incorrectly have value "6" if the matrix is pre-multiplied instead of post-multiplied.
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    A.SkewY(45);
-    EXPECT_ROW1_EQ(6, 0, 0, 0, A);
-    EXPECT_ROW2_EQ(7, 7, 0, 0, A);
-    EXPECT_ROW3_EQ(0, 0, 8, 0, A);
-    EXPECT_ROW4_EQ(0, 0, 0, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyPerspectiveDepth)
-{
-    gfx::Transform A;
-    A.ApplyPerspectiveDepth(1);
-    EXPECT_ROW1_EQ(1, 0,  0, 0, A);
-    EXPECT_ROW2_EQ(0, 1,  0, 0, A);
-    EXPECT_ROW3_EQ(0, 0,  1, 0, A);
-    EXPECT_ROW4_EQ(0, 0, -1, 1, A);
-
-    // Verify that PerspectiveDepth() post-multiplies the existing matrix.
-    A.MakeIdentity();
-    A.Translate3d(2, 3, 4);
-    A.ApplyPerspectiveDepth(1);
-    EXPECT_ROW1_EQ(1, 0, -2, 2, A);
-    EXPECT_ROW2_EQ(0, 1, -3, 3, A);
-    EXPECT_ROW3_EQ(0, 0, -3, 4, A);
-    EXPECT_ROW4_EQ(0, 0, -1, 1, A);
-}
-
-TEST(MathUtilGfxTransformTest, verifyHasPerspective)
-{
-    gfx::Transform A;
-    A.ApplyPerspectiveDepth(1);
-    EXPECT_TRUE(A.HasPerspective());
-
-    A.MakeIdentity();
-    A.ApplyPerspectiveDepth(0);
-    EXPECT_FALSE(A.HasPerspective());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 0, -1);
-    EXPECT_TRUE(A.HasPerspective());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 1, -1);
-    EXPECT_TRUE(A.HasPerspective());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 2, -0.3);
-    EXPECT_TRUE(A.HasPerspective());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 3, 0.5);
-    EXPECT_TRUE(A.HasPerspective());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 3, 0);
-    EXPECT_TRUE(A.HasPerspective());
-}
-
-TEST(MathUtilGfxTransformTest, verifyIsInvertible)
-{
-    gfx::Transform A;
-
-    // Translations, rotations, scales, skews and arbitrary combinations of them are invertible.
-    A.MakeIdentity();
-    EXPECT_TRUE(A.IsInvertible());
-
-    A.MakeIdentity();
-    A.Translate3d(2, 3, 4);
-    EXPECT_TRUE(A.IsInvertible());
-
-    A.MakeIdentity();
-    A.Scale3d(6, 7, 8);
-    EXPECT_TRUE(A.IsInvertible());
-
-    A.MakeIdentity();
-    MathUtil::rotateEulerAngles(&A, 10, 20, 30);
-    EXPECT_TRUE(A.IsInvertible());
-
-    A.MakeIdentity();
-    A.SkewX(45);
-    EXPECT_TRUE(A.IsInvertible());
-
-    // A perspective matrix (projection plane at z=0) is invertible. The intuitive
-    // explanation is that perspective is eqivalent to a skew of the w-axis; skews are
-    // invertible.
-    A.MakeIdentity();
-    A.ApplyPerspectiveDepth(1);
-    EXPECT_TRUE(A.IsInvertible());
-
-    // A "pure" perspective matrix derived by similar triangles, with m44() set to zero
-    // (i.e. camera positioned at the origin), is not invertible.
-    A.MakeIdentity();
-    A.ApplyPerspectiveDepth(1);
-    A.matrix().setDouble(3, 3, 0);
-    EXPECT_FALSE(A.IsInvertible());
-
-    // Adding more to a non-invertible matrix will not make it invertible in the general case.
-    A.MakeIdentity();
-    A.ApplyPerspectiveDepth(1);
-    A.matrix().setDouble(3, 3, 0);
-    A.Scale3d(6, 7, 8);
-    MathUtil::rotateEulerAngles(&A, 10, 20, 30);
-    A.Translate3d(6, 7, 8);
-    EXPECT_FALSE(A.IsInvertible());
-
-    // A degenerate matrix of all zeros is not invertible.
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 0, 0);
-    A.matrix().setDouble(1, 1, 0);
-    A.matrix().setDouble(2, 2, 0);
-    A.matrix().setDouble(3, 3, 0);
-    EXPECT_FALSE(A.IsInvertible());
-}
-
-TEST(MathUtilGfxTransformTest, verifyIsIdentity)
-{
-    gfx::Transform A;
-
-    initializeTestMatrix(&A);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    EXPECT_TRUE(A.IsIdentity());
-
-    // Modifying any one individual element should cause the matrix to no longer be identity.
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 0, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 0, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 0, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 0, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 1, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 1, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 1, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 1, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 2, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 2, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 2, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 2, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 3, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 3, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 3, 2);
-    EXPECT_FALSE(A.IsIdentity());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 3, 2);
-    EXPECT_FALSE(A.IsIdentity());
-}
-
-TEST(MathUtilGfxTransformTest, verifyIsIdentityOrTranslation)
-{
-    gfx::Transform A;
-
-    initializeTestMatrix(&A);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    EXPECT_TRUE(A.IsIdentityOrTranslation());
-
-    // Modifying any non-translation components should cause IsIdentityOrTranslation() to
-    // return false. NOTE: (0, 3), (1, 3), and (2, 3) are the translation components, so
-    // modifying them should still return true.
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 0, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 0, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 0, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 0, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 1, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 1, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 1, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 1, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 2, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 2, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 2, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 2, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 3, 2);
-    EXPECT_TRUE(A.IsIdentityOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 3, 2);
-    EXPECT_TRUE(A.IsIdentityOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 3, 2);
-    EXPECT_TRUE(A.IsIdentityOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 3, 2);
-    EXPECT_FALSE(A.IsIdentityOrTranslation());
-}
-
-TEST(MathUtilGfxTransformTest, verifyIsScaleOrTranslation)
-{
-    gfx::Transform A;
-
-    initializeTestMatrix(&A);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    // Modifying any non-scale or non-translation components should cause
-    // IsScaleOrTranslation() to return false. (0, 0), (1, 1), (2, 2), (0, 3),
-    // (1, 3), and (2, 3) are the scale and translation components, so
-    // modifying them should still return true.
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 0, 2);
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 0, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 0, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 0, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 1, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 1, 2);
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 1, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 1, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 2, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 2, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 2, 2);
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 2, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(0, 3, 2);
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(1, 3, 2);
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    // Note carefully - expecting true here.
-    A.MakeIdentity();
-    A.matrix().setDouble(2, 3, 2);
-    EXPECT_TRUE(A.IsScaleOrTranslation());
-
-    A.MakeIdentity();
-    A.matrix().setDouble(3, 3, 2);
-    EXPECT_FALSE(A.IsScaleOrTranslation());
-}
-
 }  // namespace
 }  // namespace cc
Index: src/cc/scoped_ptr_vector.h
===================================================================
--- src/cc/scoped_ptr_vector.h	(revision 184497)
+++ src/cc/scoped_ptr_vector.h	(working copy)
@@ -17,12 +17,25 @@
 template <typename T>
 class ScopedPtrVector {
  public:
-  typedef typename std::vector<T*>::iterator iterator;
   typedef typename std::vector<T*>::const_iterator const_iterator;
   typedef typename std::vector<T*>::reverse_iterator reverse_iterator;
   typedef typename std::vector<T*>::const_reverse_iterator
       const_reverse_iterator;
 
+#if defined(OS_ANDROID)
+  // On Android the iterator is not a class, so we can't block assignment.
+  typedef typename std::vector<T*>::iterator iterator;
+#else
+  // Ban setting values on the iterator directly. New pointers must be passed
+  // to methods on the ScopedPtrVector class to appear in the vector.
+  class iterator : public std::vector<T*>::iterator {
+   public:
+    iterator(const typename std::vector<T*>::iterator& other)
+        : std::vector<T*>::iterator(other) {}
+    T* const& operator*() { return std::vector<T*>::iterator::operator*(); }
+  };
+#endif
+
   ScopedPtrVector() {}
 
   ~ScopedPtrVector() { clear(); }
@@ -31,42 +44,66 @@
     return data_.size();
   }
 
-  T* Peek(size_t index) const {
+  T* at(size_t index) const {
     DCHECK(index < size());
     return data_[index];
   }
 
   T* operator[](size_t index) const {
-    return Peek(index);
+    return at(index);
   }
 
-  T* first() const {
-    DCHECK(!isEmpty());
-    return Peek(0);
+  T* front() const {
+    DCHECK(!empty());
+    return at(0);
   }
 
-  T* last() const {
-    DCHECK(!isEmpty());
-    return Peek(size() - 1);
+  T* back() const {
+    DCHECK(!empty());
+    return at(size() - 1);
   }
 
-  bool isEmpty() const {
-    return size() == 0;
+  bool empty() const {
+    return data_.empty();
   }
 
-  scoped_ptr<T> take(size_t index) {
-    DCHECK(index < size());
-    scoped_ptr<T> ret(data_[index]);
-    data_[index] = NULL;
+  scoped_ptr<T> take(iterator position) {
+    if (position == end())
+      return scoped_ptr<T>(NULL);
+    DCHECK(position < end());
+
+    typename std::vector<T*>::iterator writable_position = position;
+    scoped_ptr<T> ret(*writable_position);
+    *writable_position = NULL;
     return ret.Pass();
   }
 
-  void remove(size_t index) {
-    DCHECK(index < size());
-    delete data_[index];
-    data_.erase(data_.begin() + index);
+  scoped_ptr<T> take_back() {
+    DCHECK(!empty());
+    if (empty())
+      return scoped_ptr<T>(NULL);
+    return take(end() - 1);
   }
 
+  void erase(iterator position) {
+    if (position == end())
+      return;
+    typename std::vector<T*>::iterator writable_position = position;
+    delete *writable_position;
+    data_.erase(position);
+  }
+
+  void erase(iterator first, iterator last) {
+    DCHECK(first <= last);
+    for (iterator it = first; it != last; ++it) {
+      DCHECK(it < end());
+
+      typename std::vector<T*>::iterator writable_it = it;
+      delete *writable_it;
+    }
+    data_.erase(first, last);
+  }
+
   void reserve(size_t size) {
     data_.reserve(size);
   }
@@ -75,22 +112,42 @@
     STLDeleteElements(&data_);
   }
 
-  void append(scoped_ptr<T> item) {
+  void push_back(scoped_ptr<T> item) {
     data_.push_back(item.release());
   }
 
-  void insert(size_t index, scoped_ptr<T> item) {
-    DCHECK(index < size());
-    data_.insert(data_.begin() + index, item.release());
+  void pop_back() {
+    delete data_.back();
+    data_.pop_back();
   }
 
+  void insert(iterator position, scoped_ptr<T> item) {
+    DCHECK(position <= end());
+    data_.insert(position, item.release());
+  }
+
   void swap(ScopedPtrVector<T>& other) {
     data_.swap(other.data_);
   }
 
-  iterator begin() { return data_.begin(); }
+  void swap(iterator a, iterator b) {
+    DCHECK(a < end());
+    DCHECK(b < end());
+    if (a == end() || b == end() || a == b)
+      return;
+    typename std::vector<T*>::iterator writable_a = a;
+    typename std::vector<T*>::iterator writable_b = b;
+    std::swap(*writable_a, *writable_b);
+  }
+
+  template<class Compare>
+  inline void sort(Compare comp) {
+   std::sort(data_.begin(), data_.end(), comp);
+  }
+
+  iterator begin() { return static_cast<iterator>(data_.begin()); }
   const_iterator begin() const { return data_.begin(); }
-  iterator end() { return data_.end(); }
+  iterator end() { return static_cast<iterator>(data_.end()); }
   const_iterator end() const { return data_.end(); }
 
   reverse_iterator rbegin() { return data_.rbegin(); }
Index: src/cc/tile_draw_quad.h
===================================================================
--- src/cc/tile_draw_quad.h	(revision 184497)
+++ src/cc/tile_draw_quad.h	(working copy)
@@ -60,6 +60,9 @@
     return left_edge_aa || top_edge_aa || right_edge_aa || bottom_edge_aa;
   }
 
+  virtual void AppendResources(ResourceProvider::ResourceIdArray* resources)
+      OVERRIDE;
+
   static const TileDrawQuad* MaterialCast(const DrawQuad*);
  private:
   TileDrawQuad();
Index: src/cc/layer_tree_host.cc
===================================================================
--- src/cc/layer_tree_host.cc	(revision 184497)
+++ src/cc/layer_tree_host.cc	(working copy)
@@ -7,7 +7,9 @@
 #include "base/command_line.h"
 #include "base/debug/trace_event.h"
 #include "base/message_loop.h"
+#include "base/stl_util.h"
 #include "base/string_number_conversions.h"
+#include "cc/animation_registrar.h"
 #include "cc/font_atlas.h"
 #include "cc/heads_up_display_layer.h"
 #include "cc/heads_up_display_layer_impl.h"
@@ -21,14 +23,14 @@
 #include "cc/math_util.h"
 #include "cc/occlusion_tracker.h"
 #include "cc/overdraw_metrics.h"
+#include "cc/prioritized_resource_manager.h"
 #include "cc/single_thread_proxy.h"
 #include "cc/switches.h"
 #include "cc/thread.h"
 #include "cc/thread_proxy.h"
+#include "cc/top_controls_manager.h"
 #include "cc/tree_synchronizer.h"
 
-using namespace std;
-
 namespace {
 static int numLayerTreeInstances;
 }
@@ -48,6 +50,7 @@
     , usingEglImage(false)
     , allowPartialTextureUpdates(false)
     , maxTextureSize(0)
+    , avoidPow2Textures(false)
 {
 }
 
@@ -70,14 +73,12 @@
 
 LayerTreeHost::LayerTreeHost(LayerTreeHostClient* client, const LayerTreeSettings& settings)
     : m_animating(false)
-    , m_needsAnimateLayers(false)
     , m_needsFullTreeSync(true)
     , m_client(client)
     , m_commitNumber(0)
     , m_renderingStats()
     , m_rendererInitialized(false)
     , m_outputSurfaceLost(false)
-    , m_numTimesRecreateShouldFail(0)
     , m_numFailedRecreateAttempts(0)
     , m_settings(settings)
     , m_debugState(settings.initialDebugState)
@@ -90,6 +91,7 @@
     , m_backgroundColor(SK_ColorWHITE)
     , m_hasTransparentBackground(false)
     , m_partialTextureUpdateRequests(0)
+    , m_animationRegistrar(AnimationRegistrar::create())
 {
     numLayerTreeInstances++;
 }
@@ -128,6 +130,13 @@
     RateLimiterMap::iterator it = m_rateLimiters.begin();
     if (it != m_rateLimiters.end())
         it->second->stop();
+
+    if (m_rootLayer) {
+        // The layer tree must be destroyed before the layer tree host. We've
+        // made a contract with our animation controllers that the registrar
+        // will outlive them, and we must make good.
+        m_rootLayer = NULL;
+    }
 }
 
 void LayerTreeHost::setSurfaceReady()
@@ -150,7 +159,7 @@
     // Update m_settings based on partial update capability.
     size_t maxPartialTextureUpdates = 0;
     if (m_proxy->rendererCapabilities().allowPartialTextureUpdates)
-        maxPartialTextureUpdates = min(m_settings.maxPartialTextureUpdates, m_proxy->maxPartialTextureUpdates());
+        maxPartialTextureUpdates = std::min(m_settings.maxPartialTextureUpdates, m_proxy->maxPartialTextureUpdates());
     m_settings.maxPartialTextureUpdates = maxPartialTextureUpdates;
 
     m_contentsTextureManager = PrioritizedResourceManager::create(m_proxy.get());
@@ -158,10 +167,10 @@
 
     m_rendererInitialized = true;
 
-    m_settings.defaultTileSize = gfx::Size(min(m_settings.defaultTileSize.width(), m_proxy->rendererCapabilities().maxTextureSize),
-                                           min(m_settings.defaultTileSize.height(), m_proxy->rendererCapabilities().maxTextureSize));
-    m_settings.maxUntiledLayerSize = gfx::Size(min(m_settings.maxUntiledLayerSize.width(), m_proxy->rendererCapabilities().maxTextureSize),
-                                               min(m_settings.maxUntiledLayerSize.height(), m_proxy->rendererCapabilities().maxTextureSize));
+    m_settings.defaultTileSize = gfx::Size(std::min(m_settings.defaultTileSize.width(), m_proxy->rendererCapabilities().maxTextureSize),
+                                           std::min(m_settings.defaultTileSize.height(), m_proxy->rendererCapabilities().maxTextureSize));
+    m_settings.maxUntiledLayerSize = gfx::Size(std::min(m_settings.maxUntiledLayerSize.width(), m_proxy->rendererCapabilities().maxTextureSize),
+                                               std::min(m_settings.maxUntiledLayerSize.height(), m_proxy->rendererCapabilities().maxTextureSize));
 }
 
 LayerTreeHost::RecreateResult LayerTreeHost::recreateOutputSurface()
@@ -169,13 +178,7 @@
     TRACE_EVENT0("cc", "LayerTreeHost::recreateOutputSurface");
     DCHECK(m_outputSurfaceLost);
 
-    bool recreated = false;
-    if (!m_numTimesRecreateShouldFail)
-        recreated = m_proxy->recreateOutputSurface();
-    else
-        m_numTimesRecreateShouldFail--;
-
-    if (recreated) {
+    if (m_proxy->recreateOutputSurface()) {
         m_client->didRecreateOutputSurface(true);
         m_outputSurfaceLost = false;
         return RecreateSucceeded;
@@ -212,6 +215,11 @@
     m_proxy->acquireLayerTextures();
 }
 
+void LayerTreeHost::didBeginFrame()
+{
+    m_client->didBeginFrame();
+}
+
 void LayerTreeHost::updateAnimations(base::TimeTicks frameBeginTime)
 {
     m_animating = true;
@@ -238,28 +246,6 @@
     TRACE_EVENT0("cc", "LayerTreeHost::commitTo");
 }
 
-static void pushPropertiesRecursive(Layer* layer, LayerImpl* layerImpl)
-{
-    if (!layer) {
-        DCHECK(!layerImpl);
-        return;
-    }
-
-    DCHECK_EQ(layer->id(), layerImpl->id());
-    layer->pushPropertiesTo(layerImpl);
-
-    pushPropertiesRecursive(layer->maskLayer(), layerImpl->maskLayer());
-    pushPropertiesRecursive(layer->replicaLayer(), layerImpl->replicaLayer());
-
-    const std::vector<scoped_refptr<Layer> >& children = layer->children();
-    const ScopedPtrVector<LayerImpl>& implChildren = layerImpl->children();
-    DCHECK_EQ(children.size(), implChildren.size());
-
-    for (size_t i = 0; i < children.size(); ++i) {
-        pushPropertiesRecursive(children[i].get(), implChildren[i]);
-    }
-}
-
 // This function commits the LayerTreeHost to an impl tree. When modifying
 // this function, keep in mind that the function *runs* on the impl thread! Any
 // code that is logically a main thread operation, e.g. deletion of a Layer,
@@ -269,35 +255,82 @@
 {
     DCHECK(m_proxy->isImplThread());
 
+    // If there are linked evicted backings, these backings' resources may be put into the
+    // impl tree, so we can't draw yet. Determine this before clearing all evicted backings.
+    bool newImplTreeHasNoEvictedResources = !m_contentsTextureManager->linkedEvictedBackingsExist();
+
     m_contentsTextureManager->updateBackingsInDrawingImplTree();
-    m_contentsTextureManager->reduceMemory(hostImpl->resourceProvider());
 
-    if (m_needsFullTreeSync) {
-        hostImpl->setRootLayer(TreeSynchronizer::synchronizeTrees(rootLayer(), hostImpl->detachLayerTree(), hostImpl->activeTree()));
+    // In impl-side painting, synchronize to the pending tree so that it has
+    // time to raster before being displayed.  If no pending tree is needed,
+    // synchronization can happen directly to the active tree and
+    // unlinked contents resources can be reclaimed immediately.
+    LayerTreeImpl* syncTree;
+    if (m_settings.implSidePainting) {
+        // Commits should not occur while there is already a pending tree.
+        DCHECK(!hostImpl->pendingTree());
+        hostImpl->createPendingTree();
+        syncTree = hostImpl->pendingTree();
     } else {
-        TRACE_EVENT0("cc", "LayerTreeHost::pushPropertiesRecursive");
-        pushPropertiesRecursive(rootLayer(), hostImpl->rootLayer());
+        m_contentsTextureManager->reduceMemory(hostImpl->resourceProvider());
+        syncTree = hostImpl->activeTree();
     }
+
+    if (m_needsFullTreeSync)
+        syncTree->SetRootLayer(TreeSynchronizer::synchronizeTrees(rootLayer(), syncTree->DetachLayerTree(), syncTree));
+    {
+        TRACE_EVENT0("cc", "LayerTreeHost::pushProperties");
+        TreeSynchronizer::pushProperties(rootLayer(), syncTree->RootLayer());
+    }
+
+    syncTree->set_needs_full_tree_sync(m_needsFullTreeSync);
     m_needsFullTreeSync = false;
 
     if (m_rootLayer && m_hudLayer)
-        hostImpl->activeTree()->set_hud_layer(static_cast<HeadsUpDisplayLayerImpl*>(LayerTreeHostCommon::findLayerInSubtree(hostImpl->rootLayer(), m_hudLayer->id())));
+        syncTree->set_hud_layer(static_cast<HeadsUpDisplayLayerImpl*>(LayerTreeHostCommon::findLayerInSubtree(syncTree->RootLayer(), m_hudLayer->id())));
     else
-        hostImpl->activeTree()->set_hud_layer(0);
+        syncTree->set_hud_layer(0);
 
-    // We may have added an animation during the tree sync. This will cause both layer tree hosts
-    // to visit their controllers.
-    if (rootLayer() && m_needsAnimateLayers)
-        hostImpl->setNeedsAnimateLayers();
+    syncTree->set_source_frame_number(commitNumber());
+    syncTree->set_background_color(m_backgroundColor);
+    syncTree->set_has_transparent_background(m_hasTransparentBackground);
 
-    hostImpl->activeTree()->set_source_frame_number(commitNumber());
+    syncTree->FindRootScrollLayer();
+
+    float page_scale_delta, sent_page_scale_delta;
+    if (m_settings.implSidePainting) {
+        // Update the delta from the active tree, which may have
+        // adjusted its delta prior to the pending tree being created.
+        // This code is equivalent to that in LayerTreeImpl::SetPageScaleDelta.
+        DCHECK_EQ(1, syncTree->sent_page_scale_delta());
+        page_scale_delta = hostImpl->activeTree()->page_scale_delta();
+        sent_page_scale_delta = hostImpl->activeTree()->sent_page_scale_delta();
+    } else {
+        page_scale_delta = syncTree->page_scale_delta();
+        sent_page_scale_delta = syncTree->sent_page_scale_delta();
+        syncTree->set_sent_page_scale_delta(1);
+    }
+
+    syncTree->SetPageScaleFactorAndLimits(m_pageScaleFactor, m_minPageScaleFactor, m_maxPageScaleFactor);
+    syncTree->SetPageScaleDelta(page_scale_delta / sent_page_scale_delta);
+
+    if (!m_settings.implSidePainting) {
+        // If we're not in impl-side painting, the tree is immediately
+        // considered active.
+        syncTree->DidBecomeActive();
+    }
+
     hostImpl->setViewportSize(layoutViewportSize(), deviceViewportSize());
     hostImpl->setDeviceScaleFactor(deviceScaleFactor());
-    hostImpl->setPageScaleFactorAndLimits(m_pageScaleFactor, m_minPageScaleFactor, m_maxPageScaleFactor);
-    hostImpl->setBackgroundColor(m_backgroundColor);
-    hostImpl->setHasTransparentBackground(m_hasTransparentBackground);
     hostImpl->setDebugState(m_debugState);
+    hostImpl->savePaintTime(m_renderingStats.totalPaintTime);
 
+    if (newImplTreeHasNoEvictedResources) {
+        if (syncTree->ContentsTexturesPurged())
+            syncTree->ResetContentsTexturesPurged();
+    }
+    syncTree->ResetViewportSizeInvalid();
+
     m_commitNumber++;
 }
 
@@ -423,12 +456,6 @@
     setAnimationEventsRecursive(*events.get(), m_rootLayer.get(), wallClockTime);
 }
 
-void LayerTreeHost::didAddAnimation()
-{
-    m_needsAnimateLayers = true;
-    m_proxy->didAddAnimation();
-}
-
 void LayerTreeHost::setRootLayer(scoped_refptr<Layer> rootLayer)
 {
     if (m_rootLayer == rootLayer)
@@ -492,13 +519,6 @@
     m_proxy->startPageScaleAnimation(targetOffset, useAnchor, scale, duration);
 }
 
-void LayerTreeHost::loseOutputSurface(int numTimes)
-{
-    TRACE_EVENT1("cc", "LayerTreeHost::loseCompositorOutputSurface", "numTimes", numTimes);
-    m_numTimesRecreateShouldFail = numTimes - 1;
-    m_proxy->loseOutputSurface();
-}
-
 PrioritizedResourceManager* LayerTreeHost::contentsTextureManager() const
 {
     return m_contentsTextureManager.get();
@@ -747,33 +767,6 @@
         m_client->applyScrollAndScale(rootScrollDelta, info.pageScaleDelta);
 }
 
-gfx::PointF LayerTreeHost::adjustEventPointForPinchZoom(const gfx::PointF& zoomedViewportPoint)
-    const
-{
-    if (m_implTransform.IsIdentity())
-        return zoomedViewportPoint;
-
-    DCHECK(m_implTransform.IsInvertible());
-
-    // Scale to screen space before applying implTransform inverse.
-    gfx::PointF zoomedScreenspacePoint = gfx::ScalePoint(zoomedViewportPoint, deviceScaleFactor());
-
-    gfx::Transform inverseImplTransform(gfx::Transform::kSkipInitialization);
-    if (!m_implTransform.GetInverse(&inverseImplTransform)) {
-        // TODO(shawnsingh): Either we need to handle uninvertible transforms
-        // here, or DCHECK that the transform is invertible.
-    }
-
-    bool wasClipped = false;
-    gfx::PointF unzoomedScreenspacePoint = MathUtil::projectPoint(inverseImplTransform, zoomedScreenspacePoint, wasClipped);
-    DCHECK(!wasClipped);
-
-    // Convert back to logical pixels for hit testing.
-    gfx::PointF unzoomedViewportPoint = gfx::ScalePoint(unzoomedScreenspacePoint, 1 / deviceScaleFactor());
-
-    return unzoomedViewportPoint;
-}
-
 void LayerTreeHost::setImplTransform(const gfx::Transform& transform)
 {
     m_implTransform = transform;
@@ -813,7 +806,7 @@
 
 bool LayerTreeHost::bufferedUpdates()
 {
-    return m_settings.maxPartialTextureUpdates != numeric_limits<size_t>::max();
+    return m_settings.maxPartialTextureUpdates != std::numeric_limits<size_t>::max();
 }
 
 bool LayerTreeHost::requestPartialTextureUpdate()
@@ -834,35 +827,25 @@
     setNeedsCommit();
 }
 
+bool LayerTreeHost::blocksPendingCommit() const
+{
+    if (!m_rootLayer)
+        return false;
+    return m_rootLayer->blocksPendingCommitRecursive();
+}
+
 void LayerTreeHost::animateLayers(base::TimeTicks time)
 {
-    if (!m_settings.acceleratedAnimationEnabled || !m_needsAnimateLayers)
+    if (!m_settings.acceleratedAnimationEnabled || m_animationRegistrar->active_animation_controllers().empty())
         return;
 
     TRACE_EVENT0("cc", "LayerTreeHostImpl::animateLayers");
-    m_needsAnimateLayers = animateLayersRecursive(m_rootLayer.get(), time);
-}
 
-bool LayerTreeHost::animateLayersRecursive(Layer* current, base::TimeTicks time)
-{
-    if (!current)
-        return false;
-
-    bool subtreeNeedsAnimateLayers = false;
-    LayerAnimationController* currentController = current->layerAnimationController();
     double monotonicTime = (time - base::TimeTicks()).InSecondsF();
-    currentController->animate(monotonicTime, 0);
 
-    // If the current controller still has an active animation, we must continue animating layers.
-    if (currentController->hasActiveAnimation())
-         subtreeNeedsAnimateLayers = true;
-
-    for (size_t i = 0; i < current->children().size(); ++i) {
-        if (animateLayersRecursive(current->children()[i].get(), time))
-            subtreeNeedsAnimateLayers = true;
-    }
-
-    return subtreeNeedsAnimateLayers;
+    AnimationRegistrar::AnimationControllerMap copy = m_animationRegistrar->active_animation_controllers();
+    for (AnimationRegistrar::AnimationControllerMap::iterator iter = copy.begin(); iter != copy.end(); ++iter)
+        (*iter).second->animate(monotonicTime, 0);
 }
 
 void LayerTreeHost::setAnimationEventsRecursive(const AnimationEventsVector& events, Layer* layer, base::Time wallClockTime)
@@ -883,4 +866,9 @@
         setAnimationEventsRecursive(events, layer->children()[childIndex].get(), wallClockTime);
 }
 
+skia::RefPtr<SkPicture> LayerTreeHost::capturePicture()
+{
+    return m_proxy->capturePicture();
+}
+
 }  // namespace cc
Index: src/cc/picture_layer_impl.cc
===================================================================
--- src/cc/picture_layer_impl.cc	(revision 184497)
+++ src/cc/picture_layer_impl.cc	(working copy)
@@ -14,15 +14,30 @@
 #include "cc/quad_sink.h"
 #include "cc/solid_color_draw_quad.h"
 #include "cc/tile_draw_quad.h"
+#include "cc/util.h"
 #include "ui/gfx/quad_f.h"
+#include "ui/gfx/rect_conversions.h"
+#include "ui/gfx/size_conversions.h"
 
+namespace {
+const float kMaxScaleRatioDuringPinch = 2.0f;
+}
+
 namespace cc {
 
 PictureLayerImpl::PictureLayerImpl(LayerTreeImpl* treeImpl, int id)
     : LayerImpl(treeImpl, id),
-      tilings_(this),
       pile_(PicturePileImpl::Create()),
-      last_update_time_(0) {
+      last_content_scale_(0),
+      ideal_contents_scale_(0),
+      is_mask_(false),
+      ideal_page_scale_(0.f),
+      ideal_device_scale_(0.f),
+      ideal_source_scale_(0.f),
+      raster_page_scale_(0.f),
+      raster_device_scale_(0.f),
+      raster_source_scale_(0.f),
+      raster_source_scale_was_animating_(false) {
 }
 
 PictureLayerImpl::~PictureLayerImpl() {
@@ -32,14 +47,51 @@
   return "PictureLayer";
 }
 
+scoped_ptr<LayerImpl> PictureLayerImpl::createLayerImpl(
+    LayerTreeImpl* treeImpl) {
+  return PictureLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+void PictureLayerImpl::CreateTilingSet() {
+  DCHECK(layerTreeImpl()->IsPendingTree());
+  DCHECK(!tilings_);
+  tilings_.reset(new PictureLayerTilingSet(this));
+  tilings_->SetLayerBounds(bounds());
+}
+
+void PictureLayerImpl::TransferTilingSet(scoped_ptr<PictureLayerTilingSet> tilings) {
+  DCHECK(layerTreeImpl()->IsActiveTree());
+  tilings->SetClient(this);
+  tilings_ = tilings.Pass();
+}
+
+void PictureLayerImpl::pushPropertiesTo(LayerImpl* base_layer) {
+  LayerImpl::pushPropertiesTo(base_layer);
+
+  PictureLayerImpl* layer_impl = static_cast<PictureLayerImpl*>(base_layer);
+
+  layer_impl->SetIsMask(is_mask_);
+  layer_impl->TransferTilingSet(tilings_.Pass());
+  layer_impl->pile_ = pile_;
+  pile_ = PicturePileImpl::Create();
+  pile_->set_slow_down_raster_scale_factor(
+      layerTreeImpl()->debug_state().slowDownRasterScaleFactor);
+
+  layer_impl->raster_page_scale_ = raster_page_scale_;
+  layer_impl->raster_device_scale_ = raster_device_scale_;
+  layer_impl->raster_source_scale_ = raster_source_scale_;
+}
+
+
 void PictureLayerImpl::appendQuads(QuadSink& quadSink,
                                    AppendQuadsData& appendQuadsData) {
-
   const gfx::Rect& rect = visibleContentRect();
   gfx::Rect content_rect(gfx::Point(), contentBounds());
 
   SharedQuadState* sharedQuadState =
       quadSink.useSharedQuadState(createSharedQuadState());
+  appendDebugBorderQuad(quadSink, sharedQuadState, appendQuadsData);
+
   bool clipped = false;
   gfx::QuadF target_quad = MathUtil::mapQuad(
       drawTransform(),
@@ -48,17 +100,35 @@
   bool isAxisAlignedInTarget = !clipped && target_quad.IsRectilinear();
   bool useAA = !isAxisAlignedInTarget;
 
+  bool isPixelAligned = isAxisAlignedInTarget && drawTransform().IsIdentityOrIntegerTranslation();
+  PictureLayerTiling::LayerDeviceAlignment layerDeviceAlignment =
+    isPixelAligned ? PictureLayerTiling::LayerAlignedToDevice
+                   : PictureLayerTiling::LayerNotAlignedToDevice;
+
   if (showDebugBorders()) {
-    for (PictureLayerTilingSet::Iterator iter(&tilings_,
+    for (PictureLayerTilingSet::Iterator iter(tilings_.get(),
                                               contentsScaleX(),
-                                              rect);
+                                              rect,
+                                              ideal_contents_scale_,
+                                              layerDeviceAlignment);
          iter;
          ++iter) {
       SkColor color;
       float width;
       if (*iter && iter->GetResourceId()) {
-        color = DebugColors::TileBorderColor();
-        width = DebugColors::TileBorderWidth(layerTreeImpl());
+        if (iter->priority(ACTIVE_TREE).resolution == HIGH_RESOLUTION) {
+          color = DebugColors::HighResTileBorderColor();
+          width = DebugColors::HighResTileBorderWidth(layerTreeImpl());
+        } else if (iter->priority(ACTIVE_TREE).resolution == LOW_RESOLUTION) {
+          color = DebugColors::LowResTileBorderColor();
+          width = DebugColors::LowResTileBorderWidth(layerTreeImpl());
+        } else if (iter->contents_scale() > contentsScaleX()) {
+          color = DebugColors::ExtraHighResTileBorderColor();
+          width = DebugColors::ExtraHighResTileBorderWidth(layerTreeImpl());
+        } else {
+          color = DebugColors::ExtraLowResTileBorderColor();
+          width = DebugColors::ExtraLowResTileBorderWidth(layerTreeImpl());
+        }
       } else {
         color = DebugColors::MissingTileBorderColor();
         width = DebugColors::MissingTileBorderWidth(layerTreeImpl());
@@ -72,7 +142,15 @@
     }
   }
 
-  for (PictureLayerTilingSet::Iterator iter(&tilings_, contentsScaleX(), rect);
+  // Keep track of the tilings that were used so that tilings that are
+  // unused can be considered for removal.
+  std::vector<PictureLayerTiling*> seen_tilings;
+
+  for (PictureLayerTilingSet::Iterator iter(tilings_.get(),
+                                            contentsScaleX(),
+                                            rect,
+                                            ideal_contents_scale_,
+                                            layerDeviceAlignment);
        iter;
        ++iter) {
     ResourceProvider::ResourceId resource = 0;
@@ -95,9 +173,14 @@
         if (quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData))
             appendQuadsData.numMissingTiles++;
       }
+
+      appendQuadsData.hadIncompleteTile = true;
       continue;
     }
 
+    if (iter->contents_scale() != ideal_contents_scale_)
+      appendQuadsData.hadIncompleteTile = true;
+
     gfx::RectF texture_rect = iter.texture_rect();
     gfx::Rect opaque_rect = iter->opaque_rect();
     opaque_rect.Intersect(content_rect);
@@ -120,109 +203,578 @@
                  outside_right_edge && useAA,
                  outside_bottom_edge && useAA);
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
+
+    if (!seen_tilings.size() || seen_tilings.back() != iter.CurrentTiling())
+      seen_tilings.push_back(iter.CurrentTiling());
   }
+
+  // Aggressively remove any tilings that are not seen to save memory. Note
+  // that this is at the expense of doing cause more frequent re-painting. A
+  // better scheme would be to maintain a tighter visibleContentRect for the
+  // finer tilings.
+  CleanUpTilingsOnActiveLayer(seen_tilings);
 }
 
 void PictureLayerImpl::dumpLayerProperties(std::string*, int indent) const {
   // TODO(enne): implement me
 }
 
-void PictureLayerImpl::didUpdateTransforms() {
-  if (drawsContent()) {
-    // TODO(enne): Add tilings during pinch zoom
-    // TODO(enne): Consider culling old tilings after pinch finishes.
-    if (!tilings_.num_tilings()) {
-      gfx::Size tile_size = layerTreeImpl()->settings().defaultTileSize;
-      AddTiling(contentsScaleX(), tile_size);
-      // TODO(enne): Add a low-res tiling as well.
-    }
-  } else {
-    // TODO(enne): This should be unnecessary once there are two trees.
-    tilings_.Reset();
-  }
+void PictureLayerImpl::updateTilePriorities() {
+  int current_source_frame_number = layerTreeImpl()->source_frame_number();
+  double current_frame_time =
+      (layerTreeImpl()->CurrentFrameTime() - base::TimeTicks()).InSecondsF();
 
-  gfx::Transform  current_screen_space_transform = screenSpaceTransform();
-  double current_time =
-      (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF();
-  double time_delta = 0;
-  if (last_update_time_ != 0 && last_bounds_ == bounds() &&
-      last_content_bounds_ == contentBounds() &&
-      last_content_scale_x_ == contentsScaleX() &&
-      last_content_scale_y_ == contentsScaleY()) {
-    time_delta = current_time - last_update_time_;
+  gfx::Transform current_screen_space_transform =
+      screenSpaceTransform();
+
+  gfx::Rect viewport_in_content_space;
+  gfx::Transform screenToLayer(gfx::Transform::kSkipInitialization);
+  if (screenSpaceTransform().GetInverse(&screenToLayer)) {
+    gfx::Rect device_viewport(layerTreeImpl()->device_viewport_size());
+    viewport_in_content_space = gfx::ToEnclosingRect(
+        MathUtil::projectClippedRect(screenToLayer, device_viewport));
   }
-  tilings_.UpdateTilePriorities(layerTreeImpl()->device_viewport_size(),
-                                contentsScaleX(),
-                                contentsScaleY(),
-                                last_screen_space_transform_,
-                                current_screen_space_transform,
-                                time_delta);
 
+  WhichTree tree = layerTreeImpl()->IsActiveTree() ? ACTIVE_TREE : PENDING_TREE;
+  tilings_->UpdateTilePriorities(
+      tree,
+      layerTreeImpl()->device_viewport_size(),
+      viewport_in_content_space,
+      last_bounds_,
+      bounds(),
+      last_content_bounds_,
+      contentBounds(),
+      last_content_scale_,
+      contentsScaleX(),
+      last_screen_space_transform_,
+      current_screen_space_transform,
+      current_source_frame_number,
+      current_frame_time);
+
   last_screen_space_transform_ = current_screen_space_transform;
-  last_update_time_ = current_time;
   last_bounds_ = bounds();
   last_content_bounds_ = contentBounds();
-  last_content_scale_x_ = contentsScaleX();
-  last_content_scale_y_ = contentsScaleY();
+  last_content_scale_ = contentsScaleX();
 }
 
-void PictureLayerImpl::didUpdateBounds() {
-  tilings_.SetLayerBounds(bounds());
+void PictureLayerImpl::didBecomeActive() {
+  LayerImpl::didBecomeActive();
+  tilings_->DidBecomeActive();
 }
 
+void PictureLayerImpl::didLoseOutputSurface() {
+  if (tilings_)
+    tilings_->RemoveAllTilings();
+}
+
+void PictureLayerImpl::calculateContentsScale(
+    float ideal_contents_scale,
+    bool animating_transform_to_screen,
+    float* contents_scale_x,
+    float* contents_scale_y,
+    gfx::Size* content_bounds) {
+  if (!drawsContent()) {
+    DCHECK(!tilings_->num_tilings());
+    return;
+  }
+
+  float min_contents_scale = layerTreeImpl()->settings().minimumContentsScale;
+  float min_page_scale = layerTreeImpl()->min_page_scale_factor();
+  float min_device_scale = 1.f;
+  float min_source_scale =
+      min_contents_scale / min_page_scale / min_device_scale;
+
+  float ideal_page_scale = layerTreeImpl()->total_page_scale_factor();
+  float ideal_device_scale = layerTreeImpl()->device_scale_factor();
+  float ideal_source_scale =
+      ideal_contents_scale / ideal_page_scale / ideal_device_scale;
+
+  ideal_contents_scale_ = std::max(ideal_contents_scale, min_contents_scale);
+  ideal_page_scale_ = ideal_page_scale;
+  ideal_device_scale_ = ideal_device_scale;
+  ideal_source_scale_ = std::max(ideal_source_scale, min_source_scale);
+
+  ManageTilings(animating_transform_to_screen);
+
+  // The content scale and bounds for a PictureLayerImpl is somewhat fictitious.
+  // There are (usually) several tilings at different scales.  However, the
+  // content bounds is the (integer!) space in which quads are generated.
+  // In order to guarantee that we can fill this integer space with any set of
+  // tilings (and then map back to floating point texture coordinates), the
+  // contents scale must be at least as large as the largest of the tilings.
+  float max_contents_scale = min_contents_scale;
+  for (size_t i = 0; i < tilings_->num_tilings(); ++i) {
+    const PictureLayerTiling* tiling = tilings_->tiling_at(i);
+    max_contents_scale = std::max(max_contents_scale, tiling->contents_scale());
+  }
+
+  *contents_scale_x = max_contents_scale;
+  *contents_scale_y = max_contents_scale;
+  *content_bounds = gfx::ToCeiledSize(
+      gfx::ScaleSize(bounds(), max_contents_scale, max_contents_scale));
+}
+
+skia::RefPtr<SkPicture> PictureLayerImpl::getPicture() {
+  return pile_->GetFlattenedPicture();
+}
+
 scoped_refptr<Tile> PictureLayerImpl::CreateTile(PictureLayerTiling* tiling,
-                                                 gfx::Rect rect) {
-  TileManager* tile_manager = layerTreeImpl()->tile_manager();
+                                                 gfx::Rect content_rect) {
+  // Ensure there is a recording for this tile.
+  gfx::Rect layer_rect = gfx::ToEnclosingRect(
+      gfx::ScaleRect(content_rect, 1.f / tiling->contents_scale()));
+  layer_rect.Intersect(gfx::Rect(bounds()));
+  if (!pile_->recorded_region().Contains(layer_rect))
+    return scoped_refptr<Tile>();
 
   return make_scoped_refptr(new Tile(
-      tile_manager,
+      layerTreeImpl()->tile_manager(),
       pile_.get(),
-      rect.size(),
+      content_rect.size(),
       GL_RGBA,
-      rect,
+      content_rect,
+      contentsOpaque() ? content_rect : gfx::Rect(),
       tiling->contents_scale()));
 }
 
+void PictureLayerImpl::UpdatePile(Tile* tile) {
+  tile->set_picture_pile(pile_);
+}
+
+gfx::Size PictureLayerImpl::CalculateTileSize(
+    gfx::Size /* current_tile_size */,
+    gfx::Size content_bounds) {
+  if (is_mask_) {
+    int max_size = layerTreeImpl()->MaxTextureSize();
+    return gfx::Size(
+        std::min(max_size, content_bounds.width()),
+        std::min(max_size, content_bounds.height()));
+  }
+
+  gfx::Size default_tile_size = layerTreeImpl()->settings().defaultTileSize;
+  gfx::Size max_untiled_content_size =
+      layerTreeImpl()->settings().maxUntiledLayerSize;
+
+  bool any_dimension_too_large =
+      content_bounds.width() > max_untiled_content_size.width() ||
+      content_bounds.height() > max_untiled_content_size.height();
+
+  bool any_dimension_one_tile =
+      content_bounds.width() <= default_tile_size.width() ||
+      content_bounds.height() <= default_tile_size.height();
+
+  // If long and skinny, tile at the max untiled content size, and clamp
+  // the smaller dimension to the content size, e.g. 1000x12 layer with
+  // 500x500 max untiled size would get 500x12 tiles.  Also do this
+  // if the layer is small.
+  if (any_dimension_one_tile || !any_dimension_too_large) {
+    int width =
+        std::min(max_untiled_content_size.width(), content_bounds.width());
+    int height =
+        std::min(max_untiled_content_size.height(), content_bounds.height());
+    // Round width and height up to the closest multiple of 64, or 56 if
+    // we should avoid power-of-two textures. This helps reduce the number
+    // of different textures sizes to help recycling, and also keeps all
+    // textures multiple-of-eight, which is preferred on some drivers (IMG).
+    bool avoidPow2 = layerTreeImpl()->rendererCapabilities().avoidPow2Textures;
+    int roundUpTo = avoidPow2 ? 56 : 64;
+    width = RoundUp(width, roundUpTo);
+    height = RoundUp(height, roundUpTo);
+    return gfx::Size(width, height);
+  }
+
+  return default_tile_size;
+}
+
 void PictureLayerImpl::SyncFromActiveLayer() {
   DCHECK(layerTreeImpl()->IsPendingTree());
-  if (!drawsContent())
+
+  if (!drawsContent()) {
+    raster_page_scale_ = 0;
+    raster_device_scale_ = 0;
+    raster_source_scale_ = 0;
     return;
+  }
 
   // If there is an active tree version of this layer, get a copy of its
   // tiles.  This needs to be done last, after setting invalidation and the
   // pile.
-  PictureLayerImpl* active_twin = static_cast<PictureLayerImpl*>(
-      layerTreeImpl()->FindActiveTreeLayerById(id()));
-  if (!active_twin)
-    return;
-  SyncFromActiveLayer(active_twin);
+  if (PictureLayerImpl* active_twin = ActiveTwin())
+    SyncFromActiveLayer(active_twin);
 }
 
 void PictureLayerImpl::SyncFromActiveLayer(const PictureLayerImpl* other) {
-  tilings_.CloneAll(other->tilings_, invalidation_);
+  raster_page_scale_ = other->raster_page_scale_;
+  raster_device_scale_ = other->raster_device_scale_;
+  raster_source_scale_ = other->raster_source_scale_;
+
+  // Add synthetic invalidations for any recordings that were dropped.  As
+  // tiles are updated to point to this new pile, this will force the dropping
+  // of tiles that can no longer be rastered.  This is not ideal, but is a
+  // trade-off for memory (use the same pile as much as possible, by switching
+  // during DidBecomeActive) and for time (don't bother checking every tile
+  // during activation to see if the new pile can still raster it).
+  //
+  // TODO(enne): Clean up this double loop.
+  for (int x = 0; x < pile_->num_tiles_x(); ++x) {
+    for (int y = 0; y < pile_->num_tiles_y(); ++y) {
+      bool previously_had = other->pile_->HasRecordingAt(x, y);
+      bool now_has = pile_->HasRecordingAt(x, y);
+      if (now_has || !previously_had)
+        continue;
+      gfx::Rect layer_rect = pile_->tile_bounds(x, y);
+      invalidation_.Union(layer_rect);
+    }
+  }
+
+
+  tilings_->CloneAll(*other->tilings_, invalidation_);
+  DCHECK(bounds() == tilings_->LayerBounds());
+
+  // It's a sad but unfortunate fact that PicturePile tiling edges do not line
+  // up with PictureLayerTiling edges.  Tiles can only be added if they are
+  // entirely covered by recordings (that may come from multiple PicturePile
+  // tiles).  This check happens in this class's CreateTile() call.
+  for (int x = 0; x < pile_->num_tiles_x(); ++x) {
+    for (int y = 0; y < pile_->num_tiles_y(); ++y) {
+      bool previously_had = other->pile_->HasRecordingAt(x, y);
+      bool now_has = pile_->HasRecordingAt(x, y);
+      if (!now_has || previously_had)
+        continue;
+      gfx::Rect layer_rect = pile_->tile_bounds(x, y);
+      tilings_->CreateTilesFromLayerRect(layer_rect);
+    }
+  }
 }
 
 void PictureLayerImpl::SyncTiling(
-    const PictureLayerTiling* tiling) {
-  tilings_.Clone(tiling, invalidation_);
+    const PictureLayerTiling* tiling,
+    const Region& pending_layer_invalidation) {
+  if (!drawsContent())
+    return;
+  tilings_->Clone(tiling, pending_layer_invalidation);
 }
 
-void PictureLayerImpl::AddTiling(float contents_scale, gfx::Size tile_size) {
-  const PictureLayerTiling* tiling = tilings_.AddTiling(
-      contents_scale,
-      tile_size);
+void PictureLayerImpl::SetIsMask(bool is_mask) {
+  if (is_mask_ == is_mask)
+    return;
+  is_mask_ = is_mask;
+  if (tilings_)
+    tilings_->RemoveAllTiles();
+}
 
-  // If a new tiling is created on the active tree, sync it to the pending tree
-  // so that it can share the same tiles.
-  if (layerTreeImpl()->IsActiveTree())
+ResourceProvider::ResourceId PictureLayerImpl::contentsResourceId() const {
+  gfx::Rect content_rect(gfx::Point(), contentBounds());
+  float scale = contentsScaleX();
+  for (PictureLayerTilingSet::Iterator iter(tilings_.get(),
+                                            scale,
+                                            content_rect,
+                                            ideal_contents_scale_,
+                                            PictureLayerTiling::LayerDeviceAlignmentUnknown);
+       iter;
+       ++iter) {
+    // Mask resource not ready yet.
+    if (!*iter || !iter->GetResourceId())
+      return 0;
+    // Masks only supported if they fit on exactly one tile.
+    if (iter.geometry_rect() != content_rect)
+      return 0;
+    return iter->GetResourceId();
+  }
+  return 0;
+}
+
+bool PictureLayerImpl::areVisibleResourcesReady() const {
+  DCHECK(layerTreeImpl()->IsPendingTree());
+  DCHECK(ideal_contents_scale_);
+
+  const gfx::Rect& rect = visibleContentRect();
+
+  float raster_contents_scale =
+      raster_page_scale_ *
+      raster_device_scale_ *
+      raster_source_scale_;
+
+  float min_acceptable_scale =
+      std::min(raster_contents_scale, ideal_contents_scale_);
+
+  if (PictureLayerImpl* twin = ActiveTwin()) {
+    float twin_raster_contents_scale =
+        twin->raster_page_scale_ *
+        twin->raster_device_scale_ *
+        twin->raster_source_scale_;
+
+    min_acceptable_scale = std::min(
+        min_acceptable_scale,
+        std::min(twin->ideal_contents_scale_, twin_raster_contents_scale));
+  }
+
+  Region missing_region = rect;
+  for (size_t i = 0; i < tilings_->num_tilings(); ++i) {
+    PictureLayerTiling* tiling = tilings_->tiling_at(i);
+
+    if (tiling->contents_scale() < min_acceptable_scale)
+      continue;
+
+    for (PictureLayerTiling::Iterator iter(tiling,
+                                           contentsScaleX(),
+                                           rect,
+                                           PictureLayerTiling::LayerDeviceAlignmentUnknown);
+         iter;
+         ++iter) {
+      // A null tile (i.e. no recording) is considered "ready".
+      if (!*iter || iter->GetResourceId())
+        missing_region.Subtract(iter.geometry_rect());
+    }
+  }
+
+  return missing_region.IsEmpty();
+}
+
+PictureLayerTiling* PictureLayerImpl::AddTiling(float contents_scale) {
+  DCHECK(contents_scale >= layerTreeImpl()->settings().minimumContentsScale);
+
+  PictureLayerTiling* tiling = tilings_->AddTiling(contents_scale);
+
+  const Region& recorded = pile_->recorded_region();
+  DCHECK(!recorded.IsEmpty());
+
+  for (Region::Iterator iter(recorded); iter.has_rect(); iter.next())
+    tiling->CreateTilesFromLayerRect(iter.rect());
+
+  PictureLayerImpl* twin =
+      layerTreeImpl()->IsPendingTree() ? ActiveTwin() : PendingTwin();
+  if (!twin)
+    return tiling;
+
+  if (layerTreeImpl()->IsPendingTree())
+    twin->SyncTiling(tiling, invalidation_);
+  else
+    twin->SyncTiling(tiling, twin->invalidation_);
+
+  return tiling;
+}
+
+void PictureLayerImpl::RemoveTiling(float contents_scale) {
+  for (size_t i = 0; i < tilings_->num_tilings(); ++i) {
+    PictureLayerTiling* tiling = tilings_->tiling_at(i);
+    if (tiling->contents_scale() == contents_scale) {
+      tilings_->Remove(tiling);
+      break;
+    }
+  }
+}
+
+namespace {
+
+inline float PositiveRatio(float float1, float float2) {
+  DCHECK(float1 > 0);
+  DCHECK(float2 > 0);
+  return float1 > float2 ? float1 / float2 : float2 / float1;
+}
+
+inline bool IsCloserToThan(
+    PictureLayerTiling* layer1,
+    PictureLayerTiling* layer2,
+    float contents_scale) {
+  // Absolute value for ratios.
+  float ratio1 = PositiveRatio(layer1->contents_scale(), contents_scale);
+  float ratio2 = PositiveRatio(layer2->contents_scale(), contents_scale);
+  return ratio1 < ratio2;
+}
+
+}  // namespace
+
+void PictureLayerImpl::ManageTilings(bool animating_transform_to_screen) {
+  DCHECK(ideal_contents_scale_);
+  DCHECK(ideal_page_scale_);
+  DCHECK(ideal_device_scale_);
+  DCHECK(ideal_source_scale_);
+
+  if (pile_->recorded_region().IsEmpty())
     return;
 
-  PictureLayerImpl* pending_twin = static_cast<PictureLayerImpl*>(
-      layerTreeImpl()->FindPendingTreeLayerById(id()));
-  if (!pending_twin)
+  bool is_active_layer = layerTreeImpl()->IsActiveTree();
+  bool is_pinching = layerTreeImpl()->PinchGestureActive();
+
+  bool change_target_tiling = false;
+
+  if (!raster_page_scale_ || !raster_device_scale_ || !raster_source_scale_)
+    change_target_tiling = true;
+
+  // TODO(danakj): Adjust raster_source_scale_ closer to ideal_source_scale_ at
+  // a throttled rate. Possibly make use of invalidation_.IsEmpty() on pending
+  // tree. This will allow CSS scale changes to get re-rastered at an
+  // appropriate rate.
+
+  if (is_active_layer) {
+    if (raster_source_scale_was_animating_ && !animating_transform_to_screen)
+      change_target_tiling = true;
+    raster_source_scale_was_animating_ = animating_transform_to_screen;
+  }
+
+  if (is_active_layer && is_pinching && raster_page_scale_) {
+    // If the page scale diverges too far during pinch, change raster target to
+    // the current page scale.
+    float ratio = PositiveRatio(ideal_page_scale_, raster_page_scale_);
+    if (ratio >= kMaxScaleRatioDuringPinch)
+      change_target_tiling = true;
+  }
+
+  if (!is_pinching) {
+    // When not pinching, match the ideal page scale factor.
+    if (raster_page_scale_ != ideal_page_scale_)
+      change_target_tiling = true;
+  }
+
+  // Always match the ideal device scale factor.
+  if (raster_device_scale_ != ideal_device_scale_)
+    change_target_tiling = true;
+
+  if (!change_target_tiling)
     return;
-  DCHECK_EQ(id(), pending_twin->id());
-  pending_twin->SyncTiling(tiling);
+
+  raster_page_scale_ = ideal_page_scale_;
+  raster_device_scale_ = ideal_device_scale_;
+  raster_source_scale_ = ideal_source_scale_;
+
+  float raster_contents_scale;
+  float low_res_raster_contents_scale;
+  CalculateRasterContentsScale(animating_transform_to_screen,
+                               &raster_contents_scale,
+                               &low_res_raster_contents_scale);
+
+  PictureLayerTiling* high_res = NULL;
+  PictureLayerTiling* low_res = NULL;
+
+  for (size_t i = 0; i < tilings_->num_tilings(); ++i) {
+    PictureLayerTiling* tiling = tilings_->tiling_at(i);
+    if (tiling->contents_scale() == raster_contents_scale)
+      high_res = tiling;
+    if (tiling->contents_scale() == low_res_raster_contents_scale)
+      low_res = tiling;
+
+    // Reset all tilings to non-ideal until the end of this function.
+    tiling->set_resolution(NON_IDEAL_RESOLUTION);
+  }
+
+  if (!high_res) {
+    high_res = AddTiling(raster_contents_scale);
+    if (raster_contents_scale == low_res_raster_contents_scale)
+      low_res = high_res;
+  }
+  if (!low_res && low_res != high_res)
+    low_res = AddTiling(low_res_raster_contents_scale);
+
+  if (high_res)
+    high_res->set_resolution(HIGH_RESOLUTION);
+  if (low_res && low_res != high_res)
+    low_res->set_resolution(LOW_RESOLUTION);
 }
 
+void PictureLayerImpl::CalculateRasterContentsScale(
+    bool animating_transform_to_screen,
+    float* raster_contents_scale,
+    float* low_res_raster_contents_scale) {
+  *raster_contents_scale = ideal_contents_scale_;
+
+  // Don't allow animating CSS scales to drop below 1.
+  if (animating_transform_to_screen) {
+    *raster_contents_scale = std::max(
+        *raster_contents_scale, 1.f * ideal_page_scale_ * ideal_device_scale_);
+  }
+
+  float low_res_factor = layerTreeImpl()->settings().lowResContentsScaleFactor;
+  *low_res_raster_contents_scale = std::max(
+      *raster_contents_scale * low_res_factor,
+      layerTreeImpl()->settings().minimumContentsScale);
+}
+
+void PictureLayerImpl::CleanUpTilingsOnActiveLayer(
+    std::vector<PictureLayerTiling*> used_tilings) {
+  DCHECK(layerTreeImpl()->IsActiveTree());
+
+  float raster_contents_scale =
+      raster_page_scale_ * raster_device_scale_ * raster_source_scale_;
+
+  float min_acceptable_high_res_scale = std::min(
+      raster_contents_scale, ideal_contents_scale_);
+  float max_acceptable_high_res_scale = std::max(
+      raster_contents_scale, ideal_contents_scale_);
+
+  PictureLayerImpl* twin = PendingTwin();
+  if (twin) {
+    float twin_raster_contents_scale =
+        twin->raster_page_scale_ *
+        twin->raster_device_scale_ *
+        twin->raster_source_scale_;
+
+    min_acceptable_high_res_scale = std::min(
+        min_acceptable_high_res_scale,
+        std::min(twin_raster_contents_scale, twin->ideal_contents_scale_));
+    max_acceptable_high_res_scale = std::max(
+        max_acceptable_high_res_scale,
+        std::max(twin_raster_contents_scale, twin->ideal_contents_scale_));
+  }
+
+  float low_res_factor = layerTreeImpl()->settings().lowResContentsScaleFactor;
+
+  float min_acceptable_low_res_scale =
+      low_res_factor * min_acceptable_high_res_scale;
+  float max_acceptable_low_res_scale =
+      low_res_factor * max_acceptable_high_res_scale;
+
+  std::vector<PictureLayerTiling*> to_remove;
+  for (size_t i = 0; i < tilings_->num_tilings(); ++i) {
+    PictureLayerTiling* tiling = tilings_->tiling_at(i);
+
+    if (tiling->contents_scale() >= min_acceptable_high_res_scale &&
+        tiling->contents_scale() <= max_acceptable_high_res_scale)
+      continue;
+
+    if (tiling->contents_scale() >= min_acceptable_low_res_scale &&
+        tiling->contents_scale() <= max_acceptable_low_res_scale)
+      continue;
+
+    // Don't remove tilings that are being used and expected to stay around.
+    if (std::find(used_tilings.begin(), used_tilings.end(), tiling) !=
+        used_tilings.end())
+      continue;
+
+    to_remove.push_back(tiling);
+  }
+
+  for (size_t i = 0; i < to_remove.size(); ++i) {
+    if (twin)
+      twin->RemoveTiling(to_remove[i]->contents_scale());
+    tilings_->Remove(to_remove[i]);
+  }
+}
+
+PictureLayerImpl* PictureLayerImpl::PendingTwin() const {
+  DCHECK(layerTreeImpl()->IsActiveTree());
+
+  PictureLayerImpl* twin = static_cast<PictureLayerImpl*>(
+      layerTreeImpl()->FindPendingTreeLayerById(id()));
+  if (twin)
+    DCHECK_EQ(id(), twin->id());
+  return twin;
+}
+
+PictureLayerImpl* PictureLayerImpl::ActiveTwin() const {
+  DCHECK(layerTreeImpl()->IsPendingTree());
+
+  PictureLayerImpl* twin = static_cast<PictureLayerImpl*>(
+      layerTreeImpl()->FindActiveTreeLayerById(id()));
+  if (twin)
+    DCHECK_EQ(id(), twin->id());
+  return twin;
+}
+
+void PictureLayerImpl::getDebugBorderProperties(
+    SkColor* color, float* width) const {
+  *color = DebugColors::TiledContentLayerBorderColor();
+  *width = DebugColors::TiledContentLayerBorderWidth(layerTreeImpl());
+}
+
 }  // namespace cc
Index: src/cc/damage_tracker.cc
===================================================================
--- src/cc/damage_tracker.cc	(revision 184497)
+++ src/cc/damage_tracker.cc	(working copy)
@@ -8,7 +8,7 @@
 #include "cc/layer_tree_host_common.h"
 #include "cc/math_util.h"
 #include "cc/render_surface_impl.h"
-#include <public/WebFilterOperations.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 
 namespace cc {
 
Index: src/cc/picture_layer_tiling_set.h
===================================================================
--- src/cc/picture_layer_tiling_set.h	(revision 184497)
+++ src/cc/picture_layer_tiling_set.h	(working copy)
@@ -14,35 +14,56 @@
 
 class CC_EXPORT PictureLayerTilingSet {
  public:
-  PictureLayerTilingSet(PictureLayerTilingClient* client);
+  explicit PictureLayerTilingSet(PictureLayerTilingClient* client);
   ~PictureLayerTilingSet();
 
-  // Shallow copies all data (except client) from other.
+  void SetClient(PictureLayerTilingClient* client);
+
+  // Shallow copies all data (except client and bounds from other).
   void CloneAll(
      const PictureLayerTilingSet& other,
      const Region& invalidation);
   void Clone(const PictureLayerTiling* tiling, const Region& invalidation);
 
-  // TODO(enne): Remove this once syncing happens to the pending tree.
-  void Invalidate(const Region& invalidation);
-
   void SetLayerBounds(gfx::Size layer_bounds);
   gfx::Size LayerBounds() const;
 
-  const PictureLayerTiling* AddTiling(
-      float contents_scale,
-      gfx::Size tile_size);
+  PictureLayerTiling* AddTiling(float contents_scale);
   size_t num_tilings() const { return tilings_.size(); }
+  PictureLayerTiling* tiling_at(size_t idx) { return tilings_[idx]; }
+  const PictureLayerTiling* tiling_at(size_t idx) const {
+    return tilings_[idx];
+  }
 
-  void Reset();
+  // Remove all tilings.
+  void RemoveAllTilings();
 
-  void UpdateTilePriorities(const gfx::Size& device_viewport,
-                            float layer_content_scale_x,
-                            float layer_content_scale_y,
-                            const gfx::Transform& last_screen_transform,
-                            const gfx::Transform& current_screen_transform,
-                            double time_delta);
+  // Remove one tiling.
+  void Remove(PictureLayerTiling* tiling);
 
+  // Remove all tiles; keep all tilings.
+  void RemoveAllTiles();
+
+  // For all tilings, create any tile that intersects |layer_rect|.
+  void CreateTilesFromLayerRect(gfx::Rect layer_rect);
+
+  void UpdateTilePriorities(
+      WhichTree tree,
+      gfx::Size device_viewport,
+      gfx::Rect viewport_in_content_space,
+      gfx::Size last_layer_bounds,
+      gfx::Size current_layer_bounds,
+      gfx::Size last_layer_content_bounds,
+      gfx::Size current_layer_content_bounds,
+      float last_layer_contents_scale,
+      float current_layer_contents_scale,
+      const gfx::Transform& last_screen_transform,
+      const gfx::Transform& current_screen_transform,
+      int current_source_frame_number,
+      double current_frame_time);
+
+  void DidBecomeActive();
+
   // For a given rect, iterates through tiles that can fill it.  If no
   // set of tiles with resources can fill the rect, then it will iterate
   // through null tiles with valid geometry_rect() until the rect is full.
@@ -50,7 +71,11 @@
   // exactly fill rect with no overlap.
   class CC_EXPORT Iterator {
    public:
-    Iterator(PictureLayerTilingSet* set, float contents_scale, gfx::Rect rect);
+    Iterator(const PictureLayerTilingSet* set,
+      float contents_scale,
+      gfx::Rect content_rect,
+      float ideal_contents_scale,
+      PictureLayerTiling::LayerDeviceAlignment layerDeviceAlignment);
     ~Iterator();
 
     // Visible rect (no borders), always in the space of rect,
@@ -67,11 +92,18 @@
     Iterator& operator++();
     operator bool() const;
 
+    PictureLayerTiling* CurrentTiling();
+
    private:
-    PictureLayerTilingSet* set_;
+    int NextTiling() const;
+
+    const PictureLayerTilingSet* set_;
     float contents_scale_;
+    float ideal_contents_scale_;
+    PictureLayerTiling::LayerDeviceAlignment layer_device_alignment_;
     PictureLayerTiling::Iterator tiling_iter_;
     int current_tiling_;
+    int ideal_tiling_;
 
     Region current_region_;
     Region missing_region_;
@@ -82,7 +114,6 @@
   PictureLayerTilingClient* client_;
   gfx::Size layer_bounds_;
   ScopedPtrVector<PictureLayerTiling> tilings_;
-  Region invalidation_;
 
   friend class Iterator;
 };
Index: src/cc/font_atlas.cc
===================================================================
--- src/cc/font_atlas.cc	(revision 184497)
+++ src/cc/font_atlas.cc	(working copy)
@@ -7,13 +7,79 @@
 #include <vector>
 
 #include "base/string_split.h"
+#include "skia/ext/refptr.h"
 #include "third_party/skia/include/core/SkCanvas.h"
+#include "third_party/skia/include/effects/SkColorMatrixFilter.h"
 
+namespace {
+
+// The FontAtlas uses a bitmap with pre-rendered RED glyps to display text.
+// Therefore using SkPaint::setColor() has no effect on the font's color when text is drawn.
+// This helper class uses color filtering as a workaround to change the font's color.
+class ScopedFontColorFilter {
+public:
+    ScopedFontColorFilter()
+        : m_paint(0)
+    {
+    }
+
+    void init(SkPaint* paint, const SkColor& color)
+    {
+        if (color == SK_ColorRED)
+            return;
+
+        SkColorMatrix matrix;
+        memset(matrix.fMat, 0, sizeof(matrix.fMat));
+
+        // Set the matrix to transform the pre-rendered RED font into the provided color.
+        matrix.fMat[5 * 0] = SkColorGetR(color) / 255.0;
+        matrix.fMat[5 * 1] = SkColorGetG(color) / 255.0;
+        matrix.fMat[5 * 2] = SkColorGetB(color) / 255.0;
+        matrix.fMat[5 * 3 + 3] = SkColorGetA(color) / 255.0;
+
+        // SkPaint can only use one color filter, so the old one needs to be saved.
+        SkColorFilter* oldFilter = paint->getColorFilter();
+        if (oldFilter) {
+            // Increase the reference count, so the old filter is not released when it's replaced.
+            oldFilter->ref();
+
+            // Save the old filter for later restoring.
+            // Reference count will get decreased on destruction.
+            m_oldFilter = skia::AdoptRef(oldFilter);
+
+            // If the old filter had a color matrix, the new filter will use both.
+            SkColorMatrix oldMatrix;
+            if (oldFilter->asColorMatrix(oldMatrix.fMat))
+                matrix.setConcat(oldMatrix, matrix);
+        }
+
+        // Set the new color filter and replace the old one.
+        skia::RefPtr<SkColorMatrixFilter> filter = skia::AdoptRef(new SkColorMatrixFilter(matrix));
+        paint->setColorFilter(filter.get());
+
+        m_paint = paint;
+    }
+
+    ~ScopedFontColorFilter()
+    {
+        // Remove the color filter and restore the old one.
+        if (m_paint)
+            m_paint->setColorFilter(m_oldFilter.get());
+    }
+
+private:
+    SkPaint* m_paint;
+    skia::RefPtr<SkColorFilter> m_oldFilter;
+};
+
+}  // namespace
+
 namespace cc {
 
 FontAtlas::FontAtlas(SkBitmap bitmap, gfx::Rect asciiToRectTable[128], int fontHeight)
     : m_atlas(bitmap)
     , m_fontHeight(fontHeight)
+    , m_color(SK_ColorRED)
 {
     for (size_t i = 0; i < 128; ++i)
         m_asciiToRectTable[i] = asciiToRectTable[i];
@@ -23,14 +89,17 @@
 {
 }
 
-void FontAtlas::drawText(SkCanvas* canvas, const SkPaint& paint, const std::string& text, const gfx::Point& destPosition, const gfx::Size& clip) const
+void FontAtlas::drawText(SkCanvas* canvas, SkPaint* paint, const std::string& text, const gfx::Point& destPosition, const gfx::Size& clip) const
 {
+    ScopedFontColorFilter filter;
+    filter.init(paint, m_color);
+
     std::vector<std::string> lines;
     base::SplitString(text, '\n', &lines);
 
     gfx::Point position = destPosition;
     for (size_t i = 0; i < lines.size(); ++i) {
-        drawOneLineOfTextInternal(canvas, paint, lines[i], position);
+        drawOneLineOfTextInternal(canvas, *paint, lines[i], position);
         position.set_y(position.y() + m_fontHeight);
         if (position.y() > clip.height())
             return;
Index: src/cc/priority_calculator.cc
===================================================================
--- src/cc/priority_calculator.cc	(revision 184497)
+++ src/cc/priority_calculator.cc	(working copy)
@@ -3,10 +3,9 @@
 // found in the LICENSE file.
 
 #include "cc/priority_calculator.h"
+
 #include "ui/gfx/rect.h"
 
-using namespace std;
-
 namespace cc {
 
 static const int nothingPriorityCutoff = -3;
@@ -65,16 +64,16 @@
     // FIXME: We should remove this once we have priorities for all
     //        textures (we can't currently calculate distances for
     //        off-screen textures).
-    return min(lingeringLimitPriority,
-               max(lingeringBasePriority, previousPriority + 1));
+    return std::min(lingeringLimitPriority,
+                    std::max(lingeringBasePriority, previousPriority + 1));
 }
 
 namespace {
 int manhattanDistance(const gfx::Rect& a, const gfx::Rect& b)
 {
     gfx::Rect c = gfx::UnionRects(a, b);
-    int x = max(0, c.width() - a.width() - b.width() + 1);
-    int y = max(0, c.height() - a.height() - b.height() + 1);
+    int x = std::max(0, c.width() - a.width() - b.width() + 1);
+    int y = std::max(0, c.height() - a.height() - b.height() + 1);
     return (x + y);
 }
 }
@@ -85,7 +84,7 @@
     int distance = manhattanDistance(visibleRect, textureRect);
     if (!distance)
         return visiblePriority(drawsToRootSurface);
-    return min(notVisibleLimitPriority, notVisibleBasePriority + distance);
+    return std::min(notVisibleLimitPriority, notVisibleBasePriority + distance);
 }
 
 // static
@@ -94,7 +93,7 @@
     return smallAnimatedLayerPriority;
 }
 
-// static 
+// static
 int PriorityCalculator::highestPriority()
 {
     return mostHighPriority;
Index: src/cc/tiled_layer_unittest.cc
===================================================================
--- src/cc/tiled_layer_unittest.cc	(revision 184497)
+++ src/cc/tiled_layer_unittest.cc	(working copy)
@@ -7,6 +7,7 @@
 #include "cc/bitmap_content_layer_updater.h"
 #include "cc/layer_painter.h"
 #include "cc/overdraw_metrics.h"
+#include "cc/prioritized_resource_manager.h"
 #include "cc/rendering_stats.h"
 #include "cc/resource_update_controller.h"
 #include "cc/single_thread_proxy.h" // For DebugScopedSetImplThread
@@ -28,7 +29,6 @@
 public:
     TestOcclusionTracker()
         : OcclusionTracker(gfx::Rect(0, 0, 1000, 1000), true)
-        , m_layerClipRectInTarget(gfx::Rect(0, 0, 1000, 1000))
     {
         m_stack.push_back(StackObject());
     }
@@ -38,13 +38,10 @@
         m_stack.back().target = renderTarget;
     }
 
-    void setOcclusion(const Region& occlusion) { m_stack.back().occlusionFromInsideTarget = occlusion; }
-
-protected:
-    virtual gfx::Rect layerClipRectInTarget(const Layer* layer) const OVERRIDE { return m_layerClipRectInTarget; }
-
-private:
-    gfx::Rect m_layerClipRectInTarget;
+    void setOcclusion(const Region& occlusion)
+    {
+        m_stack.back().occlusionFromInsideTarget = occlusion;
+    }
 };
 
 class TiledLayerTest : public testing::Test {
@@ -1031,6 +1028,7 @@
 
     // The tile size is 100x100.
 
+    m_layerTreeHost->setViewportSize(gfx::Size(600, 600), gfx::Size(600, 600));
     layer->setBounds(gfx::Size(600, 600));
     calcDrawProps(layer);
 
@@ -1083,6 +1081,7 @@
 
     // The tile size is 100x100.
 
+    m_layerTreeHost->setViewportSize(gfx::Size(600, 600), gfx::Size(600, 600));
     layer->setBounds(gfx::Size(600, 600));
     calcDrawProps(layer);
 
@@ -1143,6 +1142,7 @@
 
     // The tile size is 100x100.
 
+    m_layerTreeHost->setViewportSize(gfx::Size(600, 600), gfx::Size(600, 600));
     layer->setBounds(gfx::Size(600, 600));
     calcDrawProps(layer);
 
@@ -1185,6 +1185,7 @@
 
     // This makes sure the painting works when the occluded region (in screen space)
     // is transformed differently than the layer.
+    m_layerTreeHost->setViewportSize(gfx::Size(600, 600), gfx::Size(600, 600));
     layer->setBounds(gfx::Size(600, 600));
     calcDrawProps(layer);
     gfx::Transform screenTransform;
@@ -1217,6 +1218,7 @@
     // This makes sure the painting works when the content space is scaled to
     // a different layer space. In this case tiles are scaled to be 200x200
     // pixels, which means none should be occluded.
+    m_layerTreeHost->setViewportSize(gfx::Size(600, 600), gfx::Size(600, 600));
     layer->setBounds(gfx::Size(600, 600));
     layer->setRasterScale(0.5);
     calcDrawProps(layer);
@@ -1576,7 +1578,7 @@
 public:
     static scoped_ptr<TrackingLayerPainter> create() { return make_scoped_ptr(new TrackingLayerPainter()); }
 
-    virtual void paint(SkCanvas*, const gfx::Rect& contentRect, gfx::RectF&) OVERRIDE
+    virtual void paint(SkCanvas*, gfx::Rect contentRect, gfx::RectF&) OVERRIDE
     {
         m_paintedRect = contentRect;
     }
Index: src/cc/scrollbar_geometry_stub.h
===================================================================
--- src/cc/scrollbar_geometry_stub.h	(revision 184497)
+++ src/cc/scrollbar_geometry_stub.h	(working copy)
@@ -7,7 +7,7 @@
 
 #include "base/memory/scoped_ptr.h"
 #include "cc/cc_export.h"
-#include <public/WebScrollbarThemeGeometry.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbarThemeGeometry.h"
 
 namespace cc {
 
Index: src/cc/texture_layer.h
===================================================================
--- src/cc/texture_layer.h	(revision 184497)
+++ src/cc/texture_layer.h	(working copy)
@@ -5,8 +5,12 @@
 #ifndef CC_TEXTURE_LAYER_H_
 #define CC_TEXTURE_LAYER_H_
 
+#include <string>
+
+#include "base/callback.h"
 #include "cc/cc_export.h"
 #include "cc/layer.h"
+#include "cc/texture_mailbox.h"
 
 namespace WebKit {
 class WebGraphicsContext3D;
@@ -24,6 +28,9 @@
     // are driven by an external process.
     static scoped_refptr<TextureLayer> create(TextureLayerClient*);
 
+    // Used when mailbox names are specified instead of texture IDs.
+    static scoped_refptr<TextureLayer> createForMailbox();
+
     void clearClient() { m_client = 0; }
 
     virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
@@ -31,8 +38,8 @@
     // Sets whether this texture should be Y-flipped at draw time. Defaults to true.
     void setFlipped(bool);
 
-    // Sets a UV transform to be used at draw time. Defaults to (0, 0, 1, 1).
-    void setUVRect(const gfx::RectF&);
+    // Sets a UV transform to be used at draw time. Defaults to (0, 0) and (1, 1).
+    void setUV(gfx::PointF topLeft, gfx::PointF bottomRight);
 
     // Sets an opacity value per vertex. It will be multiplied by the layer opacity value.
     void setVertexOpacity(float bottomLeft, float topLeft, float topRight, float bottomRight);
@@ -48,6 +55,9 @@
     // Code path for plugins which supply their own texture ID.
     void setTextureId(unsigned);
 
+    // Code path for plugins which supply their own texture ID.
+    void setTextureMailbox(const TextureMailbox&);
+
     void willModifyTexture();
 
     virtual void setNeedsDisplayRect(const gfx::RectF&) OVERRIDE;
@@ -58,15 +68,19 @@
     virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
     virtual bool blocksPendingCommit() const OVERRIDE;
 
+    virtual bool canClipSelf() const OVERRIDE;
+
 protected:
-    explicit TextureLayer(TextureLayerClient*);
+    TextureLayer(TextureLayerClient*, bool usesMailbox);
     virtual ~TextureLayer();
 
 private:
     TextureLayerClient* m_client;
+    bool m_usesMailbox;
 
     bool m_flipped;
-    gfx::RectF m_uvRect;
+    gfx::PointF m_uvTopLeft;
+    gfx::PointF m_uvBottomRight;
     // [bottom left, top left, top right, bottom right]
     float m_vertexOpacity[4];
     bool m_premultipliedAlpha;
@@ -75,6 +89,7 @@
     bool m_contentCommitted;
 
     unsigned m_textureId;
+    TextureMailbox m_textureMailbox;
 };
 
 }
Index: src/cc/render_surface_impl.cc
===================================================================
--- src/cc/render_surface_impl.cc	(revision 184497)
+++ src/cc/render_surface_impl.cc	(working copy)
@@ -150,27 +150,6 @@
     m_contributingDelegatedRenderPassLayerList.clear();
 }
 
-static inline gfx::Rect computeClippedRectInTarget(const LayerImpl* owningLayer)
-{
-    DCHECK(owningLayer->parent());
-
-    const LayerImpl* renderTarget = owningLayer->parent()->renderTarget();
-    const RenderSurfaceImpl* self = owningLayer->renderSurface();
-
-    gfx::Rect clippedRectInTarget = self->clipRect();
-    if (owningLayer->backgroundFilters().hasFilterThatMovesPixels()) {
-        // If the layer has background filters that move pixels, we cannot scissor as tightly.
-        // FIXME: this should be able to be a tighter scissor, perhaps expanded by the filter outsets?
-        clippedRectInTarget = renderTarget->renderSurface()->contentRect();
-    } else if (clippedRectInTarget.IsEmpty()) {
-        // For surfaces, empty clipRect means that the surface does not clip anything.
-        clippedRectInTarget = renderTarget->renderSurface()->contentRect();
-        clippedRectInTarget.Intersect(gfx::ToEnclosingRect(self->drawableContentRect()));
-    } else
-        clippedRectInTarget.Intersect(gfx::ToEnclosingRect(self->drawableContentRect()));
-    return clippedRectInTarget;
-}
-
 RenderPass::Id RenderSurfaceImpl::renderPassId()
 {
     int layerId = m_owningLayer->id();
@@ -182,13 +161,10 @@
 void RenderSurfaceImpl::appendRenderPasses(RenderPassSink& passSink)
 {
     for (size_t i = 0; i < m_contributingDelegatedRenderPassLayerList.size(); ++i)
-        m_contributingDelegatedRenderPassLayerList[i]->appendContributingRenderPasses(passSink);
+        m_contributingDelegatedRenderPassLayerList[i]->AppendContributingRenderPasses(&passSink);
 
     scoped_ptr<RenderPass> pass = RenderPass::Create();
     pass->SetNew(renderPassId(), m_contentRect, m_damageTracker->currentDamageRect(), m_screenSpaceTransform);
-    pass->filters = m_owningLayer->filters();
-    pass->filter = m_owningLayer->filter();
-    pass->background_filters = m_owningLayer->backgroundFilters();
     passSink.appendRenderPass(pass.Pass());
 }
 
@@ -196,10 +172,9 @@
 {
     DCHECK(!forReplica || m_owningLayer->hasReplica());
 
-    gfx::Rect clippedRectInTarget = computeClippedRectInTarget(m_owningLayer);
     const gfx::Transform& drawTransform = forReplica ? m_replicaDrawTransform : m_drawTransform;
     SharedQuadState* sharedQuadState = quadSink.useSharedQuadState(SharedQuadState::Create());
-    sharedQuadState->SetAll(drawTransform, m_contentRect, clippedRectInTarget, m_clipRect, m_isClipped, m_drawOpacity);
+    sharedQuadState->SetAll(drawTransform, m_contentRect, m_clipRect, m_isClipped, m_drawOpacity);
 
     if (m_owningLayer->showDebugBorders()) {
         SkColor color = forReplica ? DebugColors::SurfaceReplicaBorderColor() : DebugColors::SurfaceBorderColor();
@@ -227,26 +202,30 @@
 
     gfx::RectF maskUVRect(0.0f, 0.0f, 1.0f, 1.0f);
     if (maskLayer) {
-        // Because the RenderSurface is sized base on the screen footprint,
-        // there can be a scale between the RenderSurface and the owning layer,
-        // as well as the mask. While the mask doesn't have a drawTransform, the
-        // owning layer has it (and should be pure scaling), so use that to
-        // scale the mask to the right size.
-        gfx::Vector2dF maskDrawScale = MathUtil::computeTransform2dScaleComponents(m_owningLayer->drawTransform(), 1.f);
-        float scaleX = contentRect().width() / maskLayer->contentsScaleX() / maskLayer->bounds().width() / maskDrawScale.x();
-        float scaleY = contentRect().height() / maskLayer->contentsScaleY() / maskLayer->bounds().height() / maskDrawScale.y();
+        gfx::Vector2dF owningLayerDrawScale = MathUtil::computeTransform2dScaleComponents(m_owningLayer->drawTransform(), 1.f);
+        gfx::SizeF unclippedSurfaceSize = gfx::ScaleSize(
+            m_owningLayer->contentBounds(),
+            owningLayerDrawScale.x(),
+            owningLayerDrawScale.y());
+        // This assumes that the owning layer clips its subtree when a mask is
+        // present.
+        DCHECK(gfx::RectF(unclippedSurfaceSize).Contains(contentRect()));
 
-        maskUVRect = gfx::RectF(static_cast<float>(contentRect().x()) / contentRect().width() * scaleX,
-                                static_cast<float>(contentRect().y()) / contentRect().height() * scaleY,
-                                scaleX,
-                                scaleY);
+        float uvScaleX = contentRect().width() / unclippedSurfaceSize.width();
+        float uvScaleY = contentRect().height() / unclippedSurfaceSize.height();
+
+        maskUVRect = gfx::RectF(
+            static_cast<float>(contentRect().x()) / contentRect().width() * uvScaleX,
+            static_cast<float>(contentRect().y()) / contentRect().height() * uvScaleY,
+            uvScaleX,
+            uvScaleY);
     }
 
     ResourceProvider::ResourceId maskResourceId = maskLayer ? maskLayer->contentsResourceId() : 0;
     gfx::Rect contentsChangedSinceLastFrame = contentsChanged() ? m_contentRect : gfx::Rect();
 
     scoped_ptr<RenderPassDrawQuad> quad = RenderPassDrawQuad::Create();
-    quad->SetNew(sharedQuadState, contentRect(), renderPassId, forReplica, maskResourceId, contentsChangedSinceLastFrame, maskUVRect);
+    quad->SetNew(sharedQuadState, contentRect(), renderPassId, forReplica, maskResourceId, contentsChangedSinceLastFrame, maskUVRect, m_owningLayer->filters(), m_owningLayer->filter(), m_owningLayer->backgroundFilters());
     quadSink.append(quad.PassAs<DrawQuad>(), appendQuadsData);
 }
 
Index: src/cc/layer_sorter.cc
===================================================================
--- src/cc/layer_sorter.cc	(revision 184497)
+++ src/cc/layer_sorter.cc	(working copy)
@@ -14,10 +14,15 @@
 #include "cc/render_surface_impl.h"
 #include "ui/gfx/transform.h"
 
-using namespace std;
-
 namespace cc {
 
+// This epsilon is used to determine if two layers are too close to each other
+// to be able to tell which is in front of the other.  It's a relative epsilon
+// so it is robust to changes in scene scale.  This value was chosen by picking
+// a value near machine epsilon and then increasing it until the flickering on
+// the test scene went away.
+const float kLayerEpsilon = 1e-4f;
+
 inline static float perpProduct(const gfx::Vector2dF& u, const gfx::Vector2dF& v)
 {
     return u.x() * v.y() - u.y() * v.x();
@@ -71,6 +76,14 @@
 {
 }
 
+static float const checkFloatingPointNumericAccuracy(float a, float b)
+{
+    float absDif = std::abs(b - a);
+    float absMax = std::max(std::abs(b), std::abs(a));
+    // Check to see if we've got a result with a reasonable amount of error.
+    return absDif / absMax;
+}
+
 // Checks whether layer "a" draws on top of layer "b". The weight value returned is an indication of
 // the maximum z-depth difference between the layers or zero if the layers are found to be intesecting
 // (some features are in front and some are behind).
@@ -112,10 +125,25 @@
     // which layer is in front.
     float maxPositive = 0;
     float maxNegative = 0;
+
+    // This flag tracks the existance of a numerically accurate seperation
+    // between two layers.  If there is no accurate seperation, the layers
+    // cannot be effectively sorted.
+    bool accurate = false;
+
     for (unsigned o = 0; o < overlapPoints.size(); o++) {
         float za = a->layerZFromProjectedPoint(overlapPoints[o]);
         float zb = b->layerZFromProjectedPoint(overlapPoints[o]);
 
+        // Here we attempt to avoid numeric issues with layers that are too
+        // close together.  If we have 2-sided quads that are very close
+        // together then we will draw them in document order to avoid
+        // flickering.  The correct solution is for the content maker to turn
+        // on back-face culling or move the quads apart (if they're not two
+        // sides of one object).
+        if (checkFloatingPointNumericAccuracy(za, zb) > kLayerEpsilon)
+          accurate = true;
+
         float diff = za - zb;
         if (diff > maxPositive)
             maxPositive = diff;
@@ -123,6 +151,10 @@
             maxNegative = diff;
     }
 
+    // If we can't tell which should come first, we use document order.
+    if (!accurate)
+      return ABeforeB;
+
     float maxDiff = (fabsf(maxPositive) > fabsf(maxNegative) ? maxPositive : maxNegative);
 
     // If the results are inconsistent (and the z difference substantial to rule out
@@ -243,8 +275,8 @@
 
         node.shape = LayerShape(layerWidth, layerHeight, drawTransform);
 
-        maxZ = max(maxZ, node.shape.transformOrigin.z());
-        minZ = min(minZ, node.shape.transformOrigin.z());
+        maxZ = std::max(maxZ, node.shape.transformOrigin.z());
+        minZ = std::min(minZ, node.shape.transformOrigin.z());
     }
 
     m_zRange = fabsf(maxZ - minZ);
Index: src/cc/scrollbar_animation_controller.cc
===================================================================
--- src/cc/scrollbar_animation_controller.cc	(revision 184497)
+++ src/cc/scrollbar_animation_controller.cc	(working copy)
@@ -1,103 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "cc/scrollbar_animation_controller.h"
-
-#include "base/debug/trace_event.h"
-#include "base/time.h"
-#include "build/build_config.h"
-#include "cc/scrollbar_layer_impl.h"
-
-#if defined(OS_ANDROID)
-#include "cc/scrollbar_animation_controller_linear_fade.h"
-#endif
-
-namespace cc {
-
-#if defined(OS_ANDROID)
-scoped_ptr<ScrollbarAnimationController> ScrollbarAnimationController::create(LayerImpl* scrollLayer)
-{
-    static const double fadeoutDelay = 0.3;
-    static const double fadeoutLength = 0.3;
-    return ScrollbarAnimationControllerLinearFade::create(scrollLayer, fadeoutDelay, fadeoutLength).PassAs<ScrollbarAnimationController>();
-}
-#else
-scoped_ptr<ScrollbarAnimationController> ScrollbarAnimationController::create(LayerImpl* scrollLayer)
-{
-    return make_scoped_ptr(new ScrollbarAnimationController(scrollLayer));
-}
-#endif
-
-ScrollbarAnimationController::ScrollbarAnimationController(LayerImpl* scrollLayer)
-    : m_horizontalScrollbarLayer(0)
-    , m_verticalScrollbarLayer(0)
-{
-    ScrollbarAnimationController::updateScrollOffsetAtTime(scrollLayer, 0);
-}
-
-ScrollbarAnimationController::~ScrollbarAnimationController()
-{
-}
-
-bool ScrollbarAnimationController::animate(double)
-{
-    return false;
-}
-
-void ScrollbarAnimationController::didPinchGestureBegin()
-{
-    didPinchGestureBeginAtTime((base::TimeTicks::Now() - base::TimeTicks()).InSecondsF());
-}
-
-void ScrollbarAnimationController::didPinchGestureUpdate()
-{
-    didPinchGestureUpdateAtTime((base::TimeTicks::Now() - base::TimeTicks()).InSecondsF());
-}
-
-void ScrollbarAnimationController::didPinchGestureEnd()
-{
-    didPinchGestureEndAtTime((base::TimeTicks::Now() - base::TimeTicks()).InSecondsF());
-}
-
-void ScrollbarAnimationController::updateScrollOffset(LayerImpl* scrollLayer)
-{
-    updateScrollOffsetAtTime(scrollLayer, (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF());
-}
-
-gfx::Size ScrollbarAnimationController::getScrollLayerBounds(const LayerImpl* scrollLayer)
-{
-    if (!scrollLayer->children().size())
-        return gfx::Size();
-    // Copy & paste from LayerTreeHostImpl...
-    // FIXME: Hardcoding the first child here is weird. Think of
-    // a cleaner way to get the contentBounds on the Impl side.
-    return scrollLayer->children()[0]->bounds();
-}
-
-void ScrollbarAnimationController::updateScrollOffsetAtTime(LayerImpl* scrollLayer, double)
-{
-    m_currentOffset = scrollLayer->scrollOffset() + scrollLayer->scrollDelta();
-    m_totalSize = getScrollLayerBounds(scrollLayer);
-    m_maximum = scrollLayer->maxScrollOffset();
-
-    // Get the m_currentOffset.y() value for a sanity-check on scrolling
-    // benchmark metrics. Specifically, we want to make sure
-    // BasicMouseWheelSmoothScrollGesture has proper scroll curves.
-    TRACE_COUNTER_ID1("gpu", "scroll_offset_y", this, m_currentOffset.y());
-
-
-    if (m_horizontalScrollbarLayer) {
-        m_horizontalScrollbarLayer->setCurrentPos(m_currentOffset.x());
-        m_horizontalScrollbarLayer->setTotalSize(m_totalSize.width());
-        m_horizontalScrollbarLayer->setMaximum(m_maximum.x());
-    }
-
-    if (m_verticalScrollbarLayer) {
-        m_verticalScrollbarLayer->setCurrentPos(m_currentOffset.y());
-        m_verticalScrollbarLayer->setTotalSize(m_totalSize.height());
-        m_verticalScrollbarLayer->setMaximum(m_maximum.y());
-    }
-}
-
-}  // namespace cc
Index: src/cc/picture_layer_tiling_set.cc
===================================================================
--- src/cc/picture_layer_tiling_set.cc	(revision 184497)
+++ src/cc/picture_layer_tiling_set.cc	(working copy)
@@ -6,6 +6,18 @@
 
 namespace cc {
 
+namespace {
+
+class LargestToSmallestScaleFunctor {
+ public:
+  bool operator() (PictureLayerTiling* left, PictureLayerTiling* right) {
+    return left->contents_scale() > right->contents_scale();
+  }
+};
+
+}  // namespace
+
+
 PictureLayerTilingSet::PictureLayerTilingSet(
     PictureLayerTilingClient * client)
     : client_(client) {
@@ -14,16 +26,19 @@
 PictureLayerTilingSet::~PictureLayerTilingSet() {
 }
 
+void PictureLayerTilingSet::SetClient(PictureLayerTilingClient* client) {
+  client_ = client;
+  for (size_t i = 0; i < tilings_.size(); ++i)
+    tilings_[i]->SetClient(client_);
+}
+
 void PictureLayerTilingSet::CloneAll(
     const PictureLayerTilingSet& other,
     const Region& invalidation) {
-  layer_bounds_ = other.layer_bounds_;
   tilings_.clear();
   tilings_.reserve(other.tilings_.size());
-  for (size_t i = 0; i < other.tilings_.size(); ++i) {
-    tilings_.append(other.tilings_[i]->Clone());
-    tilings_.last()->Invalidate(invalidation);
-  }
+  for (size_t i = 0; i < other.tilings_.size(); ++i)
+    Clone(other.tilings_[i], invalidation);
 }
 
 void PictureLayerTilingSet::Clone(
@@ -33,8 +48,14 @@
   for (size_t i = 0; i < tilings_.size(); ++i)
     DCHECK_NE(tilings_[i]->contents_scale(), tiling->contents_scale());
 
-  tilings_.append(tiling->Clone());
-  tilings_.last()->Invalidate(invalidation);
+  tilings_.push_back(tiling->Clone());
+  gfx::Size size = tilings_.back()->layer_bounds();
+  tilings_.back()->SetClient(client_);
+  tilings_.back()->Invalidate(invalidation);
+  // Intentionally use this set's layer bounds, as it may have changed.
+  tilings_.back()->SetLayerBounds(layer_bounds_);
+
+  tilings_.sort(LargestToSmallestScaleFunctor());
 }
 
 void PictureLayerTilingSet::SetLayerBounds(gfx::Size layer_bounds) {
@@ -49,35 +70,65 @@
   return layer_bounds_;
 }
 
-void PictureLayerTilingSet::Invalidate(const Region& invalidation) {
-  if (invalidation.IsEmpty())
-    return;
+PictureLayerTiling* PictureLayerTilingSet::AddTiling(float contents_scale) {
+  tilings_.push_back(PictureLayerTiling::Create(contents_scale));
+  PictureLayerTiling* appended = tilings_.back();
+  appended->SetClient(client_);
+  appended->SetLayerBounds(layer_bounds_);
 
-  for (size_t i = 0; i < tilings_.size(); ++i)
-    tilings_[i]->Invalidate(invalidation);
+  tilings_.sort(LargestToSmallestScaleFunctor());
+  return appended;
 }
 
-const PictureLayerTiling* PictureLayerTilingSet::AddTiling(
-    float contents_scale,
-    gfx::Size tile_size) {
-  tilings_.append(PictureLayerTiling::Create(contents_scale, tile_size));
-  tilings_.last()->SetClient(client_);
-  tilings_.last()->SetLayerBounds(layer_bounds_);
-  return tilings_.last();
+void PictureLayerTilingSet::RemoveAllTilings() {
+  tilings_.clear();
 }
 
-void PictureLayerTilingSet::Reset() {
+void PictureLayerTilingSet::Remove(PictureLayerTiling* tiling) {
+  ScopedPtrVector<PictureLayerTiling>::iterator iter =
+    std::find(tilings_.begin(), tilings_.end(), tiling);
+  if (iter == tilings_.end())
+    return;
+  tilings_.erase(iter);
+}
+
+void PictureLayerTilingSet::RemoveAllTiles() {
   for (size_t i = 0; i < tilings_.size(); ++i)
     tilings_[i]->Reset();
 }
 
-PictureLayerTilingSet::Iterator::Iterator(PictureLayerTilingSet* set,
-                                          float contents_scale,
-                                          gfx::Rect content_rect)
+void PictureLayerTilingSet::CreateTilesFromLayerRect(gfx::Rect layer_rect) {
+  for (size_t i = 0; i < tilings_.size(); ++i)
+    tilings_[i]->CreateTilesFromLayerRect(layer_rect);
+}
+
+PictureLayerTilingSet::Iterator::Iterator(
+    const PictureLayerTilingSet* set,
+    float contents_scale,
+    gfx::Rect content_rect,
+    float ideal_contents_scale,
+    PictureLayerTiling::LayerDeviceAlignment layerDeviceAlignment)
     : set_(set),
       contents_scale_(contents_scale),
+      ideal_contents_scale_(ideal_contents_scale),
+      layer_device_alignment_(layerDeviceAlignment),
       current_tiling_(-1) {
   missing_region_.Union(content_rect);
+
+  for (ideal_tiling_ = 0;
+       static_cast<size_t>(ideal_tiling_) < set_->tilings_.size();
+       ++ideal_tiling_) {
+    PictureLayerTiling* tiling = set_->tilings_[ideal_tiling_];
+    if (tiling->contents_scale() < ideal_contents_scale_) {
+      if (ideal_tiling_ > 0)
+        ideal_tiling_--;
+      break;
+    }
+  }
+
+  if (ideal_tiling_ == set_->tilings_.size() && ideal_tiling_ > 0)
+    ideal_tiling_--;
+
   ++(*this);
 }
 
@@ -117,6 +168,30 @@
   return *tiling_iter_;
 }
 
+PictureLayerTiling* PictureLayerTilingSet::Iterator::CurrentTiling() {
+  if (current_tiling_ < 0)
+    return NULL;
+  if (static_cast<size_t>(current_tiling_) >= set_->tilings_.size())
+    return NULL;
+  return set_->tilings_[current_tiling_];
+}
+
+int PictureLayerTilingSet::Iterator::NextTiling() const {
+  // Order returned by this method is:
+  // 1. Ideal tiling index
+  // 2. Tiling index < Ideal in decreasing order (higher res than ideal)
+  // 3. Tiling index > Ideal in increasing order (lower res than ideal)
+  // 4. Tiling index > tilings.size() (invalid index)
+  if (current_tiling_ < 0)
+    return ideal_tiling_;
+  else if (current_tiling_ > ideal_tiling_)
+    return current_tiling_ + 1;
+  else if (current_tiling_)
+    return current_tiling_ - 1;
+  else
+    return ideal_tiling_ + 1;
+}
+
 PictureLayerTilingSet::Iterator& PictureLayerTilingSet::Iterator::operator++() {
   bool first_time = current_tiling_ < 0;
 
@@ -139,7 +214,7 @@
     // tiling and set up to iterate through all of the remaining holes.
     // This will also happen the first time through the loop.
     if (!region_iter_.has_rect()) {
-      current_tiling_++;
+      current_tiling_ = NextTiling();
       current_region_.Swap(missing_region_);
       missing_region_.Clear();
       region_iter_ = Region::Iterator(current_region_);
@@ -169,7 +244,8 @@
     tiling_iter_ = PictureLayerTiling::Iterator(
         set_->tilings_[current_tiling_],
         contents_scale_,
-        last_rect);
+        last_rect,
+        layer_device_alignment_);
   }
 
   return *this;
@@ -181,17 +257,45 @@
 }
 
 void PictureLayerTilingSet::UpdateTilePriorities(
-    const gfx::Size& device_viewport,
-    float layer_content_scale_x,
-    float layer_content_scale_y,
+    WhichTree tree,
+    gfx::Size device_viewport,
+    gfx::Rect viewport_in_content_space,
+    gfx::Size last_layer_bounds,
+    gfx::Size current_layer_bounds,
+    gfx::Size last_layer_content_bounds,
+    gfx::Size current_layer_content_bounds,
+    float last_layer_contents_scale,
+    float current_layer_contents_scale,
     const gfx::Transform& last_screen_transform,
     const gfx::Transform& current_screen_transform,
-    double time_delta) {
+    int current_source_frame_number,
+    double current_frame_time) {
+  gfx::RectF viewport_in_layer_space = gfx::ScaleRect(
+    viewport_in_content_space,
+    1.f / current_layer_contents_scale,
+    1.f / current_layer_contents_scale);
+
   for (size_t i = 0; i < tilings_.size(); ++i) {
     tilings_[i]->UpdateTilePriorities(
-        device_viewport, layer_content_scale_x, layer_content_scale_y,
-        last_screen_transform, current_screen_transform, time_delta);
+        tree,
+        device_viewport,
+        viewport_in_layer_space,
+        last_layer_bounds,
+        current_layer_bounds,
+        last_layer_content_bounds,
+        current_layer_content_bounds,
+        last_layer_contents_scale,
+        current_layer_contents_scale,
+        last_screen_transform,
+        current_screen_transform,
+        current_source_frame_number,
+        current_frame_time);
   }
 }
 
+void PictureLayerTilingSet::DidBecomeActive() {
+  for (size_t i = 0; i < tilings_.size(); ++i)
+    tilings_[i]->DidBecomeActive();
+}
+
 }  // namespace cc
Index: src/cc/content_layer_updater.h
===================================================================
--- src/cc/content_layer_updater.h	(revision 184497)
+++ src/cc/content_layer_updater.h	(working copy)
@@ -7,6 +7,7 @@
 
 #include "cc/cc_export.h"
 #include "cc/layer_updater.h"
+#include "ui/gfx/rect.h"
 
 class SkCanvas;
 
Index: src/cc/append_quads_data.h
===================================================================
--- src/cc/append_quads_data.h	(revision 184497)
+++ src/cc/append_quads_data.h	(working copy)
@@ -13,6 +13,7 @@
 struct AppendQuadsData {
     AppendQuadsData()
         : hadOcclusionFromOutsideTargetSurface(false)
+        , hadIncompleteTile(false)
         , numMissingTiles(0)
         , renderPassId(0, 0)
     {
@@ -20,6 +21,7 @@
 
     explicit AppendQuadsData(RenderPass::Id renderPassId)
         : hadOcclusionFromOutsideTargetSurface(false)
+        , hadIncompleteTile(false)
         , numMissingTiles(0)
         , renderPassId(renderPassId)
     {
@@ -28,6 +30,8 @@
     // Set by the QuadCuller.
     bool hadOcclusionFromOutsideTargetSurface;
     // Set by the layer appending quads.
+    bool hadIncompleteTile;
+    // Set by the layer appending quads.
     int64 numMissingTiles;
     // Given to the layer appending quads.
     const RenderPass::Id renderPassId;
Index: src/cc/tile_priority.h
===================================================================
--- src/cc/tile_priority.h	(revision 184497)
+++ src/cc/tile_priority.h	(working copy)
@@ -8,10 +8,15 @@
 #include <limits>
 
 #include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
 #include "cc/picture_pile.h"
 #include "ui/gfx/rect.h"
 #include "ui/gfx/size.h"
 
+namespace base {
+class Value;
+}
+
 namespace cc {
 
 enum WhichTree {
@@ -20,22 +25,53 @@
   ACTIVE_TREE = 0,
   PENDING_TREE = 1,
   NUM_TREES = 2
+  // Be sure to update WhichTreeAsValue when adding new fields.
 };
+scoped_ptr<base::Value> WhichTreeAsValue(
+    WhichTree tree);
 
 enum TileResolution {
   LOW_RESOLUTION = 0 ,
   HIGH_RESOLUTION = 1,
-  NON_IDEAL_RESOLUTION = 2
+  NON_IDEAL_RESOLUTION = 2,
 };
 
 struct CC_EXPORT TilePriority {
   TilePriority()
-     : resolution(NON_IDEAL_RESOLUTION),
-       time_to_visible_in_seconds(std::numeric_limits<float>::max()),
-       time_to_ideal_resolution_in_seconds(std::numeric_limits<float>::max()),
-       distance_to_visible_in_pixels(std::numeric_limits<float>::max()) {}
+     : is_live(false),
+       resolution(NON_IDEAL_RESOLUTION),
+       time_to_visible_in_seconds(std::numeric_limits<float>::infinity()),
+       distance_to_visible_in_pixels(std::numeric_limits<float>::infinity()) {}
 
+  TilePriority(
+    TileResolution resolution,
+    float time_to_visible_in_seconds,
+    float distance_to_visible_in_pixels)
+     : is_live(true),
+       resolution(resolution),
+       time_to_visible_in_seconds(time_to_visible_in_seconds),
+       distance_to_visible_in_pixels(distance_to_visible_in_pixels) {}
+
   TilePriority(const TilePriority& active, const TilePriority& pending) {
+    if (!pending.is_live) {
+      if (!active.is_live) {
+        is_live = false;
+        return;
+      }
+      is_live = true;
+      resolution = active.resolution;
+      time_to_visible_in_seconds = active.time_to_visible_in_seconds;
+      distance_to_visible_in_pixels = active.distance_to_visible_in_pixels;
+      return;
+    } else if (!active.is_live) {
+      is_live = true;
+      resolution = pending.resolution;
+      time_to_visible_in_seconds = pending.time_to_visible_in_seconds;
+      distance_to_visible_in_pixels = pending.distance_to_visible_in_pixels;
+      return;
+    }
+
+    is_live = true;
     if (active.resolution == HIGH_RESOLUTION ||
         pending.resolution == HIGH_RESOLUTION)
       resolution = HIGH_RESOLUTION;
@@ -48,34 +84,41 @@
     time_to_visible_in_seconds =
       std::min(active.time_to_visible_in_seconds,
                pending.time_to_visible_in_seconds);
-    time_to_ideal_resolution_in_seconds =
-      std::min(active.time_to_ideal_resolution_in_seconds,
-               pending.time_to_ideal_resolution_in_seconds);
     distance_to_visible_in_pixels =
       std::min(active.distance_to_visible_in_pixels,
                pending.distance_to_visible_in_pixels);
   }
 
-  float time_to_needed_in_seconds() const {
-    return std::min(time_to_visible_in_seconds,
-                    time_to_ideal_resolution_in_seconds);
-  }
+  static const float kMaxDistanceInContentSpace;
+  static const int64 kNumTilesToCoverWithInflatedViewportRectForPrioritization;
 
-  static const double kMaxTimeToVisibleInSeconds;
+  static inline float manhattanDistance(const gfx::RectF& a, const gfx::RectF& b) {
+    // Compute the union explicitly.
+    gfx::RectF c = gfx::RectF(
+        std::min(a.x(), b.x()),
+        std::min(a.y(), b.y()),
+        std::max(a.right(), b.right()) - std::min(a.x(), b.x()),
+        std::max(a.bottom(), b.bottom()) - std::min(a.y(), b.y()));
 
-  static int manhattanDistance(const gfx::RectF& a, const gfx::RectF& b);
+    // Rects touching the edge of the screen should not be considered visible.
+    // So we add 1 pixel here to avoid that situation.
+    float x = std::max(0.0f, c.width() - a.width() - b.width() + 1.0f);
+    float y = std::max(0.0f, c.height() - a.height() - b.height() + 1.0f);
+    return (x + y);
+  }
 
   // Calculate the time for the |current_bounds| to intersect with the
   // |target_bounds| given its previous location and time delta.
   // This function should work for both scaling and scrolling case.
-  static double TimeForBoundsToIntersect(gfx::RectF previous_bounds,
-                                         gfx::RectF current_bounds,
-                                         double time_delta,
-                                         gfx::RectF target_bounds);
+  static float TimeForBoundsToIntersect(const gfx::RectF& previous_bounds,
+                                        const gfx::RectF& current_bounds,
+                                        float time_delta,
+                                        const gfx::RectF& target_bounds);
 
+  // If a tile is not live, then all other fields are invalid.
+  bool is_live;
   TileResolution resolution;
   float time_to_visible_in_seconds;
-  float time_to_ideal_resolution_in_seconds;
   float distance_to_visible_in_pixels;
 };
 
@@ -91,22 +134,36 @@
 
   // You're the only thing in town. Go crazy.
   ALLOW_ANYTHING, // Venti.
+
+  // Be sure to update TreePriorityAsValue when adding new fields.
 };
+scoped_ptr<base::Value> TileMemoryLimitPolicyAsValue(
+    TileMemoryLimitPolicy policy);
 
+enum TreePriority {
+  SAME_PRIORITY_FOR_BOTH_TREES,
+  SMOOTHNESS_TAKES_PRIORITY,
+  NEW_CONTENT_TAKES_PRIORITY
+
+  // Be sure to update TreePriorityAsValue when adding new fields.
+};
+scoped_ptr<base::Value> TreePriorityAsValue(TreePriority prio);
+
 class GlobalStateThatImpactsTilePriority {
  public:
   GlobalStateThatImpactsTilePriority()
     : memory_limit_policy(ALLOW_NOTHING)
     , memory_limit_in_bytes(0)
-    , smoothness_takes_priority(false) {
+    , tree_priority(SAME_PRIORITY_FOR_BOTH_TREES) {
   }
 
   TileMemoryLimitPolicy memory_limit_policy;
 
   size_t memory_limit_in_bytes;
 
-  // Set when scrolling.
-  bool smoothness_takes_priority;
+  TreePriority tree_priority;
+
+  scoped_ptr<base::Value> AsValue() const;
 };
 
 }  // namespace cc
Index: src/cc/resource_provider.cc
===================================================================
--- src/cc/resource_provider.cc	(revision 184497)
+++ src/cc/resource_provider.cc	(working copy)
@@ -15,13 +15,12 @@
 #include "cc/platform_color.h"
 #include "cc/texture_uploader.h"
 #include "cc/transferable_resource.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/khronos/GLES2/gl2ext.h"
 #include "ui/gfx/rect.h"
 #include "ui/gfx/vector2d.h"
 
-#include <public/WebGraphicsContext3D.h>
-
 using WebKit::WebGraphicsContext3D;
 
 namespace cc {
@@ -48,6 +47,18 @@
     return (format == GL_RGBA || format == GL_BGRA_EXT);
 }
 
+static unsigned createTextureId(WebGraphicsContext3D* context3d)
+{
+  unsigned textureId = 0;
+  GLC(context3d, textureId = context3d->createTexture());
+  GLC(context3d, context3d->bindTexture(GL_TEXTURE_2D, textureId));
+  GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
+  GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
+  GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
+  GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+  return textureId;
+}
+
 ResourceProvider::Resource::Resource()
     : glId(0)
     , glPixelBufferId(0)
@@ -60,6 +71,9 @@
     , exported(false)
     , markedForDeletion(false)
     , pendingSetPixels(false)
+    , allocated(false)
+    , enableReadLockFences(false)
+    , readLockFence(NULL)
     , size()
     , format(0)
     , filter(0)
@@ -67,6 +81,10 @@
 {
 }
 
+ResourceProvider::Resource::~Resource()
+{
+}
+
 ResourceProvider::Resource::Resource(unsigned textureId, const gfx::Size& size, GLenum format, GLenum filter)
     : glId(textureId)
     , glPixelBufferId(0)
@@ -79,6 +97,9 @@
     , exported(false)
     , markedForDeletion(false)
     , pendingSetPixels(false)
+    , allocated(false)
+    , enableReadLockFences(false)
+    , readLockFence(NULL)
     , size(size)
     , format(format)
     , filter(filter)
@@ -98,6 +119,9 @@
     , exported(false)
     , markedForDeletion(false)
     , pendingSetPixels(false)
+    , allocated(false)
+    , enableReadLockFences(false)
+    , readLockFence(NULL)
     , size(size)
     , format(format)
     , filter(filter)
@@ -179,27 +203,18 @@
     DCHECK_LE(size.height(), m_maxTextureSize);
 
     DCHECK(m_threadChecker.CalledOnValidThread());
-    unsigned textureId = 0;
     WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
     DCHECK(context3d);
-    GLC(context3d, textureId = context3d->createTexture());
-    GLC(context3d, context3d->bindTexture(GL_TEXTURE_2D, textureId));
-    GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
-    GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
-    GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
-    GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
+
+    // Create and set texture properties. Allocation is delayed until needed.
+    unsigned textureId = createTextureId(context3d);
     GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_POOL_CHROMIUM, texturePool));
-
     if (m_useTextureUsageHint && hint == TextureUsageFramebuffer)
         GLC(context3d, context3d->texParameteri(GL_TEXTURE_2D, GL_TEXTURE_USAGE_ANGLE, GL_FRAMEBUFFER_ATTACHMENT_ANGLE));
-    if (m_useTextureStorageExt && isTextureFormatSupportedForStorage(format)) {
-        GLenum storageFormat = textureToStorageFormat(format);
-        GLC(context3d, context3d->texStorage2DEXT(GL_TEXTURE_2D, 1, storageFormat, size.width(), size.height()));
-    } else
-        GLC(context3d, context3d->texImage2D(GL_TEXTURE_2D, 0, format, size.width(), size.height(), 0, format, GL_UNSIGNED_BYTE, 0));
 
     ResourceId id = m_nextId++;
     Resource resource(textureId, size, format, GL_LINEAR);
+    resource.allocated = false;
     m_resources[id] = resource;
     return id;
 }
@@ -212,6 +227,7 @@
 
     ResourceId id = m_nextId++;
     Resource resource(pixels, size, GL_RGBA, GL_LINEAR);
+    resource.allocated = true;
     m_resources[id] = resource;
     return id;
 }
@@ -231,19 +247,33 @@
     ResourceId id = m_nextId++;
     Resource resource(textureId, gfx::Size(), 0, GL_LINEAR);
     resource.external = true;
+    resource.allocated = true;
     m_resources[id] = resource;
     return id;
 }
 
+ResourceProvider::ResourceId ResourceProvider::createResourceFromTextureMailbox(const TextureMailbox& mailbox)
+{
+    DCHECK(m_threadChecker.CalledOnValidThread());
+    // Just store the information. Mailbox will be consumed in lockForRead().
+    ResourceId id = m_nextId++;
+    unsigned textureId = 0;
+    Resource resource(textureId, gfx::Size(), 0, GL_LINEAR);
+    resource.external = true;
+    resource.mailbox = mailbox;
+    m_resources[id] = resource;
+    return id;
+}
+
 void ResourceProvider::deleteResource(ResourceId id)
 {
     DCHECK(m_threadChecker.CalledOnValidThread());
     ResourceMap::iterator it = m_resources.find(id);
     CHECK(it != m_resources.end());
     Resource* resource = &it->second;
-    DCHECK(!resource->lockedForWrite);
     DCHECK(!resource->lockForReadCount);
     DCHECK(!resource->markedForDeletion);
+    DCHECK(resource->pendingSetPixels || !resource->lockedForWrite);
 
     if (resource->exported) {
         resource->markedForDeletion = true;
@@ -270,6 +300,18 @@
         DCHECK(context3d);
         GLC(context3d, context3d->deleteBuffer(resource->glPixelBufferId));
     }
+    if (!resource->mailbox.IsEmpty() && resource->external) {
+        WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
+        DCHECK(context3d);
+        unsigned syncPoint = resource->mailbox.sync_point();
+        if (resource->glId) {
+            GLC(context3d, context3d->bindTexture(GL_TEXTURE_2D, resource->glId));
+            GLC(context3d, context3d->produceTextureCHROMIUM(GL_TEXTURE_2D, resource->mailbox.data()));
+            GLC(context3d, context3d->deleteTexture(resource->glId));
+            syncPoint = context3d->insertSyncPoint();
+        }
+        resource->mailbox.RunReleaseCallback(syncPoint);
+    }
     if (resource->pixels)
         delete[] resource->pixels;
     if (resource->pixelBuffer)
@@ -296,8 +338,11 @@
     DCHECK(!resource->lockForReadCount);
     DCHECK(!resource->external);
     DCHECK(!resource->exported);
+    DCHECK(readLockFenceHasPassed(resource));
+    lazyAllocate(resource);
 
     if (resource->glId) {
+        DCHECK(!resource->pendingSetPixels);
         WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
         DCHECK(context3d);
         DCHECK(m_textureUploader.get());
@@ -311,6 +356,7 @@
     }
 
     if (resource->pixels) {
+        DCHECK(resource->allocated);
         DCHECK(resource->format == GL_RGBA);
         SkBitmap srcFull;
         srcFull.setConfig(SkBitmap::kARGB_8888_Config, imageRect.width(), imageRect.height());
@@ -385,7 +431,24 @@
     Resource* resource = &it->second;
     DCHECK(!resource->lockedForWrite);
     DCHECK(!resource->exported);
+    DCHECK(resource->allocated); // Uninitialized! Call setPixels or lockForWrite first.
+
+    if (!resource->glId && resource->external && !resource->mailbox.IsEmpty()) {
+        WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
+        DCHECK(context3d);
+        if (resource->mailbox.sync_point()) {
+            GLC(context3d, context3d->waitSyncPoint(resource->mailbox.sync_point()));
+            resource->mailbox.ResetSyncPoint();
+        }
+        resource->glId = context3d->createTexture();
+        GLC(context3d, context3d->bindTexture(GL_TEXTURE_2D, resource->glId));
+        GLC(context3d, context3d->consumeTextureCHROMIUM(GL_TEXTURE_2D, resource->mailbox.data()));
+    }
+
     resource->lockForReadCount++;
+    if (resource->enableReadLockFences)
+        resource->readLockFence = m_currentReadLockFence;
+
     return resource;
 }
 
@@ -410,10 +473,26 @@
     DCHECK(!resource->lockForReadCount);
     DCHECK(!resource->exported);
     DCHECK(!resource->external);
+    DCHECK(readLockFenceHasPassed(resource));
+    lazyAllocate(resource);
+
     resource->lockedForWrite = true;
     return resource;
 }
 
+bool ResourceProvider::canLockForWrite(ResourceId id)
+{
+    DCHECK(m_threadChecker.CalledOnValidThread());
+    ResourceMap::iterator it = m_resources.find(id);
+    CHECK(it != m_resources.end());
+    Resource* resource = &it->second;
+    return !resource->lockedForWrite &&
+           !resource->lockForReadCount &&
+           !resource->exported &&
+           !resource->external &&
+           readLockFenceHasPassed(resource);
+}
+
 void ResourceProvider::unlockForWrite(ResourceId id)
 {
     DCHECK(m_threadChecker.CalledOnValidThread());
@@ -645,7 +724,9 @@
         GLC(context3d, context3d->consumeTextureCHROMIUM(GL_TEXTURE_2D, it->mailbox.name));
         ResourceId id = m_nextId++;
         Resource resource(textureId, it->size, it->format, it->filter);
-        resource.mailbox.setName(it->mailbox.name);
+        resource.mailbox.SetName(it->mailbox);
+        // Don't allocate a texture for a child.
+        resource.allocated = true;
         m_resources[id] = resource;
         childInfo.parentToChildMap[id] = it->id;
         childInfo.childToParentMap[it->id] = id;
@@ -668,7 +749,7 @@
         Resource* resource = &mapIterator->second;
         DCHECK(resource->exported);
         resource->exported = false;
-        resource->mailbox.setName(it->mailbox.name);
+        DCHECK(resource->mailbox.Equals(it->mailbox));
         GLC(context3d, context3d->bindTexture(GL_TEXTURE_2D, resource->glId));
         GLC(context3d, context3d->consumeTextureCHROMIUM(GL_TEXTURE_2D, it->mailbox.name));
         if (resource->markedForDeletion)
@@ -685,7 +766,8 @@
     Resource* source = &it->second;
     DCHECK(!source->lockedForWrite);
     DCHECK(!source->lockForReadCount);
-    DCHECK(!source->external);
+    DCHECK(!source->external || (source->external && !source->mailbox.IsEmpty()));
+    DCHECK(source->allocated);
     if (source->exported)
         return false;
     resource->id = id;
@@ -693,13 +775,12 @@
     resource->filter = source->filter;
     resource->size = source->size;
 
-    if (source->mailbox.isZero()) {
-      GLbyte name[GL_MAILBOX_SIZE_CHROMIUM];
-      GLC(context3d, context3d->genMailboxCHROMIUM(name));
-      source->mailbox.setName(name);
-    }
+    if (source->mailbox.IsEmpty()) {
+        GLC(context3d, context3d->genMailboxCHROMIUM(resource->mailbox.name));
+        source->mailbox.SetName(resource->mailbox);
+    } else
+        resource->mailbox = source->mailbox.name();
 
-    resource->mailbox = source->mailbox;
     GLC(context, context->bindTexture(GL_TEXTURE_2D, source->glId));
     GLC(context, context->produceTextureCHROMIUM(GL_TEXTURE_2D, resource->mailbox.name));
     return true;
@@ -833,6 +914,8 @@
     DCHECK(!resource->lockForReadCount);
     DCHECK(!resource->external);
     DCHECK(!resource->exported);
+    DCHECK(readLockFenceHasPassed(resource));
+    lazyAllocate(resource);
 
     if (resource->glId) {
         WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
@@ -894,7 +977,11 @@
     CHECK(it != m_resources.end());
     Resource* resource = &it->second;
     DCHECK(!resource->pendingSetPixels);
+    DCHECK(resource->glId || resource->allocated);
+    DCHECK(readLockFenceHasPassed(resource));
 
+    bool allocate = !resource->allocated;
+    resource->allocated = true;
     lockForWrite(id);
 
     if (resource->glId) {
@@ -910,15 +997,27 @@
         context3d->beginQueryEXT(
             GL_ASYNC_PIXEL_TRANSFERS_COMPLETED_CHROMIUM,
             resource->glUploadQueryId);
-        context3d->asyncTexSubImage2DCHROMIUM(GL_TEXTURE_2D,
-                                              0, /* level */
-                                              0, /* x */
-                                              0, /* y */
-                                              resource->size.width(),
-                                              resource->size.height(),
-                                              resource->format,
-                                              GL_UNSIGNED_BYTE,
-                                              NULL);
+        if (allocate) {
+          context3d->asyncTexImage2DCHROMIUM(GL_TEXTURE_2D,
+                                             0, /* level */
+                                             resource->format,
+                                             resource->size.width(),
+                                             resource->size.height(),
+                                             0, /* border */
+                                             resource->format,
+                                             GL_UNSIGNED_BYTE,
+                                             NULL);
+        } else {
+          context3d->asyncTexSubImage2DCHROMIUM(GL_TEXTURE_2D,
+                                                0, /* level */
+                                                0, /* x */
+                                                0, /* y */
+                                                resource->size.width(),
+                                                resource->size.height(),
+                                                resource->format,
+                                                GL_UNSIGNED_BYTE,
+                                                NULL);
+        }
         context3d->endQueryEXT(GL_ASYNC_PIXEL_TRANSFERS_COMPLETED_CHROMIUM);
         context3d->bindBuffer(GL_PIXEL_UNPACK_TRANSFER_BUFFER_CHROMIUM, 0);
     }
@@ -956,4 +1055,63 @@
     return true;
 }
 
+void ResourceProvider::abortSetPixels(ResourceId id) {
+    DCHECK(m_threadChecker.CalledOnValidThread());
+    ResourceMap::iterator it = m_resources.find(id);
+    CHECK(it != m_resources.end());
+    Resource* resource = &it->second;
+    DCHECK(resource->lockedForWrite);
+    DCHECK(resource->pendingSetPixels);
+
+    if (resource->glId) {
+        WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
+        DCHECK(context3d);
+        DCHECK(resource->glUploadQueryId);
+        // CHROMIUM_async_pixel_transfers currently doesn't have a way to
+        // abort an upload. The best we can do is delete the query and
+        // the texture.
+        context3d->deleteQueryEXT(resource->glUploadQueryId);
+        resource->glUploadQueryId = 0;
+        context3d->deleteTexture(resource->glId);
+        resource->glId = createTextureId(context3d);
+        resource->allocated = false;
+    }
+
+    resource->pendingSetPixels = false;
+    unlockForWrite(id);
+}
+
+void ResourceProvider::allocateForTesting(ResourceId id) {
+    ResourceMap::iterator it = m_resources.find(id);
+    CHECK(it != m_resources.end());
+    Resource* resource = &it->second;
+    lazyAllocate(resource);
+}
+
+void ResourceProvider::lazyAllocate(Resource* resource) {
+    DCHECK(resource);
+    DCHECK(resource->glId || resource->allocated);
+
+    if (resource->allocated || !resource->glId)
+        return;
+    resource->allocated = true;
+    WebGraphicsContext3D* context3d = m_outputSurface->Context3D();
+    gfx::Size& size = resource->size;
+    GLenum format = resource->format;
+    GLC(context3d, context3d->bindTexture(GL_TEXTURE_2D, resource->glId));
+    if (m_useTextureStorageExt && isTextureFormatSupportedForStorage(format)) {
+        GLenum storageFormat = textureToStorageFormat(format);
+        GLC(context3d, context3d->texStorage2DEXT(GL_TEXTURE_2D, 1, storageFormat, size.width(), size.height()));
+    } else
+        GLC(context3d, context3d->texImage2D(GL_TEXTURE_2D, 0, format, size.width(), size.height(), 0, format, GL_UNSIGNED_BYTE, 0));
+}
+
+void ResourceProvider::enableReadLockFences(ResourceProvider::ResourceId id, bool enable) {
+    DCHECK(m_threadChecker.CalledOnValidThread());
+    ResourceMap::iterator it = m_resources.find(id);
+    CHECK(it != m_resources.end());
+    Resource* resource = &it->second;
+    resource->enableReadLockFences = enable;
+}
+
 }  // namespace cc
Index: src/cc/direct_renderer.h
===================================================================
--- src/cc/direct_renderer.h	(revision 184497)
+++ src/cc/direct_renderer.h	(working copy)
@@ -26,13 +26,12 @@
 
     virtual void decideRenderPassAllocationsForFrame(const RenderPassList& renderPassesInDrawOrder) OVERRIDE;
     virtual bool haveCachedResourcesForRenderPassId(RenderPass::Id) const OVERRIDE;
-    virtual void drawFrame(RenderPassList& renderPassesInDrawOrder, RenderPassIdHashMap& renderPassesById) OVERRIDE;
+    virtual void drawFrame(RenderPassList& renderPassesInDrawOrder) OVERRIDE;
 
     struct CC_EXPORT DrawingFrame {
         DrawingFrame();
         ~DrawingFrame();
 
-        const RenderPassIdHashMap* renderPassesById;
         const RenderPass* rootRenderPass;
         const RenderPass* currentRenderPass;
         const ScopedResource* currentTexture;
Index: src/cc/scrollbar_layer_impl.h
===================================================================
--- src/cc/scrollbar_layer_impl.h	(revision 184497)
+++ src/cc/scrollbar_layer_impl.h	(working copy)
@@ -8,8 +8,8 @@
 #include "cc/cc_export.h"
 #include "cc/scrollbar_geometry_fixed_thumb.h"
 #include "cc/scrollbar_layer_impl_base.h"
-#include <public/WebRect.h>
-#include <public/WebVector.h>
+#include "third_party/WebKit/Source/Platform/chromium/public/WebRect.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebVector.h"
 
 namespace cc {
 
@@ -17,34 +17,41 @@
 
 class CC_EXPORT ScrollbarLayerImpl : public ScrollbarLayerImplBase {
 public:
-    static scoped_ptr<ScrollbarLayerImpl> create(LayerTreeImpl* treeImpl, int id);
+    static scoped_ptr<ScrollbarLayerImpl> create(LayerTreeImpl* treeImpl, int id, scoped_ptr<ScrollbarGeometryFixedThumb> geometry);
     virtual ~ScrollbarLayerImpl();
 
-    ScrollbarGeometryFixedThumb* scrollbarGeometry() const { return m_geometry.get(); }
-    void setScrollbarGeometry(scoped_ptr<ScrollbarGeometryFixedThumb>);
+    virtual ScrollbarLayerImpl* toScrollbarLayer() OVERRIDE;
+    int scrollLayerId() const { return m_scrollLayerId; }
+    void setScrollLayerId(int id) { m_scrollLayerId = id; }
+
     void setScrollbarData(WebKit::WebScrollbar*);
+    void setThumbSize(gfx::Size size);
 
     void setBackTrackResourceId(ResourceProvider::ResourceId id) { m_backTrackResourceId = id; }
     void setForeTrackResourceId(ResourceProvider::ResourceId id) { m_foreTrackResourceId = id; }
     void setThumbResourceId(ResourceProvider::ResourceId id) { m_thumbResourceId = id; }
 
+
+    // ScrollbarLayerImplBase implementation.
     virtual float currentPos() const OVERRIDE;
+    virtual int totalSize() const OVERRIDE;
+    virtual int maximum() const OVERRIDE;
+
     void setCurrentPos(float currentPos) { m_currentPos = currentPos; }
-
-    virtual int totalSize() const OVERRIDE;
     void setTotalSize(int totalSize) { m_totalSize = totalSize; }
-
-    virtual int maximum() const OVERRIDE;
     void setMaximum(int maximum) { m_maximum = maximum; }
 
     virtual WebKit::WebScrollbar::Orientation orientation() const OVERRIDE;
 
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
 
     virtual void didLoseOutputSurface() OVERRIDE;
 
 protected:
-    ScrollbarLayerImpl(LayerTreeImpl* treeImpl, int id);
+    ScrollbarLayerImpl(LayerTreeImpl* treeImpl, int id, scoped_ptr<ScrollbarGeometryFixedThumb> geometry);
 
 private:
     // nested class only to avoid namespace problem
@@ -87,6 +94,13 @@
 
     scoped_ptr<ScrollbarGeometryFixedThumb> m_geometry;
 
+    float m_currentPos;
+    int m_totalSize;
+    int m_maximum;
+    gfx::Size m_thumbSize;
+
+    int m_scrollLayerId;
+
     // Data to implement Scrollbar
     WebKit::WebScrollbar::ScrollbarOverlayStyle m_scrollbarOverlayStyle;
     WebKit::WebVector<WebKit::WebRect> m_tickmarks;
@@ -95,10 +109,6 @@
     WebKit::WebScrollbar::ScrollbarPart m_pressedPart;
     WebKit::WebScrollbar::ScrollbarPart m_hoveredPart;
 
-    float m_currentPos;
-    int m_totalSize;
-    int m_maximum;
-
     bool m_isScrollableAreaActive;
     bool m_isScrollViewScrollbar;
     bool m_enabled;
Index: src/cc/draw_quad_unittest.cc
===================================================================
--- src/cc/draw_quad_unittest.cc	(revision 184497)
+++ src/cc/draw_quad_unittest.cc	(working copy)
@@ -16,6 +16,8 @@
 #include "cc/tile_draw_quad.h"
 #include "cc/yuv_video_draw_quad.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
+#include "third_party/skia/include/effects/SkBlurImageFilter.h"
 #include "ui/gfx/transform.h"
 
 namespace cc {
@@ -23,20 +25,18 @@
 
 TEST(DrawQuadTest, copySharedQuadState)
 {
-    gfx::Transform quadTransform = MathUtil::createGfxTransform(1, 0.5, 0, 1, 0.5, 0);
+    gfx::Transform quadTransform = gfx::Transform(1.0, 0.0, 0.5, 1.0, 0.5, 0.0);
     gfx::Rect visibleContentRect(10, 12, 14, 16);
-    gfx::Rect clippedRectInTarget(19, 21, 23, 25);
-    gfx::Rect clipRect = clippedRectInTarget;
+    gfx::Rect clipRect(19, 21, 23, 25);
     bool isClipped = true;
     float opacity = 0.25;
 
     scoped_ptr<SharedQuadState> state(SharedQuadState::Create());
-    state->SetAll(quadTransform, visibleContentRect, clippedRectInTarget, clipRect, isClipped, opacity);
+    state->SetAll(quadTransform, visibleContentRect, clipRect, isClipped, opacity);
 
     scoped_ptr<SharedQuadState> copy(state->Copy());
     EXPECT_EQ(quadTransform, copy->content_to_target_transform);
     EXPECT_RECT_EQ(visibleContentRect, copy->visible_content_rect);
-    EXPECT_RECT_EQ(clippedRectInTarget, copy->clipped_rect_in_target);
     EXPECT_EQ(opacity, copy->opacity);
     EXPECT_RECT_EQ(clipRect, copy->clip_rect);
     EXPECT_EQ(isClipped, copy->is_clipped);
@@ -44,15 +44,14 @@
 
 scoped_ptr<SharedQuadState> createSharedQuadState()
 {
-    gfx::Transform quadTransform = MathUtil::createGfxTransform(1, 0.5, 0, 1, 0.5, 0);
+    gfx::Transform quadTransform = gfx::Transform(1.0, 0.0, 0.5, 1.0, 0.5, 0.0);
     gfx::Rect visibleContentRect(10, 12, 14, 16);
-    gfx::Rect clippedRectInTarget(19, 21, 23, 25);
-    gfx::Rect clipRect = clippedRectInTarget;
+    gfx::Rect clipRect(19, 21, 23, 25);
     bool isClipped = false;
     float opacity = 1;
 
     scoped_ptr<SharedQuadState> state(SharedQuadState::Create());
-    state->SetAll(quadTransform, visibleContentRect, clippedRectInTarget, clipRect, isClipped, opacity);
+    state->SetAll(quadTransform, visibleContentRect, clipRect, isClipped, opacity);
     return state.Pass();
 }
 
@@ -204,6 +203,18 @@
       quadAll->SetAll(sharedState.get(), quadRect, quadOpaqueRect, quadVisibleRect, needsBlending, a, b, c, d, e, f, g, h); } \
     SETUP_AND_COPY_QUAD_ALL(Type, quadAll);
 
+#define CREATE_QUAD_8_NEW_1(Type, a, b, c, d, e, f, g, h, copyA) \
+    scoped_ptr<Type> quadNew(Type::Create()); \
+    { QUAD_DATA \
+      quadNew->SetNew(sharedState.get(), quadRect, a, b, c, d, e, f, g, h); } \
+    SETUP_AND_COPY_QUAD_NEW_1(Type, quadNew, copyA);
+
+#define CREATE_QUAD_8_ALL_1(Type, a, b, c, d, e, f, g, h, copyA) \
+    scoped_ptr<Type> quadAll(Type::Create()); \
+    { QUAD_DATA \
+      quadAll->SetAll(sharedState.get(), quadRect, quadOpaqueRect, quadVisibleRect, needsBlending, a, b, c, d, e, f, g, h); } \
+    SETUP_AND_COPY_QUAD_ALL_1(Type, quadAll, copyA);
+
 #define CREATE_QUAD_9_NEW(Type, a, b, c, d, e, f, g, h, i) \
     scoped_ptr<Type> quadNew(Type::Create()); \
     { QUAD_DATA \
@@ -276,25 +287,38 @@
     ResourceProvider::ResourceId maskResourceId = 78;
     gfx::Rect contentsChangedSinceLastFrame(42, 11, 74, 24);
     gfx::RectF maskUVRect(-45, -21, 33, 19);
+    WebKit::WebFilterOperations filters;
+    filters.append(WebKit::WebFilterOperation::createBlurFilter(1.f));
+    WebKit::WebFilterOperations background_filters;
+    background_filters.append(
+        WebKit::WebFilterOperation::createGrayscaleFilter(1.f));
+    skia::RefPtr<SkImageFilter> filter = skia::AdoptRef(
+        new SkBlurImageFilter(SK_Scalar1, SK_Scalar1));
 
     RenderPass::Id copiedRenderPassId(235, 11);
     CREATE_SHARED_STATE();
 
-    CREATE_QUAD_5_NEW_1(RenderPassDrawQuad, renderPassId, isReplica, maskResourceId, contentsChangedSinceLastFrame, maskUVRect, copiedRenderPassId);
+    CREATE_QUAD_8_NEW_1(RenderPassDrawQuad, renderPassId, isReplica, maskResourceId, contentsChangedSinceLastFrame, maskUVRect, filters, filter, background_filters, copiedRenderPassId);
     EXPECT_EQ(DrawQuad::RENDER_PASS, copyQuad->material);
     EXPECT_EQ(copiedRenderPassId, copyQuad->render_pass_id);
     EXPECT_EQ(isReplica, copyQuad->is_replica);
     EXPECT_EQ(maskResourceId, copyQuad->mask_resource_id);
     EXPECT_RECT_EQ(contentsChangedSinceLastFrame, copyQuad->contents_changed_since_last_frame);
     EXPECT_EQ(maskUVRect.ToString(), copyQuad->mask_uv_rect.ToString());
+    EXPECT_EQ(filters, copyQuad->filters);
+    EXPECT_EQ(filter, copyQuad->filter);
+    EXPECT_EQ(background_filters, copyQuad->background_filters);
 
-    CREATE_QUAD_5_ALL_1(RenderPassDrawQuad, renderPassId, isReplica, maskResourceId, contentsChangedSinceLastFrame, maskUVRect, copiedRenderPassId);
+    CREATE_QUAD_8_ALL_1(RenderPassDrawQuad, renderPassId, isReplica, maskResourceId, contentsChangedSinceLastFrame, maskUVRect, filters, filter, background_filters, copiedRenderPassId);
     EXPECT_EQ(DrawQuad::RENDER_PASS, copyQuad->material);
     EXPECT_EQ(copiedRenderPassId, copyQuad->render_pass_id);
     EXPECT_EQ(isReplica, copyQuad->is_replica);
     EXPECT_EQ(maskResourceId, copyQuad->mask_resource_id);
     EXPECT_RECT_EQ(contentsChangedSinceLastFrame, copyQuad->contents_changed_since_last_frame);
     EXPECT_EQ(maskUVRect.ToString(), copyQuad->mask_uv_rect.ToString());
+    EXPECT_EQ(filters, copyQuad->filters);
+    EXPECT_EQ(filter, copyQuad->filter);
+    EXPECT_EQ(background_filters, copyQuad->background_filters);
 }
 
 TEST(DrawQuadTest, copySolidColorDrawQuad)
@@ -315,7 +339,7 @@
 {
     gfx::Rect opaqueRect(3, 7, 10, 12);
     unsigned textureId = 64;
-    gfx::Transform matrix = MathUtil::createGfxTransform(0.5, 1, 0.25, 0.75, 0, 1);
+    gfx::Transform matrix = gfx::Transform(0.5, 0.25, 1, 0.75, 0, 1);
     CREATE_SHARED_STATE();
 
     CREATE_QUAD_3_NEW(StreamVideoDrawQuad, opaqueRect, textureId, matrix);
@@ -335,29 +359,100 @@
     gfx::Rect opaqueRect(3, 7, 10, 12);
     unsigned resourceId = 82;
     bool premultipliedAlpha = true;
-    gfx::RectF uvRect(0.5, 224, -51, 36);
+    gfx::PointF uvTopLeft(0.5f, 224.f);
+    gfx::PointF uvBottomRight(51.5f, 260.f);
     const float vertex_opacity[] = {1.0f, 1.0f, 1.0f, 1.0f};
     bool flipped = true;
     CREATE_SHARED_STATE();
 
-    CREATE_QUAD_6_NEW(TextureDrawQuad, opaqueRect, resourceId, premultipliedAlpha, uvRect, vertex_opacity, flipped);
+    CREATE_QUAD_7_NEW(TextureDrawQuad, opaqueRect, resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, vertex_opacity, flipped);
     EXPECT_EQ(DrawQuad::TEXTURE_CONTENT, copyQuad->material);
     EXPECT_RECT_EQ(opaqueRect, copyQuad->opaque_rect);
     EXPECT_EQ(resourceId, copyQuad->resource_id);
     EXPECT_EQ(premultipliedAlpha, copyQuad->premultiplied_alpha);
-    EXPECT_FLOAT_RECT_EQ(uvRect, copyQuad->uv_rect);
+    EXPECT_EQ(uvTopLeft, copyQuad->uv_top_left);
+    EXPECT_EQ(uvBottomRight, copyQuad->uv_bottom_right);
     EXPECT_FLOAT_ARRAY_EQ(vertex_opacity, copyQuad->vertex_opacity, 4);
     EXPECT_EQ(flipped, copyQuad->flipped);
 
-    CREATE_QUAD_5_ALL(TextureDrawQuad, resourceId, premultipliedAlpha, uvRect, vertex_opacity, flipped);
+    CREATE_QUAD_6_ALL(TextureDrawQuad, resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, vertex_opacity, flipped);
     EXPECT_EQ(DrawQuad::TEXTURE_CONTENT, copyQuad->material);
     EXPECT_EQ(resourceId, copyQuad->resource_id);
     EXPECT_EQ(premultipliedAlpha, copyQuad->premultiplied_alpha);
-    EXPECT_FLOAT_RECT_EQ(uvRect, copyQuad->uv_rect);
+    EXPECT_EQ(uvTopLeft, copyQuad->uv_top_left);
+    EXPECT_EQ(uvBottomRight, copyQuad->uv_bottom_right);
     EXPECT_FLOAT_ARRAY_EQ(vertex_opacity, copyQuad->vertex_opacity, 4);
     EXPECT_EQ(flipped, copyQuad->flipped);
 }
 
+TEST(DrawQuadTest, clipTextureDrawQuad)
+{
+    gfx::Rect opaqueRect(3, 7, 10, 12);
+    unsigned resourceId = 82;
+    bool premultipliedAlpha = true;
+    bool flipped = true;
+    CREATE_SHARED_STATE();
+    // The original quad position is (30, 40) its size is 50*60.
+    sharedState->content_to_target_transform = gfx::Transform(1.f, 0.f, 0.f, 1.f, 10.f, 20.f);
+    // After transformation, the quad position is (40, 60) its size is 50*60.
+    sharedState->clip_rect = gfx::Rect(50, 70, 30, 20);
+
+    // The original quad is 'ABCD', the clipped quad is 'abcd':
+    //40 50       90
+    // B--:-------C 60
+    // |  b----c -|-70
+    // |  |    |  |
+    // |  a----d -|-90
+    // |          |
+    // A----------D 120
+    // UV and vertex opacity are stored per vertex on the parent rectangle 'ABCD'.
+
+    // This is the UV value for vertex 'B'.
+    gfx::PointF uvTopLeft(0.1f, 0.2f);
+    // This is the UV value for vertex 'D'.
+    gfx::PointF uvBottomRight(0.9f, 0.8f);
+    // This the vertex opacity for the vertices 'ABCD'.
+    const float vertexOpacity[] = {0.3f, 0.4f, 0.7f, 0.8f};
+
+    {
+      CREATE_QUAD_7_NEW(TextureDrawQuad, opaqueRect, resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, vertexOpacity, flipped);
+      CREATE_QUAD_6_ALL(TextureDrawQuad, resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, vertexOpacity, flipped);
+      EXPECT_TRUE(quadAll->PerformClipping());
+
+      // This is the expected UV value for vertex 'b'.
+      // uv(b) = uv(B) + (Bb / BD) * (uv(D) - uv(B))
+      // 0.3 = 0.2 + (10 / 60) * (0.8 - 0.2)
+      gfx::PointF uvTopLeftClipped(0.26f, 0.3f);
+      // This is the expected UV value for vertex 'd'.
+      // uv(d) = uv(B) + (Bd / BD) * (uv(D) - uv(B))
+      gfx::PointF uvBottomRightClipped(0.74f, 0.5f);
+      // This the expected vertex opacity for the vertices 'abcd'.
+      // They are computed with a bilinear interpolation of the corner values.
+      const float vertexOpacityClipped[] = {0.43f, 0.45f, 0.65f, 0.67f};
+
+      EXPECT_EQ(uvTopLeftClipped, quadAll->uv_top_left);
+      EXPECT_EQ(uvBottomRightClipped, quadAll->uv_bottom_right);
+      EXPECT_FLOAT_ARRAY_EQ(vertexOpacityClipped, quadAll->vertex_opacity, 4);
+    }
+
+    uvTopLeft = gfx::PointF(0.8f, 0.7f);
+    uvBottomRight = gfx::PointF(0.2f, 0.1f);
+
+    {
+      CREATE_QUAD_7_NEW(TextureDrawQuad, opaqueRect, resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, vertexOpacity, flipped);
+      CREATE_QUAD_6_ALL(TextureDrawQuad, resourceId, premultipliedAlpha, uvTopLeft, uvBottomRight, vertexOpacity, flipped);
+      EXPECT_TRUE(quadAll->PerformClipping());
+
+      // This is the expected UV value for vertex 'b'.
+      gfx::PointF uvTopLeftClipped(0.68f, 0.6f);
+      // This is the expected UV value for vertex 'd'.
+      gfx::PointF uvBottomRightClipped(0.32f, 0.4f);
+
+      EXPECT_EQ(uvTopLeftClipped, quadAll->uv_top_left);
+      EXPECT_EQ(uvBottomRightClipped, quadAll->uv_bottom_right);
+    }
+}
+
 TEST(DrawQuadTest, copyTileDrawQuad)
 {
     gfx::Rect opaqueRect(33, 44, 22, 33);
Index: src/cc/heads_up_display_layer.h
===================================================================
--- src/cc/heads_up_display_layer.h	(revision 184497)
+++ src/cc/heads_up_display_layer.h	(working copy)
@@ -6,12 +6,13 @@
 #define CC_HEADS_UP_DISPLAY_LAYER_H_
 
 #include "base/memory/scoped_ptr.h"
+#include "cc/cc_export.h"
 #include "cc/font_atlas.h"
 #include "cc/layer.h"
 
 namespace cc {
 
-class HeadsUpDisplayLayer : public Layer {
+class CC_EXPORT HeadsUpDisplayLayer : public Layer {
 public:
     static scoped_refptr<HeadsUpDisplayLayer> create();
 
Index: src/cc/layer_tiling_data.cc
===================================================================
--- src/cc/layer_tiling_data.cc	(revision 184497)
+++ src/cc/layer_tiling_data.cc	(working copy)
@@ -2,13 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-
 #include "cc/layer_tiling_data.h"
 
 #include "base/logging.h"
 
-using namespace std;
-
 namespace cc {
 
 scoped_ptr<LayerTilingData> LayerTilingData::create(const gfx::Size& tileSize, BorderTexelOption border)
@@ -62,17 +59,17 @@
 {
     DCHECK(!tileAt(i, j));
     tile->moveTo(i, j);
-    m_tiles.add(make_pair(i, j), tile.Pass());
+    m_tiles.add(std::make_pair(i, j), tile.Pass());
 }
 
 scoped_ptr<LayerTilingData::Tile> LayerTilingData::takeTile(int i, int j)
 {
-    return m_tiles.take_and_erase(make_pair(i, j));
+    return m_tiles.take_and_erase(std::make_pair(i, j));
 }
 
 LayerTilingData::Tile* LayerTilingData::tileAt(int i, int j) const
 {
-    return m_tiles.get(make_pair(i, j));
+    return m_tiles.get(std::make_pair(i, j));
 }
 
 void LayerTilingData::reset()
Index: src/cc/picture_image_layer.h
===================================================================
--- src/cc/picture_image_layer.h	(revision 184497)
+++ src/cc/picture_image_layer.h	(working copy)
@@ -20,10 +20,9 @@
   void setBitmap(const SkBitmap& image);
 
   // Layer implementation.
-  virtual void update(
-      ResourceUpdateQueue& queue,
-      const OcclusionTracker* tracker,
-      RenderingStats& stats) OVERRIDE;
+  virtual scoped_ptr<LayerImpl> createLayerImpl(
+      LayerTreeImpl* treeImpl) OVERRIDE;
+  virtual bool drawsContent() const OVERRIDE;
 
   // ContentLayerClient implementation.
   virtual void paintContents(
@@ -36,7 +35,6 @@
   virtual ~PictureImageLayer();
 
   SkBitmap bitmap_;
-  gfx::Size bounds_;
 };
 
 }  // namespace cc
Index: src/cc/image_layer.cc
===================================================================
--- src/cc/image_layer.cc	(revision 184497)
+++ src/cc/image_layer.cc	(working copy)
@@ -8,6 +8,7 @@
 #include "cc/image_layer_updater.h"
 #include "cc/layer_updater.h"
 #include "cc/layer_tree_host.h"
+#include "cc/prioritized_resource.h"
 #include "cc/resource_update_queue.h"
 
 namespace cc {
@@ -76,6 +77,7 @@
 
 void ImageLayer::calculateContentsScale(
     float ideal_contents_scale,
+    bool animating_transform_to_screen,
     float* contentsScaleX,
     float* contentsScaleY,
     gfx::Size* contentBounds)
Index: src/cc/scrollbar_layer.cc
===================================================================
--- src/cc/scrollbar_layer.cc	(revision 184497)
+++ src/cc/scrollbar_layer.cc	(working copy)
@@ -6,34 +6,44 @@
 
 #include "base/basictypes.h"
 #include "base/debug/trace_event.h"
+#include "cc/caching_bitmap_content_layer_updater.h"
 #include "cc/layer_painter.h"
 #include "cc/layer_tree_host.h"
+#include "cc/prioritized_resource.h"
 #include "cc/resource_update_queue.h"
 #include "cc/scrollbar_layer_impl.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebRect.h"
 #include "ui/gfx/rect_conversions.h"
-#include <public/WebRect.h>
 
-using WebKit::WebRect;
-
 namespace cc {
 
 scoped_ptr<LayerImpl> ScrollbarLayer::createLayerImpl(LayerTreeImpl* treeImpl)
 {
-    return ScrollbarLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+    return ScrollbarLayerImpl::create(treeImpl, id(), ScrollbarGeometryFixedThumb::create(make_scoped_ptr(m_geometry->clone()))).PassAs<LayerImpl>();
 }
 
-scoped_refptr<ScrollbarLayer> ScrollbarLayer::create(scoped_ptr<WebKit::WebScrollbar> scrollbar, WebKit::WebScrollbarThemePainter painter, scoped_ptr<WebKit::WebScrollbarThemeGeometry> geometry, int scrollLayerId)
+scoped_refptr<ScrollbarLayer> ScrollbarLayer::create(
+    scoped_ptr<WebKit::WebScrollbar> scrollbar,
+    scoped_ptr<ScrollbarThemePainter> painter,
+    scoped_ptr<WebKit::WebScrollbarThemeGeometry> geometry,
+    int scrollLayerId)
 {
-    return make_scoped_refptr(new ScrollbarLayer(scrollbar.Pass(), painter, geometry.Pass(), scrollLayerId));
+    return make_scoped_refptr(new ScrollbarLayer(scrollbar.Pass(), painter.Pass(), geometry.Pass(), scrollLayerId));
 }
 
-ScrollbarLayer::ScrollbarLayer(scoped_ptr<WebKit::WebScrollbar> scrollbar, WebKit::WebScrollbarThemePainter painter, scoped_ptr<WebKit::WebScrollbarThemeGeometry> geometry, int scrollLayerId)
+ScrollbarLayer::ScrollbarLayer(
+    scoped_ptr<WebKit::WebScrollbar> scrollbar,
+    scoped_ptr<ScrollbarThemePainter> painter,
+    scoped_ptr<WebKit::WebScrollbarThemeGeometry> geometry,
+    int scrollLayerId)
     : m_scrollbar(scrollbar.Pass())
-    , m_painter(painter)
+    , m_painter(painter.Pass())
     , m_geometry(geometry.Pass())
     , m_scrollLayerId(scrollLayerId)
     , m_textureFormat(GL_INVALID_ENUM)
 {
+    if (!m_scrollbar->isOverlay())
+        setShouldScrollOnMainThread(true);
 }
 
 ScrollbarLayer::~ScrollbarLayer()
@@ -49,12 +59,20 @@
     setNeedsFullTreeSync();
 }
 
+WebKit::WebScrollbar::Orientation ScrollbarLayer::orientation() const
+{
+    return m_scrollbar->orientation();
+}
+
 int ScrollbarLayer::maxTextureSize() {
     DCHECK(layerTreeHost());
     return layerTreeHost()->rendererCapabilities().maxTextureSize;
 }
 
 float ScrollbarLayer::clampScaleToMaxTextureSize(float scale) {
+    if (layerTreeHost()->settings().solidColorScrollbars)
+        return scale;
+
     // If the scaled contentBounds() is bigger than the max texture size of the
     // device, we need to clamp it by rescaling, since contentBounds() is used
     // below to set the texture size.
@@ -70,12 +88,14 @@
 
 void ScrollbarLayer::calculateContentsScale(
   float idealContentsScale,
+  bool animatingTransformToScreen,
   float* contentsScaleX,
   float* contentsScaleY,
   gfx::Size* contentBounds)
 {
     ContentsScalingLayer::calculateContentsScale(
         clampScaleToMaxTextureSize(idealContentsScale),
+        animatingTransformToScreen,
         contentsScaleX,
         contentsScaleY,
         contentBounds);
@@ -89,10 +109,8 @@
 
     ScrollbarLayerImpl* scrollbarLayer = static_cast<ScrollbarLayerImpl*>(layer);
 
-    if (!scrollbarLayer->scrollbarGeometry())
-        scrollbarLayer->setScrollbarGeometry(ScrollbarGeometryFixedThumb::create(make_scoped_ptr(m_geometry->clone())));
-
     scrollbarLayer->setScrollbarData(m_scrollbar.get());
+    scrollbarLayer->setThumbSize(m_thumbSize);
 
     if (m_backTrack && m_backTrack->texture()->haveBackingTexture())
         scrollbarLayer->setBackTrackResourceId(m_backTrack->texture()->resourceId());
@@ -117,46 +135,45 @@
 
 class ScrollbarBackgroundPainter : public LayerPainter {
 public:
-    static scoped_ptr<ScrollbarBackgroundPainter> create(WebKit::WebScrollbar* scrollbar, WebKit::WebScrollbarThemePainter painter, WebKit::WebScrollbarThemeGeometry* geometry, WebKit::WebScrollbar::ScrollbarPart trackPart)
+    static scoped_ptr<ScrollbarBackgroundPainter> create(WebKit::WebScrollbar* scrollbar, ScrollbarThemePainter *painter, WebKit::WebScrollbarThemeGeometry* geometry, WebKit::WebScrollbar::ScrollbarPart trackPart)
     {
         return make_scoped_ptr(new ScrollbarBackgroundPainter(scrollbar, painter, geometry, trackPart));
     }
 
-    virtual void paint(SkCanvas* skCanvas, const gfx::Rect& contentRect, gfx::RectF&) OVERRIDE
+    virtual void paint(SkCanvas* canvas, gfx::Rect contentRect, gfx::RectF&) OVERRIDE
     {
-        WebKit::WebCanvas* canvas = skCanvas;
         // The following is a simplification of ScrollbarThemeComposite::paint.
-        m_painter.paintScrollbarBackground(canvas, contentRect);
+        m_painter->PaintScrollbarBackground(canvas, contentRect);
 
         if (m_geometry->hasButtons(m_scrollbar)) {
-            WebRect backButtonStartPaintRect = m_geometry->backButtonStartRect(m_scrollbar);
-            m_painter.paintBackButtonStart(canvas, backButtonStartPaintRect);
+            gfx::Rect backButtonStartPaintRect = m_geometry->backButtonStartRect(m_scrollbar);
+            m_painter->PaintBackButtonStart(canvas, backButtonStartPaintRect);
 
-            WebRect backButtonEndPaintRect = m_geometry->backButtonEndRect(m_scrollbar);
-            m_painter.paintBackButtonEnd(canvas, backButtonEndPaintRect);
+            gfx::Rect backButtonEndPaintRect = m_geometry->backButtonEndRect(m_scrollbar);
+            m_painter->PaintBackButtonEnd(canvas, backButtonEndPaintRect);
 
-            WebRect forwardButtonStartPaintRect = m_geometry->forwardButtonStartRect(m_scrollbar);
-            m_painter.paintForwardButtonStart(canvas, forwardButtonStartPaintRect);
+            gfx::Rect forwardButtonStartPaintRect = m_geometry->forwardButtonStartRect(m_scrollbar);
+            m_painter->PaintForwardButtonStart(canvas, forwardButtonStartPaintRect);
 
-            WebRect forwardButtonEndPaintRect = m_geometry->forwardButtonEndRect(m_scrollbar);
-            m_painter.paintForwardButtonEnd(canvas, forwardButtonEndPaintRect);
+            gfx::Rect forwardButtonEndPaintRect = m_geometry->forwardButtonEndRect(m_scrollbar);
+            m_painter->PaintForwardButtonEnd(canvas, forwardButtonEndPaintRect);
         }
 
-        WebRect trackPaintRect = m_geometry->trackRect(m_scrollbar);
-        m_painter.paintTrackBackground(canvas, trackPaintRect);
+        gfx::Rect trackPaintRect = m_geometry->trackRect(m_scrollbar);
+        m_painter->PaintTrackBackground(canvas, trackPaintRect);
 
         bool thumbPresent = m_geometry->hasThumb(m_scrollbar);
         if (thumbPresent) {
             if (m_trackPart == WebKit::WebScrollbar::ForwardTrackPart)
-                m_painter.paintForwardTrackPart(canvas, trackPaintRect);
+                m_painter->PaintForwardTrackPart(canvas, trackPaintRect);
             else
-                m_painter.paintBackTrackPart(canvas, trackPaintRect);
+                m_painter->PaintBackTrackPart(canvas, trackPaintRect);
         }
 
-        m_painter.paintTickmarks(canvas, trackPaintRect);
+        m_painter->PaintTickmarks(canvas, trackPaintRect);
     }
 private:
-    ScrollbarBackgroundPainter(WebKit::WebScrollbar* scrollbar, WebKit::WebScrollbarThemePainter painter, WebKit::WebScrollbarThemeGeometry* geometry, WebKit::WebScrollbar::ScrollbarPart trackPart)
+    ScrollbarBackgroundPainter(WebKit::WebScrollbar* scrollbar, ScrollbarThemePainter *painter, WebKit::WebScrollbarThemeGeometry* geometry, WebKit::WebScrollbar::ScrollbarPart trackPart)
         : m_scrollbar(scrollbar)
         , m_painter(painter)
         , m_geometry(geometry)
@@ -165,7 +182,7 @@
     }
 
     WebKit::WebScrollbar* m_scrollbar;
-    WebKit::WebScrollbarThemePainter m_painter;
+    ScrollbarThemePainter* m_painter;
     WebKit::WebScrollbarThemeGeometry* m_geometry;
     WebKit::WebScrollbar::ScrollbarPart m_trackPart;
 
@@ -174,24 +191,20 @@
 
 class ScrollbarThumbPainter : public LayerPainter {
 public:
-    static scoped_ptr<ScrollbarThumbPainter> create(WebKit::WebScrollbar* scrollbar, WebKit::WebScrollbarThemePainter painter, WebKit::WebScrollbarThemeGeometry* geometry)
+    static scoped_ptr<ScrollbarThumbPainter> create(WebKit::WebScrollbar* scrollbar, ScrollbarThemePainter* painter, WebKit::WebScrollbarThemeGeometry* geometry)
     {
         return make_scoped_ptr(new ScrollbarThumbPainter(scrollbar, painter, geometry));
     }
 
-    virtual void paint(SkCanvas* skCanvas, const gfx::Rect& contentRect, gfx::RectF& opaque) OVERRIDE
+    virtual void paint(SkCanvas* canvas, gfx::Rect contentRect, gfx::RectF& opaque) OVERRIDE
     {
-        WebKit::WebCanvas* canvas = skCanvas;
-
         // Consider the thumb to be at the origin when painting.
-        WebRect thumbRect = m_geometry->thumbRect(m_scrollbar);
-        thumbRect.x = 0;
-        thumbRect.y = 0;
-        m_painter.paintThumb(canvas, thumbRect);
+        gfx::Rect thumbRect = m_geometry->thumbRect(m_scrollbar);
+        m_painter->PaintThumb(canvas, gfx::Rect(thumbRect.size()));
     }
 
 private:
-    ScrollbarThumbPainter(WebKit::WebScrollbar* scrollbar, WebKit::WebScrollbarThemePainter painter, WebKit::WebScrollbarThemeGeometry* geometry)
+    ScrollbarThumbPainter(WebKit::WebScrollbar* scrollbar, ScrollbarThemePainter* painter, WebKit::WebScrollbarThemeGeometry* geometry)
         : m_scrollbar(scrollbar)
         , m_painter(painter)
         , m_geometry(geometry)
@@ -199,7 +212,7 @@
     }
 
     WebKit::WebScrollbar* m_scrollbar;
-    WebKit::WebScrollbarThemePainter m_painter;
+    ScrollbarThemePainter* m_painter;
     WebKit::WebScrollbarThemeGeometry* m_geometry;
 
     DISALLOW_COPY_AND_ASSIGN(ScrollbarThumbPainter);
@@ -219,51 +232,61 @@
 
 void ScrollbarLayer::createUpdaterIfNeeded()
 {
+    if (layerTreeHost()->settings().solidColorScrollbars)
+        return;
+
     m_textureFormat = layerTreeHost()->rendererCapabilities().bestTextureFormat;
 
     if (!m_backTrackUpdater)
-        m_backTrackUpdater = CachingBitmapContentLayerUpdater::Create(ScrollbarBackgroundPainter::create(m_scrollbar.get(), m_painter, m_geometry.get(), WebKit::WebScrollbar::BackTrackPart).PassAs<LayerPainter>());
+        m_backTrackUpdater = CachingBitmapContentLayerUpdater::Create(ScrollbarBackgroundPainter::create(m_scrollbar.get(), m_painter.get(), m_geometry.get(), WebKit::WebScrollbar::BackTrackPart).PassAs<LayerPainter>());
     if (!m_backTrack)
         m_backTrack = m_backTrackUpdater->createResource(layerTreeHost()->contentsTextureManager());
 
     // Only create two-part track if we think the two parts could be different in appearance.
     if (m_scrollbar->isCustomScrollbar()) {
         if (!m_foreTrackUpdater)
-            m_foreTrackUpdater = CachingBitmapContentLayerUpdater::Create(ScrollbarBackgroundPainter::create(m_scrollbar.get(), m_painter, m_geometry.get(), WebKit::WebScrollbar::ForwardTrackPart).PassAs<LayerPainter>());
+            m_foreTrackUpdater = CachingBitmapContentLayerUpdater::Create(ScrollbarBackgroundPainter::create(m_scrollbar.get(), m_painter.get(), m_geometry.get(), WebKit::WebScrollbar::ForwardTrackPart).PassAs<LayerPainter>());
         if (!m_foreTrack)
             m_foreTrack = m_foreTrackUpdater->createResource(layerTreeHost()->contentsTextureManager());
     }
 
     if (!m_thumbUpdater)
-        m_thumbUpdater = CachingBitmapContentLayerUpdater::Create(ScrollbarThumbPainter::create(m_scrollbar.get(), m_painter, m_geometry.get()).PassAs<LayerPainter>());
+        m_thumbUpdater = CachingBitmapContentLayerUpdater::Create(ScrollbarThumbPainter::create(m_scrollbar.get(), m_painter.get(), m_geometry.get()).PassAs<LayerPainter>());
     if (!m_thumb)
         m_thumb = m_thumbUpdater->createResource(layerTreeHost()->contentsTextureManager());
 }
 
-void ScrollbarLayer::updatePart(CachingBitmapContentLayerUpdater* painter, LayerUpdater::Resource* texture, const gfx::Rect& rect, ResourceUpdateQueue& queue, RenderingStats& stats)
+void ScrollbarLayer::updatePart(CachingBitmapContentLayerUpdater* painter, LayerUpdater::Resource* resource, const gfx::Rect& rect, ResourceUpdateQueue& queue, RenderingStats& stats)
 {
+    if (layerTreeHost()->settings().solidColorScrollbars)
+        return;
+
     // Skip painting and uploading if there are no invalidations and
     // we already have valid texture data.
-    if (texture->texture()->haveBackingTexture()
-            && texture->texture()->size() == rect.size()
-            && m_updateRect.IsEmpty())
+    if (resource->texture()->haveBackingTexture() &&
+        resource->texture()->size() == rect.size() &&
+        !isDirty())
         return;
 
     // We should always have enough memory for UI.
-    DCHECK(texture->texture()->canAcquireBackingTexture());
-    if (!texture->texture()->canAcquireBackingTexture())
+    DCHECK(resource->texture()->canAcquireBackingTexture());
+    if (!resource->texture()->canAcquireBackingTexture())
         return;
 
     // Paint and upload the entire part.
     gfx::Rect paintedOpaqueRect;
     painter->prepareToUpdate(rect, rect.size(), contentsScaleX(), contentsScaleY(), paintedOpaqueRect, stats);
-    if (!painter->pixelsDidChange() && texture->texture()->haveBackingTexture()) {
+    if (!painter->pixelsDidChange() && resource->texture()->haveBackingTexture()) {
         TRACE_EVENT_INSTANT0("cc","ScrollbarLayer::updatePart no texture upload needed");
         return;
     }
 
+    bool partialUpdatesAllowed = layerTreeHost()->settings().maxPartialTextureUpdates > 0;
+    if (!partialUpdatesAllowed)
+        resource->texture()->returnBackingTexture();
+
     gfx::Vector2d destOffset(0, 0);
-    texture->update(queue, rect, destOffset, false, stats);
+    resource->update(queue, rect, destOffset, partialUpdatesAllowed, stats);
 }
 
 gfx::Rect ScrollbarLayer::scrollbarLayerRectToContentRect(const gfx::Rect& layerRect) const
@@ -276,6 +299,9 @@
 
 void ScrollbarLayer::setTexturePriorities(const PriorityCalculator&)
 {
+    if (layerTreeHost()->settings().solidColorScrollbars)
+        return;
+
     if (contentBounds().IsEmpty())
         return;
     DCHECK_LE(contentBounds().width(), maxTextureSize());
@@ -303,8 +329,11 @@
 {
     ContentsScalingLayer::update(queue, occlusion, stats);
 
+    m_dirtyRect.Union(m_updateRect);
     if (contentBounds().IsEmpty())
         return;
+    if (visibleContentRect().IsEmpty())
+        return;
 
     createUpdaterIfNeeded();
 
@@ -314,10 +343,13 @@
         updatePart(m_foreTrackUpdater.get(), m_foreTrack.get(), contentRect, queue, stats);
 
     // Consider the thumb to be at the origin when painting.
-    WebKit::WebRect thumbRect = m_geometry->thumbRect(m_scrollbar.get());
-    gfx::Rect originThumbRect = scrollbarLayerRectToContentRect(gfx::Rect(0, 0, thumbRect.width, thumbRect.height));
+    gfx::Rect thumbRect = m_geometry->thumbRect(m_scrollbar.get());
+    m_thumbSize = thumbRect.size();
+    gfx::Rect originThumbRect = scrollbarLayerRectToContentRect(gfx::Rect(thumbRect.size()));
     if (!originThumbRect.IsEmpty())
         updatePart(m_thumbUpdater.get(), m_thumb.get(), originThumbRect, queue, stats);
+
+    m_dirtyRect = gfx::RectF();
 }
 
 }  // namespace cc
Index: src/cc/layer_animation_controller.h
===================================================================
--- src/cc/layer_animation_controller.h	(revision 184497)
+++ src/cc/layer_animation_controller.h	(working copy)
@@ -7,11 +7,15 @@
 
 #include "base/basictypes.h"
 #include "base/hash_tables.h"
+#include "base/memory/ref_counted.h"
 #include "base/memory/scoped_ptr.h"
+#include "base/observer_list.h"
+#include "base/time.h"
 #include "cc/animation_events.h"
 #include "cc/cc_export.h"
-#include "cc/layer_animation_observer.h"
+#include "cc/layer_animation_event_observer.h"
 #include "cc/scoped_ptr_vector.h"
+#include "ui/gfx/transform.h"
 
 namespace gfx {
 class Transform;
@@ -20,30 +24,23 @@
 namespace cc {
 
 class Animation;
+class AnimationRegistrar;
 class KeyframeValueList;
+class LayerAnimationValueObserver;
 
-class CC_EXPORT LayerAnimationControllerClient {
+class CC_EXPORT LayerAnimationController
+    : public base::RefCounted<LayerAnimationController>,
+      public LayerAnimationEventObserver {
 public:
-    virtual ~LayerAnimationControllerClient() { }
+    static scoped_refptr<LayerAnimationController> create(int id);
 
-    virtual int id() const = 0;
-    virtual void setOpacityFromAnimation(float) = 0;
-    virtual float opacity() const = 0;
-    virtual void setTransformFromAnimation(const gfx::Transform&) = 0;
-    virtual const gfx::Transform& transform() const = 0;
-};
+    int id() const { return m_id; }
 
-class CC_EXPORT LayerAnimationController : public LayerAnimationObserver {
-public:
-    static scoped_ptr<LayerAnimationController> create(LayerAnimationControllerClient*);
-
-    virtual ~LayerAnimationController();
-
     // These methods are virtual for testing.
-    virtual void addAnimation(scoped_ptr<ActiveAnimation>);
+    virtual void addAnimation(scoped_ptr<Animation>);
     virtual void pauseAnimation(int animationId, double timeOffset);
     virtual void removeAnimation(int animationId);
-    virtual void removeAnimation(int animationId, ActiveAnimation::TargetProperty);
+    virtual void removeAnimation(int animationId, Animation::TargetProperty);
     virtual void suspendAnimations(double monotonicTime);
     virtual void resumeAnimations(double monotonicTime);
 
@@ -55,18 +52,21 @@
 
     // Returns the active animation in the given group, animating the given property, if such an
     // animation exists.
-    ActiveAnimation* getActiveAnimation(int groupId, ActiveAnimation::TargetProperty) const;
+    Animation* getAnimation(int groupId, Animation::TargetProperty) const;
 
     // Returns the active animation animating the given property that is either running, or is
     // next to run, if such an animation exists.
-    ActiveAnimation* getActiveAnimation(ActiveAnimation::TargetProperty) const;
+    Animation* getAnimation(Animation::TargetProperty) const;
 
     // Returns true if there are any animations that have neither finished nor aborted.
     bool hasActiveAnimation() const;
 
+    // Returns true if there are any animations at all to process.
+    bool hasAnyAnimation() const { return !m_activeAnimations.empty(); }
+
     // Returns true if there is an animation currently animating the given property, or
     // if there is an animation scheduled to animate this property in the future.
-    bool isAnimatingProperty(ActiveAnimation::TargetProperty) const;
+    bool isAnimatingProperty(Animation::TargetProperty) const;
 
     // This is called in response to an animation being started on the impl thread. This
     // function updates the corresponding main thread animation's start time.
@@ -76,11 +76,17 @@
     // thread, all animations will be transferred.
     void setForceSync() { m_forceSync = true; }
 
-    void setClient(LayerAnimationControllerClient*);
+    void setAnimationRegistrar(AnimationRegistrar*);
 
+    void addObserver(LayerAnimationValueObserver*);
+    void removeObserver(LayerAnimationValueObserver*);
+
 protected:
-    explicit LayerAnimationController(LayerAnimationControllerClient*);
+    friend class base::RefCounted<LayerAnimationController>;
 
+    LayerAnimationController(int id);
+    virtual ~LayerAnimationController();
+
 private:
     typedef base::hash_set<int> TargetProperties;
 
@@ -98,12 +104,25 @@
 
     void tickAnimations(double monotonicTime);
 
+    void updateActivation(bool force = false);
+
+    void notifyObserversOpacityAnimated(float opacity);
+    void notifyObserversTransformAnimated(const gfx::Transform& transform);
+
+    bool hasActiveObserver();
+
     // If this is true, we force a sync to the impl thread.
     bool m_forceSync;
 
-    LayerAnimationControllerClient* m_client;
-    ScopedPtrVector<ActiveAnimation> m_activeAnimations;
+    AnimationRegistrar* m_registrar;
+    int m_id;
+    ScopedPtrVector<Animation> m_activeAnimations;
 
+    // This is used to ensure that we don't spam the registrar.
+    bool m_isActive;
+
+    ObserverList<LayerAnimationValueObserver> m_observers;
+
     DISALLOW_COPY_AND_ASSIGN(LayerAnimationController);
 };
 
Index: src/cc/resource_pool.h
===================================================================
--- src/cc/resource_pool.h	(revision 184497)
+++ src/cc/resource_pool.h	(working copy)
@@ -8,15 +8,16 @@
 #include <list>
 
 #include "base/memory/scoped_ptr.h"
+#include "cc/cc_export.h"
 #include "cc/renderer.h"
 #include "cc/resource.h"
 
 namespace cc {
 class ResourceProvider;
 
-class ResourcePool {
+class CC_EXPORT ResourcePool {
  public:
-  class Resource : public cc::Resource {
+  class CC_EXPORT Resource : public cc::Resource {
    public:
     Resource(ResourceProvider* resource_provider,
              const gfx::Size& size,
Index: src/cc/resource_update_controller.cc
===================================================================
--- src/cc/resource_update_controller.cc	(revision 184497)
+++ src/cc/resource_update_controller.cc	(working copy)
@@ -4,17 +4,18 @@
 
 #include "cc/resource_update_controller.h"
 
+#include <limits>
+
 #include "base/debug/trace_event.h"
 #include "cc/prioritized_resource.h"
 #include "cc/resource_provider.h"
 #include "cc/texture_copier.h"
 #include "cc/thread.h"
 #include "skia/ext/refptr.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSharedGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
 #include "third_party/skia/include/gpu/SkGpuDevice.h"
-#include <limits>
-#include <public/WebGraphicsContext3D.h>
-#include <public/WebSharedGraphicsContext3D.h>
 
 using WebKit::WebGraphicsContext3D;
 using WebKit::WebSharedGraphicsContext3D;
@@ -22,11 +23,7 @@
 namespace {
 
 // Number of partial updates we allow.
-#if defined(OS_ANDROID)
-const size_t partialTextureUpdatesMax = 0;
-#else
 const size_t partialTextureUpdatesMax = 12;
-#endif
 
 // Measured in seconds.
 const double textureUpdateTickRate = 0.004;
@@ -144,9 +141,9 @@
         // is available in other shared contexts. It is important to do here
         // because the backing texture is created in one context while it is
         // being written to in another.
-        m_resourceProvider->flush();
         ResourceProvider::ScopedWriteLockGL lock(
             m_resourceProvider, texture->resourceId());
+        m_resourceProvider->flush();
 
         // Make sure ganesh uses the correct GL context.
         paintContext->makeContextCurrent();
Index: src/cc/copyfiles.py
===================================================================
--- src/cc/copyfiles.py	(revision 184497)
+++ src/cc/copyfiles.py	(working copy)
@@ -1,77 +0,0 @@
-# Copyright (c) 2012 Google Inc. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-import os
-import re
-import shutil
-
-prefixes = ["../third_party/WebKit/Source/WebCore/platform/graphics/chromium",
-            "../third_party/WebKit/Source/WebCore/platform/graphics/chromium/cc",
-            "../third_party/WebKit/Source/WebKit/chromium/tests"]
-
-def Copy(name):
-  src = name
-  dst = name
-  if name.startswith("test/"):
-    src = src[5:]
-  fullsrc = ""
-  for prefix in prefixes:
-    candidate = "%s/%s" % (prefix, src)
-    if os.path.exists(candidate):
-      fullsrc = candidate
-      break
-  assert fullsrc != ""
-  shutil.copyfile(fullsrc, dst)
-  print "copying from %s to %s" % (fullsrc, dst)
-  return dst
-
-def FixCopyrightHeaderText(text, year):
-  header_template = """// Copyright %s The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-"""
-
-  while text[0].find(" */") == -1:
-    text = text[1:]
-  text = text[1:]
-
-  return (header_template % year) + "".join(text)
-
-def FixCopyrightHeader(filepath):
-  with open(filepath, "r") as f:
-    text = f.readlines()
-
-  if filepath.endswith("CCPageScaleAnimation.cpp"):
-    year = 2012
-  else:
-    pattern = ".*Copyright \(C\) (20[01][0-9])"
-    m = re.match(pattern, text[0])
-    if m == None:
-      m = re.match(pattern, text[1])
-    assert m
-    year = m.group(1)
-
-  fixed_text = FixCopyrightHeaderText(text, year)
-  with open(filepath, "w") as f:
-    f.write(fixed_text)
-
-def Readfile(gypfile):
-  with open(gypfile, "r") as cc_gyp:
-    obj = eval(cc_gyp.read())
-    return obj
-
-def CopyFiles(files):
-  for f in files:
-    dst = Copy(f)
-    FixCopyrightHeader(dst)
-
-def Main():
-  CopyFiles(Readfile("cc.gyp")['variables']['cc_source_files'])
-  CopyFiles(Readfile("cc_tests.gyp")['variables']['cc_tests_source_files'])
-  CopyFiles(Readfile("cc_tests.gyp")['variables']['cc_tests_support_files'])
-
-if __name__ == '__main__':
-  import sys
-  os.chdir(os.path.dirname(__file__))
-  sys.exit(Main())
Index: src/cc/video_layer.cc
===================================================================
--- src/cc/video_layer.cc	(revision 184497)
+++ src/cc/video_layer.cc	(working copy)
@@ -8,17 +8,13 @@
 
 namespace cc {
 
-scoped_refptr<VideoLayer> VideoLayer::create(
-    WebKit::WebVideoFrameProvider* provider,
-    const FrameUnwrapper& unwrapper)
+scoped_refptr<VideoLayer> VideoLayer::create(VideoFrameProvider* provider)
 {
-    return make_scoped_refptr(new VideoLayer(provider, unwrapper));
+    return make_scoped_refptr(new VideoLayer(provider));
 }
 
-VideoLayer::VideoLayer(WebKit::WebVideoFrameProvider* provider,
-                       const FrameUnwrapper& unwrapper)
+VideoLayer::VideoLayer(VideoFrameProvider* provider)
     : m_provider(provider)
-    , m_unwrapper(unwrapper)
 {
     DCHECK(m_provider);
 }
@@ -29,7 +25,7 @@
 
 scoped_ptr<LayerImpl> VideoLayer::createLayerImpl(LayerTreeImpl* treeImpl)
 {
-    return VideoLayerImpl::create(treeImpl, m_layerId, m_provider, m_unwrapper).PassAs<LayerImpl>();
+    return VideoLayerImpl::create(treeImpl, m_layerId, m_provider).PassAs<LayerImpl>();
 }
 
 }  // namespace cc
Index: src/cc/layer_tree_debug_state.h
===================================================================
--- src/cc/layer_tree_debug_state.h	(revision 184497)
+++ src/cc/layer_tree_debug_state.h	(working copy)
@@ -17,6 +17,7 @@
   bool showFPSCounter;
   bool showPlatformLayerTree;
   bool showDebugBorders;
+  bool continuousPainting;
 
   bool showPaintRects;
   bool showPropertyChangedRects;
@@ -26,6 +27,8 @@
   bool showOccludingRects;
   bool showNonOccludingRects;
 
+  int slowDownRasterScaleFactor;
+
   bool showHudInfo() const;
   bool showHudRects() const;
   bool hudNeedsFont() const;
Index: src/cc/render_pass.cc
===================================================================
--- src/cc/render_pass.cc	(revision 184497)
+++ src/cc/render_pass.cc	(working copy)
@@ -4,6 +4,9 @@
 
 #include "cc/render_pass.h"
 
+#include "cc/draw_quad.h"
+#include "cc/shared_quad_state.h"
+
 namespace cc {
 
 scoped_ptr<RenderPass> RenderPass::Create() {
@@ -28,10 +31,7 @@
                     damage_rect,
                     transform_to_root_target,
                     has_transparent_background,
-                    has_occlusion_from_outside_target_surface,
-                    filters,
-                    filter,
-                    background_filters);
+                    has_occlusion_from_outside_target_surface);
   return copy_pass.Pass();
 }
 
@@ -47,8 +47,8 @@
   this->damage_rect = damage_rect;
   this->transform_to_root_target = transform_to_root_target;
 
-  DCHECK(quad_list.isEmpty());
-  DCHECK(shared_quad_state_list.isEmpty());
+  DCHECK(quad_list.empty());
+  DCHECK(shared_quad_state_list.empty());
 }
 
 void RenderPass::SetAll(Id id,
@@ -56,10 +56,7 @@
                         gfx::RectF damage_rect,
                         const gfx::Transform& transform_to_root_target,
                         bool has_transparent_background,
-                        bool has_occlusion_from_outside_target_surface,
-                        const WebKit::WebFilterOperations& filters,
-                        const skia::RefPtr<SkImageFilter>& filter,
-                        const WebKit::WebFilterOperations& background_filters) {
+                        bool has_occlusion_from_outside_target_surface) {
   DCHECK_GT(id.layer_id, 0);
   DCHECK_GE(id.index, 0);
 
@@ -70,12 +67,9 @@
   this->has_transparent_background = has_transparent_background;
   this->has_occlusion_from_outside_target_surface =
       has_occlusion_from_outside_target_surface;
-  this->filters = filters;
-  this->filter = filter;
-  this->background_filters = background_filters;
 
-  DCHECK(quad_list.isEmpty());
-  DCHECK(shared_quad_state_list.isEmpty());
+  DCHECK(quad_list.empty());
+  DCHECK(shared_quad_state_list.empty());
 }
 
 }  // namespace cc
Index: src/cc/README
===================================================================
--- src/cc/README	(revision 184497)
+++ src/cc/README	(working copy)
@@ -1,6 +0,0 @@
-This is the chromium compositor implementation.
-
-Notes about the component=shared_library build:
-Because the compositor currently depends on non-exported symbols from inside
-WebKit, in the shared library build the cc library links into WebKit.dll.
-The unit tests don't currently work at all in the component build.
Index: src/cc/compositor_frame.h
===================================================================
--- src/cc/compositor_frame.h	(revision 184497)
+++ src/cc/compositor_frame.h	(working copy)
@@ -21,6 +21,8 @@
   CompositorFrameMetadata metadata;
   scoped_ptr<DelegatedFrameData> delegated_frame_data;
   scoped_ptr<GLFrameData> gl_frame_data;
+
+  void AssignTo(CompositorFrame* target);
 };
 
 }  // namespace cc
Index: src/cc/picture.cc
===================================================================
--- src/cc/picture.cc	(revision 184497)
+++ src/cc/picture.cc	(working copy)
@@ -8,12 +8,16 @@
 #include "cc/rendering_stats.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/core/SkData.h"
+#include "third_party/skia/include/core/SkTileGridPicture.h"
 #include "third_party/skia/include/utils/SkPictureUtils.h"
 #include "ui/gfx/rect_conversions.h"
+#include "ui/gfx/skia_util.h"
 
 namespace {
 // URI label for a lazily decoded SkPixelRef.
 const char labelLazyDecoded[] = "lazy";
+// Tile size in recording coordinates used by SkTileGridPicture
+const int tileGridSize = 256;
 }
 
 namespace cc {
@@ -47,18 +51,19 @@
 
 void Picture::Record(ContentLayerClient* painter,
                      RenderingStats& stats) {
-  TRACE_EVENT0("cc", "Picture::Record");
+  TRACE_EVENT2("cc", "Picture::Record",
+               "width", layer_rect_.width(), "height", layer_rect_.height());
 
   // Record() should only be called once.
   DCHECK(!picture_);
-  picture_ = skia::AdoptRef(new SkPicture);
+  picture_ = skia::AdoptRef(new SkTileGridPicture(
+      tileGridSize, tileGridSize, layer_rect_.width(), layer_rect_.height()));
 
-  // TODO(enne): Use SkPicture::kOptimizeForClippedPlayback_RecordingFlag
-  // once http://code.google.com/p/skia/issues/detail?id=1014 is fixed.
   SkCanvas* canvas = picture_->beginRecording(
       layer_rect_.width(),
       layer_rect_.height(),
-      SkPicture::kUsePathBoundsForClip_RecordingFlag);
+      SkPicture::kUsePathBoundsForClip_RecordingFlag |
+      SkPicture::kOptimizeForClippedPlayback_RecordingFlag);
 
   canvas->save();
   canvas->translate(SkFloatToScalar(-layer_rect_.x()),
@@ -77,8 +82,7 @@
   gfx::RectF opaque_layer_rect;
   base::TimeTicks beginPaintTime = base::TimeTicks::Now();
   painter->paintContents(canvas, layer_rect_, opaque_layer_rect);
-  double delta = (base::TimeTicks::Now() - beginPaintTime).InSecondsF();
-  stats.totalPaintTimeInSeconds += delta;
+  stats.totalPaintTime += base::TimeTicks::Now() - beginPaintTime;
   stats.totalPixelsPainted += layer_rect_.width() *
                               layer_rect_.height();
 
@@ -88,23 +92,30 @@
   opaque_rect_ = gfx::ToEnclosedRect(opaque_layer_rect);
 }
 
-void Picture::Raster(SkCanvas* canvas) {
-  TRACE_EVENT0("cc", "Picture::Raster");
+void Picture::Raster(
+    SkCanvas* canvas,
+    gfx::Rect content_rect,
+    float contents_scale) {
+  TRACE_EVENT2("cc", "Picture::Raster",
+               "width", layer_rect_.width(), "height", layer_rect_.height());
   DCHECK(picture_);
+
   canvas->save();
+  canvas->clipRect(gfx::RectToSkRect(content_rect));
+  canvas->scale(contents_scale, contents_scale);
   canvas->translate(layer_rect_.x(), layer_rect_.y());
   canvas->drawPicture(*picture_);
   canvas->restore();
 }
 
-void Picture::GatherPixelRefs(const gfx::Rect& rect,
-                              std::list<skia::LazyPixelRef*>& result) {
+void Picture::GatherPixelRefs(const gfx::Rect& layer_rect,
+                              std::list<skia::LazyPixelRef*>& pixel_ref_list) {
   DCHECK(picture_);
   SkData* pixel_refs = SkPictureUtils::GatherPixelRefs(
-      picture_.get(), SkRect::MakeXYWH(rect.x(),
-                                       rect.y(),
-                                       rect.width(),
-                                       rect.height()));
+      picture_.get(), SkRect::MakeXYWH(layer_rect.x(),
+                                       layer_rect.y(),
+                                       layer_rect.width(),
+                                       layer_rect.height()));
   if (!pixel_refs)
     return;
 
@@ -118,7 +129,7 @@
   for (unsigned int i = 0; i < pixel_refs->size() / sizeof(SkPixelRef*); ++i) {
     if (*refs && (*refs)->getURI() && !strncmp(
         (*refs)->getURI(), labelLazyDecoded, 4)) {
-      result.push_back(static_cast<skia::LazyPixelRef*>(*refs));
+      pixel_ref_list.push_back(static_cast<skia::LazyPixelRef*>(*refs));
     }
     refs++;
   }
Index: src/cc/draw_properties.h
===================================================================
--- src/cc/draw_properties.h	(revision 184497)
+++ src/cc/draw_properties.h	(working copy)
@@ -27,6 +27,7 @@
         , contents_scale_x(1)
         , contents_scale_y(1)
         , num_descendants_that_draw_content(0)
+        , descendants_can_clip_selves(false)
     {
     }
 
@@ -87,6 +88,10 @@
 
     // Does not include this layer itself, only its children and descendants.
     int num_descendants_that_draw_content;
+
+    // If true, every descendant in the sub-tree can clip itself without the
+    // need to use hardware sissoring or a new render target.
+    bool descendants_can_clip_selves;
 };
 
 }  // namespace cc
Index: src/cc/single_thread_proxy.h
===================================================================
--- src/cc/single_thread_proxy.h	(revision 184497)
+++ src/cc/single_thread_proxy.h	(working copy)
@@ -33,13 +33,11 @@
     virtual bool recreateOutputSurface() OVERRIDE;
     virtual void renderingStats(RenderingStats*) OVERRIDE;
     virtual const RendererCapabilities& rendererCapabilities() const OVERRIDE;
-    virtual void loseOutputSurface() OVERRIDE;
     virtual void setNeedsAnimate() OVERRIDE;
     virtual void setNeedsCommit() OVERRIDE;
     virtual void setNeedsRedraw() OVERRIDE;
     virtual void setDeferCommits(bool) OVERRIDE;
     virtual bool commitRequested() const OVERRIDE;
-    virtual void didAddAnimation() OVERRIDE;
     virtual void mainThreadHasStoppedFlinging() OVERRIDE { }
     virtual void start() OVERRIDE;
     virtual void stop() OVERRIDE;
@@ -47,18 +45,24 @@
     virtual void acquireLayerTextures() OVERRIDE { }
     virtual void forceSerializeOnSwapBuffers() OVERRIDE;
     virtual bool commitPendingForTesting() OVERRIDE;
+    virtual skia::RefPtr<SkPicture> capturePicture() OVERRIDE;
 
     // LayerTreeHostImplClient implementation
-    virtual void didLoseOutputSurfaceOnImplThread() OVERRIDE { }
+    virtual void didLoseOutputSurfaceOnImplThread() OVERRIDE;
     virtual void onSwapBuffersCompleteOnImplThread() OVERRIDE;
     virtual void onVSyncParametersChanged(base::TimeTicks timebase, base::TimeDelta interval) OVERRIDE { }
     virtual void onCanDrawStateChanged(bool canDraw) OVERRIDE { }
+    virtual void onHasPendingTreeStateChanged(bool havePendingTree) OVERRIDE;
     virtual void setNeedsRedrawOnImplThread() OVERRIDE;
+    virtual void didUploadVisibleHighResolutionTileOnImplThread() OVERRIDE;
     virtual void setNeedsCommitOnImplThread() OVERRIDE;
     virtual void setNeedsManageTilesOnImplThread() OVERRIDE;
     virtual void postAnimationEventsToMainThreadOnImplThread(scoped_ptr<AnimationEventsVector>, base::Time wallClockTime) OVERRIDE;
     virtual bool reduceContentsTextureMemoryOnImplThread(size_t limitBytes, int priorityCutoff) OVERRIDE;
+    virtual void reduceWastedContentsTextureMemoryOnImplThread() OVERRIDE;
     virtual void sendManagedMemoryStats() OVERRIDE;
+    virtual bool isInsideDraw() OVERRIDE;
+    virtual void renewTreePriority() OVERRIDE { }
 
     // Called by the legacy path where RenderWidget does the scheduling.
     void compositeImmediately();
@@ -86,6 +90,8 @@
 
     bool m_nextFrameIsNewlyCommittedFrame;
 
+    bool m_insideDraw;
+
     base::TimeDelta m_totalCommitTime;
     size_t m_totalCommitCount;
 };
Index: src/cc/active_animation.h
===================================================================
--- src/cc/active_animation.h	(revision 184497)
+++ src/cc/active_animation.h	(working copy)
@@ -1,162 +0,0 @@
-// Copyright 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef CC_ACTIVE_ANIMATION_H_
-#define CC_ACTIVE_ANIMATION_H_
-
-#include "base/basictypes.h"
-#include "base/memory/scoped_ptr.h"
-#include "cc/cc_export.h"
-
-namespace cc {
-
-class AnimationCurve;
-
-// An ActiveAnimation, contains all the state required to play an AnimationCurve.
-// Specifically, the affected property, the run state (paused, finished, etc.),
-// loop count, last pause time, and the total time spent paused.
-class CC_EXPORT ActiveAnimation {
-public:
-    // Animations begin in one of the 'waiting' states. Animations waiting for the next tick
-    // will start the next time the controller animates. Animations waiting for target
-    // availibility will run as soon as their target property is free (and all the animations
-    // animating with it are also able to run). Animations waiting for their start time to
-    // come have be scheduled to run at a particular point in time. When this time arrives,
-    // the controller will move the animations into the Running state. Running animations
-    // may toggle between Running and Paused, and may be stopped by moving into either the
-    // Aborted or Finished states. A Finished animation was allowed to run to completion, but
-    // an Aborted animation was not.
-    enum RunState {
-        WaitingForNextTick = 0,
-        WaitingForTargetAvailability,
-        WaitingForStartTime,
-        WaitingForDeletion,
-        Running,
-        Paused,
-        Finished,
-        Aborted,
-        // This sentinel must be last.
-        RunStateEnumSize
-    };
-
-    enum TargetProperty {
-        Transform = 0,
-        Opacity,
-        // This sentinel must be last.
-        TargetPropertyEnumSize
-    };
-
-    static scoped_ptr<ActiveAnimation> create(scoped_ptr<AnimationCurve>, int animationId, int groupId, TargetProperty);
-
-    virtual ~ActiveAnimation();
-
-    int id() const { return m_id; }
-    int group() const { return m_group; }
-    TargetProperty targetProperty() const { return m_targetProperty; }
-
-    RunState runState() const { return m_runState; }
-    void setRunState(RunState, double monotonicTime);
-
-    // This is the number of times that the animation will play. If this
-    // value is zero the animation will not play. If it is negative, then
-    // the animation will loop indefinitely.
-    int iterations() const { return m_iterations; }
-    void setIterations(int n) { m_iterations = n; }
-
-    double startTime() const { return m_startTime; }
-    void setStartTime(double monotonicTime) { m_startTime = monotonicTime; }
-    bool hasSetStartTime() const { return !!m_startTime; }
-
-    double timeOffset() const { return m_timeOffset; }
-    void setTimeOffset(double monotonicTime) { m_timeOffset = monotonicTime; }
-
-    void suspend(double monotonicTime);
-    void resume(double monotonicTime);
-
-    // If alternatesDirection is true, on odd numbered iterations we reverse the curve.
-    bool alternatesDirection() const { return m_alternatesDirection; }
-    void setAlternatesDirection(bool alternates) { m_alternatesDirection = alternates; }
-
-    bool isFinishedAt(double monotonicTime) const;
-    bool isFinished() const { return m_runState == Finished
-                                  || m_runState == Aborted
-                                  || m_runState == WaitingForDeletion; }
-
-    AnimationCurve* curve() { return m_curve.get(); }
-    const AnimationCurve* curve() const { return m_curve.get(); }
-
-    // If this is true, even if the animation is running, it will not be tickable until
-    // it is given a start time. This is true for animations running on the main thread.
-    bool needsSynchronizedStartTime() const { return m_needsSynchronizedStartTime; }
-    void setNeedsSynchronizedStartTime(bool needsSynchronizedStartTime) { m_needsSynchronizedStartTime = needsSynchronizedStartTime; }
-
-    // Takes the given absolute time, and using the start time and the number
-    // of iterations, returns the relative time in the current iteration.
-    double trimTimeToCurrentIteration(double monotonicTime) const;
-
-    enum InstanceType {
-        ControllingInstance = 0,
-        NonControllingInstance
-    };
-
-    scoped_ptr<ActiveAnimation> clone(InstanceType) const;
-    scoped_ptr<ActiveAnimation> cloneAndInitialize(InstanceType, RunState initialRunState, double startTime) const;
-    bool isControllingInstance() const { return m_isControllingInstance; }
-
-    void pushPropertiesTo(ActiveAnimation*) const;
-
-private:
-    ActiveAnimation(scoped_ptr<AnimationCurve>, int animationId, int groupId, TargetProperty);
-
-    scoped_ptr<AnimationCurve> m_curve;
-
-    // IDs are not necessarily unique.
-    int m_id;
-
-    // Animations that must be run together are called 'grouped' and have the same group id
-    // Grouped animations are guaranteed to start at the same time and no other animations
-    // may animate any of the group's target properties until all animations in the
-    // group have finished animating. Note: an active animation's group id and target
-    // property uniquely identify that animation.
-    int m_group;
-
-    TargetProperty m_targetProperty;
-    RunState m_runState;
-    int m_iterations;
-    double m_startTime;
-    bool m_alternatesDirection;
-
-    // The time offset effectively pushes the start of the animation back in time. This is
-    // used for resuming paused animations -- an animation is added with a non-zero time
-    // offset, causing the animation to skip ahead to the desired point in time.
-    double m_timeOffset;
-
-    bool m_needsSynchronizedStartTime;
-
-    // When an animation is suspended, it behaves as if it is paused and it also ignores
-    // all run state changes until it is resumed. This is used for testing purposes.
-    bool m_suspended;
-
-    // These are used in trimTimeToCurrentIteration to account for time
-    // spent while paused. This is not included in AnimationState since it
-    // there is absolutely no need for clients of this controller to know
-    // about these values.
-    double m_pauseTime;
-    double m_totalPausedTime;
-
-    // Animations lead dual lives. An active animation will be conceptually owned by
-    // two controllers, one on the impl thread and one on the main. In reality, there
-    // will be two separate ActiveAnimation instances for the same animation. They
-    // will have the same group id and the same target property (these two values
-    // uniquely identify an animation). The instance on the impl thread is the instance
-    // that ultimately controls the values of the animating layer and so we will refer
-    // to it as the 'controlling instance'.
-    bool m_isControllingInstance;
-
-    DISALLOW_COPY_AND_ASSIGN(ActiveAnimation);
-};
-
-} // namespace cc
-
-#endif  // CC_ACTIVE_ANIMATION_H_
Index: src/cc/picture_layer_tiling.cc
===================================================================
--- src/cc/picture_layer_tiling.cc	(revision 184497)
+++ src/cc/picture_layer_tiling.cc	(working copy)
@@ -4,49 +4,50 @@
 
 #include "cc/picture_layer_tiling.h"
 
+#include <cmath>
+
+#include "base/debug/trace_event.h"
 #include "cc/math_util.h"
+#include "ui/gfx/point_conversions.h"
 #include "ui/gfx/rect_conversions.h"
+#include "ui/gfx/safe_integer_conversions.h"
 #include "ui/gfx/size_conversions.h"
 
 namespace cc {
 
 scoped_ptr<PictureLayerTiling> PictureLayerTiling::Create(
-    float contents_scale,
-    gfx::Size tile_size) {
-  return make_scoped_ptr(new PictureLayerTiling(contents_scale, tile_size));
+    float contents_scale) {
+  return make_scoped_ptr(new PictureLayerTiling(contents_scale));
 }
 
 scoped_ptr<PictureLayerTiling> PictureLayerTiling::Clone() const {
   return make_scoped_ptr(new PictureLayerTiling(*this));
 }
 
-PictureLayerTiling::PictureLayerTiling(float contents_scale,
-                                       gfx::Size tile_size)
+PictureLayerTiling::PictureLayerTiling(float contents_scale)
     : client_(NULL),
       contents_scale_(contents_scale),
-      tiling_data_(tile_size, gfx::Size(), true) {
+      tiling_data_(gfx::Size(), gfx::Size(), true),
+      resolution_(NON_IDEAL_RESOLUTION),
+      last_source_frame_number_(0),
+      last_impl_frame_time_(0) {
 }
 
 PictureLayerTiling::~PictureLayerTiling() {
 }
 
-const PictureLayerTiling& PictureLayerTiling::operator=(
-    const PictureLayerTiling& tiler) {
-  tiling_data_ = tiler.tiling_data_;
-  tiles_ = tiler.tiles_;
-  return *this;
-}
-
 void PictureLayerTiling::SetClient(PictureLayerTilingClient* client) {
   client_ = client;
 }
 
 gfx::Rect PictureLayerTiling::ContentRect() const {
-  gfx::Size content_bounds =
-      gfx::ToCeiledSize(gfx::ScaleSize(layer_bounds_, contents_scale_));
-  return gfx::Rect(gfx::Point(), content_bounds);
+  return gfx::Rect(tiling_data_.total_size());
 }
 
+gfx::SizeF PictureLayerTiling::ContentSizeF() const {
+  return gfx::ScaleSize(layer_bounds_, contents_scale_);
+}
+
 Tile* PictureLayerTiling::TileAt(int i, int j) const {
   TileMap::const_iterator iter = tiles_.find(TileMapKey(i, j));
   if (iter == tiles_.end())
@@ -58,14 +59,10 @@
   gfx::Rect tile_rect = tiling_data_.TileBoundsWithBorder(i, j);
   tile_rect.set_size(tiling_data_.max_texture_size());
   TileMapKey key(i, j);
-  DCHECK(!tiles_[key]);
-  tiles_[key] = client_->CreateTile(this, tile_rect);
-
-  // TODO(enne): Remove this when we start setting priorities correctly.
-  TilePriority priority;
-  priority.resolution = HIGH_RESOLUTION;
-  priority.time_to_visible_in_seconds = 1000;
-  tiles_[key]->set_priority(ACTIVE_TREE, priority);
+  DCHECK(tiles_.find(key) == tiles_.end());
+  scoped_refptr<Tile> tile = client_->CreateTile(this, tile_rect);
+  if (tile)
+    tiles_[key] = tile;
 }
 
 Region PictureLayerTiling::OpaqueRegionInContentRect(
@@ -79,7 +76,9 @@
   if (layer_bounds_ == layer_bounds)
     return;
 
+  gfx::Size old_layer_bounds = layer_bounds_;
   layer_bounds_ = layer_bounds;
+  gfx::Size old_content_bounds = tiling_data_.total_size();
   gfx::Size content_bounds =
       gfx::ToCeiledSize(gfx::ScaleSize(layer_bounds_, contents_scale_));
 
@@ -89,25 +88,41 @@
     return;
   }
 
-  int right = tiling_data_.TileXIndexFromSrcCoord(content_bounds.width() - 1);
-  int bottom = tiling_data_.TileYIndexFromSrcCoord(content_bounds.height() - 1);
+  gfx::Size tile_size = client_->CalculateTileSize(
+      tiling_data_.max_texture_size(),
+      content_bounds);
+  if (tile_size != tiling_data_.max_texture_size()) {
+    tiling_data_.SetMaxTextureSize(tile_size);
+    tiles_.clear();
+    CreateTilesFromLayerRect(gfx::Rect(layer_bounds_));
+    return;
+  }
 
-  // TODO(enne): Be more efficient about what tiles are created.
-  for (int j = 0; j <= bottom; ++j) {
-    for (int i = 0; i <= right; ++i) {
-      if (tiles_.find(TileMapKey(i, j)) == tiles_.end())
-        CreateTile(i, j);
+  // Any tiles outside our new bounds are invalid and should be dropped.
+  if (old_content_bounds.width() > content_bounds.width() ||
+      old_content_bounds.height() > content_bounds.height()) {
+    int right =
+        tiling_data_.TileXIndexFromSrcCoord(content_bounds.width() - 1);
+    int bottom =
+        tiling_data_.TileYIndexFromSrcCoord(content_bounds.height() - 1);
+
+    std::vector<TileMapKey> invalid_tile_keys;
+    for (TileMap::const_iterator it = tiles_.begin();
+         it != tiles_.end(); ++it) {
+      if (it->first.first > right || it->first.second > bottom)
+        invalid_tile_keys.push_back(it->first);
     }
+    for (size_t i = 0; i < invalid_tile_keys.size(); ++i)
+      tiles_.erase(invalid_tile_keys[i]);
   }
 
-  // Any tiles outside our new bounds are invalid and should be dropped.
-  std::vector<TileMapKey> invalid_tile_keys;
-  for (TileMap::const_iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
-    if (it->first.first > right || it->first.second > bottom)
-      invalid_tile_keys.push_back(it->first);
+  // Create tiles for newly exposed areas.
+  Region layer_region((gfx::Rect(layer_bounds_)));
+  layer_region.Subtract(gfx::Rect(old_layer_bounds));
+  for (Region::Iterator iter(layer_region); iter.has_rect(); iter.next()) {
+    Invalidate(iter.rect());
+    CreateTilesFromLayerRect(iter.rect());
   }
-  for (size_t i = 0; i < invalid_tile_keys.size(); ++i)
-    tiles_.erase(invalid_tile_keys[i]);
 }
 
 void PictureLayerTiling::Invalidate(const Region& layer_invalidation) {
@@ -117,24 +132,43 @@
        region_iter.has_rect();
        region_iter.next()) {
 
+    gfx::Rect layer_invalidation = region_iter.rect();
+    layer_invalidation.Intersect(gfx::Rect(layer_bounds_));
     gfx::Rect rect =
-        gfx::ToEnclosingRect(ScaleRect(region_iter.rect(), contents_scale_));
-    rect.Intersect(ContentRect());
+        gfx::ToEnclosingRect(ScaleRect(layer_invalidation, contents_scale_));
 
-    for (PictureLayerTiling::Iterator tile_iter(this, contents_scale_, rect);
+    for (PictureLayerTiling::Iterator tile_iter(this, contents_scale_, rect,
+                                                PictureLayerTiling::LayerDeviceAlignmentUnknown);
          tile_iter;
          ++tile_iter) {
       TileMapKey key(tile_iter.tile_i_, tile_iter.tile_j_);
-      if (!tiles_[key])
+      TileMap::iterator found = tiles_.find(key);
+      if (found == tiles_.end())
         continue;
 
-      tiles_[key] = NULL;
+      tiles_.erase(found);
       new_tiles.push_back(key);
     }
   }
 
-  for (size_t i = 0; i < new_tiles.size(); ++i) {
+  for (size_t i = 0; i < new_tiles.size(); ++i)
     CreateTile(new_tiles[i].first, new_tiles[i].second);
+}
+
+void PictureLayerTiling::CreateTilesFromLayerRect(gfx::Rect layer_rect) {
+  gfx::Rect content_rect =
+      gfx::ToEnclosingRect(ScaleRect(layer_rect, contents_scale_));
+  CreateTilesFromContentRect(content_rect);
+}
+
+void PictureLayerTiling::CreateTilesFromContentRect(gfx::Rect content_rect) {
+  for (TilingData::Iterator iter(&tiling_data_, content_rect); iter; ++iter) {
+    TileMap::iterator found =
+        tiles_.find(TileMapKey(iter.index_x(), iter.index_y()));
+    // Ignore any tiles that already exist.
+    if (found != tiles_.end())
+      continue;
+    CreateTile(iter.index_x(), iter.index_y());
   }
 }
 
@@ -145,29 +179,70 @@
       tile_j_(0),
       left_(0),
       top_(0),
-      right_(0),
-      bottom_(0) {
+      right_(-1),
+      bottom_(-1) {
 }
 
-PictureLayerTiling::Iterator::Iterator(PictureLayerTiling* tiling,
+PictureLayerTiling::Iterator::Iterator(const PictureLayerTiling* tiling,
                                        float dest_scale,
-                                       gfx::Rect dest_rect)
+                                       gfx::Rect dest_rect,
+                                       LayerDeviceAlignment layerDeviceAlignment)
     : tiling_(tiling),
       dest_rect_(dest_rect),
-      dest_to_content_scale_(tiling_->contents_scale_ / dest_scale),
       current_tile_(NULL),
+      dest_to_content_scale_x_(0),
+      dest_to_content_scale_y_(0),
       tile_i_(0),
       tile_j_(0),
       left_(0),
       top_(0),
-      right_(0),
-      bottom_(0) {
+      right_(-1),
+      bottom_(-1) {
   DCHECK(tiling_);
   if (dest_rect_.IsEmpty())
     return;
 
+  float dest_to_content_scale = tiling_->contents_scale_ / dest_scale;
+  // This is the maximum size that the dest rect can be, given the content size.
+  gfx::Size dest_content_size = gfx::ToCeiledSize(gfx::ScaleSize(
+      tiling_->ContentRect().size(),
+      1 / dest_to_content_scale,
+      1 / dest_to_content_scale));
+
+  // The last row/column of texels may not have full rasterization coverage,
+  // which can happen if the ceiled content size does not equal the floored
+  // content size.  These texels will sample outside of the recording to
+  // generate their pixels.  Use the floored size here to ignore them.
+  gfx::Size content_size_floor = gfx::ToFlooredSize(tiling->ContentSizeF());
+  dest_to_content_scale_x_ = content_size_floor.width() /
+      static_cast<float>(dest_content_size.width());
+  dest_to_content_scale_y_ = content_size_floor.height() /
+      static_cast<float>(dest_content_size.height());
+
+  // It's possible that when drawing a quad with texel:pixel ratio < 1
+  // GL_LINEAR will cause us to blend in invalid texels.
+  // We stretch the content a little more to prevent sampling past the
+  // middle of the last texel.
+  if (layerDeviceAlignment == LayerAlignedToDevice){
+    if (dest_to_content_scale_x_ < 1.0)
+      dest_to_content_scale_x_ -= 0.5f / dest_content_size.width();
+    if (dest_to_content_scale_y_ < 1.0)
+      dest_to_content_scale_y_ -= 0.5f / dest_content_size.height();
+  }
+  else if (layerDeviceAlignment == LayerNotAlignedToDevice) {
+    dest_to_content_scale_x_ -= 0.5f / dest_content_size.width();
+    dest_to_content_scale_y_ -= 0.5f / dest_content_size.height();
+  }
+
   gfx::Rect content_rect =
-      gfx::ToEnclosingRect(gfx::ScaleRect(dest_rect_, dest_to_content_scale_));
+      gfx::ToEnclosingRect(gfx::ScaleRect(dest_rect_,
+                                          dest_to_content_scale_x_,
+                                          dest_to_content_scale_y_));
+  // IndexFromSrcCoord clamps to valid tile ranges, so it's necessary to
+  // check for non-intersection first.
+  content_rect.Intersect(gfx::Rect(tiling_->tiling_data_.total_size()));
+  if (content_rect.IsEmpty())
+    return;
 
   left_ = tiling_->tiling_data_.TileXIndexFromSrcCoord(content_rect.x());
   top_ = tiling_->tiling_data_.TileYIndexFromSrcCoord(content_rect.y());
@@ -204,13 +279,16 @@
   current_tile_ = tiling_->TileAt(tile_i_, tile_j_);
 
   // Calculate the current geometry rect.  Due to floating point rounding
-  // and ToEnclosedRect, tiles might overlap in destination space on the
+  // and ToEnclosingRect, tiles might overlap in destination space on the
   // edges.
   gfx::Rect last_geometry_rect = current_geometry_rect_;
 
   gfx::Rect content_rect = tiling_->tiling_data_.TileBounds(tile_i_, tile_j_);
+
   current_geometry_rect_ = gfx::ToEnclosingRect(
-      gfx::ScaleRect(content_rect, 1 / dest_to_content_scale_));
+      gfx::ScaleRect(content_rect, 1 / dest_to_content_scale_x_,
+                                   1 / dest_to_content_scale_y_));
+
   current_geometry_rect_.Intersect(dest_rect_);
 
   if (first_time)
@@ -246,21 +324,23 @@
   return current_geometry_rect_;
 }
 
+gfx::Rect PictureLayerTiling::Iterator::full_tile_geometry_rect() const {
+  gfx::Rect rect = tiling_->tiling_data_.TileBoundsWithBorder(tile_i_, tile_j_);
+  rect.set_size(tiling_->tiling_data_.max_texture_size());
+  return rect;
+}
+
 gfx::RectF PictureLayerTiling::Iterator::texture_rect() const {
-  gfx::Rect full_bounds = tiling_->tiling_data_.TileBoundsWithBorder(tile_i_,
-                                                                     tile_j_);
-  full_bounds.set_size(texture_size());
+  gfx::PointF tex_origin =
+      tiling_->tiling_data_.TileBoundsWithBorder(tile_i_, tile_j_).origin();
 
   // Convert from dest space => content space => texture space.
-  gfx::RectF texture_rect = gfx::ScaleRect(current_geometry_rect_,
-                                           dest_to_content_scale_);
-  texture_rect.Offset(-full_bounds.OffsetFromOrigin());
+  gfx::RectF texture_rect(current_geometry_rect_);
+  texture_rect.Scale(dest_to_content_scale_x_,
+                     dest_to_content_scale_y_);
+  texture_rect.Offset(-tex_origin.OffsetFromOrigin());
+  texture_rect.Intersect(tiling_->ContentRect());
 
-  DCHECK_GE(texture_rect.x(), 0);
-  DCHECK_GE(texture_rect.y(), 0);
-  DCHECK_LE(texture_rect.right(), texture_size().width());
-  DCHECK_LE(texture_rect.bottom(), texture_size().height());
-
   return texture_rect;
 }
 
@@ -269,51 +349,390 @@
 }
 
 void PictureLayerTiling::UpdateTilePriorities(
-    const gfx::Size& device_viewport,
-    float layer_content_scale_x,
-    float layer_content_scale_y,
+    WhichTree tree,
+    gfx::Size device_viewport,
+    const gfx::RectF& viewport_in_layer_space,
+    gfx::Size last_layer_bounds,
+    gfx::Size current_layer_bounds,
+    gfx::Size last_layer_content_bounds,
+    gfx::Size current_layer_content_bounds,
+    float last_layer_contents_scale,
+    float current_layer_contents_scale,
     const gfx::Transform& last_screen_transform,
     const gfx::Transform& current_screen_transform,
-    double time_delta) {
-  gfx::Rect content_rect = ContentRect();
-  if (content_rect.IsEmpty())
+    int current_source_frame_number,
+    double current_frame_time) {
+  if (ContentRect().IsEmpty())
     return;
 
-  gfx::Rect view_rect(gfx::Point(), device_viewport);
-  int right = tiling_data_.TileXIndexFromSrcCoord(content_rect.width() - 1);
-  int bottom = tiling_data_.TileYIndexFromSrcCoord(content_rect.height() - 1);
+  bool first_update_in_new_source_frame =
+      current_source_frame_number != last_source_frame_number_;
+
+  bool first_update_in_new_impl_frame =
+      current_frame_time != last_impl_frame_time_;
+
+  // In pending tree, this is always called. We update priorities:
+  // - Immediately after a commit (first_update_in_new_source_frame).
+  // - On animation ticks after the first frame in the tree
+  //   (first_update_in_new_impl_frame).
+  // In active tree, this is only called during draw. We update priorities:
+  // - On draw if properties were not already computed by the pending tree
+  //   and activated for the frame (first_update_in_new_impl_frame).
+  if (!first_update_in_new_impl_frame && !first_update_in_new_source_frame)
+    return;
+
+  double time_delta = 0;
+  if (last_impl_frame_time_ != 0 &&
+      last_layer_bounds == current_layer_bounds &&
+      last_layer_content_bounds == current_layer_content_bounds &&
+      last_layer_contents_scale == current_layer_contents_scale) {
+    time_delta = current_frame_time - last_impl_frame_time_;
+  }
+
+  gfx::Rect viewport_in_content_space =
+      gfx::ToEnclosingRect(gfx::ScaleRect(viewport_in_layer_space,
+                                          contents_scale_));
+
+  gfx::Size tile_size = tiling_data_.max_texture_size();
+  int64 prioritized_rect_area =
+      TilePriority::kNumTilesToCoverWithInflatedViewportRectForPrioritization *
+      tile_size.width() * tile_size.height();
+
+  gfx::Rect prioritized_rect = ExpandRectEquallyToAreaBoundedBy(
+      viewport_in_content_space,
+      prioritized_rect_area,
+      ContentRect());
+  DCHECK(ContentRect().Contains(prioritized_rect));
+
+  // Iterate through all of the tiles that were live last frame but will
+  // not be live this frame, and mark them as being dead.
+  for (TilingData::DifferenceIterator iter(&tiling_data_,
+                                           last_prioritized_rect_,
+                                           prioritized_rect);
+       iter;
+       ++iter) {
+    TileMap::iterator find = tiles_.find(iter.index());
+    if (find == tiles_.end())
+      continue;
+
+    TilePriority priority;
+    DCHECK(!priority.is_live);
+    Tile* tile = find->second.get();
+    tile->set_priority(tree, priority);
+  }
+  last_prioritized_rect_ = prioritized_rect;
+
+  gfx::Rect view_rect(device_viewport);
+  float current_scale = current_layer_contents_scale / contents_scale_;
+  float last_scale = last_layer_contents_scale / contents_scale_;
+
+  // Fast path tile priority calculation when both transforms are translations.
+  if (last_screen_transform.IsIdentityOrTranslation() &&
+      current_screen_transform.IsIdentityOrTranslation())
+  {
+    gfx::Vector2dF current_offset(
+        current_screen_transform.matrix().get(0, 3),
+        current_screen_transform.matrix().get(1, 3));
+    gfx::Vector2dF last_offset(
+        last_screen_transform.matrix().get(0, 3),
+        last_screen_transform.matrix().get(1, 3));
+
+    for (TilingData::Iterator iter(&tiling_data_, prioritized_rect);
+         iter; ++iter) {
+      TileMap::iterator find = tiles_.find(iter.index());
+      if (find == tiles_.end())
+        continue;
+      Tile* tile = find->second.get();
+
+      gfx::Rect tile_bounds =
+          tiling_data_.TileBounds(iter.index_x(), iter.index_y());
+      gfx::RectF current_screen_rect = gfx::ScaleRect(
+          tile_bounds,
+          current_scale,
+          current_scale) + current_offset;
+      gfx::RectF last_screen_rect = gfx::ScaleRect(
+          tile_bounds,
+          last_scale,
+          last_scale) + last_offset;
+
+      float distance_to_visible_in_pixels =
+          TilePriority::manhattanDistance(current_screen_rect, view_rect);
+
+      float time_to_visible_in_seconds =
+          TilePriority::TimeForBoundsToIntersect(
+              last_screen_rect, current_screen_rect, time_delta, view_rect);
+      TilePriority priority(
+          resolution_,
+          time_to_visible_in_seconds,
+          distance_to_visible_in_pixels);
+      tile->set_priority(tree, priority);
+    }
+  }
+  else
+  {
+    for (TilingData::Iterator iter(&tiling_data_, prioritized_rect);
+         iter; ++iter) {
+      TileMap::iterator find = tiles_.find(iter.index());
+      if (find == tiles_.end())
+        continue;
+      Tile* tile = find->second.get();
+
+      gfx::Rect tile_bounds =
+          tiling_data_.TileBounds(iter.index_x(), iter.index_y());
+      gfx::RectF current_layer_content_rect = gfx::ScaleRect(
+          tile_bounds,
+          current_scale,
+          current_scale);
+      gfx::RectF current_screen_rect = MathUtil::mapClippedRect(
+          current_screen_transform, current_layer_content_rect);
+      gfx::RectF last_layer_content_rect = gfx::ScaleRect(
+          tile_bounds,
+          last_scale,
+          last_scale);
+      gfx::RectF last_screen_rect  = MathUtil::mapClippedRect(
+          last_screen_transform, last_layer_content_rect);
+
+      float distance_to_visible_in_pixels =
+          TilePriority::manhattanDistance(current_screen_rect, view_rect);
+
+      float time_to_visible_in_seconds =
+          TilePriority::TimeForBoundsToIntersect(
+              last_screen_rect, current_screen_rect, time_delta, view_rect);
+
+      TilePriority priority(
+          resolution_,
+          time_to_visible_in_seconds,
+          distance_to_visible_in_pixels);
+      tile->set_priority(tree, priority);
+    }
+  }
+
+  last_source_frame_number_ = current_source_frame_number;
+  last_impl_frame_time_ = current_frame_time;
+}
+
+void PictureLayerTiling::DidBecomeActive() {
   for (TileMap::const_iterator it = tiles_.begin(); it != tiles_.end(); ++it) {
-    TileMapKey key = it->first;
-    TilePriority priority;
-    if (key.first > right || key.second > bottom) {
-      priority.distance_to_visible_in_pixels = std::numeric_limits<int>::max();
-      priority.time_to_visible_in_seconds =
-          TilePriority::kMaxTimeToVisibleInSeconds;
-      // TODO(qinmin): pass the correct tree to this function.
-      it->second->set_priority(ACTIVE_TREE, priority);
+    it->second->set_priority(ACTIVE_TREE, it->second->priority(PENDING_TREE));
+    it->second->set_priority(PENDING_TREE, TilePriority());
+
+    // Tile holds a ref onto a picture pile. If the tile never gets invalidated
+    // and recreated, then that picture pile ref could exist indefinitely.  To
+    // prevent this, ask the client to update the pile to its own ref.  This
+    // will cause PicturePileImpls and their clones to get deleted once the
+    // corresponding PictureLayerImpl and any in flight raster jobs go out of
+    // scope.
+    client_->UpdatePile(it->second);
+  }
+}
+
+namespace {
+
+int ComputeOffsetToExpand4EdgesEqually(int old_width,
+                                       int old_height,
+                                       int64 target_area) {
+  // We need to expand the rect in 4 directions, we can compute the
+  // amount to expand along each axis with a quadratic equation:
+  //   (old_w + add) * (old_h + add) = target_area
+  //   old_w * old_h + old_w * add + add * old_h + add * add = target_area
+  //   add^2 + add * (old_w + old_h) - target_area + old_w * old_h = 0
+  // Therefore, we solve the quadratic equation with:
+  // a = 1
+  // b = old_w + old_h
+  // c = -target_area + old_w * old_h
+  int a = 1;
+  int64 b = old_width + old_height;
+  int64 c = -target_area + old_width * old_height;
+  int sqrt_part = std::sqrt(b * b - 4.0 * a * c);
+  int add_each_axis = (-b + sqrt_part) / 2 / a;
+  return add_each_axis / 2;
+}
+
+int ComputeOffsetToExpand3EdgesEqually(int old_width,
+                                       int old_height,
+                                       int64 target_area,
+                                       bool left_complete,
+                                       bool top_complete,
+                                       bool right_complete,
+                                       bool bottom_complete) {
+  // We need to expand the rect in three directions, so we will have to
+  // expand along one axis twice as much as the other. Otherwise, this
+  // is very similar to the case where we expand in all 4 directions.
+
+  if (left_complete || right_complete) {
+    // Expanding twice as much vertically as horizontally.
+    //   (old_w + add) * (old_h + add*2) = target_area
+    //   old_w * old_h + old_w * add*2 + add * old_h + add * add*2 = target_area
+    //   (add^2)*2 + add * (old_w*2 + old_h) - target_area + old_w * old_h = 0
+    // Therefore, we solve the quadratic equation with:
+    // a = 2
+    // b = old_w*2 + old_h
+    // c = -target_area + old_w * old_h
+    int a = 2;
+    int64 b = old_width * 2 + old_height;
+    int64 c = -target_area + old_width * old_height;
+    int sqrt_part = std::sqrt(b * b - 4.0 * a * c);
+    int add_each_direction = (-b + sqrt_part) / 2 / a;
+    return add_each_direction;
+  } else {
+    // Expanding twice as much horizontally as vertically.
+    //   (old_w + add*2) * (old_h + add) = target_area
+    //   old_w * old_h + old_w * add + add*2 * old_h + add*2 * add = target_area
+    //   (add^2)*2 + add * (old_w + old_h*2) - target_area + old_w * old_h = 0
+    // Therefore, we solve the quadratic equation with:
+    // a = 2
+    // b = old_w + old_h*2
+    // c = -target_area + old_w * old_h
+    int a = 2;
+    int64 b = old_width + old_height * 2;
+    int64 c = -target_area + old_width * old_height;
+    int sqrt_part = std::sqrt(b * b - 4.0 * a * c);
+    int add_each_direction = (-b + sqrt_part) / 2 / a;
+    return add_each_direction;
+  }
+}
+
+int ComputeOffsetToExpand2EdgesEqually(int old_width,
+                                       int old_height,
+                                       int64 target_area,
+                                       bool left_complete,
+                                       bool top_complete,
+                                       bool right_complete,
+                                       bool bottom_complete) {
+  // We need to expand the rect along two directions. If the two directions
+  // are opposite from each other then we only need to compute a distance
+  // along a single axis.
+  if (left_complete && right_complete) {
+    // Expanding along the vertical axis only:
+    //   old_w * (old_h + add) = target_area
+    //   old_w * old_h + old_w * add = target_area
+    //   add_vertically = (target_area - old_w * old_h) / old_w
+    int add_vertically = target_area / old_width - old_height;
+    return add_vertically / 2;
+  } else if (top_complete && bottom_complete) {
+    // Expanding along the horizontal axis only:
+    //   (old_w + add) * old_h = target_area
+    //   old_w * old_h + add * old_h = target_area
+    //   add_horizontally = (target_area - old_w * old_h) / old_h
+    int add_horizontally = target_area / old_height - old_width;
+    return add_horizontally / 2;
+  } else {
+    // If we need to expand along both horizontal and vertical axes, we can use
+    // the same result as if we were expanding all four edges. But we apply the
+    // offset computed for opposing edges to a single edge.
+    int add_each_direction = ComputeOffsetToExpand4EdgesEqually(
+        old_width, old_height, target_area);
+    return add_each_direction * 2;
+  }
+}
+
+int ComputeOffsetToExpand1Edge(int old_width,
+                               int old_height,
+                               int64 target_area,
+                               bool left_complete,
+                               bool top_complete,
+                               bool right_complete,
+                               bool bottom_complete) {
+  // We need to expand the rect in a single direction, so we are either
+  // moving just a verical edge, or just a horizontal edge.
+  if (!top_complete || !bottom_complete) {
+    // Moving a vertical edge:
+    //   old_w * (old_h + add) = target_area
+    //   old_w * old_h + old_w * add = target_area
+    //   add_vertically = (target_area - old_w * old_h) / old_w
+    int add_vertically = target_area / old_width - old_height;
+    return add_vertically;
+  } else {
+    // Moving a horizontal edge:
+    //   (old_w + add) * old_h = target_area
+    //   old_w * old_h + add * old_h = target_area
+    //   add_horizontally = (target_area - old_w * old_h) / old_h
+    int add_horizontally = target_area / old_height - old_width;
+    return add_horizontally;
+  }
+}
+
+}  // namespace
+
+// static
+gfx::Rect PictureLayerTiling::ExpandRectEquallyToAreaBoundedBy(
+    gfx::Rect starting_rect,
+    int64 target_area,
+    gfx::Rect bounding_rect) {
+
+  bool left_complete = false;
+  bool top_complete = false;
+  bool right_complete = false;
+  bool bottom_complete = false;
+  int num_edges_complete = 0;
+
+  gfx::Rect working_rect = starting_rect;
+  for (int i = 0; i < 4; ++i) {
+    if (num_edges_complete != i)
       continue;
+    int offset_for_each_edge = 0;
+    switch (num_edges_complete) {
+      case 0:
+        offset_for_each_edge = ComputeOffsetToExpand4EdgesEqually(
+            working_rect.width(),
+            working_rect.height(),
+            target_area);
+        break;
+      case 1:
+        offset_for_each_edge = ComputeOffsetToExpand3EdgesEqually(
+            working_rect.width(),
+            working_rect.height(),
+            target_area,
+            left_complete,
+            top_complete,
+            right_complete,
+            bottom_complete);
+        break;
+      case 2:
+        offset_for_each_edge = ComputeOffsetToExpand2EdgesEqually(
+            working_rect.width(),
+            working_rect.height(),
+            target_area,
+            left_complete,
+            top_complete,
+            right_complete,
+            bottom_complete);
+        break;
+      case 3:
+        offset_for_each_edge = ComputeOffsetToExpand1Edge(
+            working_rect.width(),
+            working_rect.height(),
+            target_area,
+            left_complete,
+            top_complete,
+            right_complete,
+            bottom_complete);
     }
 
-    gfx::Rect tile_bound = tiling_data_.TileBounds(key.first, key.second);
-    gfx::RectF layer_content_rect = gfx::ScaleRect(
-        tile_bound,
-        layer_content_scale_x / contents_scale_,
-        layer_content_scale_y / contents_scale_);
-    gfx::RectF screen_rect = MathUtil::mapClippedRect(
-        current_screen_transform, layer_content_rect);
-    gfx::RectF previous_rect = MathUtil::mapClippedRect(
-        last_screen_transform, layer_content_rect);
+    working_rect.Inset((left_complete ? 0 : -offset_for_each_edge),
+                       (top_complete ? 0 : -offset_for_each_edge),
+                       (right_complete ? 0 : -offset_for_each_edge),
+                       (bottom_complete ? 0 : -offset_for_each_edge));
 
-    priority.resolution = HIGH_RESOLUTION;
-    priority.time_to_visible_in_seconds =
-        TilePriority::TimeForBoundsToIntersect(
-            previous_rect, screen_rect, time_delta, view_rect);
+    if (bounding_rect.Contains(working_rect))
+      return working_rect;
+    working_rect.Intersect(bounding_rect);
 
-    priority.distance_to_visible_in_pixels =
-        TilePriority::manhattanDistance(screen_rect, view_rect);
-    // TODO(qinmin): pass the correct tree to this function.
-    it->second->set_priority(ACTIVE_TREE, priority);
+    if (working_rect.x() == bounding_rect.x()) left_complete = true;
+    if (working_rect.y() == bounding_rect.y()) top_complete = true;
+    if (working_rect.right() == bounding_rect.right()) right_complete = true;
+    if (working_rect.bottom() == bounding_rect.bottom()) bottom_complete = true;
+
+    num_edges_complete = (left_complete ? 1 : 0) +
+                         (top_complete ? 1 : 0) +
+                         (right_complete ? 1 : 0) +
+                         (bottom_complete ? 1 : 0);
+    if (num_edges_complete == 4)
+      return working_rect;
   }
+
+  NOTREACHED();
+  return starting_rect;
 }
 
 }  // namespace cc
Index: src/cc/layer_tree_impl.h
===================================================================
--- src/cc/layer_tree_impl.h	(revision 184497)
+++ src/cc/layer_tree_impl.h	(working copy)
@@ -28,12 +28,18 @@
 class LayerTreeHostImpl;
 class LayerTreeImpl;
 class LayerTreeSettings;
+class MemoryHistory;
 class OutputSurface;
+class PaintTimeCounter;
+class Proxy;
 class ResourceProvider;
 class TileManager;
+struct RendererCapabilities;
 
 class CC_EXPORT LayerTreeImpl {
  public:
+  typedef std::vector<LayerImpl*> LayerList;
+
   static scoped_ptr<LayerTreeImpl> create(LayerTreeHostImpl* layer_tree_host_impl)
   {
     return make_scoped_ptr(new LayerTreeImpl(layer_tree_host_impl));
@@ -43,19 +49,25 @@
   // Methods called by the layer tree that pass-through or access LTHI.
   // ---------------------------------------------------------------------------
   const LayerTreeSettings& settings() const;
+  const RendererCapabilities& rendererCapabilities() const;
   OutputSurface* output_surface() const;
   ResourceProvider* resource_provider() const;
   TileManager* tile_manager() const;
   FrameRateCounter* frame_rate_counter() const;
+  PaintTimeCounter* paint_time_counter() const;
+  MemoryHistory* memory_history() const;
   bool IsActiveTree() const;
   bool IsPendingTree() const;
+  bool IsRecycleTree() const;
   LayerImpl* FindActiveTreeLayerById(int id);
   LayerImpl* FindPendingTreeLayerById(int id);
+  int MaxTextureSize() const;
+  bool PinchGestureActive() const;
+  base::TimeTicks CurrentFrameTime() const;
 
   // Tree specific methods exposed to layer-impl tree.
   // ---------------------------------------------------------------------------
   void SetNeedsRedraw();
-  void SetNeedsUpdateDrawProperties();
 
   // TODO(nduca): These are implemented in cc files temporarily, but will become
   // trivial accessors in a followup patch.
@@ -72,26 +84,110 @@
   void SetRootLayer(scoped_ptr<LayerImpl>);
   scoped_ptr<LayerImpl> DetachLayerTree();
 
+  void pushPropertiesTo(LayerTreeImpl*);
+
   int source_frame_number() const { return source_frame_number_; }
-  void set_source_frame_number(int frame_number) { source_frame_number_ = frame_number; }
+  void set_source_frame_number(int frame_number) {
+    source_frame_number_ = frame_number;
+  }
 
   HeadsUpDisplayLayerImpl* hud_layer() { return hud_layer_; }
-  void set_hud_layer(HeadsUpDisplayLayerImpl* layer_impl) { hud_layer_ = layer_impl; }
+  void set_hud_layer(HeadsUpDisplayLayerImpl* layer_impl) {
+    hud_layer_ = layer_impl;
+  }
 
-  LayerImpl* root_scroll_layer() { return root_scroll_layer_; }
-  void set_root_scroll_layer(LayerImpl* layer_impl) { root_scroll_layer_ = layer_impl; }
+  LayerImpl* RootScrollLayer();
+  LayerImpl* CurrentlyScrollingLayer();
+  void set_currently_scrolling_layer(LayerImpl* layer) {
+    currently_scrolling_layer_ = layer;
+  }
 
-  LayerImpl* currently_scrolling_layer() { return currently_scrolling_layer_; }
-  void set_currently_scrolling_layer(LayerImpl* layer_impl) { currently_scrolling_layer_ = layer_impl; }
-
   void ClearCurrentlyScrollingLayer();
 
+  void FindRootScrollLayer();
+  void UpdateMaxScrollOffset();
+
+  SkColor background_color() const { return background_color_; }
+  void set_background_color(SkColor color) { background_color_ = color; }
+
+  bool has_transparent_background() const {
+    return has_transparent_background_;
+  }
+  void set_has_transparent_background(bool transparent) {
+    has_transparent_background_ = transparent;
+  }
+
+  enum UpdateDrawPropertiesReason {
+    UPDATE_PENDING_TREE,
+    UPDATE_ACTIVE_TREE,
+    UPDATE_ACTIVE_TREE_FOR_DRAW
+  };
+
+  gfx::Transform ImplTransform() const;
+
+  void SetPageScaleFactorAndLimits(float page_scale_factor,
+      float min_page_scale_factor, float max_page_scale_factor);
+  void SetPageScaleDelta(float delta);
+  float total_page_scale_factor() const {
+    return page_scale_factor_ * page_scale_delta_;
+  }
+  float page_scale_factor() const { return page_scale_factor_; }
+  float min_page_scale_factor() const { return min_page_scale_factor_; }
+  float max_page_scale_factor() const { return max_page_scale_factor_; }
+  float page_scale_delta() const  { return page_scale_delta_; }
+  void set_sent_page_scale_delta(float delta) {
+    sent_page_scale_delta_ = delta;
+  }
+  float sent_page_scale_delta() const { return sent_page_scale_delta_; }
+
+  // Updates draw properties and render surface layer list
+  void UpdateDrawProperties(UpdateDrawPropertiesReason reason);
+  void set_needs_update_draw_properties() {
+    needs_update_draw_properties_ = true;
+  }
+  bool needs_update_draw_properties() const {
+    return needs_update_draw_properties_;
+  }
+
+  void set_needs_full_tree_sync(bool needs) { needs_full_tree_sync_ = needs; }
+  bool needs_full_tree_sync() const { return needs_full_tree_sync_; }
+
+  void ClearRenderSurfaces();
+
+  bool AreVisibleResourcesReady() const;
+
+  const LayerList& RenderSurfaceLayerList() const;
+
+  // These return the size of the root scrollable area and the size of
+  // the user-visible scrolling viewport, in CSS layout coordinates.
+  gfx::Size ScrollableSize() const;
+  gfx::SizeF ScrollableViewportSize() const;
+
   LayerImpl* LayerById(int id);
 
   // These should be called by LayerImpl's ctor/dtor.
   void RegisterLayer(LayerImpl* layer);
   void UnregisterLayer(LayerImpl* layer);
 
+  AnimationRegistrar* animationRegistrar() const;
+
+  void PushPersistedState(LayerTreeImpl* pendingTree);
+
+  void DidBecomeActive();
+
+  bool ContentsTexturesPurged() const;
+  void SetContentsTexturesPurged();
+  void ResetContentsTexturesPurged();
+
+  // Set on the active tree when the viewport size recently changed
+  // and the active tree's size is now out of date.
+  bool ViewportSizeInvalid() const;
+  void SetViewportSizeInvalid();
+  void ResetViewportSizeInvalid();
+
+  // Useful for debug assertions, probably shouldn't be used for anything else.
+  Proxy* proxy() const;
+
 protected:
   LayerTreeImpl(LayerTreeHostImpl* layer_tree_host_impl);
 
@@ -101,13 +197,33 @@
   HeadsUpDisplayLayerImpl* hud_layer_;
   LayerImpl* root_scroll_layer_;
   LayerImpl* currently_scrolling_layer_;
+  SkColor background_color_;
+  bool has_transparent_background_;
 
+  float page_scale_factor_;
+  float page_scale_delta_;
+  float sent_page_scale_delta_;
+  float min_page_scale_factor_;
+  float max_page_scale_factor_;
+
   typedef base::hash_map<int, LayerImpl*> LayerIdMap;
   LayerIdMap layer_id_map_;
 
-  // Persisted state
+  // Persisted state for non-impl-side-painting.
   int scrolling_layer_id_from_previous_tree_;
 
+  // List of visible layers for the most recently prepared frame. Used for
+  // rendering and input event hit testing.
+  LayerList render_surface_layer_list_;
+
+  bool contents_textures_purged_;
+  bool viewport_size_invalid_;
+  bool needs_update_draw_properties_;
+
+  // In impl-side painting mode, this is true when the tree may contain
+  // structural differences relative to the active tree.
+  bool needs_full_tree_sync_;
+
   DISALLOW_COPY_AND_ASSIGN(LayerTreeImpl);
 };
 
Index: src/cc/scrollbar_geometry_fixed_thumb.h
===================================================================
--- src/cc/scrollbar_geometry_fixed_thumb.h	(revision 184497)
+++ src/cc/scrollbar_geometry_fixed_thumb.h	(working copy)
@@ -20,8 +20,7 @@
     static scoped_ptr<ScrollbarGeometryFixedThumb> create(scoped_ptr<WebKit::WebScrollbarThemeGeometry>);
     virtual ~ScrollbarGeometryFixedThumb();
 
-    // Update thumb length from scrollbar
-    void update(WebKit::WebScrollbar*);
+    void setThumbSize(gfx::Size size) { m_thumbSize = size; }
 
     // WebScrollbarThemeGeometry interface
     virtual WebKit::WebScrollbarThemeGeometry* clone() const OVERRIDE;
Index: src/cc/software_renderer_unittest.cc
===================================================================
--- src/cc/software_renderer_unittest.cc	(revision 184497)
+++ src/cc/software_renderer_unittest.cc	(working copy)
@@ -78,7 +78,7 @@
     initializeRenderer();
 
     scoped_ptr<SharedQuadState> sharedQuadState = SharedQuadState::Create();
-    sharedQuadState->SetAll(gfx::Transform(), outerRect, outerRect, outerRect, false, 1.0);
+    sharedQuadState->SetAll(gfx::Transform(), outerRect, outerRect, false, 1.0);
     RenderPass::Id rootRenderPassId = RenderPass::Id(1, 1);
     scoped_ptr<TestRenderPass> rootRenderPass = TestRenderPass::Create();
     rootRenderPass->SetNew(rootRenderPassId, outerRect, gfx::Rect(), gfx::Transform());
@@ -90,10 +90,8 @@
     rootRenderPass->AppendQuad(outerQuad.PassAs<DrawQuad>());
 
     RenderPassList list;
-    RenderPassIdHashMap hashmap;
-    list.push_back(rootRenderPass.get());
-    hashmap.add(rootRenderPassId, rootRenderPass.PassAs<RenderPass>());
-    renderer()->drawFrame(list, hashmap);
+    list.push_back(rootRenderPass.PassAs<RenderPass>());
+    renderer()->drawFrame(list);
 
     scoped_array<SkColor> pixels(new SkColor[deviceViewportSize().width() * deviceViewportSize().height()]);
     renderer()->getFramebufferPixels(pixels.get(), outerRect);
@@ -139,7 +137,7 @@
     gfx::Rect rect = gfx::Rect(gfx::Point(), deviceViewportSize());
 
     scoped_ptr<SharedQuadState> sharedQuadState = SharedQuadState::Create();
-    sharedQuadState->SetAll(gfx::Transform(), outerRect, outerRect, outerRect, false, 1.0);
+    sharedQuadState->SetAll(gfx::Transform(), outerRect, outerRect, false, 1.0);
     RenderPass::Id rootRenderPassId = RenderPass::Id(1, 1);
     scoped_ptr<TestRenderPass> rootRenderPass = TestRenderPass::Create();
     rootRenderPass->SetNew(rootRenderPassId, gfx::Rect(gfx::Point(), deviceViewportSize()), gfx::Rect(), gfx::Transform());
@@ -151,10 +149,8 @@
     rootRenderPass->AppendQuad(outerQuad.PassAs<DrawQuad>());
 
     RenderPassList list;
-    RenderPassIdHashMap hashmap;
-    list.push_back(rootRenderPass.get());
-    hashmap.add(rootRenderPassId, rootRenderPass.PassAs<RenderPass>());
-    renderer()->drawFrame(list, hashmap);
+    list.push_back(rootRenderPass.PassAs<RenderPass>());
+    renderer()->drawFrame(list);
 
     scoped_array<SkColor> pixels(new SkColor[deviceViewportSize().width() * deviceViewportSize().height()]);
     renderer()->getFramebufferPixels(pixels.get(), outerRect);
@@ -174,41 +170,31 @@
     initializeRenderer();
 
     RenderPassList list;
-    RenderPassIdHashMap hashmap;
-    ScopedPtrVector<RenderPass> renderPasses;
     scoped_array<SkColor> pixels(new SkColor[viewportPixels]);
 
     // Draw a fullscreen green quad in a first frame.
     RenderPass::Id rootClearPassId(1, 0);
-    TestRenderPass* rootClearPass = addRenderPass(renderPasses, rootClearPassId, viewportRect, gfx::Transform());
+    TestRenderPass* rootClearPass = addRenderPass(list, rootClearPassId, viewportRect, gfx::Transform());
     addQuad(rootClearPass, viewportRect, SK_ColorGREEN);
 
-    list.push_back(rootClearPass);
-    hashmap.set(rootClearPassId, renderPasses.take(0));
-
     renderer()->decideRenderPassAllocationsForFrame(list);
-    renderer()->drawFrame(list, hashmap);
+    renderer()->drawFrame(list);
     renderer()->getFramebufferPixels(pixels.get(), viewportRect);
 
     EXPECT_EQ(SK_ColorGREEN, pixels[0]);
     EXPECT_EQ(SK_ColorGREEN, pixels[viewportPixels - 1]);
 
-    renderPasses.clear();
-    hashmap.clear();
     list.clear();
 
     // Draw a smaller magenta rect without filling the viewport in a separate frame.
     gfx::Rect smallerRect(20, 20, 60, 60);
 
     RenderPass::Id rootSmallerPassId(2, 0);
-    TestRenderPass* rootSmallerPass = addRenderPass(renderPasses, rootSmallerPassId, viewportRect, gfx::Transform());
+    TestRenderPass* rootSmallerPass = addRenderPass(list, rootSmallerPassId, viewportRect, gfx::Transform());
     addQuad(rootSmallerPass, smallerRect, SK_ColorMAGENTA);
 
-    list.push_back(rootSmallerPass);
-    hashmap.set(rootSmallerPassId, renderPasses.take(0));
-
     renderer()->decideRenderPassAllocationsForFrame(list);
-    renderer()->drawFrame(list, hashmap);
+    renderer()->drawFrame(list);
     renderer()->getFramebufferPixels(pixels.get(), viewportRect);
 
     // If we didn't clear, the borders should still be green.
Index: src/cc/bitmap_skpicture_content_layer_updater.cc
===================================================================
--- src/cc/bitmap_skpicture_content_layer_updater.cc	(revision 184497)
+++ src/cc/bitmap_skpicture_content_layer_updater.cc	(working copy)
@@ -6,6 +6,7 @@
 
 #include "base/time.h"
 #include "cc/layer_painter.h"
+#include "cc/prioritized_resource.h"
 #include "cc/rendering_stats.h"
 #include "cc/resource_update_queue.h"
 #include "third_party/skia/include/core/SkCanvas.h"
@@ -28,7 +29,7 @@
     SkCanvas canvas(&device);
     base::TimeTicks paintBeginTime = base::TimeTicks::Now();
     updater()->paintContentsRect(&canvas, sourceRect, stats);
-    stats.totalPaintTimeInSeconds += (base::TimeTicks::Now() - paintBeginTime).InSecondsF();
+    stats.totalPaintTime += base::TimeTicks::Now() - paintBeginTime;
 
     ResourceUpdate upload = ResourceUpdate::Create(
         texture(), &m_bitmap, sourceRect, sourceRect, destOffset);
@@ -64,7 +65,7 @@
                       contentRect().y() - sourceRect.y());
     base::TimeTicks rasterizeBeginTime = base::TimeTicks::Now();
     drawPicture(canvas);
-    stats.totalRasterizeTimeInSeconds += (base::TimeTicks::Now() - rasterizeBeginTime).InSecondsF();
+    stats.totalRasterizeTime += base::TimeTicks::Now() - rasterizeBeginTime;
     stats.totalPixelsRasterized += sourceRect.width() * sourceRect.height();
 }
 
Index: src/cc/delegated_frame_data.h
===================================================================
--- src/cc/delegated_frame_data.h	(revision 184497)
+++ src/cc/delegated_frame_data.h	(working copy)
@@ -18,6 +18,7 @@
   DelegatedFrameData();
   ~DelegatedFrameData();
 
+  // TODO(danakj): This is redundant with the root render pass outputRect.
   gfx::Size size;
   TransferableResourceList resource_list;
   ScopedPtrVector<RenderPass> render_pass_list;
Index: src/cc/scrollbar_animation_controller.h
===================================================================
--- src/cc/scrollbar_animation_controller.h	(revision 184497)
+++ src/cc/scrollbar_animation_controller.h	(working copy)
@@ -5,59 +5,22 @@
 #ifndef CC_SCROLLBAR_ANIMATION_CONTROLLER_H_
 #define CC_SCROLLBAR_ANIMATION_CONTROLLER_H_
 
-#include "base/memory/scoped_ptr.h"
+#include "base/time.h"
 #include "cc/cc_export.h"
-#include "ui/gfx/size.h"
-#include "ui/gfx/vector2d.h"
 #include "ui/gfx/vector2d_f.h"
 
 namespace cc {
 
-class LayerImpl;
-class ScrollbarLayerImpl;
-
 // This abstract class represents the compositor-side analogy of ScrollbarAnimator.
 // Individual platforms should subclass it to provide specialized implementation.
 class CC_EXPORT ScrollbarAnimationController {
 public:
-    static scoped_ptr<ScrollbarAnimationController> create(LayerImpl* scrollLayer);
+    virtual ~ScrollbarAnimationController() {}
 
-    virtual ~ScrollbarAnimationController();
-
-    virtual bool animate(double monotonicTime);
-    void didPinchGestureBegin();
-    void didPinchGestureUpdate();
-    void didPinchGestureEnd();
-    void updateScrollOffset(LayerImpl* scrollLayer);
-
-    void setHorizontalScrollbarLayer(ScrollbarLayerImpl* layer) { m_horizontalScrollbarLayer = layer; }
-    ScrollbarLayerImpl* horizontalScrollbarLayer() const { return m_horizontalScrollbarLayer; }
-
-    void setVerticalScrollbarLayer(ScrollbarLayerImpl* layer) { m_verticalScrollbarLayer = layer; }
-    ScrollbarLayerImpl* verticalScrollbarLayer() const { return m_verticalScrollbarLayer; }
-
-    gfx::Vector2dF currentOffset() const { return m_currentOffset; }
-    gfx::Size totalSize() const { return m_totalSize; }
-    gfx::Vector2d maximum() const { return m_maximum; }
-
-    virtual void didPinchGestureBeginAtTime(double monotonicTime) { }
-    virtual void didPinchGestureUpdateAtTime(double monotonicTime) { }
-    virtual void didPinchGestureEndAtTime(double monotonicTime) { }
-    virtual void updateScrollOffsetAtTime(LayerImpl* scrollLayer, double monotonicTime);
-
-protected:
-    explicit ScrollbarAnimationController(LayerImpl* scrollLayer);
-
-private:
-    static gfx::Size getScrollLayerBounds(const LayerImpl*);
-
-    // Beware of dangling pointer. Always update these during tree synchronization.
-    ScrollbarLayerImpl* m_horizontalScrollbarLayer;
-    ScrollbarLayerImpl* m_verticalScrollbarLayer;
-
-    gfx::Vector2dF m_currentOffset;
-    gfx::Size m_totalSize;
-    gfx::Vector2d m_maximum;
+    virtual bool animate(base::TimeTicks) = 0;
+    virtual void didPinchGestureUpdate(base::TimeTicks) = 0;
+    virtual void didPinchGestureEnd(base::TimeTicks) = 0;
+    virtual void didUpdateScrollOffset(base::TimeTicks) = 0;
 };
 
 } // namespace cc
Index: src/cc/io_surface_layer_impl.h
===================================================================
--- src/cc/io_surface_layer_impl.h	(revision 184497)
+++ src/cc/io_surface_layer_impl.h	(working copy)
@@ -21,6 +21,9 @@
 
     void setIOSurfaceProperties(unsigned ioSurfaceId, const gfx::Size&);
 
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* treeImpl) OVERRIDE;
+    virtual void pushPropertiesTo(LayerImpl*) OVERRIDE;
+
     virtual void appendQuads(QuadSink&, AppendQuadsData&) OVERRIDE;
 
     virtual void willDraw(ResourceProvider*) OVERRIDE;
Index: src/cc/layer_impl.h
===================================================================
--- src/cc/layer_impl.h	(revision 184497)
+++ src/cc/layer_impl.h	(working copy)
@@ -5,7 +5,6 @@
 #ifndef CC_LAYER_IMPL_H_
 #define CC_LAYER_IMPL_H_
 
-#include <public/WebFilterOperations.h>
 #include <string>
 
 #include "base/logging.h"
@@ -14,6 +13,7 @@
 #include "cc/draw_properties.h"
 #include "cc/input_handler.h"
 #include "cc/layer_animation_controller.h"
+#include "cc/layer_animation_value_observer.h"
 #include "cc/region.h"
 #include "cc/render_pass.h"
 #include "cc/render_surface_impl.h"
@@ -21,8 +21,10 @@
 #include "cc/scoped_ptr_vector.h"
 #include "cc/shared_quad_state.h"
 #include "skia/ext/refptr.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFilterOperations.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkImageFilter.h"
+#include "third_party/skia/include/core/SkPicture.h"
 #include "ui/gfx/rect.h"
 #include "ui/gfx/rect_f.h"
 #include "ui/gfx/transform.h"
@@ -43,7 +45,7 @@
 
 struct AppendQuadsData;
 
-class CC_EXPORT LayerImpl : public LayerAnimationControllerClient {
+class CC_EXPORT LayerImpl : LayerAnimationValueObserver {
 public:
     typedef ScopedPtrVector<LayerImpl> LayerList;
 
@@ -54,28 +56,34 @@
 
     virtual ~LayerImpl();
 
-    // LayerAnimationControllerClient implementation.
-    virtual int id() const OVERRIDE;
-    virtual void setOpacityFromAnimation(float) OVERRIDE;
-    virtual float opacity() const OVERRIDE;
-    virtual void setTransformFromAnimation(const gfx::Transform&) OVERRIDE;
-    virtual const gfx::Transform& transform() const OVERRIDE;
+    int id() const;
 
+    // LayerAnimationValueObserver implementation.
+    virtual void OnOpacityAnimated(float) OVERRIDE;
+    virtual void OnTransformAnimated(const gfx::Transform&) OVERRIDE;
+    virtual bool IsActive() const OVERRIDE;
+
     // Tree structure.
     LayerImpl* parent() { return m_parent; }
     const LayerImpl* parent() const { return m_parent; }
     const LayerList& children() const { return m_children; }
+    LayerList& children() { return m_children; }
+    LayerImpl* childAt(size_t index) const;
     void addChild(scoped_ptr<LayerImpl>);
     scoped_ptr<LayerImpl> removeChild(LayerImpl* child);
     void removeAllChildren();
+    void setParent(LayerImpl* parent) { m_parent = parent; }
+    void clearChildList(); // Warning: This does not preserve tree structure invariants.
 
     void setMaskLayer(scoped_ptr<LayerImpl>);
     LayerImpl* maskLayer() { return m_maskLayer.get(); }
     const LayerImpl* maskLayer() const { return m_maskLayer.get(); }
+    scoped_ptr<LayerImpl> takeMaskLayer();
 
     void setReplicaLayer(scoped_ptr<LayerImpl>);
     LayerImpl* replicaLayer() { return m_replicaLayer.get(); }
     const LayerImpl* replicaLayer() const { return m_replicaLayer.get(); }
+    scoped_ptr<LayerImpl> takeReplicaLayer();
 
     bool hasMask() const { return m_maskLayer; }
     bool hasReplica() const { return m_replicaLayer; }
@@ -99,6 +107,10 @@
     virtual RenderPass::Id firstContributingRenderPassId() const;
     virtual RenderPass::Id nextContributingRenderPassId(RenderPass::Id) const;
 
+    virtual void updateTilePriorities() { }
+
+    virtual ScrollbarLayerImpl* toScrollbarLayer();
+
     // Returns true if this layer has content to draw.
     void setDrawsContent(bool);
     bool drawsContent() const { return m_drawsContent; }
@@ -131,6 +143,7 @@
     bool contentsOpaque() const { return m_contentsOpaque; }
 
     void setOpacity(float);
+    float opacity() const;
     bool opacityIsAnimating() const;
 
     void setPosition(const gfx::PointF&);
@@ -197,6 +210,13 @@
     float contentsScaleY() const { return m_drawProperties.contents_scale_y; }
     void setContentsScale(float contentsScaleX, float contentsScaleY);
 
+    virtual void calculateContentsScale(
+        float idealContentsScale,
+        bool animatingTransformToScreen,
+        float* contentsScaleX,
+        float* contentsScaleY,
+        gfx::Size* contentBounds);
+
     gfx::Vector2d scrollOffset() const { return m_scrollOffset; }
     void setScrollOffset(gfx::Vector2d);
 
@@ -210,7 +230,7 @@
     void setImplTransform(const gfx::Transform& transform);
 
     const gfx::Vector2d& sentScrollDelta() const { return m_sentScrollDelta; }
-    void setSentScrollDelta(const gfx::Vector2d& sentScrollDelta) { m_sentScrollDelta = sentScrollDelta; }
+    void setSentScrollDelta(const gfx::Vector2d& sentScrollDelta);
 
     // Returns the delta of the scroll that was outside of the bounds of the initial scroll
     gfx::Vector2dF scrollBy(const gfx::Vector2dF& scroll);
@@ -239,6 +259,7 @@
     void setDoubleSided(bool);
 
     void setTransform(const gfx::Transform&);
+    const gfx::Transform& transform() const;
     bool transformIsAnimating() const;
 
     const gfx::RectF& updateRect() const { return m_updateRect; }
@@ -260,7 +281,7 @@
 
     virtual Region visibleContentOpaqueRegion() const;
 
-    virtual void didUpdateTransforms() { }
+    virtual void didBecomeActive();
 
     // Indicates that the surface previously used to render this layer
     // was lost and that a new one has been created. Won't be called
@@ -269,16 +290,25 @@
 
     ScrollbarAnimationController* scrollbarAnimationController() const { return m_scrollbarAnimationController.get(); }
 
+    void setScrollbarOpacity(float opacity);
+
     void setHorizontalScrollbarLayer(ScrollbarLayerImpl*);
-    ScrollbarLayerImpl* horizontalScrollbarLayer();
-    const ScrollbarLayerImpl* horizontalScrollbarLayer() const;
+    ScrollbarLayerImpl* horizontalScrollbarLayer() { return m_horizontalScrollbarLayer; }
 
     void setVerticalScrollbarLayer(ScrollbarLayerImpl*);
-    ScrollbarLayerImpl* verticalScrollbarLayer();
-    const ScrollbarLayerImpl* verticalScrollbarLayer() const;
+    ScrollbarLayerImpl* verticalScrollbarLayer() { return m_verticalScrollbarLayer; }
 
     gfx::Rect layerRectToContentRect(const gfx::RectF& layerRect) const;
 
+    virtual skia::RefPtr<SkPicture> getPicture();
+
+    virtual bool canClipSelf() const;
+
+    virtual bool areVisibleResourcesReady() const;
+
+    virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl*);
+    virtual void pushPropertiesTo(LayerImpl*);
+
 protected:
     LayerImpl(LayerTreeImpl* layerImpl, int);
 
@@ -291,13 +321,8 @@
     static std::string indentString(int indent);
 
 private:
-    scoped_ptr<LayerImpl> takeMaskLayer();
-    scoped_ptr<LayerImpl> takeReplicaLayer();
+    void updateScrollbarPositions();
 
-    void setParent(LayerImpl* parent) { m_parent = parent; }
-    friend class TreeSynchronizer;
-    void clearChildList(); // Warning: This does not preserve tree structure invariants and so is only exposed to the tree synchronizer.
-
     void noteLayerSurfacePropertyChanged();
     void noteLayerPropertyChanged();
     void noteLayerPropertyChangedForSubtree();
@@ -331,6 +356,7 @@
     Region m_nonFastScrollableRegion;
     Region m_touchEventHandlerRegion;
     SkColor m_backgroundColor;
+    bool m_stackingOrderChanged;
 
     // Whether the "back" of this layer should draw.
     bool m_doubleSided;
@@ -366,6 +392,7 @@
     gfx::Vector2d m_sentScrollDelta;
     gfx::Vector2d m_maxScrollOffset;
     gfx::Transform m_implTransform;
+    gfx::Vector2dF m_lastScrollOffset;
 
     // The global depth value of the center of the layer. This value is used
     // to sort layers from back to front.
@@ -388,11 +415,16 @@
     gfx::RectF m_updateRect;
 
     // Manages animations for this layer.
-    scoped_ptr<LayerAnimationController> m_layerAnimationController;
+    scoped_refptr<LayerAnimationController> m_layerAnimationController;
 
     // Manages scrollbars for this layer
     scoped_ptr<ScrollbarAnimationController> m_scrollbarAnimationController;
 
+    // Weak pointers to this layer's scrollbars, if it has them. Updated during
+    // tree synchronization.
+    ScrollbarLayerImpl* m_horizontalScrollbarLayer;
+    ScrollbarLayerImpl* m_verticalScrollbarLayer;
+
     // Group of properties that need to be computed based on the layer tree
     // hierarchy before layers can be drawn.
     DrawProperties<LayerImpl, RenderSurfaceImpl> m_drawProperties;
Index: src/cc/texture_copier.cc
===================================================================
--- src/cc/texture_copier.cc	(revision 184497)
+++ src/cc/texture_copier.cc	(working copy)
@@ -7,8 +7,8 @@
 #include "base/debug/trace_event.h"
 #include "build/build_config.h"
 #include "cc/gl_renderer.h" // For the GLC() macro.
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
-#include <public/WebGraphicsContext3D.h>
 
 namespace cc {
 
Index: src/cc/program_binding.cc
===================================================================
--- src/cc/program_binding.cc	(revision 184497)
+++ src/cc/program_binding.cc	(working copy)
@@ -7,8 +7,8 @@
 #include "base/debug/trace_event.h"
 #include "cc/geometry_binding.h"
 #include "cc/gl_renderer.h" // For the GLC() macro.
+#include "third_party/WebKit/Source/Platform/chromium/public/WebGraphicsContext3D.h"
 #include "third_party/khronos/GLES2/gl2.h"
-#include <public/WebGraphicsContext3D.h>
 
 using WebKit::WebGraphicsContext3D;
 
Index: src/cc/managed_memory_policy.cc
===================================================================
--- src/cc/managed_memory_policy.cc	(revision 184497)
+++ src/cc/managed_memory_policy.cc	(working copy)
@@ -4,22 +4,23 @@
 
 #include "managed_memory_policy.h"
 
+#include "base/logging.h"
 #include "priority_calculator.h"
 
 namespace cc {
 
 ManagedMemoryPolicy::ManagedMemoryPolicy(size_t bytesLimitWhenVisible)
     : bytesLimitWhenVisible(bytesLimitWhenVisible)
-    , priorityCutoffWhenVisible(PriorityCalculator::allowEverythingCutoff())
+    , priorityCutoffWhenVisible(CUTOFF_ALLOW_EVERYTHING)
     , bytesLimitWhenNotVisible(0)
-    , priorityCutoffWhenNotVisible(PriorityCalculator::allowNothingCutoff())
+    , priorityCutoffWhenNotVisible(CUTOFF_ALLOW_NOTHING)
 {
 }
 
 ManagedMemoryPolicy::ManagedMemoryPolicy(size_t bytesLimitWhenVisible,
-                                         int priorityCutoffWhenVisible,
+                                         PriorityCutoff priorityCutoffWhenVisible,
                                          size_t bytesLimitWhenNotVisible,
-                                         int priorityCutoffWhenNotVisible)
+                                         PriorityCutoff priorityCutoffWhenNotVisible)
     : bytesLimitWhenVisible(bytesLimitWhenVisible)
     , priorityCutoffWhenVisible(priorityCutoffWhenVisible)
     , bytesLimitWhenNotVisible(bytesLimitWhenNotVisible)
@@ -40,4 +41,38 @@
     return !(*this == other);
 }
 
+// static
+int ManagedMemoryPolicy::priorityCutoffToValue(PriorityCutoff priorityCutoff)
+{
+    switch (priorityCutoff) {
+    case CUTOFF_ALLOW_NOTHING:
+        return PriorityCalculator::allowNothingCutoff();
+    case CUTOFF_ALLOW_REQUIRED_ONLY:
+        return PriorityCalculator::allowVisibleOnlyCutoff();
+    case CUTOFF_ALLOW_NICE_TO_HAVE:
+        return PriorityCalculator::allowVisibleAndNearbyCutoff();
+    case CUTOFF_ALLOW_EVERYTHING:
+        return PriorityCalculator::allowEverythingCutoff();
+    }
+    NOTREACHED();
+    return PriorityCalculator::allowNothingCutoff();
+}
+
+// static
+TileMemoryLimitPolicy ManagedMemoryPolicy::priorityCutoffToTileMemoryLimitPolicy(PriorityCutoff priorityCutoff)
+{
+    switch (priorityCutoff) {
+    case CUTOFF_ALLOW_NOTHING:
+        return ALLOW_NOTHING;
+    case CUTOFF_ALLOW_REQUIRED_ONLY:
+        return ALLOW_ABSOLUTE_MINIMUM;
+    case CUTOFF_ALLOW_NICE_TO_HAVE:
+        return ALLOW_PREPAINT_ONLY;
+    case CUTOFF_ALLOW_EVERYTHING:
+        return ALLOW_ANYTHING;
+    }
+    NOTREACHED();
+    return ALLOW_NOTHING;
+}
+
 }  // namespace cc
Index: src/cc/caching_bitmap_content_layer_updater.h
===================================================================
--- src/cc/caching_bitmap_content_layer_updater.h	(revision 184497)
+++ src/cc/caching_bitmap_content_layer_updater.h	(working copy)
@@ -7,6 +7,7 @@
 
 #include "base/compiler_specific.h"
 #include "cc/bitmap_content_layer_updater.h"
+#include "third_party/skia/include/core/SkBitmap.h"
 
 namespace cc {
 
Index: src/skia/skia.gyp
===================================================================
--- src/skia/skia.gyp	(revision 184497)
+++ src/skia/skia.gyp	(working copy)
@@ -88,8 +88,6 @@
         '../third_party/skia/src/pdf/SkPDFUtils.h',
 
         '../third_party/skia/src/ports/FontHostConfiguration_android.cpp',
-        '../third_party/skia/src/ports/SkFontDescriptor.cpp',
-        '../third_party/skia/src/ports/SkFontDescriptor.h',
         #'../third_party/skia/src/ports/SkFontHost_FONTPATH.cpp',
         '../third_party/skia/src/ports/SkFontHost_FreeType.cpp',
         '../third_party/skia/src/ports/SkFontHost_FreeType_common.cpp',
@@ -231,6 +229,10 @@
         # Temporarily keep old int-srcrect behavior, until we determine if
         # the few failures are a bug or not.
         'SK_SUPPORT_INT_SRCRECT_DRAWBITMAPRECT',
+
+        # Disable this check because it is too strict for some Chromium-specific
+        # subclasses of SkPixelRef. See bug: crbug.com/171776.
+        'SK_DISABLE_PIXELREF_LOCKCOUNT_BALANCE_CHECK',
       ],
       'sources!': [
         '../third_party/skia/include/core/SkTypes.h',
Index: src/skia/ext/image_operations.cc
===================================================================
--- src/skia/ext/image_operations.cc	(revision 184497)
+++ src/skia/ext/image_operations.cc	(working copy)
@@ -18,7 +18,6 @@
 #include "build/build_config.h"
 #include "skia/ext/convolver.h"
 #include "third_party/skia/include/core/SkColorPriv.h"
-#include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkRect.h"
 #include "third_party/skia/include/core/SkFontHost.h"
 
@@ -344,17 +343,22 @@
 SkBitmap ImageOperations::Resize(const SkBitmap& source,
                                  ResizeMethod method,
                                  int dest_width, int dest_height,
-                                 const SkIRect& dest_subset) {
-  if (method == ImageOperations::RESIZE_SUBPIXEL)
-    return ResizeSubpixel(source, dest_width, dest_height, dest_subset);
-  else
-    return ResizeBasic(source, method, dest_width, dest_height, dest_subset);
+                                 const SkIRect& dest_subset,
+                                 SkBitmap::Allocator* allocator) {
+  if (method == ImageOperations::RESIZE_SUBPIXEL) {
+    return ResizeSubpixel(source, dest_width, dest_height,
+                          dest_subset, allocator);
+  } else {
+    return ResizeBasic(source, method, dest_width, dest_height, dest_subset,
+                       allocator);
+  }
 }
 
 // static
 SkBitmap ImageOperations::ResizeSubpixel(const SkBitmap& source,
                                          int dest_width, int dest_height,
-                                         const SkIRect& dest_subset) {
+                                         const SkIRect& dest_subset,
+                                         SkBitmap::Allocator* allocator) {
   TRACE_EVENT2("skia", "ImageOperations::ResizeSubpixel",
                "src_pixels", source.width()*source.height(),
                "dst_pixels", dest_width*dest_height);
@@ -385,7 +389,7 @@
                      dest_subset.fLeft + dest_subset.width() * w,
                      dest_subset.fTop + dest_subset.height() * h };
   SkBitmap img = ResizeBasic(source, ImageOperations::RESIZE_LANCZOS3, width,
-                             height, subset);
+                             height, subset, allocator);
   const int row_words = img.rowBytes() / 4;
   if (w == 1 && h == 1)
     return img;
@@ -394,7 +398,7 @@
   SkBitmap result;
   result.setConfig(SkBitmap::kARGB_8888_Config, dest_subset.width(),
                    dest_subset.height());
-  result.allocPixels();
+  result.allocPixels(allocator, NULL);
   if (!result.readyToDraw())
     return img;
 
@@ -465,7 +469,8 @@
 SkBitmap ImageOperations::ResizeBasic(const SkBitmap& source,
                                       ResizeMethod method,
                                       int dest_width, int dest_height,
-                                      const SkIRect& dest_subset) {
+                                      const SkIRect& dest_subset,
+                                      SkBitmap::Allocator* allocator) {
   TRACE_EVENT2("skia", "ImageOperations::ResizeBasic",
                "src_pixels", source.width()*source.height(),
                "dst_pixels", dest_width*dest_height);
@@ -511,7 +516,7 @@
   SkBitmap result;
   result.setConfig(SkBitmap::kARGB_8888_Config,
                    dest_subset.width(), dest_subset.height());
-  result.allocPixels();
+  result.allocPixels(allocator, NULL);
   if (!result.readyToDraw())
     return SkBitmap();
 
@@ -533,9 +538,11 @@
 // static
 SkBitmap ImageOperations::Resize(const SkBitmap& source,
                                  ResizeMethod method,
-                                 int dest_width, int dest_height) {
+                                 int dest_width, int dest_height,
+                                 SkBitmap::Allocator* allocator) {
   SkIRect dest_subset = { 0, 0, dest_width, dest_height };
-  return Resize(source, method, dest_width, dest_height, dest_subset);
+  return Resize(source, method, dest_width, dest_height, dest_subset,
+                allocator);
 }
 
 }  // namespace skia
Index: src/skia/ext/image_operations.h
===================================================================
--- src/skia/ext/image_operations.h	(revision 184497)
+++ src/skia/ext/image_operations.h	(working copy)
@@ -5,9 +5,9 @@
 #ifndef SKIA_EXT_IMAGE_OPERATIONS_H_
 #define SKIA_EXT_IMAGE_OPERATIONS_H_
 
+#include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkTypes.h"
 
-class SkBitmap;
 struct SkIRect;
 
 namespace skia {
@@ -101,13 +101,15 @@
   static SkBitmap Resize(const SkBitmap& source,
                          ResizeMethod method,
                          int dest_width, int dest_height,
-                         const SkIRect& dest_subset);
+                         const SkIRect& dest_subset,
+                         SkBitmap::Allocator* allocator = NULL);
 
   // Alternate version for resizing and returning the entire bitmap rather than
   // a subset.
   static SkBitmap Resize(const SkBitmap& source,
                          ResizeMethod method,
-                         int dest_width, int dest_height);
+                         int dest_width, int dest_height,
+                         SkBitmap::Allocator* allocator = NULL);
 
  private:
   ImageOperations();  // Class for scoping only.
@@ -116,12 +118,14 @@
   static SkBitmap ResizeBasic(const SkBitmap& source,
                               ResizeMethod method,
                               int dest_width, int dest_height,
-                              const SkIRect& dest_subset);
+                              const SkIRect& dest_subset,
+                              SkBitmap::Allocator* allocator = NULL);
 
   // Subpixel renderer.
   static SkBitmap ResizeSubpixel(const SkBitmap& source,
                                  int dest_width, int dest_height,
-                                 const SkIRect& dest_subset);
+                                 const SkIRect& dest_subset,
+                                 SkBitmap::Allocator* allocator = NULL);
 };
 
 }  // namespace skia
Index: src/skia/ext/SkFontHost_fontconfig.cpp
===================================================================
--- src/skia/ext/SkFontHost_fontconfig.cpp	(revision 184497)
+++ src/skia/ext/SkFontHost_fontconfig.cpp	(working copy)
@@ -32,7 +32,7 @@
 #include <unistd.h>
 
 #include "base/compiler_specific.h"
-#include "third_party/skia/src/ports/SkFontDescriptor.h"
+#include "third_party/skia/src/core/SkFontDescriptor.h"
 #include "SkFontHost.h"
 #include "SkStream.h"
 #include "SkFontHost_fontconfig_control.h"
Index: src/cc/scoped_ptr_algorithm.h
===================================================================
--- src/cc/scoped_ptr_algorithm.h (revision 0)
+++ src/cc/scoped_ptr_algorithm.h (revision 0)
@@ -0,0 +1,30 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_SCOPED_PTR_ALGORITHM_H_
+#define CC_SCOPED_PTR_ALGORITHM_H_
+
+namespace cc {
+
+// ScopedContainers need to implement a swap() method since they do not allow
+// assignment to their iterators.
+template <class ForwardIterator, class Predicate, class ScopedContainer>
+ForwardIterator remove_if(
+    ScopedContainer& container,
+    ForwardIterator first,
+    ForwardIterator last,
+    Predicate predicate) {
+  ForwardIterator result = first;
+  for (; first != last; ++first) {
+    if (!predicate(*first)) {
+      container.swap(first, result);
+      ++result;
+    }
+  }
+  return result;
+}
+
+}  // namespace cc
+
+#endif  // CC_SCOPED_PTR_ALGORITHM_H_
Index: src/cc/picture_layer_impl_unittest.cc
===================================================================
--- src/cc/picture_layer_impl_unittest.cc (revision 0)
+++ src/cc/picture_layer_impl_unittest.cc (revision 0)
@@ -0,0 +1,613 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/picture_layer_impl.h"
+
+#include "cc/layer_tree_impl.h"
+#include "cc/test/fake_content_layer_client.h"
+#include "cc/test/fake_impl_proxy.h"
+#include "cc/test/fake_layer_tree_host_impl.h"
+#include "cc/test/fake_output_surface.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/rect_conversions.h"
+
+namespace cc {
+namespace {
+
+class TestablePictureLayerImpl : public PictureLayerImpl {
+ public:
+  static scoped_ptr<TestablePictureLayerImpl> create(
+      LayerTreeImpl* treeImpl,
+      int id,
+      scoped_refptr<PicturePileImpl> pile)
+  {
+    return make_scoped_ptr(new TestablePictureLayerImpl(treeImpl, id, pile));
+  }
+
+  PictureLayerTilingSet& tilings() { return *tilings_; }
+  Region& invalidation() { return invalidation_; }
+
+  virtual gfx::Size CalculateTileSize(
+      gfx::Size current_tile_size,
+      gfx::Size /* content_bounds */) OVERRIDE {
+    if (current_tile_size.IsEmpty())
+      return gfx::Size(100, 100);
+    return current_tile_size;
+  }
+
+  using PictureLayerImpl::AddTiling;
+  using PictureLayerImpl::CleanUpTilingsOnActiveLayer;
+
+ private:
+  TestablePictureLayerImpl(
+      LayerTreeImpl* treeImpl,
+      int id,
+      scoped_refptr<PicturePileImpl> pile)
+      : PictureLayerImpl(treeImpl, id) {
+    pile_ = pile;
+    setBounds(pile_->size());
+    CreateTilingSet();
+  }
+};
+
+class TestablePicturePileImpl : public PicturePileImpl {
+ public:
+  static scoped_refptr<TestablePicturePileImpl> CreateFilledPile(
+      gfx::Size tile_size,
+      gfx::Size layer_bounds) {
+    scoped_refptr<TestablePicturePileImpl> pile(new TestablePicturePileImpl());
+    pile->tiling().SetTotalSize(layer_bounds);
+    pile->tiling().SetMaxTextureSize(tile_size);
+    for (int x = 0; x < pile->tiling().num_tiles_x(); ++x) {
+      for (int y = 0; y < pile->tiling().num_tiles_y(); ++y)
+        pile->AddRecordingAt(x, y);
+    }
+    pile->UpdateRecordedRegion();
+    return pile;
+  }
+
+  static scoped_refptr<TestablePicturePileImpl> CreateEmptyPile(
+      gfx::Size tile_size,
+      gfx::Size layer_bounds) {
+    scoped_refptr<TestablePicturePileImpl> pile(new TestablePicturePileImpl());
+    pile->tiling().SetTotalSize(layer_bounds);
+    pile->tiling().SetMaxTextureSize(tile_size);
+    pile->UpdateRecordedRegion();
+    return pile;
+  }
+
+  TilingData& tiling() { return tiling_; }
+
+  void AddRecordingAt(int x, int y) {
+    EXPECT_GE(x, 0);
+    EXPECT_GE(y, 0);
+    EXPECT_LT(x, tiling_.num_tiles_x());
+    EXPECT_LT(y, tiling_.num_tiles_y());
+
+    if (HasRecordingAt(x, y))
+      return;
+    gfx::Rect bounds(tiling().TileBounds(x, y));
+    scoped_refptr<Picture> picture(Picture::Create(bounds));
+    FakeContentLayerClient client;
+    RenderingStats stats;
+    picture->Record(&client, stats);
+    picture_list_map_[std::pair<int, int>(x, y)].push_back(picture);
+    EXPECT_TRUE(HasRecordingAt(x, y));
+
+    UpdateRecordedRegion();
+  }
+
+  void RemoveRecordingAt(int x, int y) {
+    EXPECT_GE(x, 0);
+    EXPECT_GE(y, 0);
+    EXPECT_LT(x, tiling_.num_tiles_x());
+    EXPECT_LT(y, tiling_.num_tiles_y());
+
+    if (!HasRecordingAt(x, y))
+      return;
+    picture_list_map_.erase(std::pair<int, int>(x, y));
+    EXPECT_FALSE(HasRecordingAt(x, y));
+
+    UpdateRecordedRegion();
+  }
+
+ protected:
+  ~TestablePicturePileImpl() {
+  }
+};
+
+class ImplSidePaintingSettings : public LayerTreeSettings {
+ public:
+  ImplSidePaintingSettings() {
+    implSidePainting = true;
+  }
+};
+
+class PictureLayerImplTest : public testing::Test {
+ public:
+  PictureLayerImplTest()
+      : host_impl_(ImplSidePaintingSettings(), &proxy_),
+        id_(7) {
+    host_impl_.initializeRenderer(createFakeOutputSurface());
+  }
+
+  ~PictureLayerImplTest() {
+  }
+
+  void SetupTrees(
+      scoped_refptr<PicturePileImpl> pending_pile,
+      scoped_refptr<PicturePileImpl> active_pile) {
+    SetupPendingTree(active_pile);
+    host_impl_.activatePendingTree();
+
+    active_layer_ = static_cast<TestablePictureLayerImpl*>(
+        host_impl_.activeTree()->LayerById(id_));
+
+    SetupPendingTree(pending_pile);
+    pending_layer_ = static_cast<TestablePictureLayerImpl*>(
+        host_impl_.pendingTree()->LayerById(id_));
+  }
+
+  void AddDefaultTilingsWithInvalidation(const Region& invalidation) {
+    active_layer_->AddTiling(2.3f);
+    active_layer_->AddTiling(1.0f);
+    active_layer_->AddTiling(0.5f);
+    pending_layer_->invalidation() = invalidation;
+    pending_layer_->SyncFromActiveLayer();
+  }
+
+  void SetupPendingTree(
+      scoped_refptr<PicturePileImpl> pile) {
+    host_impl_.createPendingTree();
+    LayerTreeImpl* pending_tree = host_impl_.pendingTree();
+    // Clear recycled tree.
+    pending_tree->DetachLayerTree();
+
+    scoped_ptr<TestablePictureLayerImpl> pending_layer =
+        TestablePictureLayerImpl::create(pending_tree, id_, pile);
+    pending_layer->setDrawsContent(true);
+    pending_tree->SetRootLayer(pending_layer.PassAs<LayerImpl>());
+  }
+
+  static void VerifyAllTilesExistAndHavePile(
+      const PictureLayerTiling* tiling,
+      PicturePileImpl* pile) {
+    for (PictureLayerTiling::Iterator iter(tiling,
+                                           tiling->contents_scale(),
+                                           tiling->ContentRect(),
+                                           PictureLayerTiling::LayerDeviceAlignmentUnknown);
+         iter; ++iter) {
+      EXPECT_TRUE(*iter);
+      EXPECT_EQ(pile, iter->picture_pile());
+    }
+  }
+
+  void SetContentsScaleOnBothLayers(float scale, bool animating_transform) {
+    float result_scale_x, result_scale_y;
+    gfx::Size result_bounds;
+    pending_layer_->calculateContentsScale(
+        scale, animating_transform,
+        &result_scale_x, &result_scale_y, &result_bounds);
+    active_layer_->calculateContentsScale(
+        scale, animating_transform,
+        &result_scale_x, &result_scale_y, &result_bounds);
+  }
+
+ protected:
+  FakeImplProxy proxy_;
+  FakeLayerTreeHostImpl host_impl_;
+  int id_;
+  TestablePictureLayerImpl* pending_layer_;
+  TestablePictureLayerImpl* active_layer_;
+
+  DISALLOW_COPY_AND_ASSIGN(PictureLayerImplTest);
+};
+
+TEST_F(PictureLayerImplTest, cloneNoInvalidation) {
+  gfx::Size tile_size(100, 100);
+  gfx::Size layer_bounds(400, 400);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+
+  SetupTrees(pending_pile, active_pile);
+
+  Region invalidation;
+  AddDefaultTilingsWithInvalidation(invalidation);
+
+  EXPECT_EQ(pending_layer_->tilings().num_tilings(),
+            active_layer_->tilings().num_tilings());
+
+  const PictureLayerTilingSet& tilings = pending_layer_->tilings();
+  EXPECT_GT(tilings.num_tilings(), 0u);
+  for (size_t i = 0; i < tilings.num_tilings(); ++i)
+    VerifyAllTilesExistAndHavePile(tilings.tiling_at(i), active_pile.get());
+}
+
+TEST_F(PictureLayerImplTest, clonePartialInvalidation) {
+  gfx::Size tile_size(100, 100);
+  gfx::Size layer_bounds(400, 400);
+  gfx::Rect layer_invalidation(150, 200, 30, 180);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+
+  SetupTrees(pending_pile, active_pile);
+
+  Region invalidation(layer_invalidation);
+  AddDefaultTilingsWithInvalidation(invalidation);
+
+  const PictureLayerTilingSet& tilings = pending_layer_->tilings();
+  EXPECT_GT(tilings.num_tilings(), 0u);
+  for (size_t i = 0; i < tilings.num_tilings(); ++i) {
+    const PictureLayerTiling* tiling = tilings.tiling_at(i);
+    gfx::Rect content_invalidation = gfx::ToEnclosingRect(gfx::ScaleRect(
+        layer_invalidation,
+        tiling->contents_scale()));
+    for (PictureLayerTiling::Iterator iter(tiling,
+                                           tiling->contents_scale(),
+                                           tiling->ContentRect(),
+                                           PictureLayerTiling::LayerDeviceAlignmentUnknown);
+         iter; ++iter) {
+      EXPECT_TRUE(*iter);
+      EXPECT_FALSE(iter.geometry_rect().IsEmpty());
+      if (iter.geometry_rect().Intersects(content_invalidation))
+        EXPECT_EQ(pending_pile, iter->picture_pile());
+      else
+        EXPECT_EQ(active_pile, iter->picture_pile());
+    }
+  }
+}
+
+TEST_F(PictureLayerImplTest, cloneFullInvalidation) {
+  gfx::Size tile_size(90, 80);
+  gfx::Size layer_bounds(300, 500);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+
+  SetupTrees(pending_pile, active_pile);
+
+  Region invalidation((gfx::Rect(layer_bounds)));
+  AddDefaultTilingsWithInvalidation(invalidation);
+
+  EXPECT_EQ(pending_layer_->tilings().num_tilings(),
+            active_layer_->tilings().num_tilings());
+
+  const PictureLayerTilingSet& tilings = pending_layer_->tilings();
+  EXPECT_GT(tilings.num_tilings(), 0u);
+  for (size_t i = 0; i < tilings.num_tilings(); ++i)
+    VerifyAllTilesExistAndHavePile(tilings.tiling_at(i), pending_pile.get());
+}
+
+TEST_F(PictureLayerImplTest, noInvalidationBoundsChange) {
+  gfx::Size tile_size(90, 80);
+  gfx::Size active_layer_bounds(300, 500);
+  gfx::Size pending_layer_bounds(400, 800);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size,
+                                                pending_layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, active_layer_bounds);
+
+  SetupTrees(pending_pile, active_pile);
+
+  Region invalidation;
+  AddDefaultTilingsWithInvalidation(invalidation);
+
+  const PictureLayerTilingSet& tilings = pending_layer_->tilings();
+  EXPECT_GT(tilings.num_tilings(), 0u);
+  for (size_t i = 0; i < tilings.num_tilings(); ++i) {
+    const PictureLayerTiling* tiling = tilings.tiling_at(i);
+    gfx::Rect active_content_bounds = gfx::ToEnclosingRect(gfx::ScaleRect(
+        gfx::Rect(active_layer_bounds),
+        tiling->contents_scale()));
+    for (PictureLayerTiling::Iterator iter(tiling,
+                                           tiling->contents_scale(),
+                                           tiling->ContentRect(),
+                                           PictureLayerTiling::LayerDeviceAlignmentUnknown);
+         iter; ++iter) {
+      EXPECT_TRUE(*iter);
+      EXPECT_FALSE(iter.geometry_rect().IsEmpty());
+      if (iter.geometry_rect().right() >= active_content_bounds.width() ||
+          iter.geometry_rect().bottom() >= active_content_bounds.height()) {
+        EXPECT_EQ(pending_pile, iter->picture_pile());
+      } else {
+        EXPECT_EQ(active_pile, iter->picture_pile());
+      }
+    }
+  }
+}
+
+TEST_F(PictureLayerImplTest, addTilesFromNewRecording) {
+  gfx::Size tile_size(400, 400);
+  gfx::Size layer_bounds(1300, 1900);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateEmptyPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateEmptyPile(tile_size, layer_bounds);
+
+  // Fill in some of active pile, but more of pending pile.
+  int hole_count = 0;
+  for (int x = 0; x < active_pile->tiling().num_tiles_x(); ++x) {
+    for (int y = 0; y < active_pile->tiling().num_tiles_y(); ++y) {
+      if ((x + y) % 2) {
+        pending_pile->AddRecordingAt(x, y);
+        active_pile->AddRecordingAt(x, y);
+      } else {
+        hole_count++;
+        if (hole_count % 2)
+          pending_pile->AddRecordingAt(x, y);
+      }
+    }
+  }
+
+  SetupTrees(pending_pile, active_pile);
+  Region invalidation;
+  AddDefaultTilingsWithInvalidation(invalidation);
+
+  const PictureLayerTilingSet& tilings = pending_layer_->tilings();
+  EXPECT_GT(tilings.num_tilings(), 0u);
+  for (size_t i = 0; i < tilings.num_tilings(); ++i) {
+    const PictureLayerTiling* tiling = tilings.tiling_at(i);
+
+    for (PictureLayerTiling::Iterator iter(tiling,
+                                           tiling->contents_scale(),
+                                           tiling->ContentRect(),
+                                           PictureLayerTiling::LayerDeviceAlignmentUnknown);
+         iter; ++iter) {
+      EXPECT_FALSE(iter.full_tile_geometry_rect().IsEmpty());
+      // Ensure there is a recording for this tile.
+      gfx::Rect layer_rect = gfx::ToEnclosingRect(
+          gfx::ScaleRect(
+              iter.full_tile_geometry_rect(), 1.f / tiling->contents_scale()));
+      layer_rect.Intersect(gfx::Rect(layer_bounds));
+
+      bool in_pending = pending_pile->recorded_region().Contains(layer_rect);
+      bool in_active = active_pile->recorded_region().Contains(layer_rect);
+
+      if (in_pending && !in_active)
+        EXPECT_EQ(pending_pile, iter->picture_pile());
+      else if (in_active)
+        EXPECT_EQ(active_pile, iter->picture_pile());
+      else
+        EXPECT_FALSE(*iter);
+    }
+  }
+}
+
+TEST_F(PictureLayerImplTest, ManageTilingsWithNoRecording) {
+  gfx::Size tile_size(400, 400);
+  gfx::Size layer_bounds(1300, 1900);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateEmptyPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateEmptyPile(tile_size, layer_bounds);
+
+  float result_scale_x, result_scale_y;
+  gfx::Size result_bounds;
+
+  SetupTrees(pending_pile, active_pile);
+
+  // These are included in the scale given to the layer.
+  host_impl_.setDeviceScaleFactor(1.f);
+  host_impl_.pendingTree()->SetPageScaleFactorAndLimits(1.f, 1.f, 1.f);
+
+  pending_layer_->calculateContentsScale(
+      1.f, false, &result_scale_x, &result_scale_y, &result_bounds);
+
+  EXPECT_EQ(0u, pending_layer_->tilings().num_tilings());
+}
+
+TEST_F(PictureLayerImplTest, ManageTilingsCreatesTilings) {
+  gfx::Size tile_size(400, 400);
+  gfx::Size layer_bounds(1300, 1900);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+
+  float result_scale_x, result_scale_y;
+  gfx::Size result_bounds;
+
+  SetupTrees(pending_pile, active_pile);
+  EXPECT_EQ(0u, pending_layer_->tilings().num_tilings());
+
+  float low_res_factor = host_impl_.settings().lowResContentsScaleFactor;
+  EXPECT_LT(low_res_factor, 1.f);
+
+  // These are included in the scale given to the layer.
+  host_impl_.setDeviceScaleFactor(1.7f);
+  host_impl_.pendingTree()->SetPageScaleFactorAndLimits(3.2f, 3.2f, 3.2f);
+
+  pending_layer_->calculateContentsScale(
+      1.3f, false, &result_scale_x, &result_scale_y, &result_bounds);
+  ASSERT_EQ(2u, pending_layer_->tilings().num_tilings());
+  EXPECT_FLOAT_EQ(
+      1.3f,
+      pending_layer_->tilings().tiling_at(0)->contents_scale());
+  EXPECT_FLOAT_EQ(
+      1.3f * low_res_factor,
+      pending_layer_->tilings().tiling_at(1)->contents_scale());
+
+  // If we change the layer's CSS scale factor, then we should not get new
+  // tilings.
+  pending_layer_->calculateContentsScale(
+      1.8f, false, &result_scale_x, &result_scale_y, &result_bounds);
+  ASSERT_EQ(2u, pending_layer_->tilings().num_tilings());
+  EXPECT_FLOAT_EQ(
+      1.3f,
+      pending_layer_->tilings().tiling_at(0)->contents_scale());
+  EXPECT_FLOAT_EQ(
+      1.3f * low_res_factor,
+      pending_layer_->tilings().tiling_at(1)->contents_scale());
+
+  // If we change the page scale factor, then we should get new tilings.
+  host_impl_.pendingTree()->SetPageScaleFactorAndLimits(2.2f, 2.2f, 2.2f);
+
+  pending_layer_->calculateContentsScale(
+      1.8f, false, &result_scale_x, &result_scale_y, &result_bounds);
+  ASSERT_EQ(4u, pending_layer_->tilings().num_tilings());
+  EXPECT_FLOAT_EQ(
+      1.8f,
+      pending_layer_->tilings().tiling_at(0)->contents_scale());
+  EXPECT_FLOAT_EQ(
+      1.8f * low_res_factor,
+      pending_layer_->tilings().tiling_at(2)->contents_scale());
+
+  // If we change the device scale factor, then we should get new tilings.
+  host_impl_.setDeviceScaleFactor(1.4f);
+
+  pending_layer_->calculateContentsScale(
+      1.9f, false, &result_scale_x, &result_scale_y, &result_bounds);
+  ASSERT_EQ(6u, pending_layer_->tilings().num_tilings());
+  EXPECT_FLOAT_EQ(
+      1.9f,
+      pending_layer_->tilings().tiling_at(0)->contents_scale());
+  EXPECT_FLOAT_EQ(
+      1.9f * low_res_factor,
+      pending_layer_->tilings().tiling_at(3)->contents_scale());
+
+  // If we change the device scale factor, but end up at the same total scale
+  // factor somehow, then we don't get new tilings.
+  host_impl_.setDeviceScaleFactor(2.2f);
+  host_impl_.pendingTree()->SetPageScaleFactorAndLimits(1.4f, 1.4f, 1.4f);
+
+  pending_layer_->calculateContentsScale(
+      1.9f, false, &result_scale_x, &result_scale_y, &result_bounds);
+  ASSERT_EQ(6u, pending_layer_->tilings().num_tilings());
+  EXPECT_FLOAT_EQ(
+      1.9f,
+      pending_layer_->tilings().tiling_at(0)->contents_scale());
+  EXPECT_FLOAT_EQ(
+      1.9f * low_res_factor,
+      pending_layer_->tilings().tiling_at(3)->contents_scale());
+}
+
+TEST_F(PictureLayerImplTest, CleanUpTilings) {
+  gfx::Size tile_size(400, 400);
+  gfx::Size layer_bounds(1300, 1900);
+
+  scoped_refptr<TestablePicturePileImpl> pending_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+  scoped_refptr<TestablePicturePileImpl> active_pile =
+      TestablePicturePileImpl::CreateFilledPile(tile_size, layer_bounds);
+
+  float result_scale_x, result_scale_y;
+  gfx::Size result_bounds;
+  std::vector<PictureLayerTiling*> used_tilings;
+
+  SetupTrees(pending_pile, active_pile);
+  EXPECT_EQ(0u, pending_layer_->tilings().num_tilings());
+
+  float low_res_factor = host_impl_.settings().lowResContentsScaleFactor;
+  EXPECT_LT(low_res_factor, 1.f);
+
+  // These are included in the scale given to the layer.
+  host_impl_.setDeviceScaleFactor(1.7f);
+  host_impl_.pendingTree()->SetPageScaleFactorAndLimits(3.2f, 3.2f, 3.2f);
+  host_impl_.activeTree()->SetPageScaleFactorAndLimits(3.2f, 3.2f, 3.2f);
+
+  SetContentsScaleOnBothLayers(1.f, false);
+  ASSERT_EQ(2u, active_layer_->tilings().num_tilings());
+
+  // We only have ideal tilings, so they aren't removed.
+  used_tilings.clear();
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(2u, active_layer_->tilings().num_tilings());
+
+  // Changing the ideal but not creating new tilings.
+  SetContentsScaleOnBothLayers(1.5f, false);
+  ASSERT_EQ(2u, active_layer_->tilings().num_tilings());
+
+  // The tilings are still our target scale, so they aren't removed.
+  used_tilings.clear();
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(2u, active_layer_->tilings().num_tilings());
+
+  // Create a 1.2 scale tiling. Now we have 1.0 and 1.2 tilings. Ideal = 1.2.
+  host_impl_.pendingTree()->SetPageScaleFactorAndLimits(1.2f, 1.2f, 1.2f);
+  host_impl_.activeTree()->SetPageScaleFactorAndLimits(1.2f, 1.2f, 1.2f);
+  SetContentsScaleOnBothLayers(1.2f, false);
+  ASSERT_EQ(4u, active_layer_->tilings().num_tilings());
+  EXPECT_FLOAT_EQ(
+      1.f,
+      active_layer_->tilings().tiling_at(1)->contents_scale());
+  EXPECT_FLOAT_EQ(
+      1.f * low_res_factor,
+      active_layer_->tilings().tiling_at(3)->contents_scale());
+
+  // Mark the non-ideal tilings as used. They won't be removed.
+  used_tilings.clear();
+  used_tilings.push_back(active_layer_->tilings().tiling_at(1));
+  used_tilings.push_back(active_layer_->tilings().tiling_at(3));
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(4u, active_layer_->tilings().num_tilings());
+
+  // Now move the ideal scale to 0.5. Our target stays 1.2.
+  SetContentsScaleOnBothLayers(0.5f, false);
+
+  // All the tilings are between are target and the ideal, so they are not
+  // removed.
+  used_tilings.clear();
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(4u, active_layer_->tilings().num_tilings());
+
+  // Now move the ideal scale to 1.0. Our target stays 1.2.
+  SetContentsScaleOnBothLayers(1.f, false);
+
+  // All the tilings are between are target and the ideal, so they are not
+  // removed.
+  used_tilings.clear();
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(4u, active_layer_->tilings().num_tilings());
+
+  // Now move the ideal scale to 1.1 on the active layer. Our target stays 1.2.
+  active_layer_->calculateContentsScale(
+      1.1f, false, &result_scale_x, &result_scale_y, &result_bounds);
+
+  // Because the pending layer's ideal scale is still 1.0, our tilings fall
+  // in the range [1.0,1.2] and are kept.
+  used_tilings.clear();
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(4u, active_layer_->tilings().num_tilings());
+
+  // Move the ideal scale on the pending layer to 1.1 as well. Our target stays
+  // 1.2 still.
+  pending_layer_->calculateContentsScale(
+      1.1f, false, &result_scale_x, &result_scale_y, &result_bounds);
+
+  // Our 1.0 tiling now falls outside the range between our ideal scale and our
+  // target raster scale. But it is in our used tilings set, so nothing is
+  // deleted.
+  used_tilings.clear();
+  used_tilings.push_back(active_layer_->tilings().tiling_at(1));
+  used_tilings.push_back(active_layer_->tilings().tiling_at(3));
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(4u, active_layer_->tilings().num_tilings());
+
+  // If we remove it from our used tilings set, it is outside the range to keep
+  // so it is deleted. Try one tiling at a time.
+  used_tilings.clear();
+  used_tilings.push_back(active_layer_->tilings().tiling_at(1));
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(3u, active_layer_->tilings().num_tilings());
+  used_tilings.clear();
+  active_layer_->CleanUpTilingsOnActiveLayer(used_tilings);
+  ASSERT_EQ(2u, active_layer_->tilings().num_tilings());
+  
+}
+
+}  // namespace
+}  // namespace cc
Index: src/cc/picture_image_layer_impl.cc
===================================================================
--- src/cc/picture_image_layer_impl.cc (revision 0)
+++ src/cc/picture_image_layer_impl.cc (revision 0)
@@ -0,0 +1,46 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/picture_image_layer_impl.h"
+
+#include "cc/debug_colors.h"
+#include "cc/layer_tree_impl.h"
+
+namespace cc {
+
+PictureImageLayerImpl::PictureImageLayerImpl(LayerTreeImpl* treeImpl, int id)
+    : PictureLayerImpl(treeImpl, id) {
+}
+
+PictureImageLayerImpl::~PictureImageLayerImpl() {
+}
+
+const char* PictureImageLayerImpl::layerTypeAsString() const {
+  return "PictureImageLayer";
+}
+
+scoped_ptr<LayerImpl> PictureImageLayerImpl::createLayerImpl(
+    LayerTreeImpl* treeImpl) {
+  return PictureImageLayerImpl::create(treeImpl, id()).PassAs<LayerImpl>();
+}
+
+void PictureImageLayerImpl::getDebugBorderProperties(
+    SkColor* color, float* width) const {
+  *color = DebugColors::ImageLayerBorderColor();
+  *width = DebugColors::ImageLayerBorderWidth(layerTreeImpl());
+}
+
+void PictureImageLayerImpl::CalculateRasterContentsScale(
+    bool animating_transform_to_screen,
+    float* raster_contents_scale,
+    float* low_res_raster_contents_scale) {
+  // Don't scale images during rastering to ensure image quality, save memory
+  // and avoid frequent re-rastering on change of scale.
+  *raster_contents_scale =
+      std::max(1.f, layerTreeImpl()->settings().minimumContentsScale);
+  // We don't need low res tiles.
+  *low_res_raster_contents_scale = *raster_contents_scale;
+}
+
+}  // namespace cc
Index: src/cc/transform_operation.h
===================================================================
--- src/cc/transform_operation.h (revision 0)
+++ src/cc/transform_operation.h (revision 0)
@@ -0,0 +1,63 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TRANSFORM_OPERATION_H_
+#define CC_TRANSFORM_OPERATION_H
+
+#include "ui/gfx/transform.h"
+
+namespace cc {
+
+struct TransformOperation {
+  enum Type {
+    TransformOperationTranslate,
+    TransformOperationRotate,
+    TransformOperationScale,
+    TransformOperationSkew,
+    TransformOperationPerspective,
+    TransformOperationMatrix,
+    TransformOperationIdentity
+  };
+
+  TransformOperation()
+      : type(TransformOperationIdentity) {
+  }
+
+  Type type;
+  gfx::Transform matrix;
+
+  union {
+    double perspective_depth;
+
+    struct {
+      double x, y;
+    } skew;
+
+    struct {
+      double x, y, z;
+    } scale;
+
+    struct {
+      double x, y, z;
+    } translate;
+
+    struct {
+      struct {
+        double x, y, z;
+      } axis;
+
+      double angle;
+    } rotate;
+  };
+
+  bool IsIdentity() const;
+  static bool BlendTransformOperations(const TransformOperation* from,
+                                       const TransformOperation* to,
+                                       double progress,
+                                       gfx::Transform& result);
+};
+
+}  // namespace cc
+
+#endif  // CC_TRANSFORM_OPERATION_H_
Index: src/cc/transform_operations.cc
===================================================================
--- src/cc/transform_operations.cc (revision 0)
+++ src/cc/transform_operations.cc (revision 0)
@@ -0,0 +1,156 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/transform_operations.h"
+#include "ui/gfx/vector3d_f.h"
+
+namespace cc {
+
+TransformOperations::TransformOperations() {
+}
+
+TransformOperations::TransformOperations(const TransformOperations& other) {
+  operations_ = other.operations_;
+}
+
+TransformOperations::~TransformOperations() {
+}
+
+gfx::Transform TransformOperations::Apply() const {
+  gfx::Transform to_return;
+  for (size_t i = 0; i < operations_.size(); ++i)
+    to_return.PreconcatTransform(operations_[i].matrix);
+  return to_return;
+}
+
+gfx::Transform TransformOperations::Blend(
+    const TransformOperations& from, double progress) const {
+  gfx::Transform to_return;
+  BlendInternal(from, progress, &to_return);
+  return to_return;
+}
+
+bool TransformOperations::MatchesTypes(const TransformOperations& other) const {
+  if (IsIdentity() || other.IsIdentity())
+    return true;
+
+  if (operations_.size() != other.operations_.size())
+    return false;
+
+  for (size_t i = 0; i < operations_.size(); ++i) {
+    if (operations_[i].type != other.operations_[i].type
+      && !operations_[i].IsIdentity()
+      && !other.operations_[i].IsIdentity())
+      return false;
+  }
+
+  return true;
+}
+
+bool TransformOperations::CanBlendWith(
+    const TransformOperations& other) const {
+  gfx::Transform dummy;
+  return BlendInternal(other, 0.5, &dummy);
+}
+
+void TransformOperations::AppendTranslate(double x, double y, double z) {
+  TransformOperation to_add;
+  to_add.matrix.Translate3d(x, y, z);
+  to_add.type = TransformOperation::TransformOperationTranslate;
+  to_add.translate.x = x;
+  to_add.translate.y = y;
+  to_add.translate.z = z;
+  operations_.push_back(to_add);
+}
+
+void TransformOperations::AppendRotate(double x, double y, double z,
+                                       double degrees) {
+  TransformOperation to_add;
+  to_add.matrix.RotateAbout(gfx::Vector3dF(x, y, z), degrees);
+  to_add.type = TransformOperation::TransformOperationRotate;
+  to_add.rotate.axis.x = x;
+  to_add.rotate.axis.y = y;
+  to_add.rotate.axis.z = z;
+  to_add.rotate.angle = degrees;
+  operations_.push_back(to_add);
+}
+
+void TransformOperations::AppendScale(double x, double y, double z) {
+  TransformOperation to_add;
+  to_add.matrix.Scale3d(x, y, z);
+  to_add.type = TransformOperation::TransformOperationScale;
+  to_add.scale.x = x;
+  to_add.scale.y = y;
+  to_add.scale.z = z;
+  operations_.push_back(to_add);
+}
+
+void TransformOperations::AppendSkew(double x, double y) {
+  TransformOperation to_add;
+  to_add.matrix.SkewX(x);
+  to_add.matrix.SkewY(y);
+  to_add.type = TransformOperation::TransformOperationSkew;
+  to_add.skew.x = x;
+  to_add.skew.y = y;
+  operations_.push_back(to_add);
+}
+
+void TransformOperations::AppendPerspective(double depth) {
+  TransformOperation to_add;
+  to_add.matrix.ApplyPerspectiveDepth(depth);
+  to_add.type = TransformOperation::TransformOperationPerspective;
+  to_add.perspective_depth = depth;
+  operations_.push_back(to_add);
+}
+
+void TransformOperations::AppendMatrix(const gfx::Transform& matrix) {
+  TransformOperation to_add;
+  to_add.matrix = matrix;
+  to_add.type = TransformOperation::TransformOperationMatrix;
+  operations_.push_back(to_add);
+}
+
+void TransformOperations::AppendIdentity() {
+  operations_.push_back(TransformOperation());
+}
+
+bool TransformOperations::IsIdentity() const {
+  for (size_t i = 0; i < operations_.size(); ++i) {
+    if (!operations_[i].IsIdentity())
+      return false;
+  }
+  return true;
+}
+
+bool TransformOperations::BlendInternal(const TransformOperations& from,
+                                        double progress,
+                                        gfx::Transform* result) const {
+  bool from_identity = from.IsIdentity();
+  bool to_identity = IsIdentity();
+  if (from_identity && to_identity)
+    return true;
+
+  if (MatchesTypes(from)) {
+    size_t num_operations =
+        std::max(from_identity ? 0 : from.operations_.size(),
+                 to_identity ? 0 : operations_.size());
+    for (size_t i = 0; i < num_operations; ++i) {
+      gfx::Transform blended;
+      if (!TransformOperation::BlendTransformOperations(
+          from_identity ? 0 : &from.operations_[i],
+          to_identity ? 0 : &operations_[i],
+          progress,
+          blended))
+          return false;
+      result->PreconcatTransform(blended);
+    }
+    return true;
+  }
+
+  *result = Apply();
+  gfx::Transform from_transform = from.Apply();
+  return result->Blend(from_transform, progress);
+}
+
+}  // namespace cc
Index: src/cc/transform_operations.h
===================================================================
--- src/cc/transform_operations.h (revision 0)
+++ src/cc/transform_operations.h (revision 0)
@@ -0,0 +1,71 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TRANSFORM_OPERATIONS_H_
+#define CC_TRANSFORM_OPERATIONS_H_
+
+#include <vector>
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/cc_export.h"
+#include "cc/transform_operation.h"
+#include "ui/gfx/transform.h"
+
+namespace cc {
+
+// Transform operations are a decomposed transformation matrix. It can be
+// applied to obtain a gfx::Transform at any time, and can be blended
+// intelligently with other transform operations, so long as they represent the
+// same decomposition. For example, if we have a transform that is made up of
+// a rotation followed by skew, it can be blended intelligently with another
+// transform made up of a rotation followed by a skew. Blending is possible if
+// we have two dissimilar sets of transform operations, but the effect may not
+// be what was intended. For more information, see the comments for the blend
+// function below.
+class CC_EXPORT TransformOperations {
+ public:
+  TransformOperations();
+  TransformOperations(const TransformOperations& other);
+  ~TransformOperations();
+
+  // Returns a transformation matrix representing these transform operations.
+  gfx::Transform Apply() const;
+
+  // Given another set of transform operations and a progress in the range
+  // [0, 1], returns a transformation matrix representing the intermediate
+  // value. If this->MatchesTypes(from), then each of the operations are
+  // blended separately and then combined. Otherwise, the two sets of
+  // transforms are baked to matrices (using apply), and the matrices are
+  // then decomposed and interpolated. For more information, see
+  // http://www.w3.org/TR/2011/WD-css3-2d-transforms-20111215/#matrix-decomposition.
+  gfx::Transform Blend(const TransformOperations& from, double progress) const;
+
+  // Returns true if this operation and its descendants have the same types
+  // as other and its descendants.
+  bool MatchesTypes(const TransformOperations& other) const;
+
+  // Returns true if these operations can be blended. It will only return
+  // false if we must resort to matrix interpolation, and matrix interpolation
+  // fails (this can happen if either matrix cannot be decomposed).
+  bool CanBlendWith(const TransformOperations& other) const;
+
+  void AppendTranslate(double x, double y, double z);
+  void AppendRotate(double x, double y, double z, double degrees);
+  void AppendScale(double x, double y, double z);
+  void AppendSkew(double x, double y);
+  void AppendPerspective(double depth);
+  void AppendMatrix(const gfx::Transform& matrix);
+  void AppendIdentity();
+  bool IsIdentity() const;
+
+ private:
+  bool BlendInternal(const TransformOperations& from, double progress,
+                     gfx::Transform* result) const;
+
+  std::vector<TransformOperation> operations_;
+};
+
+}  // namespace cc
+
+#endif  // CC_TRANSFORM_OPERATIONS_H_
Index: src/cc/layer_animation_event_observer.h
===================================================================
--- src/cc/layer_animation_event_observer.h (revision 0)
+++ src/cc/layer_animation_event_observer.h (revision 0)
@@ -0,0 +1,18 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_LAYER_ANIMATION_EVENT_OBSERVER_H_
+#define CC_LAYER_ANIMATION_EVENT_OBSERVER_H_
+
+namespace cc {
+
+class CC_EXPORT LayerAnimationEventObserver {
+ public:
+  virtual void OnAnimationStarted(const AnimationEvent& event) = 0;
+};
+
+} // namespace cc
+
+#endif  // CC_LAYER_ANIMATION_EVENT_OBSERVER_H_
+
Index: src/cc/paint_time_counter.cc
===================================================================
--- src/cc/paint_time_counter.cc (revision 0)
+++ src/cc/paint_time_counter.cc (revision 0)
@@ -0,0 +1,56 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/paint_time_counter.h"
+
+namespace cc {
+
+// static
+scoped_ptr<PaintTimeCounter> PaintTimeCounter::create() {
+  return make_scoped_ptr(new PaintTimeCounter());
+}
+
+PaintTimeCounter::PaintTimeCounter() {
+}
+
+base::TimeDelta PaintTimeCounter::GetPaintTimeOfRecentFrame(
+    const size_t& n) const {
+  DCHECK(n < ring_buffer_.BufferSize());
+
+  if (ring_buffer_.IsFilledIndex(n))
+    return ring_buffer_.ReadBuffer(n);
+
+  return base::TimeDelta();
+}
+
+void PaintTimeCounter::SavePaintTime(const base::TimeDelta& total_paint_time) {
+  base::TimeDelta paint_time = total_paint_time - last_total_paint_time_;
+
+  if (paint_time.InMillisecondsF() > 0)
+    ring_buffer_.SaveToBuffer(paint_time);
+
+  last_total_paint_time_ = total_paint_time;
+}
+
+void PaintTimeCounter::GetMinAndMaxPaintTime(base::TimeDelta* min,
+                                             base::TimeDelta* max) const {
+  *min = base::TimeDelta::FromDays(1);
+  *max = base::TimeDelta();
+
+  for (size_t i = 0; i < ring_buffer_.BufferSize(); i++) {
+    if (ring_buffer_.IsFilledIndex(i)) {
+      base::TimeDelta paint_time = ring_buffer_.ReadBuffer(i);
+
+      if (paint_time < *min)
+        *min = paint_time;
+      if (paint_time > *max)
+        *max = paint_time;
+    }
+  }
+
+  if (*min > *max)
+    *min = *max;
+}
+
+}  // namespace cc
Index: src/cc/texture_mailbox.h
===================================================================
--- src/cc/texture_mailbox.h (revision 0)
+++ src/cc/texture_mailbox.h (revision 0)
@@ -0,0 +1,50 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEXTURE_MAILBOX_H_
+#define CC_TEXTURE_MAILBOX_H_
+
+#include <string>
+
+#include "base/basictypes.h"
+#include "base/callback.h"
+#include "cc/cc_export.h"
+#include "cc/transferable_resource.h"
+
+namespace cc {
+
+class CC_EXPORT TextureMailbox {
+ public:
+  typedef base::Callback<void(unsigned)> ReleaseCallback;
+  TextureMailbox();
+  TextureMailbox(const std::string& mailbox_name,
+                 const ReleaseCallback& callback);
+  TextureMailbox(const Mailbox& mailbox_name,
+                 const ReleaseCallback& callback);
+  TextureMailbox(const Mailbox& mailbox_name,
+                 const ReleaseCallback& callback,
+                 unsigned sync_point);
+
+  ~TextureMailbox();
+
+  const ReleaseCallback& callback() const { return callback_; }
+  const int8* data() const { return name_.name; }
+  bool Equals(const Mailbox&) const;
+  bool Equals(const TextureMailbox&) const;
+  bool IsEmpty() const;
+  const Mailbox& name() const { return name_; }
+  void ResetSyncPoint() { sync_point_ = 0; }
+  void RunReleaseCallback(unsigned sync_point) const;
+  void SetName(const Mailbox&);
+  unsigned sync_point() const { return sync_point_; }
+
+ private:
+  Mailbox name_;
+  ReleaseCallback callback_;
+  unsigned sync_point_;
+};
+
+}  // namespace cc
+
+#endif  // CC_TEXTURE_MAILBOX_H_
Index: src/cc/scheduler_settings.cc
===================================================================
--- src/cc/scheduler_settings.cc (revision 0)
+++ src/cc/scheduler_settings.cc (revision 0)
@@ -0,0 +1,18 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/scheduler_settings.h"
+
+namespace cc {
+
+SchedulerSettings::SchedulerSettings()
+  : implSidePainting(false)
+{
+}
+
+SchedulerSettings::~SchedulerSettings()
+{
+}
+
+}  // namespace cc
Index: src/cc/vsync_time_source_unittest.cc
===================================================================
--- src/cc/vsync_time_source_unittest.cc (revision 0)
+++ src/cc/vsync_time_source_unittest.cc (revision 0)
@@ -0,0 +1,103 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/vsync_time_source.h"
+
+#include "cc/test/scheduler_test_common.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace cc {
+namespace {
+
+class FakeVSyncProvider : public VSyncProvider {
+ public:
+  FakeVSyncProvider()
+    : client_(NULL) {}
+
+  // VSyncProvider implementation.
+  virtual void RequestVSyncNotification(VSyncClient* client) OVERRIDE {
+    client_ = client;
+  }
+
+  bool IsVSyncNotificationEnabled() const { return client_ != NULL; }
+
+  void Trigger(base::TimeTicks frame_time) {
+    if (client_)
+      client_->DidVSync(frame_time);
+  }
+
+ private:
+  VSyncClient* client_;
+};
+
+class VSyncTimeSourceTest : public testing::Test {
+ public:
+  VSyncTimeSourceTest()
+      : timer_(VSyncTimeSource::create(&provider_)) {
+    timer_->setClient(&client_);
+  }
+
+ protected:
+  FakeTimeSourceClient client_;
+  FakeVSyncProvider provider_;
+  scoped_refptr<VSyncTimeSource> timer_;
+};
+
+TEST_F(VSyncTimeSourceTest, TaskPostedAndTickCalled)
+{
+  EXPECT_FALSE(provider_.IsVSyncNotificationEnabled());
+
+  timer_->setActive(true);
+  EXPECT_TRUE(provider_.IsVSyncNotificationEnabled());
+
+  base::TimeTicks frame_time = base::TimeTicks::Now();
+  provider_.Trigger(frame_time);
+  EXPECT_TRUE(client_.tickCalled());
+  EXPECT_EQ(timer_->lastTickTime(), frame_time);
+}
+
+TEST_F(VSyncTimeSourceTest, NotificationDisabledLazily)
+{
+  base::TimeTicks frame_time = base::TimeTicks::Now();
+
+  // Enable timer and trigger sync once.
+  timer_->setActive(true);
+  EXPECT_TRUE(provider_.IsVSyncNotificationEnabled());
+  provider_.Trigger(frame_time);
+  EXPECT_TRUE(client_.tickCalled());
+
+  // Disabling the timer should not disable vsync notification immediately.
+  client_.reset();
+  timer_->setActive(false);
+  EXPECT_TRUE(provider_.IsVSyncNotificationEnabled());
+
+  // At the next vsync the notification is disabled, but the timer isn't ticked.
+  provider_.Trigger(frame_time);
+  EXPECT_FALSE(provider_.IsVSyncNotificationEnabled());
+  EXPECT_FALSE(client_.tickCalled());
+
+  // The notification should not be disabled multiple times.
+  provider_.RequestVSyncNotification(timer_.get());
+  provider_.Trigger(frame_time);
+  EXPECT_TRUE(provider_.IsVSyncNotificationEnabled());
+  EXPECT_FALSE(client_.tickCalled());
+}
+
+TEST_F(VSyncTimeSourceTest, ValidNextTickTime)
+{
+  base::TimeTicks frame_time = base::TimeTicks::Now();
+  base::TimeDelta interval = base::TimeDelta::FromSeconds(1);
+
+  ASSERT_EQ(timer_->nextTickTime(), base::TimeTicks());
+
+  timer_->setActive(true);
+  provider_.Trigger(frame_time);
+  ASSERT_EQ(timer_->nextTickTime(), frame_time);
+
+  timer_->setTimebaseAndInterval(frame_time, interval);
+  ASSERT_EQ(timer_->nextTickTime(), frame_time + interval);
+}
+
+}  // namespace
+}  // namespace cc
Index: src/cc/animation_registrar.h
===================================================================
--- src/cc/animation_registrar.h (revision 0)
+++ src/cc/animation_registrar.h (revision 0)
@@ -0,0 +1,65 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_ANIMATION_REGISTRAR_H_
+#define CC_ANIMATION_REGISTRAR_H_
+
+#include "base/hash_tables.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "cc/cc_export.h"
+
+namespace cc {
+
+class LayerAnimationController;
+
+class CC_EXPORT AnimationRegistrar {
+ public:
+  typedef base::hash_map<int, LayerAnimationController*> AnimationControllerMap;
+
+  static scoped_ptr<AnimationRegistrar> create() {
+    return make_scoped_ptr(new AnimationRegistrar());
+  }
+
+  virtual ~AnimationRegistrar();
+
+  // If an animation has been registered for the given id, return it. Otherwise
+  // creates a new one and returns a scoped_refptr to it.
+  scoped_refptr<LayerAnimationController> GetAnimationControllerForId(int id);
+
+  // Registers the given animation controller as active. An active animation
+  // controller is one that has a running animation that needs to be ticked.
+  void DidActivateAnimationController(LayerAnimationController*);
+
+  // Unregisters the given animation controller. When this happens, the
+  // animation controller will no longer be ticked (since it's not active). It
+  // is not an error to call this function with a deactivated controller.
+  void DidDeactivateAnimationController(LayerAnimationController*);
+
+  // Registers the given controller as alive.
+  void RegisterAnimationController(LayerAnimationController*);
+
+  // Unregisters the given controller as alive.
+  void UnregisterAnimationController(LayerAnimationController*);
+
+  const AnimationControllerMap& active_animation_controllers() const {
+    return active_animation_controllers_;
+  }
+
+  const AnimationControllerMap& all_animation_controllers() const {
+    return all_animation_controllers_;
+  }
+
+ private:
+  AnimationRegistrar();
+
+  AnimationControllerMap active_animation_controllers_;
+  AnimationControllerMap all_animation_controllers_;
+
+  DISALLOW_COPY_AND_ASSIGN(AnimationRegistrar);
+};
+
+}  // namespace cc
+
+#endif  // CC_ANIMATION_REGISTRAR_H_
Index: src/cc/picture_pile_base.cc
===================================================================
--- src/cc/picture_pile_base.cc (revision 0)
+++ src/cc/picture_pile_base.cc (revision 0)
@@ -0,0 +1,109 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/picture_pile_base.h"
+
+#include "base/logging.h"
+
+namespace {
+// Dimensions of the tiles in this picture pile as well as the dimensions of
+// the base picture in each tile.
+const int kBasePictureSize = 3000;
+}
+
+namespace cc {
+
+PicturePileBase::PicturePileBase()
+    : min_contents_scale_(0) {
+  tiling_.SetMaxTextureSize(gfx::Size(kBasePictureSize, kBasePictureSize));
+}
+
+PicturePileBase::~PicturePileBase() {
+}
+
+void PicturePileBase::Resize(gfx::Size new_size) {
+  if (size() == new_size)
+    return;
+
+  gfx::Size old_size = size();
+  tiling_.SetTotalSize(new_size);
+
+  // Find all tiles that contain any pixels outside the new size.
+  std::vector<PictureListMapKey> to_erase;
+  int min_toss_x = tiling_.FirstBorderTileXIndexFromSrcCoord(
+      std::min(old_size.width(), new_size.width()));
+  int min_toss_y = tiling_.FirstBorderTileYIndexFromSrcCoord(
+      std::min(old_size.height(), new_size.height()));
+  for (PictureListMap::iterator iter = picture_list_map_.begin();
+       iter != picture_list_map_.end(); ++iter) {
+    if (iter->first.first < min_toss_x && iter->first.second < min_toss_y)
+      continue;
+    to_erase.push_back(iter->first);
+  }
+
+  for (size_t i = 0; i < to_erase.size(); ++i)
+    picture_list_map_.erase(to_erase[i]);
+}
+
+void PicturePileBase::SetMinContentsScale(float min_contents_scale) {
+  DCHECK(min_contents_scale);
+  if (min_contents_scale_ == min_contents_scale)
+    return;
+
+  // Picture contents are played back scaled. When the final contents scale is
+  // less than 1 (i.e. low res), then multiple recorded pixels will be used
+  // to raster one final pixel.  To avoid splitting a final pixel across
+  // pictures (which would result in incorrect rasterization due to blending), a
+  // buffer margin is added so that any picture can be snapped to integral
+  // final pixels.
+  //
+  // For example, if a 1/4 contents scale is used, then that would be 3 buffer
+  // pixels, since that's the minimum number of pixels to add so that resulting
+  // content can be snapped to a four pixel aligned grid.
+  int buffer_pixels = static_cast<int>(ceil(1 / min_contents_scale) - 1);
+  buffer_pixels = std::max(0, buffer_pixels);
+  SetBufferPixels(buffer_pixels);
+  min_contents_scale_ = min_contents_scale;
+}
+
+void PicturePileBase::SetBufferPixels(int new_buffer_pixels) {
+  if (new_buffer_pixels == buffer_pixels())
+    return;
+
+  Clear();
+  tiling_.SetBorderTexels(new_buffer_pixels);
+}
+
+void PicturePileBase::Clear() {
+  picture_list_map_.clear();
+}
+
+void PicturePileBase::PushPropertiesTo(PicturePileBase* other) {
+  other->picture_list_map_ = picture_list_map_;
+  other->tiling_ = tiling_;
+  other->recorded_region_ = recorded_region_;
+  other->min_contents_scale_ = min_contents_scale_;
+}
+
+void PicturePileBase::UpdateRecordedRegion() {
+  recorded_region_.Clear();
+  for (int x = 0; x < num_tiles_x(); ++x) {
+    for (int y = 0; y < num_tiles_y(); ++y) {
+      if (!HasRecordingAt(x, y))
+        continue;
+      recorded_region_.Union(tile_bounds(x, y));
+    }
+  }
+}
+
+bool PicturePileBase::HasRecordingAt(int x, int y) {
+  PictureListMap::iterator found =
+      picture_list_map_.find(PictureListMapKey(x, y));
+  if (found == picture_list_map_.end())
+    return false;
+  DCHECK(!found->second.empty());
+  return true;
+}
+
+}  // namespace cc
Index: src/cc/memory_history.cc
===================================================================
--- src/cc/memory_history.cc (revision 0)
+++ src/cc/memory_history.cc (revision 0)
@@ -0,0 +1,50 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/memory_history.h"
+
+namespace cc {
+
+// static
+scoped_ptr<MemoryHistory> MemoryHistory::create() {
+  return make_scoped_ptr(new MemoryHistory());
+}
+
+MemoryHistory::MemoryHistory() {
+}
+
+MemoryHistory::Entry MemoryHistory::GetEntry(const size_t& n) const {
+  DCHECK(n < ring_buffer_.BufferSize());
+
+  if (ring_buffer_.IsFilledIndex(n))
+    return ring_buffer_.ReadBuffer(n);
+
+  return MemoryHistory::Entry();
+}
+
+void MemoryHistory::SaveEntry(const MemoryHistory::Entry& entry) {
+  ring_buffer_.SaveToBuffer(entry);
+}
+
+void MemoryHistory::GetMinAndMax(size_t* min, size_t* max) const {
+  *min = std::numeric_limits<size_t>::max();
+  *max = 0;
+
+  for (size_t i = 0; i < ring_buffer_.BufferSize(); i++) {
+    if (!ring_buffer_.IsFilledIndex(i))
+        continue;
+    const Entry entry = ring_buffer_.ReadBuffer(i);
+    size_t bytes_total = entry.bytes_total();
+
+    if (bytes_total < *min)
+      *min = bytes_total;
+    if (bytes_total > *max)
+        *max = bytes_total;
+  }
+
+  if (*min > *max)
+    *min = *max;
+}
+
+}  // namespace cc
Index: src/cc/scrollbar_theme_painter.h
===================================================================
--- src/cc/scrollbar_theme_painter.h (revision 0)
+++ src/cc/scrollbar_theme_painter.h (revision 0)
@@ -0,0 +1,36 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_SCROLLBAR_THEME_PAINTER_H_
+#define CC_SCROLLBAR_THEME_PAINTER_H_
+
+#include "cc/cc_export.h"
+
+class SkCanvas;
+
+namespace gfx {
+class Rect;
+}
+
+namespace cc {
+
+class CC_EXPORT ScrollbarThemePainter {
+ public:
+  virtual ~ScrollbarThemePainter() {}
+
+  virtual void PaintScrollbarBackground(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintTrackBackground(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintBackTrackPart(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintForwardTrackPart(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintBackButtonStart(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintBackButtonEnd(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintForwardButtonStart(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintForwardButtonEnd(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintTickmarks(SkCanvas*, const gfx::Rect&) = 0;
+  virtual void PaintThumb(SkCanvas*, const gfx::Rect&) = 0;
+};
+
+}  // namespace cc
+
+#endif  // CC_SCROLLBAR_THEME_PAINTER_H_
Index: src/cc/scheduler_settings.h
===================================================================
--- src/cc/scheduler_settings.h (revision 0)
+++ src/cc/scheduler_settings.h (revision 0)
@@ -0,0 +1,23 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_SCHEDULER_SETTINGS_H_
+#define CC_SCHEDULER_SETTINGS_H_
+
+#include "cc/cc_export.h"
+
+namespace cc {
+
+class CC_EXPORT SchedulerSettings
+{
+public:
+  SchedulerSettings();
+  ~SchedulerSettings();
+
+  bool implSidePainting;
+};
+
+}  // namespace cc
+
+#endif  // CC_SCHEDULER_SETTINGS_H_
Index: src/cc/video_frame_provider_client_impl.cc
===================================================================
--- src/cc/video_frame_provider_client_impl.cc (revision 0)
+++ src/cc/video_frame_provider_client_impl.cc (revision 0)
@@ -0,0 +1,87 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/video_frame_provider_client_impl.h"
+
+#include "cc/math_util.h"
+#include "cc/video_layer_impl.h"
+
+namespace cc {
+
+// static
+scoped_refptr<VideoFrameProviderClientImpl>
+    VideoFrameProviderClientImpl::Create(
+        VideoFrameProvider* provider) {
+  return make_scoped_refptr(
+      new VideoFrameProviderClientImpl(provider));
+}
+
+VideoFrameProviderClientImpl::~VideoFrameProviderClientImpl() {}
+
+VideoFrameProviderClientImpl::VideoFrameProviderClientImpl(
+    VideoFrameProvider* provider)
+    : provider_(provider) {
+  // This only happens during a commit on the compositor thread while the main
+  // thread is blocked. That makes this a thread-safe call to set the video
+  // frame provider client that does not require a lock. The same is true of
+  // the call to Stop().
+  provider_->SetVideoFrameProviderClient(this);
+
+  // This matrix is the default transformation for stream textures, and flips
+  // on the Y axis.
+  stream_texture_matrix_ = gfx::Transform(
+      1.0, 0.0, 0.0, 0.0,
+      0.0, -1.0, 0.0, 1.0,
+      0.0, 0.0, 1.0, 0.0,
+      0.0, 0.0, 0.0, 1.0);
+}
+
+void VideoFrameProviderClientImpl::Stop() {
+  if (!provider_)
+    return;
+  provider_->SetVideoFrameProviderClient(NULL);
+  provider_ = NULL;
+}
+
+media::VideoFrame* VideoFrameProviderClientImpl::AcquireLockAndCurrentFrame() {
+  provider_lock_.Acquire();  // Balanced by call to ReleaseLock().
+  if (!provider_)
+    return NULL;
+
+  return provider_->GetCurrentFrame();
+}
+
+void VideoFrameProviderClientImpl::PutCurrentFrame(media::VideoFrame* frame) {
+  provider_lock_.AssertAcquired();
+  provider_->PutCurrentFrame(frame);
+}
+
+void VideoFrameProviderClientImpl::ReleaseLock() {
+  provider_lock_.AssertAcquired();
+  provider_lock_.Release();
+}
+
+void VideoFrameProviderClientImpl::StopUsingProvider() {
+  // Block the provider from shutting down until this client is done
+  // using the frame.
+  base::AutoLock locker(provider_lock_);
+  provider_ = 0;
+}
+
+void VideoFrameProviderClientImpl::DidReceiveFrame() {
+  if (active_video_layer_)
+    active_video_layer_->setNeedsRedraw();
+}
+
+void VideoFrameProviderClientImpl::DidUpdateMatrix(const float* matrix) {
+  stream_texture_matrix_ = gfx::Transform(
+      matrix[0], matrix[4], matrix[8], matrix[12],
+      matrix[1], matrix[5], matrix[9], matrix[13],
+      matrix[2], matrix[6], matrix[10], matrix[14],
+      matrix[3], matrix[7], matrix[11], matrix[15]);
+  if (active_video_layer_)
+    active_video_layer_->setNeedsRedraw();
+}
+
+}  // namespace cc
Index: src/cc/transform_operations_unittest.cc
===================================================================
--- src/cc/transform_operations_unittest.cc (revision 0)
+++ src/cc/transform_operations_unittest.cc (revision 0)
@@ -0,0 +1,603 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/memory/scoped_vector.h"
+#include "cc/test/geometry_test_utils.h"
+#include "cc/transform_operations.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/vector3d_f.h"
+
+namespace cc {
+namespace {
+
+TEST(TransformOperationTest, TransformTypesAreUnique) {
+  ScopedVector<TransformOperations> transforms;
+
+  TransformOperations* to_add = new TransformOperations();
+  to_add->AppendTranslate(1, 0, 0);
+  transforms.push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendRotate(0, 0, 1, 2);
+  transforms.push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendScale(2, 2, 2);
+  transforms.push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendSkew(1, 0);
+  transforms.push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendPerspective(800);
+  transforms.push_back(to_add);
+
+  for (size_t i = 0; i < transforms.size(); ++i) {
+    for (size_t j = 0; j < transforms.size(); ++j) {
+      bool matches_type = transforms[i]->MatchesTypes(*transforms[j]);
+      EXPECT_TRUE((i == j && matches_type) || !matches_type);
+    }
+  }
+}
+
+TEST(TransformOperationTest, MatchTypesSameLength) {
+  TransformOperations translates;
+  translates.AppendTranslate(1, 0, 0);
+  translates.AppendTranslate(1, 0, 0);
+  translates.AppendTranslate(1, 0, 0);
+
+  TransformOperations skews;
+  skews.AppendSkew(0, 2);
+  skews.AppendSkew(0, 2);
+  skews.AppendSkew(0, 2);
+
+  TransformOperations translates2;
+  translates2.AppendTranslate(0, 2, 0);
+  translates2.AppendTranslate(0, 2, 0);
+  translates2.AppendTranslate(0, 2, 0);
+
+  TransformOperations translates3 = translates2;
+
+  EXPECT_FALSE(translates.MatchesTypes(skews));
+  EXPECT_TRUE(translates.MatchesTypes(translates2));
+  EXPECT_TRUE(translates.MatchesTypes(translates3));
+}
+
+TEST(TransformOperationTest, MatchTypesDifferentLength) {
+  TransformOperations translates;
+  translates.AppendTranslate(1, 0, 0);
+  translates.AppendTranslate(1, 0, 0);
+  translates.AppendTranslate(1, 0, 0);
+
+  TransformOperations skews;
+  skews.AppendSkew(2, 0);
+  skews.AppendSkew(2, 0);
+
+  TransformOperations translates2;
+  translates2.AppendTranslate(0, 2, 0);
+  translates2.AppendTranslate(0, 2, 0);
+
+  EXPECT_FALSE(translates.MatchesTypes(skews));
+  EXPECT_FALSE(translates.MatchesTypes(translates2));
+}
+
+void GetIdentityOperations(ScopedVector<TransformOperations>* operations) {
+  TransformOperations* to_add = new TransformOperations();
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendTranslate(0, 0, 0);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendTranslate(0, 0, 0);
+  to_add->AppendTranslate(0, 0, 0);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendScale(1, 1, 1);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendScale(1, 1, 1);
+  to_add->AppendScale(1, 1, 1);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendSkew(0, 0);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendSkew(0, 0);
+  to_add->AppendSkew(0, 0);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendRotate(0, 0, 1, 0);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendRotate(0, 0, 1, 0);
+  to_add->AppendRotate(0, 0, 1, 0);
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendMatrix(gfx::Transform());
+  operations->push_back(to_add);
+
+  to_add = new TransformOperations();
+  to_add->AppendMatrix(gfx::Transform());
+  to_add->AppendMatrix(gfx::Transform());
+  operations->push_back(to_add);
+}
+
+TEST(TransformOperationTest, IdentityAlwaysMatches) {
+  ScopedVector<TransformOperations> operations;
+  GetIdentityOperations(&operations);
+
+  for (size_t i = 0; i < operations.size(); ++i) {
+    for (size_t j = 0; j < operations.size(); ++j)
+      EXPECT_TRUE(operations[i]->MatchesTypes(*operations[j]));
+  }
+}
+
+TEST(TransformOperationTest, ApplyTranslate) {
+  double x = 1;
+  double y = 2;
+  double z = 3;
+  TransformOperations operations;
+  operations.AppendTranslate(x, y, z);
+  gfx::Transform expected;
+  expected.Translate3d(x, y, z);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.Apply());
+}
+
+TEST(TransformOperationTest, ApplyRotate) {
+  double x = 1;
+  double y = 2;
+  double z = 3;
+  double degrees = 80;
+  TransformOperations operations;
+  operations.AppendRotate(x, y, z, degrees);
+  gfx::Transform expected;
+  expected.RotateAbout(gfx::Vector3dF(x, y, z), degrees);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.Apply());
+}
+
+TEST(TransformOperationTest, ApplyScale) {
+  double x = 1;
+  double y = 2;
+  double z = 3;
+  TransformOperations operations;
+  operations.AppendScale(x, y, z);
+  gfx::Transform expected;
+  expected.Scale3d(x, y, z);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.Apply());
+}
+
+TEST(TransformOperationTest, ApplySkew) {
+  double x = 1;
+  double y = 2;
+  TransformOperations operations;
+  operations.AppendSkew(x, y);
+  gfx::Transform expected;
+  expected.SkewX(x);
+  expected.SkewY(y);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.Apply());
+}
+
+TEST(TransformOperationTest, ApplyPerspective) {
+  double depth = 800;
+  TransformOperations operations;
+  operations.AppendPerspective(depth);
+  gfx::Transform expected;
+  expected.ApplyPerspectiveDepth(depth);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected, operations.Apply());
+}
+
+TEST(TransformOperationTest, ApplyMatrix) {
+  double dx = 1;
+  double dy = 2;
+  double dz = 3;
+  gfx::Transform expected_matrix;
+  expected_matrix.Translate3d(dx, dy, dz);
+  TransformOperations matrix_transform;
+  matrix_transform.AppendMatrix(expected_matrix);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected_matrix, matrix_transform.Apply());
+}
+
+TEST(TransformOperationTest, ApplyOrder) {
+  double sx = 2;
+  double sy = 4;
+  double sz = 8;
+
+  double dx = 1;
+  double dy = 2;
+  double dz = 3;
+
+  TransformOperations operations;
+  operations.AppendScale(sx, sy, sz);
+  operations.AppendTranslate(dx, dy, dz);
+
+  gfx::Transform expected_scale_matrix;
+  expected_scale_matrix.Scale3d(sx, sy, sz);
+
+  gfx::Transform expected_translate_matrix;
+  expected_translate_matrix.Translate3d(dx, dy, dz);
+
+  gfx::Transform expected_combined_matrix = expected_scale_matrix;
+  expected_combined_matrix.PreconcatTransform(expected_translate_matrix);
+
+  EXPECT_TRANSFORMATION_MATRIX_EQ(expected_combined_matrix, operations.Apply());
+}
+
+TEST(TransformOperationTest, BlendOrder) {
+  double sx1 = 2;
+  double sy1 = 4;
+  double sz1 = 8;
+
+  double dx1 = 1;
+  double dy1 = 2;
+  double dz1 = 3;
+
+  double sx2 = 4;
+  double sy2 = 8;
+  double sz2 = 16;
+
+  double dx2 = 10;
+  double dy2 = 20;
+  double dz2 = 30;
+
+  TransformOperations operations_from;
+  operations_from.AppendScale(sx1, sy1, sz1);
+  operations_from.AppendTranslate(dx1, dy1, dz1);
+
+  TransformOperations operations_to;
+  operations_to.AppendScale(sx2, sy2, sz2);
+  operations_to.AppendTranslate(dx2, dy2, dz2);
+
+  gfx::Transform scale_from;
+  scale_from.Scale3d(sx1, sy1, sz1);
+  gfx::Transform translate_from;
+  translate_from.Translate3d(dx1, dy1, dz1);
+
+  gfx::Transform scale_to;
+  scale_to.Scale3d(sx2, sy2, sz2);
+  gfx::Transform translate_to;
+  translate_to.Translate3d(dx2, dy2, dz2);
+
+  double progress = 0.25;
+
+  gfx::Transform blended_scale = scale_to;
+  blended_scale.Blend(scale_from, progress);
+
+  gfx::Transform blended_translate = translate_to;
+  blended_translate.Blend(translate_from, progress);
+
+  gfx::Transform expected = blended_scale;
+  expected.PreconcatTransform(blended_translate);
+
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, operations_to.Blend(operations_from, progress));
+}
+
+static void CheckProgress(double progress,
+              const gfx::Transform& from_matrix,
+              const gfx::Transform& to_matrix,
+              const TransformOperations& from_transform,
+              const TransformOperations& to_transform) {
+  gfx::Transform expected_matrix = to_matrix;
+  expected_matrix.Blend(from_matrix, progress);
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected_matrix, to_transform.Blend(from_transform, progress));
+}
+
+TEST(TransformOperationTest, BlendProgress) {
+  double sx = 2;
+  double sy = 4;
+  double sz = 8;
+  TransformOperations operations_from;
+  operations_from.AppendScale(sx, sy, sz);
+
+  gfx::Transform matrix_from;
+  matrix_from.Scale3d(sx, sy, sz);
+
+  sx = 4;
+  sy = 8;
+  sz = 16;
+  TransformOperations operations_to;
+  operations_to.AppendScale(sx, sy, sz);
+
+  gfx::Transform matrix_to;
+  matrix_to.Scale3d(sx, sy, sz);
+
+  CheckProgress(-1, matrix_from, matrix_to, operations_from, operations_to);
+  CheckProgress(0, matrix_from, matrix_to, operations_from, operations_to);
+  CheckProgress(0.25, matrix_from, matrix_to, operations_from, operations_to);
+  CheckProgress(0.5, matrix_from, matrix_to, operations_from, operations_to);
+  CheckProgress(1, matrix_from, matrix_to, operations_from, operations_to);
+  CheckProgress(2, matrix_from, matrix_to, operations_from, operations_to);
+}
+
+TEST(TransformOperationTest, BlendWhenTypesDoNotMatch) {
+  double sx1 = 2;
+  double sy1 = 4;
+  double sz1 = 8;
+
+  double dx1 = 1;
+  double dy1 = 2;
+  double dz1 = 3;
+
+  double sx2 = 4;
+  double sy2 = 8;
+  double sz2 = 16;
+
+  double dx2 = 10;
+  double dy2 = 20;
+  double dz2 = 30;
+
+  TransformOperations operations_from;
+  operations_from.AppendScale(sx1, sy1, sz1);
+  operations_from.AppendTranslate(dx1, dy1, dz1);
+
+  TransformOperations operations_to;
+  operations_to.AppendTranslate(dx2, dy2, dz2);
+  operations_to.AppendScale(sx2, sy2, sz2);
+
+  gfx::Transform from;
+  from.Scale3d(sx1, sy1, sz1);
+  from.Translate3d(dx1, dy1, dz1);
+
+  gfx::Transform to;
+  to.Translate3d(dx2, dy2, dz2);
+  to.Scale3d(sx2, sy2, sz2);
+
+  double progress = 0.25;
+
+  gfx::Transform expected = to;
+  expected.Blend(from, progress);
+
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, operations_to.Blend(operations_from, progress));
+}
+
+TEST(TransformOperationTest, LargeRotationsWithSameAxis) {
+  TransformOperations operations_from;
+  operations_from.AppendRotate(0, 0, 1, 0);
+
+  TransformOperations operations_to;
+  operations_to.AppendRotate(0, 0, 2, 360);
+
+  double progress = 0.5;
+
+  gfx::Transform expected;
+  expected.RotateAbout(gfx::Vector3dF(0, 0, 1), 180);
+
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, operations_to.Blend(operations_from, progress));
+}
+
+TEST(TransformOperationTest, LargeRotationsWithSameAxisInDifferentDirection) {
+  TransformOperations operations_from;
+  operations_from.AppendRotate(0, 0, 1, 180);
+
+  TransformOperations operations_to;
+  operations_to.AppendRotate(0, 0, -1, 180);
+
+  double progress = 0.5;
+
+  gfx::Transform expected;
+
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, operations_to.Blend(operations_from, progress));
+}
+
+TEST(TransformOperationTest, LargeRotationsWithDifferentAxes) {
+  TransformOperations operations_from;
+  operations_from.AppendRotate(0, 0, 1, 175);
+
+  TransformOperations operations_to;
+  operations_to.AppendRotate(0, 1, 0, 175);
+
+  double progress = 0.5;
+  gfx::Transform matrix_from;
+  matrix_from.RotateAbout(gfx::Vector3dF(0, 0, 1), 175);
+
+  gfx::Transform matrix_to;
+  matrix_to.RotateAbout(gfx::Vector3dF(0, 1, 0), 175);
+
+  gfx::Transform expected = matrix_to;
+  expected.Blend(matrix_from, progress);
+
+  EXPECT_TRANSFORMATION_MATRIX_EQ(
+      expected, operations_to.Blend(operations_from, progress));
+}
+
+TEST(TransformOperationTest, BlendRotationFromIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendRotate(0, 0, 1, 360);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.RotateAbout(gfx::Vector3dF(0, 0, 1), 180);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, operations.Blend(*identity_operations[i], progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendTranslationFromIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendTranslate(2, 2, 2);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.Translate3d(1, 1, 1);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, operations.Blend(*identity_operations[i], progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendScaleFromIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendScale(3, 3, 3);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.Scale3d(2, 2, 2);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, operations.Blend(*identity_operations[i], progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendSkewFromIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendSkew(2, 2);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.SkewX(1);
+    expected.SkewY(1);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, operations.Blend(*identity_operations[i], progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendPerspectiveFromIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendPerspective(1000);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.ApplyPerspectiveDepth(
+        500 + 0.5 * std::numeric_limits<double>::max());
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, operations.Blend(*identity_operations[i], progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendRotationToIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendRotate(0, 0, 1, 360);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.RotateAbout(gfx::Vector3dF(0, 0, 1), 180);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, identity_operations[i]->Blend(operations, progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendTranslationToIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendTranslate(2, 2, 2);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.Translate3d(1, 1, 1);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, identity_operations[i]->Blend(operations, progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendScaleToIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendScale(3, 3, 3);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.Scale3d(2, 2, 2);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, identity_operations[i]->Blend(operations, progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendSkewToIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendSkew(2, 2);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.SkewX(1);
+    expected.SkewY(1);
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, identity_operations[i]->Blend(operations, progress));
+  }
+}
+
+TEST(TransformOperationTest, BlendPerspectiveToIdentity) {
+  ScopedVector<TransformOperations> identity_operations;
+  GetIdentityOperations(&identity_operations);
+
+  for (size_t i = 0; i < identity_operations.size(); ++i) {
+    TransformOperations operations;
+    operations.AppendPerspective(1000);
+
+    double progress = 0.5;
+
+    gfx::Transform expected;
+    expected.ApplyPerspectiveDepth(
+        500 + 0.5 * std::numeric_limits<double>::max());
+
+    EXPECT_TRANSFORMATION_MATRIX_EQ(
+        expected, identity_operations[i]->Blend(operations, progress));
+  }
+}
+
+}  // namespace
+}  // namespace cc
Index: src/cc/animation_unittest.cc
===================================================================
--- src/cc/animation_unittest.cc (revision 0)
+++ src/cc/animation_unittest.cc (revision 0)
@@ -0,0 +1,218 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/animation.h"
+
+#include "cc/test/animation_test_common.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace cc {
+namespace {
+
+scoped_ptr<Animation> createAnimation(int iterations, double duration)
+{
+    scoped_ptr<Animation> toReturn(Animation::create(make_scoped_ptr(new FakeFloatAnimationCurve(duration)).PassAs<AnimationCurve>(), 0, 1, Animation::Opacity));
+    toReturn->setIterations(iterations);
+    return toReturn.Pass();
+}
+
+scoped_ptr<Animation> createAnimation(int iterations)
+{
+    return createAnimation(iterations, 1);
+}
+
+TEST(AnimationTest, TrimTimeZeroIterations)
+{
+    scoped_ptr<Animation> anim(createAnimation(0));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(-1));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(1));
+}
+
+TEST(AnimationTest, TrimTimeOneIteration)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(-1));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(2));
+}
+
+TEST(AnimationTest, TrimTimeInfiniteIterations)
+{
+    scoped_ptr<Animation> anim(createAnimation(-1));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(1));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1.5));
+}
+
+TEST(AnimationTest, TrimTimeAlternating)
+{
+    scoped_ptr<Animation> anim(createAnimation(-1));
+    anim->setAlternatesDirection(true);
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
+    EXPECT_EQ(0.75, anim->trimTimeToCurrentIteration(1.25));
+}
+
+TEST(AnimationTest, TrimTimeStartTime)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setStartTime(4);
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(4));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(4.5));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(5));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(6));
+}
+
+TEST(AnimationTest, TrimTimeTimeOffset)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setTimeOffset(4);
+    anim->setStartTime(4);
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1));
+}
+
+TEST(AnimationTest, TrimTimePauseResume)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
+    anim->setRunState(Animation::Paused, 0.5);
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
+    anim->setRunState(Animation::Running, 1024);
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1024.5));
+}
+
+TEST(AnimationTest, TrimTimeSuspendResume)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(0.5));
+    anim->suspend(0.5);
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
+    anim->resume(1024);
+    EXPECT_EQ(0.5, anim->trimTimeToCurrentIteration(1024));
+    EXPECT_EQ(1, anim->trimTimeToCurrentIteration(1024.5));
+}
+
+TEST(AnimationTest, TrimTimeZeroDuration)
+{
+    scoped_ptr<Animation> anim(createAnimation(0, 0));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(-1));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(0));
+    EXPECT_EQ(0, anim->trimTimeToCurrentIteration(1));
+}
+
+TEST(AnimationTest, IsFinishedAtZeroIterations)
+{
+    scoped_ptr<Animation> anim(createAnimation(0));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_FALSE(anim->isFinishedAt(-1));
+    EXPECT_TRUE(anim->isFinishedAt(0));
+    EXPECT_TRUE(anim->isFinishedAt(1));
+}
+
+TEST(AnimationTest, IsFinishedAtOneIteration)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_FALSE(anim->isFinishedAt(-1));
+    EXPECT_FALSE(anim->isFinishedAt(0));
+    EXPECT_TRUE(anim->isFinishedAt(1));
+    EXPECT_TRUE(anim->isFinishedAt(2));
+}
+
+TEST(AnimationTest, IsFinishedAtInfiniteIterations)
+{
+    scoped_ptr<Animation> anim(createAnimation(-1));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_FALSE(anim->isFinishedAt(0));
+    EXPECT_FALSE(anim->isFinishedAt(0.5));
+    EXPECT_FALSE(anim->isFinishedAt(1));
+    EXPECT_FALSE(anim->isFinishedAt(1.5));
+}
+
+TEST(AnimationTest, IsFinishedAtNotRunning)
+{
+    scoped_ptr<Animation> anim(createAnimation(0));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_TRUE(anim->isFinishedAt(0));
+    anim->setRunState(Animation::Paused, 0);
+    EXPECT_FALSE(anim->isFinishedAt(0));
+    anim->setRunState(Animation::WaitingForNextTick, 0);
+    EXPECT_FALSE(anim->isFinishedAt(0));
+    anim->setRunState(Animation::WaitingForTargetAvailability, 0);
+    EXPECT_FALSE(anim->isFinishedAt(0));
+    anim->setRunState(Animation::WaitingForStartTime, 0);
+    EXPECT_FALSE(anim->isFinishedAt(0));
+    anim->setRunState(Animation::Finished, 0);
+    EXPECT_TRUE(anim->isFinishedAt(0));
+    anim->setRunState(Animation::Aborted, 0);
+    EXPECT_TRUE(anim->isFinishedAt(0));
+}
+
+TEST(AnimationTest, IsFinished)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::Paused, 0);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::WaitingForNextTick, 0);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::WaitingForTargetAvailability, 0);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::WaitingForStartTime, 0);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::Finished, 0);
+    EXPECT_TRUE(anim->isFinished());
+    anim->setRunState(Animation::Aborted, 0);
+    EXPECT_TRUE(anim->isFinished());
+}
+
+TEST(AnimationTest, IsFinishedNeedsSynchronizedStartTime)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->setRunState(Animation::Running, 2);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::Paused, 2);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::WaitingForNextTick, 2);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::WaitingForTargetAvailability, 2);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::WaitingForStartTime, 2);
+    EXPECT_FALSE(anim->isFinished());
+    anim->setRunState(Animation::Finished, 0);
+    EXPECT_TRUE(anim->isFinished());
+    anim->setRunState(Animation::Aborted, 0);
+    EXPECT_TRUE(anim->isFinished());
+}
+
+TEST(AnimationTest, RunStateChangesIgnoredWhileSuspended)
+{
+    scoped_ptr<Animation> anim(createAnimation(1));
+    anim->suspend(0);
+    EXPECT_EQ(Animation::Paused, anim->runState());
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_EQ(Animation::Paused, anim->runState());
+    anim->resume(0);
+    anim->setRunState(Animation::Running, 0);
+    EXPECT_EQ(Animation::Running, anim->runState());
+}
+
+}  // namespace
+}  // namespace cc
Index: src/cc/top_controls_manager_unittest.cc
===================================================================
--- src/cc/top_controls_manager_unittest.cc (revision 0)
+++ src/cc/top_controls_manager_unittest.cc (revision 0)
@@ -0,0 +1,259 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/top_controls_manager.h"
+
+#include "base/memory/scoped_ptr.h"
+#include "base/time.h"
+#include "cc/layer_impl.h"
+#include "cc/layer_tree_impl.h"
+#include "cc/test/fake_impl_proxy.h"
+#include "cc/test/fake_layer_tree_host_impl.h"
+#include "cc/top_controls_manager_client.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "ui/gfx/vector2d_f.h"
+
+namespace cc {
+namespace {
+
+static const float kTopControlsHeight = 100;
+
+class MockTopControlsManagerClient : public TopControlsManagerClient {
+ public:
+  MockTopControlsManagerClient()
+      : host_impl_(&proxy_),
+        redraw_needed_(false),
+        update_draw_properties_needed_(false) {
+    active_tree_ = LayerTreeImpl::create(&host_impl_);
+    root_scroll_layer_ = LayerImpl::create(active_tree_.get(), 1);
+  }
+
+  virtual ~MockTopControlsManagerClient() {}
+
+  virtual void setNeedsRedraw() OVERRIDE {
+    redraw_needed_ = true;
+  }
+
+  virtual void setActiveTreeNeedsUpdateDrawProperties() OVERRIDE {
+    update_draw_properties_needed_ = true;
+  }
+
+  virtual bool haveRootScrollLayer() const OVERRIDE {
+    return true;
+  }
+
+  virtual float rootScrollLayerTotalScrollY() const OVERRIDE {
+    return root_scroll_layer_->scrollOffset().y() +
+           root_scroll_layer_->scrollDelta().y();
+  }
+
+  LayerImpl* rootScrollLayer() {
+    return root_scroll_layer_.get();
+  }
+
+  TopControlsManager* manager() {
+    if (!manager_)
+      manager_ = TopControlsManager::Create(this, kTopControlsHeight);
+    return manager_.get();
+  }
+
+ private:
+  FakeImplProxy proxy_;
+  FakeLayerTreeHostImpl host_impl_;
+  scoped_ptr<LayerTreeImpl> active_tree_;
+  scoped_ptr<LayerImpl> root_scroll_layer_;
+  scoped_ptr<TopControlsManager> manager_;
+  bool redraw_needed_;
+  bool update_draw_properties_needed_;
+};
+
+TEST(TopControlsManagerTest, overlayModeDetection) {
+  MockTopControlsManagerClient client;
+  TopControlsManager* manager = client.manager();
+  client.rootScrollLayer()->setScrollDelta(gfx::Vector2dF(0.f, 0.f));
+
+  manager->ScrollBegin();
+
+  gfx::Vector2dF remaining_scroll = manager->ScrollBy(
+      gfx::Vector2dF(0.f, 30.f));
+  EXPECT_EQ(0.f, remaining_scroll.y());
+  EXPECT_EQ(-30.f, manager->controls_top_offset());
+  EXPECT_EQ(70.f, manager->content_top_offset());
+  EXPECT_FALSE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, 69.f));
+  EXPECT_EQ(0.f, remaining_scroll.y());
+  EXPECT_EQ(-99.f, manager->controls_top_offset());
+  EXPECT_EQ(1.f, manager->content_top_offset());
+  EXPECT_FALSE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, -20.f));
+  EXPECT_EQ(0.f, remaining_scroll.y());
+  EXPECT_EQ(-79.f, manager->controls_top_offset());
+  EXPECT_EQ(21.f, manager->content_top_offset());
+  EXPECT_FALSE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  // Scroll to the toggle point
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, 21.f));
+  EXPECT_EQ(0.f, remaining_scroll.y());
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_FALSE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, 1.f));
+  EXPECT_EQ(1.f, remaining_scroll.y());
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, -1.f));
+  EXPECT_EQ(-1.f, remaining_scroll.y());
+  EXPECT_EQ(-99.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, -50.f));
+  EXPECT_EQ(-50.f, remaining_scroll.y());
+  EXPECT_EQ(-49.f, manager->controls_top_offset());
+  EXPECT_EQ(50.f, manager->content_top_offset());
+  EXPECT_FALSE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+
+  remaining_scroll = manager->ScrollBy(gfx::Vector2dF(0.f, -50.f));
+  EXPECT_EQ(0.f, manager->controls_top_offset());
+  EXPECT_EQ(100.f, manager->content_top_offset());
+  EXPECT_FALSE(manager->is_overlay_mode());
+  client.rootScrollLayer()->setScrollDelta(
+      client.rootScrollLayer()->scrollDelta() + remaining_scroll);
+}
+
+TEST(TopControlsManagerTest, ensureScrollThresholdApplied) {
+  MockTopControlsManagerClient client;
+  TopControlsManager* manager = client.manager();
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 200));
+
+  manager->ScrollBegin();
+
+  // Scroll down to hide the controls entirely.
+  manager->ScrollBy(gfx::Vector2dF(0.f, 30.f));
+  EXPECT_EQ(-30.f, manager->controls_top_offset());
+  EXPECT_EQ(70.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 230));
+
+  manager->ScrollBy(gfx::Vector2dF(0.f, 30.f));
+  EXPECT_EQ(-60.f, manager->controls_top_offset());
+  EXPECT_EQ(40.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 260));
+
+  manager->ScrollBy(gfx::Vector2dF(0.f, 100.f));
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 360));
+
+  // Scroll back up a bit and ensure the controls don't move until we cross
+  // the threshold.
+  manager->ScrollBy(gfx::Vector2dF(0.f, -10.f));
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 350));
+
+  manager->ScrollBy(gfx::Vector2dF(0.f, -50.f));
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 300));
+
+  // After hitting the threshold, further scrolling up should result in the top
+  // controls showing.
+  manager->ScrollBy(gfx::Vector2dF(0.f, -10.f));
+  EXPECT_EQ(-90.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 290));
+
+  manager->ScrollBy(gfx::Vector2dF(0.f, -50.f));
+  EXPECT_EQ(-40.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 240));
+
+  manager->ScrollEnd();
+}
+
+TEST(TopControlsManagerTest, partialShownHideAnimation) {
+  MockTopControlsManagerClient client;
+  TopControlsManager* manager = client.manager();
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 300));
+  manager->ScrollBy(gfx::Vector2dF(0.f, 300.f));
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 270));
+  manager->ScrollBy(gfx::Vector2dF(0.f, -15.f));
+  EXPECT_EQ(-85.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+
+  manager->ScrollEnd();
+  EXPECT_TRUE(manager->animation());
+
+  base::TimeTicks time = base::TimeTicks::Now();
+  float previous_offset = manager->controls_top_offset();
+  while(manager->animation()) {
+    time = base::TimeDelta::FromMicroseconds(100) + time;
+    manager->Animate(time);
+    EXPECT_LT(manager->controls_top_offset(), previous_offset);
+    previous_offset = manager->controls_top_offset();
+  }
+  EXPECT_FALSE(manager->animation());
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+}
+
+TEST(TopControlsManagerTest, partialShownShowAnimation) {
+  MockTopControlsManagerClient client;
+  TopControlsManager* manager = client.manager();
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 300));
+  manager->ScrollBy(gfx::Vector2dF(0.f, 300.f));
+  EXPECT_EQ(-100.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+
+  client.rootScrollLayer()->setScrollOffset(gfx::Vector2d(0, 230));
+  manager->ScrollBy(gfx::Vector2dF(0.f, -70.f));
+  EXPECT_EQ(-30.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+
+  manager->ScrollEnd();
+  EXPECT_TRUE(manager->animation());
+
+  base::TimeTicks time = base::TimeTicks::Now();
+  float previous_offset = manager->controls_top_offset();
+  while(manager->animation()) {
+    time = base::TimeDelta::FromMicroseconds(100) + time;
+    manager->Animate(time);
+    EXPECT_GT(manager->controls_top_offset(), previous_offset);
+    previous_offset = manager->controls_top_offset();
+  }
+  EXPECT_FALSE(manager->animation());
+  EXPECT_EQ(0.f, manager->controls_top_offset());
+  EXPECT_EQ(0.f, manager->content_top_offset());
+  EXPECT_TRUE(manager->is_overlay_mode());
+}
+
+}  // namespace
+}  // namespace cc
Index: src/cc/layer_animation_value_observer.h
===================================================================
--- src/cc/layer_animation_value_observer.h (revision 0)
+++ src/cc/layer_animation_value_observer.h (revision 0)
@@ -0,0 +1,23 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_LAYER_ANIMATION_VALUE_OBSERVER_H_
+#define CC_LAYER_ANIMATION_VALUE_OBSERVER_H_
+
+namespace cc {
+
+class CC_EXPORT LayerAnimationValueObserver {
+ public:
+  virtual ~LayerAnimationValueObserver() { }
+
+  virtual void OnOpacityAnimated(float) = 0;
+  virtual void OnTransformAnimated(const gfx::Transform&) = 0;
+
+  virtual bool IsActive() const = 0;
+};
+
+} // namespace cc
+
+#endif  // CC_LAYER_ANIMATION_VALUE_OBSERVER_H_
+
Index: src/cc/picture_pile_base.h
===================================================================
--- src/cc/picture_pile_base.h (revision 0)
+++ src/cc/picture_pile_base.h (revision 0)
@@ -0,0 +1,65 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_PICTURE_PILE_BASE_H_
+#define CC_PICTURE_PILE_BASE_H_
+
+#include <list>
+
+#include "base/hash_tables.h"
+#include "base/memory/ref_counted.h"
+#include "cc/cc_export.h"
+#include "cc/hash_pair.h"
+#include "cc/picture.h"
+#include "cc/region.h"
+#include "cc/tiling_data.h"
+#include "ui/gfx/size.h"
+
+namespace cc {
+
+class CC_EXPORT PicturePileBase : public base::RefCounted<PicturePileBase> {
+ public:
+  PicturePileBase();
+
+  void Resize(gfx::Size size);
+  gfx::Size size() const { return tiling_.total_size(); }
+  void SetMinContentsScale(float min_contents_scale);
+
+  void PushPropertiesTo(PicturePileBase* other);
+
+  void UpdateRecordedRegion();
+  const Region& recorded_region() const { return recorded_region_; }
+
+  int num_tiles_x() const { return tiling_.num_tiles_x(); }
+  int num_tiles_y() const { return tiling_.num_tiles_y(); }
+  gfx::Rect tile_bounds(int x, int y) const { return tiling_.TileBounds(x, y); }
+  bool HasRecordingAt(int x, int y);
+
+ protected:
+  virtual ~PicturePileBase();
+
+  int buffer_pixels() const { return tiling_.border_texels(); }
+  void Clear();
+
+  typedef std::pair<int, int> PictureListMapKey;
+  typedef std::list<scoped_refptr<Picture> > PictureList;
+  typedef base::hash_map<PictureListMapKey, PictureList> PictureListMap;
+
+  // A picture pile is a tiled set of picture lists.  The picture list map
+  // is a map of tile indices to picture lists.
+  PictureListMap picture_list_map_;
+  TilingData tiling_;
+  Region recorded_region_;
+  float min_contents_scale_;
+
+ private:
+  void SetBufferPixels(int buffer_pixels);
+
+  friend class base::RefCounted<PicturePileBase>;
+  DISALLOW_COPY_AND_ASSIGN(PicturePileBase);
+};
+
+}  // namespace cc
+
+#endif  // CC_PICTURE_PILE_H_
Index: src/cc/picture_image_layer_impl.h
===================================================================
--- src/cc/picture_image_layer_impl.h (revision 0)
+++ src/cc/picture_image_layer_impl.h (revision 0)
@@ -0,0 +1,39 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_PICTURE_IMAGE_LAYER_IMPL_H_
+#define CC_PICTURE_IMAGE_LAYER_IMPL_H_
+
+#include "cc/picture_layer_impl.h"
+
+namespace cc {
+
+class CC_EXPORT PictureImageLayerImpl : public PictureLayerImpl {
+ public:
+  static scoped_ptr<PictureImageLayerImpl> create(LayerTreeImpl* treeImpl,
+                                                  int id) {
+    return make_scoped_ptr(new PictureImageLayerImpl(treeImpl, id));
+  }
+  virtual ~PictureImageLayerImpl();
+
+  virtual const char* layerTypeAsString() const OVERRIDE;
+  virtual scoped_ptr<LayerImpl> createLayerImpl(
+      LayerTreeImpl* treeImpl) OVERRIDE;
+
+ protected:
+  PictureImageLayerImpl(LayerTreeImpl* treeImpl, int id);
+
+  virtual void CalculateRasterContentsScale(
+      bool animating_transform_to_screen,
+      float* raster_contents_scale,
+      float* low_res_raster_contents_scale) OVERRIDE;
+  virtual void getDebugBorderProperties(
+      SkColor* color, float* width) const OVERRIDE;
+
+  DISALLOW_COPY_AND_ASSIGN(PictureImageLayerImpl);
+};
+
+}
+
+#endif  // CC_PICTURE_IMAGE_LAYER_IMPL_H_
Index: src/cc/animation_registrar.cc
===================================================================
--- src/cc/animation_registrar.cc (revision 0)
+++ src/cc/animation_registrar.cc (revision 0)
@@ -0,0 +1,46 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/animation_registrar.h"
+
+#include "cc/layer_animation_controller.h"
+
+namespace cc {
+
+AnimationRegistrar::AnimationRegistrar() { }
+AnimationRegistrar::~AnimationRegistrar() { }
+
+scoped_refptr<LayerAnimationController>
+AnimationRegistrar::GetAnimationControllerForId(int id)
+{
+    scoped_refptr<LayerAnimationController> toReturn;
+    if (!ContainsKey(all_animation_controllers_, id)) {
+        toReturn = LayerAnimationController::create(id);
+        toReturn->setAnimationRegistrar(this);
+        all_animation_controllers_[id] = toReturn.get();
+    } else
+        toReturn = all_animation_controllers_[id];
+    return toReturn;
+}
+
+void AnimationRegistrar::DidActivateAnimationController(LayerAnimationController* controller) {
+    active_animation_controllers_[controller->id()] = controller;
+}
+
+void AnimationRegistrar::DidDeactivateAnimationController(LayerAnimationController* controller) {
+    if (ContainsKey(active_animation_controllers_, controller->id()))
+        active_animation_controllers_.erase(controller->id());
+}
+
+void AnimationRegistrar::RegisterAnimationController(LayerAnimationController* controller) {
+    all_animation_controllers_[controller->id()] = controller;
+}
+
+void AnimationRegistrar::UnregisterAnimationController(LayerAnimationController* controller) {
+    if (ContainsKey(all_animation_controllers_, controller->id()))
+        all_animation_controllers_.erase(controller->id());
+    DidDeactivateAnimationController(controller);
+}
+
+}  // namespace cc
Index: src/cc/worker_pool.h
===================================================================
--- src/cc/worker_pool.h (revision 0)
+++ src/cc/worker_pool.h (revision 0)
@@ -0,0 +1,164 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_WORKER_POOL_H_
+#define CC_WORKER_POOL_H_
+
+#include <string>
+
+#include "base/basictypes.h"
+#include "base/callback.h"
+#include "base/cancelable_callback.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread.h"
+#include "cc/rendering_stats.h"
+#include "cc/scoped_ptr_deque.h"
+
+namespace cc {
+namespace internal {
+
+class WorkerPoolTask {
+ public:
+  virtual ~WorkerPoolTask();
+
+  virtual void Run() = 0;
+
+  bool HasCompleted();
+  void DidComplete();
+
+  RenderingStats& rendering_stats() { return rendering_stats_; }
+
+ protected:
+  WorkerPoolTask(const base::Closure& reply);
+
+  const base::Closure reply_;
+
+  // Accessed from multiple threads. Set to 1 when task has completed.
+  base::subtle::Atomic32 completed_;
+
+  RenderingStats rendering_stats_;
+};
+
+}  // namespace internal
+
+class CC_EXPORT WorkerPoolClient {
+ public:
+  virtual void DidFinishDispatchingWorkerPoolCompletionCallbacks() = 0;
+
+ protected:
+  virtual ~WorkerPoolClient() {}
+};
+
+// A worker thread pool that runs rendering tasks and guarantees completion
+// of all pending tasks at shutdown.
+class WorkerPool {
+ public:
+  typedef base::Callback<void(RenderingStats*)> Callback;
+
+  virtual ~WorkerPool();
+
+  static scoped_ptr<WorkerPool> Create(
+      WorkerPoolClient* client, size_t num_threads) {
+    return make_scoped_ptr(new WorkerPool(client, num_threads));
+  }
+
+  // Tells the worker pool to shutdown and returns once all pending tasks have
+  // completed.
+  void Shutdown();
+
+  // Posts |task| to worker pool. On completion, |reply|
+  // is posted to the thread that called PostTaskAndReply().
+  void PostTaskAndReply(const Callback& task, const base::Closure& reply);
+
+  // Returns true when worker pool has reached its internal limit for number
+  // of pending tasks.
+  bool IsBusy();
+
+  // Collect rendering stats all completed tasks.
+  void GetRenderingStats(RenderingStats* stats);
+
+ protected:
+  class Worker : public base::Thread {
+   public:
+    Worker(WorkerPool* worker_pool, const std::string name);
+    virtual ~Worker();
+
+    // This must be called before the destructor.
+    void StopAfterCompletingAllPendingTasks();
+
+    // Posts a task to the worker thread.
+    void PostTask(scoped_ptr<internal::WorkerPoolTask> task);
+
+    // Check for completed tasks and run reply callbacks.
+    void CheckForCompletedTasks();
+
+    int num_pending_tasks() const { return pending_tasks_.size(); }
+    const RenderingStats& rendering_stats() const { return rendering_stats_; }
+
+    // Overridden from base::Thread:
+    virtual void Init() OVERRIDE;
+
+   private:
+    static void RunTask(internal::WorkerPoolTask* task,
+                        WorkerPool* worker_pool);
+
+    void OnTaskCompleted();
+
+    WorkerPool* worker_pool_;
+    ScopedPtrDeque<internal::WorkerPoolTask> pending_tasks_;
+    RenderingStats rendering_stats_;
+  };
+
+  WorkerPool(WorkerPoolClient* client, size_t num_threads);
+
+  WorkerPool::Worker* GetWorkerForNextTask();
+
+ private:
+  class NumPendingTasksComparator {
+   public:
+    bool operator() (const Worker* a, const Worker* b) const {
+      return a->num_pending_tasks() < b->num_pending_tasks();
+    }
+  };
+
+  // Schedule a completed tasks check if not already pending.
+  void ScheduleCheckForCompletedTasks();
+
+  // Called on origin thread before posting task to worker.
+  void WillPostTask();
+
+  // Called on worker thread after completing work.
+  void OnWorkCompletedOnWorkerThread();
+
+  // Called on origin thread after becoming idle.
+  void OnIdle();
+
+  // Check for completed tasks and run reply callbacks.
+  void CheckForCompletedTasks();
+
+  // Called when processing task completion.
+  void OnTaskCompleted();
+
+  // Ensure workers are sorted by number of pending tasks.
+  void SortWorkersIfNeeded();
+
+  typedef std::vector<Worker*> WorkerVector;
+  WorkerVector workers_;
+  WorkerPoolClient* client_;
+  scoped_refptr<base::MessageLoopProxy> origin_loop_;
+  base::WeakPtrFactory<WorkerPool> weak_ptr_factory_;
+  bool workers_need_sorting_;
+  bool shutdown_;
+  base::CancelableClosure check_for_completed_tasks_callback_;
+  bool check_for_completed_tasks_pending_;
+  base::Closure idle_callback_;
+  // Accessed from multiple threads. 0 when worker pool is idle.
+  base::subtle::Atomic32 pending_task_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(WorkerPool);
+};
+
+}  // namespace cc
+
+#endif  // CC_WORKER_POOL_H_
Index: src/cc/raster_worker_pool.h
===================================================================
--- src/cc/raster_worker_pool.h (revision 0)
+++ src/cc/raster_worker_pool.h (revision 0)
@@ -0,0 +1,40 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_RASTER_WORKER_POOL_H_
+#define CC_RASTER_WORKER_POOL_H_
+
+#include <string>
+
+#include "cc/worker_pool.h"
+
+namespace cc {
+class PicturePileImpl;
+
+// A worker thread pool that runs raster tasks.
+class RasterWorkerPool : public WorkerPool {
+ public:
+  typedef base::Callback<void(PicturePileImpl*, RenderingStats*)>
+      RasterCallback;
+
+  virtual ~RasterWorkerPool();
+
+  static scoped_ptr<RasterWorkerPool> Create(
+      WorkerPoolClient* client, size_t num_threads) {
+    return make_scoped_ptr(new RasterWorkerPool(client, num_threads));
+  }
+
+  void PostRasterTaskAndReply(PicturePileImpl* picture_pile,
+                              const RasterCallback& task,
+                              const base::Closure& reply);
+
+ private:
+  RasterWorkerPool(WorkerPoolClient* client, size_t num_threads);
+
+  DISALLOW_COPY_AND_ASSIGN(RasterWorkerPool);
+};
+
+}  // namespace cc
+
+#endif  // CC_RASTER_WORKER_POOL_H_
Index: src/cc/layer_tree_host_unittest_animation.cc
===================================================================
--- src/cc/layer_tree_host_unittest_animation.cc (revision 0)
+++ src/cc/layer_tree_host_unittest_animation.cc (revision 0)
@@ -0,0 +1,544 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/layer_tree_host.h"
+
+#include "cc/animation_curve.h"
+#include "cc/layer.h"
+#include "cc/layer_animation_controller.h"
+#include "cc/layer_impl.h"
+#include "cc/test/fake_content_layer.h"
+#include "cc/test/fake_content_layer_client.h"
+#include "cc/test/layer_tree_test_common.h"
+#include "cc/timing_function.h"
+
+namespace cc {
+namespace {
+
+class LayerTreeHostAnimationTest : public ThreadedTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    ThreadedTest::setupTree();
+    m_layerTreeHost->rootLayer()->setLayerAnimationDelegate(this);
+  }
+};
+
+// Makes sure that setNeedsAnimate does not cause the commitRequested() state to
+// be set.
+class LayerTreeHostAnimationTestSetNeedsAnimateShouldNotSetCommitRequested :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestSetNeedsAnimateShouldNotSetCommitRequested()
+      : num_commits_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void animate(base::TimeTicks monotonicTime) OVERRIDE {
+    // We skip the first commit becasue its the commit that populates the
+    // impl thread with a tree. After the second commit, the test is done.
+    if (num_commits_ != 1)
+      return;
+
+    m_layerTreeHost->setNeedsAnimate();
+    // Right now, commitRequested is going to be true, because during
+    // beginFrame, we force commitRequested to true to prevent requests from
+    // hitting the impl thread. But, when the next didCommit happens, we should
+    // verify that commitRequested has gone back to false.
+  }
+
+  virtual void didCommit() OVERRIDE {
+    if (!num_commits_) {
+      EXPECT_FALSE(m_layerTreeHost->commitRequested());
+      m_layerTreeHost->setNeedsAnimate();
+      EXPECT_FALSE(m_layerTreeHost->commitRequested());
+    }
+
+    // Verifies that the setNeedsAnimate we made in ::animate did not
+    // trigger commitRequested.
+    EXPECT_FALSE(m_layerTreeHost->commitRequested());
+    endTest();
+    num_commits_++;
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  int num_commits_;
+};
+
+MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestSetNeedsAnimateShouldNotSetCommitRequested)
+
+// Trigger a frame with setNeedsCommit. Then, inside the resulting animate
+// callback, requet another frame using setNeedsAnimate. End the test when
+// animate gets called yet-again, indicating that the proxy is correctly
+// handling the case where setNeedsAnimate() is called inside the begin frame
+// flow.
+class LayerTreeHostAnimationTestSetNeedsAnimateInsideAnimationCallback :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestSetNeedsAnimateInsideAnimationCallback()
+      : num_animates_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void animate(base::TimeTicks) OVERRIDE {
+    if (!num_animates_) {
+      m_layerTreeHost->setNeedsAnimate();
+      num_animates_++;
+      return;
+    }
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  int num_animates_;
+};
+
+MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestSetNeedsAnimateInsideAnimationCallback)
+
+// Add a layer animation and confirm that LayerTreeHostImpl::animateLayers does
+// get called and continues to get called.
+class LayerTreeHostAnimationTestAddAnimation :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestAddAnimation()
+      : num_animates_(0)
+      , received_animation_started_notification_(false)
+      , start_time_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postAddInstantAnimationToMainThread();
+  }
+
+  virtual void animateLayers(
+      LayerTreeHostImpl* impl_host,
+      base::TimeTicks monotonic_time,
+      bool hasUnfinishedAnimation) OVERRIDE {
+    if (!num_animates_) {
+      // The animation had zero duration so layerTreeHostImpl should no
+      // longer need to animate its layers.
+      EXPECT_FALSE(hasUnfinishedAnimation);
+      num_animates_++;
+      first_monotonic_time_ = monotonic_time;
+      return;
+    }
+    EXPECT_LT(0, start_time_);
+    EXPECT_TRUE(received_animation_started_notification_);
+    endTest();
+  }
+
+  virtual void notifyAnimationStarted(double wall_clock_time) OVERRIDE {
+    received_animation_started_notification_ = true;
+    start_time_ = wall_clock_time;
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+private:
+  int num_animates_;
+  bool received_animation_started_notification_;
+  double start_time_;
+  base::TimeTicks first_monotonic_time_;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostAnimationTestAddAnimation)
+
+// Add a layer animation to a layer, but continually fail to draw. Confirm that
+// after a while, we do eventually force a draw.
+class LayerTreeHostAnimationTestCheckerboardDoesNotStarveDraws :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestCheckerboardDoesNotStarveDraws()
+      : started_animating_(false) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
+  }
+
+  virtual void animateLayers(
+      LayerTreeHostImpl* host_impl,
+      base::TimeTicks monotonicTime,
+      bool hasUnfinishedAnimation) OVERRIDE {
+    started_animating_ = true;
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl*) OVERRIDE {
+    if (started_animating_)
+      endTest();
+  }
+
+  virtual bool prepareToDrawOnThread(
+      LayerTreeHostImpl* host_impl,
+      LayerTreeHostImpl::FrameData& frame,
+      bool result) OVERRIDE {
+    return false;
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  bool started_animating_;
+};
+
+// Starvation can only be an issue with the MT compositor.
+MULTI_THREAD_TEST_F(LayerTreeHostAnimationTestCheckerboardDoesNotStarveDraws)
+
+// Ensures that animations continue to be ticked when we are backgrounded.
+class LayerTreeHostAnimationTestTickAnimationWhileBackgrounded :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestTickAnimationWhileBackgrounded()
+      : num_animates_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
+  }
+
+  // Use willAnimateLayers to set visible false before the animation runs and
+  // causes a commit, so we block the second visible animate in single-thread
+  // mode.
+  virtual void willAnimateLayers(
+      LayerTreeHostImpl* host_impl,
+      base::TimeTicks monotonicTime) OVERRIDE {
+    if (num_animates_ < 2) {
+      if (!num_animates_) {
+        // We have a long animation running. It should continue to tick even
+        // if we are not visible.
+        postSetVisibleToMainThread(false);
+      }
+      num_animates_++;
+      return;
+    }
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  int num_animates_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestTickAnimationWhileBackgrounded)
+
+// Ensures that animations continue to be ticked when we are backgrounded.
+class LayerTreeHostAnimationTestAddAnimationWithTimingFunction :
+    public LayerTreeHostAnimationTest {
+public:
+  LayerTreeHostAnimationTestAddAnimationWithTimingFunction() {}
+
+  virtual void beginTest() OVERRIDE {
+    postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
+  }
+
+  virtual void animateLayers(
+      LayerTreeHostImpl* host_impl,
+      base::TimeTicks monotonicTime,
+      bool hasUnfinishedAnimation) OVERRIDE {
+    LayerAnimationController* controller =
+        m_layerTreeHost->rootLayer()->layerAnimationController();
+    Animation* animation =
+        controller->getAnimation(0, Animation::Opacity);
+    if (!animation)
+      return;
+
+    const FloatAnimationCurve* curve =
+        animation->curve()->toFloatAnimationCurve();
+    float startOpacity = curve->getValue(0);
+    float endOpacity = curve->getValue(curve->duration());
+    float linearly_interpolated_opacity =
+        0.25 * endOpacity + 0.75 * startOpacity;
+    double time = curve->duration() * 0.25;
+    // If the linear timing function associated with this animation was not
+    // picked up, then the linearly interpolated opacity would be different
+    // because of the default ease timing function.
+    EXPECT_FLOAT_EQ(linearly_interpolated_opacity, curve->getValue(time));
+
+    LayerAnimationController* controller_impl =
+        host_impl->rootLayer()->layerAnimationController();
+    Animation* animation_impl =
+        controller_impl->getAnimation(0, Animation::Opacity);
+
+    controller->removeAnimation(animation->id());
+    controller_impl->removeAnimation(animation_impl->id());
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestAddAnimationWithTimingFunction)
+
+// Ensures that main thread animations have their start times synchronized with
+// impl thread animations.
+class LayerTreeHostAnimationTestSynchronizeAnimationStartTimes :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestSynchronizeAnimationStartTimes()
+      : main_start_time_(-1),
+        impl_start_time_(-1) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postAddAnimationToMainThread(m_layerTreeHost->rootLayer());
+  }
+
+  virtual void notifyAnimationStarted(double time) OVERRIDE {
+    LayerAnimationController* controller =
+        m_layerTreeHost->rootLayer()->layerAnimationController();
+    Animation* animation =
+        controller->getAnimation(0, Animation::Opacity);
+    main_start_time_ = animation->startTime();
+    controller->removeAnimation(animation->id());
+
+    if (impl_start_time_ > 0)
+      endTest();
+  }
+
+  virtual void animateLayers(
+      LayerTreeHostImpl* impl_host,
+      base::TimeTicks monotonicTime,
+      bool hasUnfinishedAnimation) OVERRIDE {
+    LayerAnimationController* controller =
+        impl_host->rootLayer()->layerAnimationController();
+    Animation* animation =
+        controller->getAnimation(0, Animation::Opacity);
+    if (!animation)
+      return;
+
+    impl_start_time_ = animation->startTime();
+    controller->removeAnimation(animation->id());
+
+    if (main_start_time_ > 0)
+      endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {
+    EXPECT_FLOAT_EQ(impl_start_time_, main_start_time_);
+  }
+
+ private:
+  double main_start_time_;
+  double impl_start_time_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostAnimationTestSynchronizeAnimationStartTimes)
+
+// Ensures that notifyAnimationFinished is called.
+class LayerTreeHostAnimationTestAnimationFinishedEvents :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestAnimationFinishedEvents() {}
+
+  virtual void beginTest() OVERRIDE {
+    postAddInstantAnimationToMainThread();
+  }
+
+  virtual void notifyAnimationFinished(double time) OVERRIDE {
+    LayerAnimationController* controller =
+        m_layerTreeHost->rootLayer()->layerAnimationController();
+    Animation* animation =
+        controller->getAnimation(0, Animation::Opacity);
+    controller->removeAnimation(animation->id());
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestAnimationFinishedEvents)
+
+// Ensures that when opacity is being animated, this value does not cause the
+// subtree to be skipped.
+class LayerTreeHostAnimationTestDoNotSkipLayersWithAnimatedOpacity :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestDoNotSkipLayersWithAnimatedOpacity()
+      : update_check_layer_(FakeContentLayer::Create(&client_)) {
+  }
+
+  virtual void setupTree() OVERRIDE {
+    update_check_layer_->setOpacity(0);
+    m_layerTreeHost->setRootLayer(update_check_layer_);
+    LayerTreeHostAnimationTest::setupTree();
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postAddAnimationToMainThread(update_check_layer_.get());
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl*) OVERRIDE {
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {
+    // update() should have been called once, proving that the layer was not
+    // skipped.
+    EXPECT_EQ(1, update_check_layer_->update_count());
+
+    // clear update_check_layer_ so LayerTreeHost dies.
+    update_check_layer_ = NULL;
+  }
+
+ private:
+  FakeContentLayerClient client_;
+  scoped_refptr<FakeContentLayer> update_check_layer_;
+};
+
+MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestDoNotSkipLayersWithAnimatedOpacity)
+
+// Layers added to tree with existing active animations should have the
+// animation correctly recognized.
+class LayerTreeHostAnimationTestLayerAddedWithAnimation :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestLayerAddedWithAnimation() { }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didCommit() OVERRIDE {
+    if (m_layerTreeHost->commitNumber() == 1) {
+      scoped_refptr<Layer> layer = Layer::create();
+      layer->setLayerAnimationDelegate(this);
+
+      // Any valid AnimationCurve will do here.
+      scoped_ptr<AnimationCurve> curve(EaseTimingFunction::create());
+      scoped_ptr<Animation> animation(
+          Animation::create(curve.Pass(), 1, 1,
+                                  Animation::Opacity));
+      layer->layerAnimationController()->addAnimation(animation.Pass());
+
+      // We add the animation *before* attaching the layer to the tree.
+      m_layerTreeHost->rootLayer()->addChild(layer);
+    }
+  }
+
+  virtual void animateLayers(
+      LayerTreeHostImpl* impl_host,
+      base::TimeTicks monotonic_time,
+      bool hasUnfinishedAnimation) OVERRIDE {
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostAnimationTestLayerAddedWithAnimation)
+
+class LayerTreeHostAnimationTestCompositeAndReadbackAnimateCount :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestCompositeAndReadbackAnimateCount()
+      : animated_commit_(-1) {
+  }
+
+  virtual void animate(base::TimeTicks) OVERRIDE {
+    // We shouldn't animate on the compositeAndReadback-forced commit, but we
+    // should for the setNeedsCommit-triggered commit.
+    animated_commit_ = m_layerTreeHost->commitNumber();
+    EXPECT_NE(2, animated_commit_);
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didCommit() OVERRIDE {
+    switch (m_layerTreeHost->commitNumber()) {
+      case 1:
+        m_layerTreeHost->setNeedsCommit();
+        break;
+      case 2: {
+        char pixels[4];
+        m_layerTreeHost->compositeAndReadback(&pixels, gfx::Rect(0, 0, 1, 1));
+        break;
+      }
+      case 3:
+        // This is finishing the readback's commit.
+        break;
+      case 4:
+        // This is finishing the followup commit.
+        endTest();
+        break;
+      default:
+        NOTREACHED();
+    }
+  }
+
+  virtual void afterTest() OVERRIDE {
+    EXPECT_EQ(3, animated_commit_);
+  }
+
+ private:
+  int animated_commit_;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostAnimationTestCompositeAndReadbackAnimateCount)
+
+class LayerTreeHostAnimationTestContinuousAnimate :
+    public LayerTreeHostAnimationTest {
+ public:
+  LayerTreeHostAnimationTestContinuousAnimate()
+      : num_commit_complete_(0),
+        num_draw_layers_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void animate(base::TimeTicks) OVERRIDE {
+    if (num_draw_layers_ == 2)
+      return;
+    m_layerTreeHost->setNeedsAnimate();
+  }
+
+  virtual void layout() OVERRIDE {
+    m_layerTreeHost->rootLayer()->setNeedsDisplay();
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl*) OVERRIDE {
+    if (num_draw_layers_ == 1)
+      num_commit_complete_++;
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    num_draw_layers_++;
+    if (num_draw_layers_ == 2)
+      endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {
+    // Check that we didn't commit twice between first and second draw.
+    EXPECT_EQ(1, num_commit_complete_);
+  }
+
+ private:
+  int num_commit_complete_;
+  int num_draw_layers_;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostAnimationTestContinuousAnimate)
+
+}  // namespace
+}  // namespace cc
Index: src/cc/ring_buffer.h
===================================================================
--- src/cc/ring_buffer.h (revision 0)
+++ src/cc/ring_buffer.h (revision 0)
@@ -0,0 +1,55 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_RING_BUFFER_H_
+#define CC_RING_BUFFER_H_
+
+#include "base/logging.h"
+
+namespace cc {
+
+template<typename T, size_t size>
+class RingBuffer {
+ public:
+  explicit RingBuffer()
+    : current_index_(0) {
+  }
+
+  size_t BufferSize() const {
+    return size;
+  }
+
+  size_t CurrentIndex() const {
+    return current_index_;
+  }
+
+  // tests if a value was saved to this index
+  bool IsFilledIndex(size_t n) const {
+    return BufferIndex(n) < current_index_;
+  }
+
+  // n = 0 returns the oldest value and
+  // n = bufferSize() - 1 returns the most recent value.
+  const T& ReadBuffer(size_t n) const {
+    DCHECK(IsFilledIndex(n));
+    return buffer_[BufferIndex(n)];
+  }
+
+  void SaveToBuffer(T value) {
+    buffer_[BufferIndex(0)] = value;
+    current_index_++;
+  }
+
+ private:
+  inline size_t BufferIndex(size_t n) const {
+    return (current_index_ + n) % size;
+  }
+
+  T buffer_[size];
+  size_t current_index_;
+};
+
+}  // namespace cc
+
+#endif  // CC_RING_BUFFER_H_
Index: src/cc/top_controls_manager.cc
===================================================================
--- src/cc/top_controls_manager.cc (revision 0)
+++ src/cc/top_controls_manager.cc (revision 0)
@@ -0,0 +1,212 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/top_controls_manager.h"
+
+#include <algorithm>
+
+#include "base/logging.h"
+#include "base/time.h"
+#include "cc/keyframed_animation_curve.h"
+#include "cc/layer_tree_impl.h"
+#include "cc/timing_function.h"
+#include "cc/top_controls_manager_client.h"
+#include "ui/gfx/transform.h"
+#include "ui/gfx/vector2d_f.h"
+
+namespace cc {
+namespace {
+// These constants were chosen empirically for their visually pleasant behavior.
+// Contact tedchoc@chromium.org for questions about changing these values.
+const float kShowHideThreshold = 0.5f;
+const int64 kShowHideMaxDurationMs = 175;
+}
+
+// static
+scoped_ptr<TopControlsManager> TopControlsManager::Create(
+    TopControlsManagerClient* client, float top_controls_height) {
+  return make_scoped_ptr(new TopControlsManager(client, top_controls_height));
+}
+
+TopControlsManager::TopControlsManager(TopControlsManagerClient* client,
+                                       float top_controls_height)
+    : client_(client),
+      animation_direction_(NO_ANIMATION),
+      is_overlay_mode_(false),
+      in_scroll_gesture_(false),
+      top_controls_height_(top_controls_height),
+      controls_top_offset_(0),
+      content_top_offset_(top_controls_height),
+      previous_root_scroll_offset_(0.f),
+      scroll_start_offset_(0.f) {
+  CHECK(client_);
+}
+
+TopControlsManager::~TopControlsManager() {
+}
+
+void TopControlsManager::UpdateDrawPositions() {
+  if (!client_->haveRootScrollLayer())
+    return;
+
+  // If the scroll position has changed underneath us (i.e. a javascript
+  // scroll), then simulate a scroll that covers the delta.
+  float scroll_total_y = RootScrollLayerTotalScrollY();
+  if (!in_scroll_gesture_
+      && scroll_total_y != previous_root_scroll_offset_) {
+    ScrollBy(gfx::Vector2dF(0, scroll_total_y - previous_root_scroll_offset_));
+    StartAnimationIfNecessary();
+    previous_root_scroll_offset_ = RootScrollLayerTotalScrollY();
+  }
+}
+
+void TopControlsManager::ScrollBegin() {
+  ResetAnimations();
+  in_scroll_gesture_ = true;
+  scroll_start_offset_ = RootScrollLayerTotalScrollY() + controls_top_offset_;
+}
+
+gfx::Vector2dF TopControlsManager::ScrollBy(
+    const gfx::Vector2dF pending_delta) {
+  if (pending_delta.y() == 0)
+    return pending_delta;
+
+  float scroll_total_y = RootScrollLayerTotalScrollY();
+  if (in_scroll_gesture_ &&
+      ((pending_delta.y() > 0 && scroll_total_y < scroll_start_offset_) ||
+       (pending_delta.y() < 0 &&
+           scroll_total_y > scroll_start_offset_ + top_controls_height_))) {
+    return pending_delta;
+  }
+
+  ResetAnimations();
+  return ScrollInternal(pending_delta);
+}
+
+gfx::Vector2dF TopControlsManager::ScrollInternal(
+    const gfx::Vector2dF pending_delta) {
+  float scroll_total_y = RootScrollLayerTotalScrollY();
+  float scroll_delta_y = pending_delta.y();
+
+  float previous_controls_offset = controls_top_offset_;
+  float previous_content_offset = content_top_offset_;
+  bool previous_was_overlay = is_overlay_mode_;
+
+  controls_top_offset_ -= scroll_delta_y;
+  controls_top_offset_ = std::min(
+      std::max(controls_top_offset_, -top_controls_height_), 0.f);
+
+  if (scroll_total_y > 0 || (scroll_total_y == 0
+      && content_top_offset_ < scroll_delta_y)) {
+    is_overlay_mode_ = true;
+
+    // The first case is where the page applies a scroll (javascript) and is
+    // being re-adjusted in a call to UpdateDrawPositions.  Instead of slamming
+    // the controls to the top, we adjust by the scroll delta until we reach
+    // zero as we expect.
+    if (scroll_total_y > 0 && content_top_offset_ != 0)
+      content_top_offset_ -= scroll_delta_y;
+    else
+      content_top_offset_ = 0;
+  } else if (scroll_total_y <= 0 && (scroll_delta_y < 0
+      || (scroll_delta_y > 0 && content_top_offset_ > 0))) {
+    is_overlay_mode_ = false;
+    content_top_offset_ -= scroll_delta_y;
+  }
+  content_top_offset_ = std::max(
+      std::min(content_top_offset_,
+               controls_top_offset_ + top_controls_height_), 0.f);
+
+  gfx::Vector2dF applied_delta;
+  if (!previous_was_overlay)
+    applied_delta.set_y(previous_content_offset - content_top_offset_);
+
+  if (is_overlay_mode_ != previous_was_overlay
+      || previous_controls_offset != controls_top_offset_
+      || previous_content_offset != content_top_offset_) {
+    client_->setNeedsRedraw();
+    client_->setActiveTreeNeedsUpdateDrawProperties();
+  }
+
+  return pending_delta - applied_delta;
+}
+
+void TopControlsManager::ScrollEnd() {
+  StartAnimationIfNecessary();
+  previous_root_scroll_offset_ = RootScrollLayerTotalScrollY();
+  in_scroll_gesture_ = false;
+}
+
+void TopControlsManager::Animate(base::TimeTicks monotonic_time) {
+  if (!top_controls_animation_ || !client_->haveRootScrollLayer())
+    return;
+
+  double time = (monotonic_time - base::TimeTicks()).InMillisecondsF();
+  float new_offset = top_controls_animation_->getValue(time);
+  gfx::Vector2dF scroll_vector(0.f, -(new_offset - controls_top_offset_));
+  ScrollInternal(scroll_vector);
+  client_->setNeedsRedraw();
+
+  if (IsAnimationCompleteAtTime(monotonic_time))
+    ResetAnimations();
+}
+
+void TopControlsManager::ResetAnimations() {
+  if (top_controls_animation_)
+    top_controls_animation_.reset();
+
+  animation_direction_ = NO_ANIMATION;
+}
+
+float TopControlsManager::RootScrollLayerTotalScrollY() {
+  return client_->rootScrollLayerTotalScrollY();
+}
+
+void TopControlsManager::SetupAnimation(AnimationDirection direction) {
+  top_controls_animation_ = KeyframedFloatAnimationCurve::create();
+  double start_time =
+      (base::TimeTicks::Now() - base::TimeTicks()).InMillisecondsF();
+  top_controls_animation_->addKeyframe(
+      FloatKeyframe::create(start_time, controls_top_offset_,
+                            scoped_ptr<TimingFunction>()));
+  float max_ending_offset =
+      (direction == SHOWING_CONTROLS ? 1 : -1) * top_controls_height_;
+  top_controls_animation_->addKeyframe(
+      FloatKeyframe::create(start_time + kShowHideMaxDurationMs,
+                            controls_top_offset_ + max_ending_offset,
+                            EaseTimingFunction::create()));
+  animation_direction_ = direction;
+}
+
+void TopControlsManager::StartAnimationIfNecessary() {
+  float scroll_total_y = RootScrollLayerTotalScrollY();
+
+  if (controls_top_offset_ != 0
+      && controls_top_offset_ != -top_controls_height_) {
+    AnimationDirection show_controls =
+        controls_top_offset_ >= -(top_controls_height_ * kShowHideThreshold) ?
+            SHOWING_CONTROLS : HIDING_CONTROLS;
+    if (!top_controls_animation_ || animation_direction_ != show_controls) {
+      SetupAnimation(show_controls);
+      client_->setNeedsRedraw();
+    }
+  }
+}
+
+bool TopControlsManager::IsAnimationCompleteAtTime(base::TimeTicks time) {
+  if (!top_controls_animation_)
+    return true;
+
+  double time_ms = (time - base::TimeTicks()).InMillisecondsF();
+  float new_offset = top_controls_animation_->getValue(time_ms);
+
+  if ((animation_direction_ == SHOWING_CONTROLS && new_offset >= 0) ||
+      (animation_direction_ == HIDING_CONTROLS
+          && new_offset <= -top_controls_height_)) {
+    return true;
+  }
+  return false;
+}
+
+}  // namespace cc
Index: src/cc/animation.cc
===================================================================
--- src/cc/animation.cc (revision 0)
+++ src/cc/animation.cc (revision 0)
@@ -0,0 +1,208 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/animation.h"
+
+#include <cmath>
+
+#include "base/debug/trace_event.h"
+#include "base/string_util.h"
+#include "cc/animation_curve.h"
+
+namespace {
+
+// This should match the RunState enum.
+static const char* const s_runStateNames[] = {
+    "WaitingForNextTick",
+    "WaitingForTargetAvailability",
+    "WaitingForStartTime",
+    "WaitingForDeletion",
+    "Running",
+    "Paused",
+    "Finished",
+    "Aborted"
+};
+
+COMPILE_ASSERT(static_cast<int>(cc::Animation::RunStateEnumSize) == arraysize(s_runStateNames), RunState_names_match_enum);
+
+// This should match the TargetProperty enum.
+static const char* const s_targetPropertyNames[] = {
+    "Transform",
+    "Opacity"
+};
+
+COMPILE_ASSERT(static_cast<int>(cc::Animation::TargetPropertyEnumSize) == arraysize(s_targetPropertyNames), TargetProperty_names_match_enum);
+
+} // namespace
+
+namespace cc {
+
+scoped_ptr<Animation> Animation::create(scoped_ptr<AnimationCurve> curve, int animationId, int groupId, TargetProperty targetProperty)
+{
+    return make_scoped_ptr(new Animation(curve.Pass(), animationId, groupId, targetProperty));
+}
+
+Animation::Animation(scoped_ptr<AnimationCurve> curve, int animationId, int groupId, TargetProperty targetProperty)
+    : m_curve(curve.Pass())
+    , m_id(animationId)
+    , m_group(groupId)
+    , m_targetProperty(targetProperty)
+    , m_runState(WaitingForTargetAvailability)
+    , m_iterations(1)
+    , m_startTime(0)
+    , m_alternatesDirection(false)
+    , m_timeOffset(0)
+    , m_needsSynchronizedStartTime(false)
+    , m_suspended(false)
+    , m_pauseTime(0)
+    , m_totalPausedTime(0)
+    , m_isControllingInstance(false)
+{
+}
+
+Animation::~Animation()
+{
+    if (m_runState == Running || m_runState == Paused)
+        setRunState(Aborted, 0);
+}
+
+void Animation::setRunState(RunState runState, double monotonicTime)
+{
+    if (m_suspended)
+        return;
+
+    char nameBuffer[256];
+    base::snprintf(nameBuffer, sizeof(nameBuffer), "%s-%d%s", s_targetPropertyNames[m_targetProperty], m_group, m_isControllingInstance ? "(impl)" : "");
+
+    bool isWaitingToStart = m_runState == WaitingForNextTick
+        || m_runState == WaitingForTargetAvailability
+        || m_runState == WaitingForStartTime;
+
+    if (isWaitingToStart && runState == Running)
+        TRACE_EVENT_ASYNC_BEGIN1("cc", "Animation", this, "Name", TRACE_STR_COPY(nameBuffer));
+
+    bool wasFinished = isFinished();
+
+    const char* oldRunStateName = s_runStateNames[m_runState];
+
+    if (runState == Running && m_runState == Paused)
+        m_totalPausedTime += monotonicTime - m_pauseTime;
+    else if (runState == Paused)
+        m_pauseTime = monotonicTime;
+    m_runState = runState;
+
+    const char* newRunStateName = s_runStateNames[runState];
+
+    if (!wasFinished && isFinished())
+        TRACE_EVENT_ASYNC_END0("cc", "Animation", this);
+
+    char stateBuffer[256];
+    base::snprintf(stateBuffer, sizeof(stateBuffer), "%s->%s", oldRunStateName, newRunStateName);
+
+    TRACE_EVENT_INSTANT2("cc", "LayerAnimationController::setRunState", "Name", TRACE_STR_COPY(nameBuffer), "State", TRACE_STR_COPY(stateBuffer));
+}
+
+void Animation::suspend(double monotonicTime)
+{
+    setRunState(Paused, monotonicTime);
+    m_suspended = true;
+}
+
+void Animation::resume(double monotonicTime)
+{
+    m_suspended = false;
+    setRunState(Running, monotonicTime);
+}
+
+bool Animation::isFinishedAt(double monotonicTime) const
+{
+    if (isFinished())
+        return true;
+
+    if (m_needsSynchronizedStartTime)
+        return false;
+
+    return m_runState == Running
+        && m_iterations >= 0
+        && m_iterations * m_curve->duration() <= monotonicTime - startTime() - m_totalPausedTime;
+}
+
+double Animation::trimTimeToCurrentIteration(double monotonicTime) const
+{
+    double trimmed = monotonicTime + m_timeOffset;
+
+    // If we're paused, time is 'stuck' at the pause time.
+    if (m_runState == Paused)
+        trimmed = m_pauseTime;
+
+    // Returned time should always be relative to the start time and should subtract
+    // all time spent paused.
+    trimmed -= m_startTime + m_totalPausedTime;
+
+    // Zero is always the start of the animation.
+    if (trimmed <= 0)
+        return 0;
+
+    // Always return zero if we have no iterations.
+    if (!m_iterations)
+        return 0;
+
+    // Don't attempt to trim if we have no duration.
+    if (m_curve->duration() <= 0)
+        return 0;
+
+    // If less than an iteration duration, just return trimmed.
+    if (trimmed < m_curve->duration())
+        return trimmed;
+
+    // If greater than or equal to the total duration, return iteration duration.
+    if (m_iterations >= 0 && trimmed >= m_curve->duration() * m_iterations) {
+        if (m_alternatesDirection && !(m_iterations % 2))
+            return 0;
+        return m_curve->duration();
+    }
+
+    // We need to know the current iteration if we're alternating.
+    int iteration = static_cast<int>(trimmed / m_curve->duration());
+
+    // Calculate x where trimmed = x + n * m_curve->duration() for some positive integer n.
+    trimmed = fmod(trimmed, m_curve->duration());
+
+    // If we're alternating and on an odd iteration, reverse the direction.
+    if (m_alternatesDirection && iteration % 2 == 1)
+        return m_curve->duration() - trimmed;
+
+    return trimmed;
+}
+
+scoped_ptr<Animation> Animation::clone(InstanceType instanceType) const
+{
+    return cloneAndInitialize(instanceType, m_runState, m_startTime);
+}
+
+scoped_ptr<Animation> Animation::cloneAndInitialize(InstanceType instanceType, RunState initialRunState, double startTime) const
+{
+    scoped_ptr<Animation> toReturn(new Animation(m_curve->clone(), m_id, m_group, m_targetProperty));
+    toReturn->m_runState = initialRunState;
+    toReturn->m_iterations = m_iterations;
+    toReturn->m_startTime = startTime;
+    toReturn->m_pauseTime = m_pauseTime;
+    toReturn->m_totalPausedTime = m_totalPausedTime;
+    toReturn->m_timeOffset = m_timeOffset;
+    toReturn->m_alternatesDirection = m_alternatesDirection;
+    toReturn->m_isControllingInstance = instanceType == ControllingInstance;
+    return toReturn.Pass();
+}
+
+void Animation::pushPropertiesTo(Animation* other) const
+{
+    // Currently, we only push changes due to pausing and resuming animations on the main thread.
+    if (m_runState == Animation::Paused || other->m_runState == Animation::Paused) {
+        other->m_runState = m_runState;
+        other->m_pauseTime = m_pauseTime;
+        other->m_totalPausedTime = m_totalPausedTime;
+    }
+}
+
+}  // namespace cc
Index: src/cc/animation.h
===================================================================
--- src/cc/animation.h (revision 0)
+++ src/cc/animation.h (revision 0)
@@ -0,0 +1,162 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_ANIMATION_H_
+#define CC_ANIMATION_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "cc/cc_export.h"
+
+namespace cc {
+
+class AnimationCurve;
+
+// An Animation, contains all the state required to play an AnimationCurve.
+// Specifically, the affected property, the run state (paused, finished, etc.),
+// loop count, last pause time, and the total time spent paused.
+class CC_EXPORT Animation {
+public:
+    // Animations begin in one of the 'waiting' states. Animations waiting for the next tick
+    // will start the next time the controller animates. Animations waiting for target
+    // availibility will run as soon as their target property is free (and all the animations
+    // animating with it are also able to run). Animations waiting for their start time to
+    // come have be scheduled to run at a particular point in time. When this time arrives,
+    // the controller will move the animations into the Running state. Running animations
+    // may toggle between Running and Paused, and may be stopped by moving into either the
+    // Aborted or Finished states. A Finished animation was allowed to run to completion, but
+    // an Aborted animation was not.
+    enum RunState {
+        WaitingForNextTick = 0,
+        WaitingForTargetAvailability,
+        WaitingForStartTime,
+        WaitingForDeletion,
+        Running,
+        Paused,
+        Finished,
+        Aborted,
+        // This sentinel must be last.
+        RunStateEnumSize
+    };
+
+    enum TargetProperty {
+        Transform = 0,
+        Opacity,
+        // This sentinel must be last.
+        TargetPropertyEnumSize
+    };
+
+    static scoped_ptr<Animation> create(scoped_ptr<AnimationCurve>, int animationId, int groupId, TargetProperty);
+
+    virtual ~Animation();
+
+    int id() const { return m_id; }
+    int group() const { return m_group; }
+    TargetProperty targetProperty() const { return m_targetProperty; }
+
+    RunState runState() const { return m_runState; }
+    void setRunState(RunState, double monotonicTime);
+
+    // This is the number of times that the animation will play. If this
+    // value is zero the animation will not play. If it is negative, then
+    // the animation will loop indefinitely.
+    int iterations() const { return m_iterations; }
+    void setIterations(int n) { m_iterations = n; }
+
+    double startTime() const { return m_startTime; }
+    void setStartTime(double monotonicTime) { m_startTime = monotonicTime; }
+    bool hasSetStartTime() const { return !!m_startTime; }
+
+    double timeOffset() const { return m_timeOffset; }
+    void setTimeOffset(double monotonicTime) { m_timeOffset = monotonicTime; }
+
+    void suspend(double monotonicTime);
+    void resume(double monotonicTime);
+
+    // If alternatesDirection is true, on odd numbered iterations we reverse the curve.
+    bool alternatesDirection() const { return m_alternatesDirection; }
+    void setAlternatesDirection(bool alternates) { m_alternatesDirection = alternates; }
+
+    bool isFinishedAt(double monotonicTime) const;
+    bool isFinished() const { return m_runState == Finished
+                                  || m_runState == Aborted
+                                  || m_runState == WaitingForDeletion; }
+
+    AnimationCurve* curve() { return m_curve.get(); }
+    const AnimationCurve* curve() const { return m_curve.get(); }
+
+    // If this is true, even if the animation is running, it will not be tickable until
+    // it is given a start time. This is true for animations running on the main thread.
+    bool needsSynchronizedStartTime() const { return m_needsSynchronizedStartTime; }
+    void setNeedsSynchronizedStartTime(bool needsSynchronizedStartTime) { m_needsSynchronizedStartTime = needsSynchronizedStartTime; }
+
+    // Takes the given absolute time, and using the start time and the number
+    // of iterations, returns the relative time in the current iteration.
+    double trimTimeToCurrentIteration(double monotonicTime) const;
+
+    enum InstanceType {
+        ControllingInstance = 0,
+        NonControllingInstance
+    };
+
+    scoped_ptr<Animation> clone(InstanceType) const;
+    scoped_ptr<Animation> cloneAndInitialize(InstanceType, RunState initialRunState, double startTime) const;
+    bool isControllingInstance() const { return m_isControllingInstance; }
+
+    void pushPropertiesTo(Animation*) const;
+
+private:
+    Animation(scoped_ptr<AnimationCurve>, int animationId, int groupId, TargetProperty);
+
+    scoped_ptr<AnimationCurve> m_curve;
+
+    // IDs are not necessarily unique.
+    int m_id;
+
+    // Animations that must be run together are called 'grouped' and have the same group id
+    // Grouped animations are guaranteed to start at the same time and no other animations
+    // may animate any of the group's target properties until all animations in the
+    // group have finished animating. Note: an active animation's group id and target
+    // property uniquely identify that animation.
+    int m_group;
+
+    TargetProperty m_targetProperty;
+    RunState m_runState;
+    int m_iterations;
+    double m_startTime;
+    bool m_alternatesDirection;
+
+    // The time offset effectively pushes the start of the animation back in time. This is
+    // used for resuming paused animations -- an animation is added with a non-zero time
+    // offset, causing the animation to skip ahead to the desired point in time.
+    double m_timeOffset;
+
+    bool m_needsSynchronizedStartTime;
+
+    // When an animation is suspended, it behaves as if it is paused and it also ignores
+    // all run state changes until it is resumed. This is used for testing purposes.
+    bool m_suspended;
+
+    // These are used in trimTimeToCurrentIteration to account for time
+    // spent while paused. This is not included in AnimationState since it
+    // there is absolutely no need for clients of this controller to know
+    // about these values.
+    double m_pauseTime;
+    double m_totalPausedTime;
+
+    // Animations lead dual lives. An active animation will be conceptually owned by
+    // two controllers, one on the impl thread and one on the main. In reality, there
+    // will be two separate Animation instances for the same animation. They
+    // will have the same group id and the same target property (these two values
+    // uniquely identify an animation). The instance on the impl thread is the instance
+    // that ultimately controls the values of the animating layer and so we will refer
+    // to it as the 'controlling instance'.
+    bool m_isControllingInstance;
+
+    DISALLOW_COPY_AND_ASSIGN(Animation);
+};
+
+} // namespace cc
+
+#endif  // CC_ANIMATION_H_
Index: src/cc/top_controls_manager.h
===================================================================
--- src/cc/top_controls_manager.h (revision 0)
+++ src/cc/top_controls_manager.h (revision 0)
@@ -0,0 +1,83 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TOP_CONTROLS_MANAGER_H_
+#define CC_TOP_CONTROLS_MANAGER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "cc/layer_impl.h"
+#include "ui/gfx/size.h"
+#include "ui/gfx/vector2d_f.h"
+
+namespace base {
+class TimeTicks;
+}
+
+namespace cc {
+
+class KeyframedFloatAnimationCurve;
+class LayerTreeImpl;
+class TopControlsManagerClient;
+
+// Manages the position of the top controls.
+class CC_EXPORT TopControlsManager {
+ public:
+  enum AnimationDirection {
+    NO_ANIMATION,
+    SHOWING_CONTROLS,
+    HIDING_CONTROLS
+  };
+
+  static scoped_ptr<TopControlsManager> Create(TopControlsManagerClient* client,
+                                               float top_controls_height);
+  virtual ~TopControlsManager();
+
+  float controls_top_offset() { return controls_top_offset_; }
+  float content_top_offset() { return content_top_offset_; }
+  float is_overlay_mode() { return is_overlay_mode_; }
+  KeyframedFloatAnimationCurve* animation() {
+    return top_controls_animation_.get();
+  }
+  AnimationDirection animation_direction() { return animation_direction_; }
+
+  void UpdateDrawPositions();
+
+  void ScrollBegin();
+  gfx::Vector2dF ScrollBy(const gfx::Vector2dF pending_delta);
+  void ScrollEnd();
+
+  void Animate(base::TimeTicks monotonic_time);
+
+ protected:
+  TopControlsManager(TopControlsManagerClient* client,
+                     float top_controls_height);
+
+ private:
+  gfx::Vector2dF ScrollInternal(const gfx::Vector2dF pending_delta);
+  void ResetAnimations();
+  float RootScrollLayerTotalScrollY();
+  void SetupAnimation(AnimationDirection direction);
+  void StartAnimationIfNecessary();
+  bool IsAnimationCompleteAtTime(base::TimeTicks time);
+
+  TopControlsManagerClient* client_;  // The client manages the lifecycle of
+                                      // this.
+
+  scoped_ptr<KeyframedFloatAnimationCurve> top_controls_animation_;
+  AnimationDirection animation_direction_;
+  bool is_overlay_mode_;
+  bool in_scroll_gesture_;
+  float controls_top_offset_;
+  float content_top_offset_;
+  float top_controls_height_;
+  float previous_root_scroll_offset_;
+  float scroll_start_offset_;
+
+  DISALLOW_COPY_AND_ASSIGN(TopControlsManager);
+};
+
+}  // namespace cc
+
+#endif  // CC_TOP_CONTROLS_MANAGER_H_
Index: src/cc/paint_time_counter.h
===================================================================
--- src/cc/paint_time_counter.h (revision 0)
+++ src/cc/paint_time_counter.h (revision 0)
@@ -0,0 +1,40 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_PAINT_TIME_COUNTER_H_
+#define CC_PAINT_TIME_COUNTER_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/time.h"
+#include "cc/ring_buffer.h"
+
+namespace cc {
+
+// Maintains a history of paint times for each frame
+class PaintTimeCounter {
+ public:
+  static scoped_ptr<PaintTimeCounter> create();
+
+  size_t HistorySize() const { return ring_buffer_.BufferSize(); }
+
+  // n = 0 returns the oldest and
+  // n = PaintTimeHistorySize() - 1 the most recent paint time.
+  base::TimeDelta GetPaintTimeOfRecentFrame(const size_t& n) const;
+
+  void SavePaintTime(const base::TimeDelta& total_paint_time);
+  void GetMinAndMaxPaintTime(base::TimeDelta* min, base::TimeDelta* max) const;
+
+ private:
+  PaintTimeCounter();
+
+  RingBuffer<base::TimeDelta, 80> ring_buffer_;
+  base::TimeDelta last_total_paint_time_;
+
+  DISALLOW_COPY_AND_ASSIGN(PaintTimeCounter);
+};
+
+}  // namespace cc
+
+#endif  // CC_PAINT_TIME_COUNTER_H_
Index: src/cc/worker_pool.cc
===================================================================
--- src/cc/worker_pool.cc (revision 0)
+++ src/cc/worker_pool.cc (revision 0)
@@ -0,0 +1,296 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/worker_pool.h"
+
+#include <algorithm>
+
+#include "base/bind.h"
+#include "base/stl_util.h"
+#include "base/stringprintf.h"
+
+#if defined(OS_ANDROID)
+// TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+#include <sys/resource.h>
+#endif
+
+namespace cc {
+
+namespace {
+
+class WorkerPoolTaskImpl : public internal::WorkerPoolTask {
+ public:
+  WorkerPoolTaskImpl(const WorkerPool::Callback& task,
+                     const base::Closure& reply)
+      : internal::WorkerPoolTask(reply),
+        task_(task) {}
+
+  virtual void Run() OVERRIDE {
+    task_.Run(&rendering_stats_);
+    base::subtle::Release_Store(&completed_, 1);
+  }
+
+ private:
+  WorkerPool::Callback task_;
+};
+
+const char* kWorkerThreadNamePrefix = "Compositor";
+
+#if defined(OS_ANDROID)
+const int kNumPendingTasksPerWorker = 8;
+#else
+const int kNumPendingTasksPerWorker = 40;
+#endif
+
+const int kCheckForCompletedTasksDelayMs = 6;
+
+}  // namespace
+
+namespace internal {
+
+WorkerPoolTask::WorkerPoolTask(const base::Closure& reply) : reply_(reply) {
+  base::subtle::Acquire_Store(&completed_, 0);
+}
+
+WorkerPoolTask::~WorkerPoolTask() {
+}
+
+bool WorkerPoolTask::HasCompleted() {
+  return base::subtle::Acquire_Load(&completed_) == 1;
+}
+
+void WorkerPoolTask::DidComplete() {
+  DCHECK_EQ(base::subtle::Acquire_Load(&completed_), 1);
+  reply_.Run();
+}
+
+}  // namespace internal
+
+WorkerPool::Worker::Worker(WorkerPool* worker_pool, const std::string name)
+    : base::Thread(name.c_str()),
+      worker_pool_(worker_pool) {
+  Start();
+  DCHECK(IsRunning());
+}
+
+WorkerPool::Worker::~Worker() {
+  DCHECK(!IsRunning());
+  DCHECK_EQ(pending_tasks_.size(), 0);
+}
+
+void WorkerPool::Worker::StopAfterCompletingAllPendingTasks() {
+  // Signals the thread to exit and returns once all pending tasks have run.
+  Stop();
+
+  // Complete all pending tasks. The Stop() call above guarantees that
+  // all tasks have finished running.
+  while (!pending_tasks_.empty())
+    OnTaskCompleted();
+}
+
+void WorkerPool::Worker::PostTask(scoped_ptr<internal::WorkerPoolTask> task) {
+  worker_pool_->WillPostTask();
+
+  message_loop_proxy()->PostTask(
+      FROM_HERE,
+      base::Bind(&Worker::RunTask,
+                 base::Unretained(task.get()),
+                 base::Unretained(worker_pool_)));
+
+  pending_tasks_.push_back(task.Pass());
+}
+
+void WorkerPool::Worker::Init() {
+#if defined(OS_ANDROID)
+  // TODO(epenner): Move thread priorities to base. (crbug.com/170549)
+  int nice_value = 10; // Idle priority.
+  setpriority(PRIO_PROCESS, base::PlatformThread::CurrentId(), nice_value);
+#endif
+}
+
+// static
+void WorkerPool::Worker::RunTask(
+    internal::WorkerPoolTask* task, WorkerPool* worker_pool) {
+  task->Run();
+  worker_pool->OnWorkCompletedOnWorkerThread();
+}
+
+void WorkerPool::Worker::OnTaskCompleted() {
+  CHECK(!pending_tasks_.empty());
+
+  scoped_ptr<internal::WorkerPoolTask> task = pending_tasks_.take_front();
+
+  // Notify worker pool of task completion.
+  worker_pool_->OnTaskCompleted();
+
+  task->DidComplete();
+
+  rendering_stats_.totalRasterizeTime +=
+      task->rendering_stats().totalRasterizeTime;
+  rendering_stats_.totalPixelsRasterized +=
+      task->rendering_stats().totalPixelsRasterized;
+  rendering_stats_.totalDeferredImageDecodeTime +=
+      task->rendering_stats().totalDeferredImageDecodeTime;
+  rendering_stats_.totalDeferredImageDecodeCount +=
+      task->rendering_stats().totalDeferredImageDecodeCount;
+}
+
+void WorkerPool::Worker::CheckForCompletedTasks() {
+  while (!pending_tasks_.empty()) {
+    if (!pending_tasks_.front()->HasCompleted())
+      return;
+
+    OnTaskCompleted();
+  }
+}
+
+WorkerPool::WorkerPool(WorkerPoolClient* client, size_t num_threads)
+    : client_(client),
+      origin_loop_(base::MessageLoopProxy::current()),
+      weak_ptr_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
+      workers_need_sorting_(false),
+      pending_task_count_(0),
+      shutdown_(false),
+      check_for_completed_tasks_pending_(false),
+      idle_callback_(
+          base::Bind(&WorkerPool::OnIdle, weak_ptr_factory_.GetWeakPtr())) {
+  const std::string thread_name_prefix = kWorkerThreadNamePrefix;
+  while (workers_.size() < num_threads) {
+    int thread_number = workers_.size() + 1;
+    workers_.push_back(
+        new Worker(this,
+                   thread_name_prefix +
+                   StringPrintf("Worker%d", thread_number).c_str()));
+  }
+  base::subtle::Acquire_Store(&pending_task_count_, 0);
+}
+
+WorkerPool::~WorkerPool() {
+  Shutdown();
+  STLDeleteElements(&workers_);
+  // Cancel all pending callbacks.
+  weak_ptr_factory_.InvalidateWeakPtrs();
+  DCHECK_EQ(base::subtle::Acquire_Load(&pending_task_count_), 0);
+}
+
+void WorkerPool::Shutdown() {
+  DCHECK(!shutdown_);
+  shutdown_ = true;
+
+  for (WorkerVector::iterator it = workers_.begin();
+       it != workers_.end(); it++) {
+    Worker* worker = *it;
+    worker->StopAfterCompletingAllPendingTasks();
+  }
+}
+
+void WorkerPool::PostTaskAndReply(
+    const Callback& task, const base::Closure& reply) {
+  Worker* worker = GetWorkerForNextTask();
+
+  worker->PostTask(
+      make_scoped_ptr(new WorkerPoolTaskImpl(
+                          task,
+                          reply)).PassAs<internal::WorkerPoolTask>());
+}
+
+bool WorkerPool::IsBusy() {
+  Worker* worker = GetWorkerForNextTask();
+
+  return worker->num_pending_tasks() >= kNumPendingTasksPerWorker;
+}
+
+void WorkerPool::GetRenderingStats(RenderingStats* stats) {
+  stats->totalRasterizeTime = base::TimeDelta();
+  stats->totalPixelsRasterized = 0;
+  stats->totalDeferredImageDecodeCount = 0;
+  stats->totalDeferredImageDecodeTime = base::TimeDelta();
+  for (WorkerVector::iterator it = workers_.begin();
+       it != workers_.end(); ++it) {
+    Worker* worker = *it;
+    stats->totalRasterizeTime +=
+        worker->rendering_stats().totalRasterizeTime;
+    stats->totalPixelsRasterized +=
+        worker->rendering_stats().totalPixelsRasterized;
+    stats->totalDeferredImageDecodeCount +=
+        worker->rendering_stats().totalDeferredImageDecodeCount;
+    stats->totalDeferredImageDecodeTime +=
+        worker->rendering_stats().totalDeferredImageDecodeTime;
+  }
+}
+
+WorkerPool::Worker* WorkerPool::GetWorkerForNextTask() {
+  CHECK(!shutdown_);
+  SortWorkersIfNeeded();
+  return workers_.front();
+}
+
+void WorkerPool::ScheduleCheckForCompletedTasks() {
+  if (check_for_completed_tasks_pending_)
+    return;
+
+  check_for_completed_tasks_callback_.Reset(
+      base::Bind(&WorkerPool::CheckForCompletedTasks,
+                 weak_ptr_factory_.GetWeakPtr()));
+  origin_loop_->PostDelayedTask(
+      FROM_HERE,
+      check_for_completed_tasks_callback_.callback(),
+      base::TimeDelta::FromMilliseconds(kCheckForCompletedTasksDelayMs));
+  check_for_completed_tasks_pending_ = true;
+}
+
+void WorkerPool::WillPostTask() {
+  base::subtle::Barrier_AtomicIncrement(&pending_task_count_, 1);
+  ScheduleCheckForCompletedTasks();
+  workers_need_sorting_ = true;
+}
+
+void WorkerPool::OnWorkCompletedOnWorkerThread() {
+  // Post idle handler task when pool work count reaches 0.
+  if (base::subtle::Barrier_AtomicIncrement(&pending_task_count_, -1) == 0) {
+    origin_loop_->PostTask(FROM_HERE, idle_callback_);
+  }
+}
+
+void WorkerPool::OnIdle() {
+  if (base::subtle::Acquire_Load(&pending_task_count_) == 0) {
+    check_for_completed_tasks_callback_.Cancel();
+    CheckForCompletedTasks();
+  }
+}
+
+void WorkerPool::CheckForCompletedTasks() {
+  check_for_completed_tasks_pending_ = false;
+
+  for (WorkerVector::iterator it = workers_.begin();
+       it != workers_.end(); it++) {
+    Worker* worker = *it;
+    worker->CheckForCompletedTasks();
+  }
+
+  client_->DidFinishDispatchingWorkerPoolCompletionCallbacks();
+
+  for (WorkerVector::iterator it = workers_.begin();
+       it != workers_.end(); it++) {
+    Worker* worker = *it;
+    if (worker->num_pending_tasks()) {
+      ScheduleCheckForCompletedTasks();
+      break;
+    }
+  }
+}
+
+void WorkerPool::OnTaskCompleted() {
+  workers_need_sorting_ = true;
+}
+
+void WorkerPool::SortWorkersIfNeeded() {
+  if (!workers_need_sorting_)
+    return;
+
+  std::sort(workers_.begin(), workers_.end(), NumPendingTasksComparator());
+  workers_need_sorting_ = false;
+}
+
+}  // namespace cc
Index: src/cc/raster_worker_pool.cc
===================================================================
--- src/cc/raster_worker_pool.cc (revision 0)
+++ src/cc/raster_worker_pool.cc (revision 0)
@@ -0,0 +1,59 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/raster_worker_pool.h"
+
+#include "cc/picture_pile_impl.h"
+
+namespace cc {
+
+namespace {
+
+class RasterWorkerPoolTaskImpl : public internal::WorkerPoolTask {
+ public:
+  RasterWorkerPoolTaskImpl(PicturePileImpl* picture_pile,
+                           const RasterWorkerPool::RasterCallback& task,
+                           const base::Closure& reply)
+      : internal::WorkerPoolTask(reply),
+        picture_pile_(picture_pile),
+        task_(task) {
+    DCHECK(picture_pile_);
+  }
+
+  virtual void Run() OVERRIDE {
+    task_.Run(picture_pile_.get(), &rendering_stats_);
+    base::subtle::Release_Store(&completed_, 1);
+  }
+
+ private:
+  scoped_refptr<PicturePileImpl> picture_pile_;
+  RasterWorkerPool::RasterCallback task_;
+};
+
+}  // namespace
+
+RasterWorkerPool::RasterWorkerPool(
+    WorkerPoolClient* client, size_t num_threads)
+    : WorkerPool(client, num_threads) {
+}
+
+RasterWorkerPool::~RasterWorkerPool() {
+}
+
+void RasterWorkerPool::PostRasterTaskAndReply(PicturePileImpl* picture_pile,
+                                              const RasterCallback& task,
+                                              const base::Closure& reply) {
+  Worker* worker = GetWorkerForNextTask();
+
+  scoped_refptr<PicturePileImpl> picture_pile_clone =
+      picture_pile->GetCloneForDrawingOnThread(worker);
+
+  worker->PostTask(
+      make_scoped_ptr(new RasterWorkerPoolTaskImpl(
+                          picture_pile_clone.get(),
+                          task,
+                          reply)).PassAs<internal::WorkerPoolTask>());
+}
+
+}  // namespace cc
Index: src/cc/delegating_renderer_unittest.cc
===================================================================
--- src/cc/delegating_renderer_unittest.cc (revision 0)
+++ src/cc/delegating_renderer_unittest.cc (revision 0)
@@ -0,0 +1,135 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/delegating_renderer.h"
+
+#include "cc/test/fake_output_surface.h"
+#include "cc/test/layer_tree_test_common.h"
+#include "cc/test/render_pass_test_common.h"
+#include "cc/test/render_pass_test_utils.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace cc {
+
+class DelegatingRendererTest : public ThreadedTest {
+ public:
+  DelegatingRendererTest() : ThreadedTest(), output_surface_(NULL) {}
+  virtual ~DelegatingRendererTest() {}
+
+  virtual scoped_ptr<OutputSurface> createOutputSurface() OVERRIDE {
+    scoped_ptr<FakeWebGraphicsContext3D> context3d =
+        FakeWebGraphicsContext3D::Create(
+            WebKit::WebGraphicsContext3D::Attributes());
+    context3d_ = context3d.get();
+    scoped_ptr<FakeOutputSurface> output_surface =
+        FakeOutputSurface::CreateDelegating3d(
+            context3d.PassAs<WebKit::WebGraphicsContext3D>());
+    output_surface_ = output_surface.get();
+    return output_surface.PassAs<OutputSurface>();
+  }
+
+ protected:
+  FakeWebGraphicsContext3D* context3d_;
+  FakeOutputSurface* output_surface_;
+};
+
+class DelegatingRendererTestDraw : public DelegatingRendererTest {
+ public:
+  virtual void beginTest() OVERRIDE {
+    m_layerTreeHost->setPageScaleFactorAndLimits(1.f, 0.5f, 4.f);
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+  virtual bool prepareToDrawOnThread(
+      LayerTreeHostImpl*, LayerTreeHostImpl::FrameData& frame, bool result)
+      OVERRIDE {
+    EXPECT_EQ(0u, output_surface_->num_sent_frames());
+
+    CompositorFrame& last_frame = output_surface_->last_sent_frame();
+    EXPECT_FALSE(last_frame.delegated_frame_data);
+    EXPECT_FALSE(last_frame.gl_frame_data);
+    EXPECT_EQ(0.f, last_frame.metadata.min_page_scale_factor);
+    EXPECT_EQ(0.f, last_frame.metadata.max_page_scale_factor);
+    return true;
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* host_impl) OVERRIDE {
+    EXPECT_EQ(1u, output_surface_->num_sent_frames());
+
+    CompositorFrame& last_frame = output_surface_->last_sent_frame();
+    ASSERT_TRUE(last_frame.delegated_frame_data);
+    EXPECT_FALSE(last_frame.gl_frame_data);
+    EXPECT_EQ(
+        host_impl->deviceViewportSize().ToString(),
+        last_frame.delegated_frame_data->size.ToString());
+    EXPECT_EQ(0.5f, last_frame.metadata.min_page_scale_factor);
+    EXPECT_EQ(4.f, last_frame.metadata.max_page_scale_factor);
+
+    EXPECT_EQ(
+        0u, last_frame.delegated_frame_data->resource_list.resources.size());
+    EXPECT_EQ(1u, last_frame.delegated_frame_data->render_pass_list.size());
+
+    endTest();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(DelegatingRendererTestDraw)
+
+class DelegatingRendererTestResources : public DelegatingRendererTest {
+ public:
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+  virtual bool prepareToDrawOnThread(
+      LayerTreeHostImpl* host_impl,
+      LayerTreeHostImpl::FrameData& frame,
+      bool result) OVERRIDE {
+
+    frame.renderPasses.clear();
+    frame.renderPassesById.clear();
+
+    TestRenderPass* child_pass = addRenderPass(
+        frame.renderPasses,
+        RenderPass::Id(2, 1),
+        gfx::Rect(3, 3, 10, 10),
+        gfx::Transform());
+    child_pass->AppendOneOfEveryQuadType(
+        host_impl->resourceProvider(), RenderPass::Id(0, 0));
+
+    TestRenderPass* pass = addRenderPass(
+        frame.renderPasses,
+        RenderPass::Id(1, 1),
+        gfx::Rect(3, 3, 10, 10),
+        gfx::Transform());
+    pass->AppendOneOfEveryQuadType(
+        host_impl->resourceProvider(), child_pass->id);
+    return true;
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* host_impl) OVERRIDE {
+    EXPECT_EQ(1u, output_surface_->num_sent_frames());
+
+    CompositorFrame& last_frame = output_surface_->last_sent_frame();
+    ASSERT_TRUE(last_frame.delegated_frame_data);
+
+    EXPECT_EQ(2u, last_frame.delegated_frame_data->render_pass_list.size());
+    // Each render pass has 7 resources in it. And the root render pass has a
+    // mask resource used when drawing the child render pass. The number 7 may
+    // change if AppendOneOfEveryQuadType is updated, and the value here should
+    // be updated accordingly.
+    EXPECT_EQ(
+        15u, last_frame.delegated_frame_data->resource_list.resources.size());
+
+    endTest();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(DelegatingRendererTestResources)
+
+}  // namespace cc
Index: src/cc/memory_history.h
===================================================================
--- src/cc/memory_history.h (revision 0)
+++ src/cc/memory_history.h (revision 0)
@@ -0,0 +1,57 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_MEMORY_HISTORY_H_
+#define CC_MEMORY_HISTORY_H_
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/time.h"
+#include "cc/ring_buffer.h"
+
+namespace cc {
+
+// Maintains a history of memory for each frame
+class MemoryHistory {
+ public:
+  static scoped_ptr<MemoryHistory> create();
+
+  size_t HistorySize() const { return ring_buffer_.BufferSize(); }
+
+  struct Entry {
+  Entry()
+      : total_budget_in_bytes(0),
+        bytes_allocated(0),
+        bytes_unreleasable(0),
+        bytes_over(0) { }
+
+      size_t total_budget_in_bytes;
+      size_t bytes_allocated;
+      size_t bytes_unreleasable;
+      size_t bytes_over;
+      size_t bytes_total() const {
+          return bytes_allocated +
+              bytes_unreleasable +
+              bytes_over;
+      }
+  };
+
+  // n = 0 returns the oldest and
+  // n = HistorySize() - 1 the most recent paint time.
+  Entry GetEntry(const size_t& n) const;
+
+  void SaveEntry(const Entry& entry);
+  void GetMinAndMax(size_t* min, size_t* max) const;
+
+ private:
+  MemoryHistory();
+
+  RingBuffer<Entry, 80> ring_buffer_;
+
+  DISALLOW_COPY_AND_ASSIGN(MemoryHistory);
+};
+
+}  // namespace cc
+
+#endif  // CC_MEMORY_HISTORY_H_
Index: src/cc/layer_tree_host_unittest_scroll.cc
===================================================================
--- src/cc/layer_tree_host_unittest_scroll.cc (revision 0)
+++ src/cc/layer_tree_host_unittest_scroll.cc (revision 0)
@@ -0,0 +1,665 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/layer_tree_host.h"
+
+#include "cc/content_layer.h"
+#include "cc/layer.h"
+#include "cc/layer_impl.h"
+#include "cc/layer_tree_impl.h"
+#include "cc/test/fake_content_layer_client.h"
+#include "cc/test/geometry_test_utils.h"
+#include "cc/test/layer_tree_test_common.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebLayerScrollClient.h"
+#include "ui/gfx/point_conversions.h"
+#include "ui/gfx/size_conversions.h"
+#include "ui/gfx/vector2d_conversions.h"
+
+namespace cc {
+namespace {
+
+class LayerTreeHostScrollTest : public ThreadedTest {};
+
+class LayerTreeHostScrollTestScrollSimple : public LayerTreeHostScrollTest {
+ public:
+  LayerTreeHostScrollTestScrollSimple()
+      : initial_scroll_(10, 20),
+        second_scroll_(40, 5),
+        scroll_amount_(2, -1),
+        num_scrolls_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    m_layerTreeHost->rootLayer()->setScrollable(true);
+    m_layerTreeHost->rootLayer()->setScrollOffset(initial_scroll_);
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void layout() OVERRIDE {
+    Layer* root = m_layerTreeHost->rootLayer();
+    if (!m_layerTreeHost->commitNumber())
+      EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+    else {
+      EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_ + scroll_amount_);
+
+      // Pretend like Javascript updated the scroll position itself.
+      root->setScrollOffset(second_scroll_);
+    }
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    LayerImpl* root = impl->rootLayer();
+    EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
+
+    root->setScrollable(true);
+    root->setMaxScrollOffset(gfx::Vector2d(100, 100));
+    root->scrollBy(scroll_amount_);
+
+    switch (impl->activeTree()->source_frame_number()) {
+      case 0:
+        EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+        EXPECT_VECTOR_EQ(root->scrollDelta(), scroll_amount_);
+        postSetNeedsCommitToMainThread();
+        break;
+      case 1:
+        EXPECT_VECTOR_EQ(root->scrollOffset(), second_scroll_);
+        EXPECT_VECTOR_EQ(root->scrollDelta(), scroll_amount_);
+        endTest();
+        break;
+    }
+  }
+
+  virtual void applyScrollAndScale(
+      gfx::Vector2d scroll_delta, float scale) OVERRIDE {
+    gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
+    m_layerTreeHost->rootLayer()->setScrollOffset(offset + scroll_delta);
+    num_scrolls_++;
+  }
+
+  virtual void afterTest() OVERRIDE {
+    EXPECT_EQ(1, num_scrolls_);
+  }
+
+ private:
+  gfx::Vector2d initial_scroll_;
+  gfx::Vector2d second_scroll_;
+  gfx::Vector2d scroll_amount_;
+  int num_scrolls_;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostScrollTestScrollSimple)
+
+class LayerTreeHostScrollTestScrollMultipleRedraw :
+    public LayerTreeHostScrollTest {
+ public:
+  LayerTreeHostScrollTestScrollMultipleRedraw()
+      : initial_scroll_(40, 10),
+        scroll_amount_(-3, 17),
+        num_scrolls_(0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    m_layerTreeHost->rootLayer()->setScrollable(true);
+    m_layerTreeHost->rootLayer()->setScrollOffset(initial_scroll_);
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void beginCommitOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    Layer* root = m_layerTreeHost->rootLayer();
+    switch (m_layerTreeHost->commitNumber()) {
+      case 0:
+        EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+        break;
+      case 1:
+        EXPECT_VECTOR_EQ(
+            root->scrollOffset(),
+            initial_scroll_ + scroll_amount_ + scroll_amount_);
+      case 2:
+        EXPECT_VECTOR_EQ(
+            root->scrollOffset(),
+            initial_scroll_ + scroll_amount_ + scroll_amount_);
+        break;
+    }
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    LayerImpl* root = impl->rootLayer();
+    root->setScrollable(true);
+    root->setMaxScrollOffset(gfx::Vector2d(100, 100));
+
+    if (impl->activeTree()->source_frame_number() == 0 &&
+        impl->sourceAnimationFrameNumber() == 1) {
+      // First draw after first commit.
+      EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
+      root->scrollBy(scroll_amount_);
+      EXPECT_VECTOR_EQ(root->scrollDelta(), scroll_amount_);
+
+      EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+      postSetNeedsRedrawToMainThread();
+    } else if (impl->activeTree()->source_frame_number() == 0 &&
+               impl->sourceAnimationFrameNumber() == 2) {
+      // Second draw after first commit.
+      EXPECT_EQ(root->scrollDelta(), scroll_amount_);
+      root->scrollBy(scroll_amount_);
+      EXPECT_VECTOR_EQ(root->scrollDelta(), scroll_amount_ + scroll_amount_);
+
+      EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+      postSetNeedsCommitToMainThread();
+    } else if (impl->activeTree()->source_frame_number() == 1) {
+      // Third or later draw after second commit.
+      EXPECT_GE(impl->sourceAnimationFrameNumber(), 3);
+      EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
+      EXPECT_VECTOR_EQ(
+          root->scrollOffset(),
+          initial_scroll_ + scroll_amount_ + scroll_amount_);
+      endTest();
+    }
+  }
+
+  virtual void applyScrollAndScale(
+      gfx::Vector2d scroll_delta, float scale) OVERRIDE {
+    gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
+    m_layerTreeHost->rootLayer()->setScrollOffset(offset + scroll_delta);
+    num_scrolls_++;
+  }
+
+  virtual void afterTest() OVERRIDE {
+    EXPECT_EQ(1, num_scrolls_);
+  }
+ private:
+  gfx::Vector2d initial_scroll_;
+  gfx::Vector2d scroll_amount_;
+  int num_scrolls_;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostScrollTestScrollMultipleRedraw)
+
+class LayerTreeHostScrollTestFractionalScroll : public LayerTreeHostScrollTest {
+ public:
+  LayerTreeHostScrollTestFractionalScroll()
+      : scroll_amount_(1.75, 0) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    m_layerTreeHost->rootLayer()->setScrollable(true);
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    LayerImpl* root = impl->rootLayer();
+    root->setMaxScrollOffset(gfx::Vector2d(100, 100));
+
+    // Check that a fractional scroll delta is correctly accumulated over
+    // multiple commits.
+    switch (impl->activeTree()->source_frame_number()) {
+      case 0:
+        EXPECT_VECTOR_EQ(root->scrollOffset(), gfx::Vector2d(0, 0));
+        EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d(0, 0));
+        postSetNeedsCommitToMainThread();
+        break;
+      case 1:
+        EXPECT_VECTOR_EQ(
+            root->scrollOffset(),
+            gfx::ToFlooredVector2d(scroll_amount_));
+        EXPECT_VECTOR_EQ(
+            root->scrollDelta(),
+            gfx::Vector2dF(fmod(scroll_amount_.x(), 1.0f), 0.0f));
+        postSetNeedsCommitToMainThread();
+        break;
+      case 2:
+        EXPECT_VECTOR_EQ(
+            root->scrollOffset(),
+            gfx::ToFlooredVector2d(scroll_amount_ + scroll_amount_));
+        EXPECT_VECTOR_EQ(
+            root->scrollDelta(),
+            gfx::Vector2dF(fmod(2.0f * scroll_amount_.x(), 1.0f), 0.0f));
+        endTest();
+        break;
+    }
+    root->scrollBy(scroll_amount_);
+  }
+
+  virtual void applyScrollAndScale(
+      gfx::Vector2d scroll_delta, float scale) OVERRIDE {
+    gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
+    m_layerTreeHost->rootLayer()->setScrollOffset(offset + scroll_delta);
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  gfx::Vector2dF scroll_amount_;
+};
+
+TEST_F(LayerTreeHostScrollTestFractionalScroll, runMultiThread)
+{
+    runTest(true);
+}
+
+class LayerTreeHostScrollTestCaseWithChild :
+    public LayerTreeHostScrollTest,
+    public WebKit::WebLayerScrollClient {
+ public:
+  LayerTreeHostScrollTestCaseWithChild()
+      : initial_offset_(10, 20),
+        javascript_scroll_(40, 5),
+        scroll_amount_(2, -1),
+        num_scrolls_(0) {
+  }
+
+  virtual void setupTree() OVERRIDE {
+    m_layerTreeHost->setDeviceScaleFactor(device_scale_factor_);
+
+    scoped_refptr<Layer> root_layer = Layer::create();
+    root_layer->setBounds(gfx::Size(10, 10));
+
+    root_scroll_layer_ = ContentLayer::create(&fake_content_layer_client_);
+    root_scroll_layer_->setBounds(gfx::Size(110, 110));
+
+    root_scroll_layer_->setPosition(gfx::Point(0, 0));
+    root_scroll_layer_->setAnchorPoint(gfx::PointF());
+
+    root_scroll_layer_->setIsDrawable(true);
+    root_scroll_layer_->setScrollable(true);
+    root_scroll_layer_->setMaxScrollOffset(gfx::Vector2d(100, 100));
+    root_layer->addChild(root_scroll_layer_);
+
+    child_layer_ = ContentLayer::create(&fake_content_layer_client_);
+    child_layer_->setLayerScrollClient(this);
+    child_layer_->setBounds(gfx::Size(110, 110));
+
+    // Scrolls on the child layer will happen at 5, 5. If they are treated
+    // like device pixels, and device scale factor is 2, then they will
+    // be considered at 2.5, 2.5 in logical pixels, and will miss this layer.
+    child_layer_->setPosition(gfx::Point(5, 5));
+    child_layer_->setAnchorPoint(gfx::PointF());
+
+    child_layer_->setIsDrawable(true);
+    child_layer_->setScrollable(true);
+    child_layer_->setMaxScrollOffset(gfx::Vector2d(100, 100));
+    root_scroll_layer_->addChild(child_layer_);
+
+    if (scroll_child_layer_) {
+      expected_scroll_layer_ = child_layer_;
+      expected_no_scroll_layer_ = root_scroll_layer_;
+    } else {
+      expected_scroll_layer_ = root_scroll_layer_;
+      expected_no_scroll_layer_ = child_layer_;
+    }
+
+    expected_scroll_layer_->setScrollOffset(initial_offset_);
+
+    m_layerTreeHost->setRootLayer(root_layer);
+    LayerTreeHostScrollTest::setupTree();
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didScroll() OVERRIDE {
+    final_scroll_offset_ = expected_scroll_layer_->scrollOffset();
+  }
+
+  virtual void applyScrollAndScale(
+      gfx::Vector2d scroll_delta, float scale) OVERRIDE {
+    gfx::Vector2d offset = root_scroll_layer_->scrollOffset();
+    root_scroll_layer_->setScrollOffset(offset + scroll_delta);
+    num_scrolls_++;
+  }
+
+  virtual void layout() OVERRIDE {
+    EXPECT_VECTOR_EQ(
+        gfx::Vector2d(), expected_no_scroll_layer_->scrollOffset());
+
+    switch (m_layerTreeHost->commitNumber()) {
+      case 0:
+        EXPECT_VECTOR_EQ(
+            initial_offset_,
+            expected_scroll_layer_->scrollOffset());
+        break;
+      case 1:
+        EXPECT_VECTOR_EQ(
+            initial_offset_ + scroll_amount_,
+            expected_scroll_layer_->scrollOffset());
+
+        // Pretend like Javascript updated the scroll position itself.
+        expected_scroll_layer_->setScrollOffset(javascript_scroll_);
+        break;
+      case 2:
+        EXPECT_VECTOR_EQ(
+            javascript_scroll_ + scroll_amount_,
+            expected_scroll_layer_->scrollOffset());
+        break;
+    }
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    LayerImpl* root_impl = impl->rootLayer();
+    LayerImpl* root_scroll_layer_impl = root_impl->children()[0];
+    LayerImpl* child_layer_impl = root_scroll_layer_impl->children()[0];
+
+    LayerImpl* expected_scroll_layer_impl = NULL;
+    LayerImpl* expected_no_scroll_layer_impl = NULL;
+    if (scroll_child_layer_) {
+      expected_scroll_layer_impl = child_layer_impl;
+      expected_no_scroll_layer_impl = root_scroll_layer_impl;
+    } else {
+      expected_scroll_layer_impl = root_scroll_layer_impl;
+      expected_no_scroll_layer_impl = child_layer_impl;
+    }
+
+    EXPECT_VECTOR_EQ(gfx::Vector2d(), root_impl->scrollDelta());
+    EXPECT_VECTOR_EQ(
+        gfx::Vector2d(),
+        expected_no_scroll_layer_impl->scrollDelta());
+
+    // Ensure device scale factor is affecting the layers.
+    gfx::Size expected_content_bounds = gfx::ToCeiledSize(
+        gfx::ScaleSize(root_scroll_layer_impl->bounds(), device_scale_factor_));
+    EXPECT_SIZE_EQ(
+        expected_content_bounds,
+        root_scroll_layer_->contentBounds());
+
+    expected_content_bounds = gfx::ToCeiledSize(
+        gfx::ScaleSize(child_layer_impl->bounds(), device_scale_factor_));
+    EXPECT_SIZE_EQ(expected_content_bounds, child_layer_->contentBounds());
+
+    switch (impl->activeTree()->source_frame_number()) {
+      case 0: {
+        // Gesture scroll on impl thread.
+        InputHandlerClient::ScrollStatus status = impl->scrollBegin(
+            gfx::ToCeiledPoint(
+                expected_scroll_layer_impl->position() +
+                gfx::Vector2dF(0.5f, 0.5f)),
+            InputHandlerClient::Gesture);
+        EXPECT_EQ(InputHandlerClient::ScrollStarted, status);
+        impl->scrollBy(gfx::Point(), scroll_amount_);
+        impl->scrollEnd();
+
+        // Check the scroll is applied as a delta.
+        EXPECT_VECTOR_EQ(
+            initial_offset_,
+            expected_scroll_layer_impl->scrollOffset());
+        EXPECT_VECTOR_EQ(
+            scroll_amount_,
+            expected_scroll_layer_impl->scrollDelta());
+        break;
+      }
+      case 1: {
+        // Wheel scroll on impl thread.
+        InputHandlerClient::ScrollStatus status = impl->scrollBegin(
+            gfx::ToCeiledPoint(
+                expected_scroll_layer_impl->position() +
+                gfx::Vector2dF(0.5f, 0.5f)),
+            InputHandlerClient::Wheel);
+        EXPECT_EQ(InputHandlerClient::ScrollStarted, status);
+        impl->scrollBy(gfx::Point(), scroll_amount_);
+        impl->scrollEnd();
+
+        // Check the scroll is applied as a delta.
+        EXPECT_VECTOR_EQ(
+            javascript_scroll_,
+            expected_scroll_layer_impl->scrollOffset());
+        EXPECT_VECTOR_EQ(
+            scroll_amount_,
+            expected_scroll_layer_impl->scrollDelta());
+        break;
+      }
+      case 2:
+
+        EXPECT_VECTOR_EQ(
+            javascript_scroll_ + scroll_amount_,
+            expected_scroll_layer_impl->scrollOffset());
+        EXPECT_VECTOR_EQ(
+            gfx::Vector2d(),
+            expected_scroll_layer_impl->scrollDelta());
+
+        endTest();
+        break;
+    }
+  }
+
+  virtual void afterTest() OVERRIDE {
+    if (scroll_child_layer_) {
+      EXPECT_EQ(0, num_scrolls_);
+      EXPECT_VECTOR_EQ(
+          javascript_scroll_ + scroll_amount_,
+          final_scroll_offset_);
+    } else {
+      EXPECT_EQ(2, num_scrolls_);
+      EXPECT_VECTOR_EQ(gfx::Vector2d(), final_scroll_offset_);
+    }
+  }
+
+ protected:
+  float device_scale_factor_;
+  bool scroll_child_layer_;
+
+  gfx::Vector2d initial_offset_;
+  gfx::Vector2d javascript_scroll_;
+  gfx::Vector2d scroll_amount_;
+  int num_scrolls_;
+  gfx::Vector2d final_scroll_offset_;
+
+  FakeContentLayerClient fake_content_layer_client_;
+
+  scoped_refptr<Layer> root_scroll_layer_;
+  scoped_refptr<Layer> child_layer_;
+  scoped_refptr<Layer> expected_scroll_layer_;
+  scoped_refptr<Layer> expected_no_scroll_layer_;
+};
+
+TEST_F(LayerTreeHostScrollTestCaseWithChild, DeviceScaleFactor1_ScrollChild) {
+  device_scale_factor_ = 1.f;
+  scroll_child_layer_ = true;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostScrollTestCaseWithChild, DeviceScaleFactor15_ScrollChild) {
+  device_scale_factor_ = 1.5f;
+  scroll_child_layer_ = true;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostScrollTestCaseWithChild, DeviceScaleFactor2_ScrollChild) {
+  device_scale_factor_ = 2.f;
+  scroll_child_layer_ = true;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostScrollTestCaseWithChild,
+       DeviceScaleFactor1_ScrollRootScrollLayer) {
+  device_scale_factor_ = 1.f;
+  scroll_child_layer_ = false;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostScrollTestCaseWithChild,
+       DeviceScaleFactor15_ScrollRootScrollLayer) {
+  device_scale_factor_ = 1.5f;
+  scroll_child_layer_ = false;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostScrollTestCaseWithChild,
+       DeviceScaleFactor2_ScrollRootScrollLayer) {
+  device_scale_factor_ = 2.f;
+  scroll_child_layer_ = false;
+  runTest(true);
+}
+
+class ImplSidePaintingScrollTest : public LayerTreeHostScrollTest {
+ public:
+  virtual void initializeSettings(LayerTreeSettings& settings) OVERRIDE {
+    settings.implSidePainting = true;
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    // Manual vsync tick.
+    if (impl->pendingTree())
+      impl->setNeedsRedraw();
+  }
+};
+
+class ImplSidePaintingScrollTestSimple : public ImplSidePaintingScrollTest {
+ public:
+  ImplSidePaintingScrollTestSimple()
+      : initial_scroll_(10, 20),
+        main_thread_scroll_(40, 5),
+        impl_thread_scroll1_(2, -1),
+        impl_thread_scroll2_(-3, 10),
+        num_scrolls_(0),
+        can_activate_(true) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    m_layerTreeHost->rootLayer()->setScrollable(true);
+    m_layerTreeHost->rootLayer()->setScrollOffset(initial_scroll_);
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void layout() OVERRIDE {
+    Layer* root = m_layerTreeHost->rootLayer();
+    if (!m_layerTreeHost->commitNumber())
+      EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+    else {
+      EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_ + impl_thread_scroll1_);
+
+      // Pretend like Javascript updated the scroll position itself with a
+      // change of main_thread_scroll.
+      root->setScrollOffset(initial_scroll_ + main_thread_scroll_ + impl_thread_scroll1_);
+    }
+  }
+
+  virtual bool canActivatePendingTree() OVERRIDE {
+    return can_activate_;
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    // We force a second draw here of the first commit before activating
+    // the second commit.
+    if (impl->activeTree()->source_frame_number() == 0)
+      impl->setNeedsRedraw();
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    ImplSidePaintingScrollTest::drawLayersOnThread(impl);
+
+    LayerImpl* root = impl->rootLayer();
+    root->setScrollable(true);
+    root->setMaxScrollOffset(gfx::Vector2d(100, 100));
+
+    LayerImpl* pending_root =
+        impl->activeTree()->FindPendingTreeLayerById(root->id());
+
+    switch (impl->activeTree()->source_frame_number()) {
+      case 0:
+        if (!impl->pendingTree()) {
+          can_activate_ = false;
+          EXPECT_VECTOR_EQ(root->scrollDelta(), gfx::Vector2d());
+          root->scrollBy(impl_thread_scroll1_);
+
+          EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+          EXPECT_VECTOR_EQ(root->scrollDelta(), impl_thread_scroll1_);
+          EXPECT_VECTOR_EQ(root->sentScrollDelta(), gfx::Vector2d());
+          postSetNeedsCommitToMainThread();
+
+          // commitCompleteOnThread will trigger this function again
+          // and cause us to take the else clause.
+        } else {
+          can_activate_ = true;
+          ASSERT_TRUE(pending_root);
+          EXPECT_EQ(impl->pendingTree()->source_frame_number(), 1);
+
+          root->scrollBy(impl_thread_scroll2_);
+          EXPECT_VECTOR_EQ(root->scrollOffset(), initial_scroll_);
+          EXPECT_VECTOR_EQ(root->scrollDelta(),
+              impl_thread_scroll1_ + impl_thread_scroll2_);
+          EXPECT_VECTOR_EQ(root->sentScrollDelta(), impl_thread_scroll1_);
+
+          EXPECT_VECTOR_EQ(pending_root->scrollOffset(),
+              initial_scroll_ + main_thread_scroll_ + impl_thread_scroll1_);
+          EXPECT_VECTOR_EQ(pending_root->scrollDelta(), impl_thread_scroll2_);
+          EXPECT_VECTOR_EQ(pending_root->sentScrollDelta(), gfx::Vector2d());
+        }
+        break;
+      case 1:
+        EXPECT_FALSE(impl->pendingTree());
+        EXPECT_VECTOR_EQ(root->scrollOffset(),
+            initial_scroll_ + main_thread_scroll_ + impl_thread_scroll1_);
+        EXPECT_VECTOR_EQ(root->scrollDelta(), impl_thread_scroll2_);
+        EXPECT_VECTOR_EQ(root->sentScrollDelta(), gfx::Vector2d());
+        endTest();
+        break;
+    }
+  }
+
+  virtual void applyScrollAndScale(
+      gfx::Vector2d scroll_delta, float scale) OVERRIDE {
+    gfx::Vector2d offset = m_layerTreeHost->rootLayer()->scrollOffset();
+    m_layerTreeHost->rootLayer()->setScrollOffset(offset + scroll_delta);
+    num_scrolls_++;
+  }
+
+  virtual void afterTest() OVERRIDE {
+    EXPECT_EQ(1, num_scrolls_);
+  }
+
+ private:
+  gfx::Vector2d initial_scroll_;
+  gfx::Vector2d main_thread_scroll_;
+  gfx::Vector2d impl_thread_scroll1_;
+  gfx::Vector2d impl_thread_scroll2_;
+  int num_scrolls_;
+  bool can_activate_;
+};
+
+MULTI_THREAD_TEST_F(ImplSidePaintingScrollTestSimple);
+
+class LayerTreeHostScrollTestScrollZeroMaxScrollOffset
+    : public LayerTreeHostScrollTest {
+ public:
+  LayerTreeHostScrollTestScrollZeroMaxScrollOffset() {}
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    LayerImpl* root = impl->rootLayer();
+    root->setScrollable(true);
+
+    root->setMaxScrollOffset(gfx::Vector2d(100, 100));
+    EXPECT_EQ(
+        InputHandlerClient::ScrollStarted,
+        root->tryScroll(
+            gfx::PointF(0.0f, 1.0f),
+            InputHandlerClient::Gesture));
+
+    root->setMaxScrollOffset(gfx::Vector2d(0, 0));
+    EXPECT_EQ(
+        InputHandlerClient::ScrollIgnored,
+        root->tryScroll(
+            gfx::PointF(0.0f, 1.0f),
+            InputHandlerClient::Gesture));
+
+    root->setMaxScrollOffset(gfx::Vector2d(-100, -100));
+    EXPECT_EQ(
+        InputHandlerClient::ScrollIgnored,
+        root->tryScroll(
+            gfx::PointF(0.0f, 1.0f),
+            InputHandlerClient::Gesture));
+
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostScrollTestScrollZeroMaxScrollOffset)
+
+
+}  // namespace
+}  // namespace cc
Index: src/cc/video_frame_provider_client_impl.h
===================================================================
--- src/cc/video_frame_provider_client_impl.h (revision 0)
+++ src/cc/video_frame_provider_client_impl.h (revision 0)
@@ -0,0 +1,62 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_VIDEO_FRAME_PROVIDER_CLIENT_IMPL_H_
+#define CC_VIDEO_FRAME_PROVIDER_CLIENT_IMPL_H_
+
+#include "base/memory/ref_counted.h"
+#include "base/synchronization/lock.h"
+#include "cc/video_frame_provider.h"
+#include "ui/gfx/transform.h"
+
+namespace media {
+class VideoFrame;
+}
+
+namespace cc {
+class VideoLayerImpl;
+
+class VideoFrameProviderClientImpl :
+    public VideoFrameProvider::Client,
+    public base::RefCounted<VideoFrameProviderClientImpl> {
+ public:
+  static scoped_refptr<VideoFrameProviderClientImpl> Create(
+      VideoFrameProvider* provider);
+
+  void set_active_video_layer(VideoLayerImpl* video_layer) {
+    active_video_layer_ = video_layer;
+  }
+
+  void Stop();
+  bool Stopped() const { return !provider_; }
+
+  media::VideoFrame* AcquireLockAndCurrentFrame();
+  void PutCurrentFrame(media::VideoFrame* frame);
+  void ReleaseLock();
+  const gfx::Transform& stream_texture_matrix() const {
+    return stream_texture_matrix_;
+  }
+
+  // VideoFrameProvider::Client implementation.
+  virtual void StopUsingProvider() OVERRIDE; // Callable on any thread.
+  virtual void DidReceiveFrame() OVERRIDE; // Callable on impl thread.
+  virtual void DidUpdateMatrix(const float*) OVERRIDE; // Callable on impl thread.
+
+ private:
+  explicit VideoFrameProviderClientImpl(VideoFrameProvider* provider);
+  friend class base::RefCounted<VideoFrameProviderClientImpl>;
+  virtual ~VideoFrameProviderClientImpl();
+
+  VideoLayerImpl* active_video_layer_;
+
+  // Guards the destruction of provider_ and the frame that it provides
+  base::Lock provider_lock_;
+  VideoFrameProvider* provider_;
+
+  gfx::Transform stream_texture_matrix_;
+};
+
+}  // namespace cc
+
+#endif  // CC_VIDEO_FRAME_PROVIDER_CLIENT_IMPL_H_
Index: src/cc/top_controls_manager_client.h
===================================================================
--- src/cc/top_controls_manager_client.h (revision 0)
+++ src/cc/top_controls_manager_client.h (revision 0)
@@ -0,0 +1,25 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TOP_CONTROLS_MANAGER_CLIENT_H_
+#define CC_TOP_CONTROLS_MANAGER_CLIENT_H_
+
+namespace cc {
+
+class LayerTreeImpl;
+
+class CC_EXPORT TopControlsManagerClient {
+ public:
+  virtual void setNeedsRedraw() = 0;
+  virtual void setActiveTreeNeedsUpdateDrawProperties() = 0;
+  virtual bool haveRootScrollLayer() const = 0;
+  virtual float rootScrollLayerTotalScrollY() const = 0;
+
+ protected:
+  virtual ~TopControlsManagerClient() {}
+};
+
+}  // namespace cc
+
+#endif  // CC_TOP_CONTROLS_MANAGER_CLIENT_H_
Index: src/cc/layer_tree_host_unittest_context.cc
===================================================================
--- src/cc/layer_tree_host_unittest_context.cc (revision 0)
+++ src/cc/layer_tree_host_unittest_context.cc (revision 0)
@@ -0,0 +1,1029 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/layer_tree_host.h"
+
+#include "base/basictypes.h"
+#include "cc/content_layer.h"
+#include "cc/delegated_renderer_layer.h"
+#include "cc/delegated_renderer_layer_impl.h"
+#include "cc/heads_up_display_layer.h"
+#include "cc/io_surface_layer.h"
+#include "cc/layer_impl.h"
+#include "cc/layer_tree_host_impl.h"
+#include "cc/layer_tree_impl.h"
+#include "cc/picture_layer.h"
+#include "cc/scrollbar_layer.h"
+#include "cc/single_thread_proxy.h"
+#include "cc/test/fake_content_layer.h"
+#include "cc/test/fake_content_layer_client.h"
+#include "cc/test/fake_content_layer_impl.h"
+#include "cc/test/fake_output_surface.h"
+#include "cc/test/fake_scrollbar_layer.h"
+#include "cc/test/fake_scrollbar_theme_painter.h"
+#include "cc/test/fake_video_frame_provider.h"
+#include "cc/test/fake_web_graphics_context_3d.h"
+#include "cc/test/fake_web_scrollbar.h"
+#include "cc/test/fake_web_scrollbar_theme_geometry.h"
+#include "cc/test/layer_tree_test_common.h"
+#include "cc/test/render_pass_test_common.h"
+#include "cc/texture_layer.h"
+#include "cc/video_layer.h"
+#include "cc/video_layer_impl.h"
+#include "third_party/khronos/GLES2/gl2ext.h"
+#include "media/base/media.h"
+
+using media::VideoFrame;
+using WebKit::WebGraphicsContext3D;
+
+namespace cc {
+namespace {
+
+// These tests deal with losing the 3d graphics context.
+class LayerTreeHostContextTest : public ThreadedTest {
+ public:
+  LayerTreeHostContextTest()
+      : ThreadedTest(),
+        context3d_(NULL),
+        times_to_fail_create_(0),
+        times_to_fail_initialize_(0),
+        times_to_lose_on_create_(0),
+        times_to_lose_during_commit_(0),
+        times_to_lose_during_draw_(0),
+        times_to_fail_recreate_(0),
+        times_to_fail_reinitialize_(0),
+        times_to_lose_on_recreate_(0) {
+    media::InitializeMediaLibraryForTesting();
+  }
+
+  void LoseContext() {
+    context3d_->loseContextCHROMIUM(GL_GUILTY_CONTEXT_RESET_ARB,
+                                    GL_INNOCENT_CONTEXT_RESET_ARB);
+    context3d_ = NULL;
+  }
+
+  virtual scoped_ptr<FakeWebGraphicsContext3D> CreateContext3d() {
+    return FakeWebGraphicsContext3D::Create();
+  }
+
+  virtual scoped_ptr<OutputSurface> createOutputSurface() OVERRIDE {
+    if (times_to_fail_create_) {
+      --times_to_fail_create_;
+      return scoped_ptr<OutputSurface>();
+    }
+
+    scoped_ptr<FakeWebGraphicsContext3D> context3d = CreateContext3d();
+    context3d_ = context3d.get();
+
+    if (times_to_fail_initialize_) {
+      --times_to_fail_initialize_;
+      // Make the context get lost during reinitialization.
+      // The number of times MakeCurrent succeeds is not important, and
+      // can be changed if needed to make this pass with future changes.
+      context3d_->set_times_make_current_succeeds(2);
+    } else if (times_to_lose_on_create_) {
+      --times_to_lose_on_create_;
+      LoseContext();
+    }
+
+    return FakeOutputSurface::Create3d(
+        context3d.PassAs<WebGraphicsContext3D>()).PassAs<OutputSurface>();
+  }
+
+    virtual bool prepareToDrawOnThread(
+        LayerTreeHostImpl*, LayerTreeHostImpl::FrameData&, bool result)
+        OVERRIDE {
+      EXPECT_TRUE(result);
+      if (!times_to_lose_during_draw_)
+        return result;
+
+      --times_to_lose_during_draw_;
+      if (context3d_)
+        context3d_->set_times_make_current_succeeds(0);
+      return result;
+    }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl *host_impl) OVERRIDE {
+    if (!times_to_lose_during_commit_)
+      return;
+    --times_to_lose_during_commit_;
+    LoseContext();
+
+    times_to_fail_create_ = times_to_fail_recreate_;
+    times_to_fail_recreate_ = 0;
+    times_to_fail_initialize_ = times_to_fail_reinitialize_;
+    times_to_fail_reinitialize_ = 0;
+    times_to_lose_on_create_ = times_to_lose_on_recreate_;
+    times_to_lose_on_recreate_ = 0;
+  }
+
+ protected:
+  FakeWebGraphicsContext3D* context3d_;
+  int times_to_fail_create_;
+  int times_to_fail_initialize_;
+  int times_to_lose_on_create_;
+  int times_to_lose_during_commit_;
+  int times_to_lose_during_draw_;
+  int times_to_fail_reinitialize_;
+  int times_to_fail_recreate_;
+  int times_to_lose_on_recreate_;
+};
+
+class LayerTreeHostContextTestLostContextSucceeds :
+      public LayerTreeHostContextTest {
+ public:
+  LayerTreeHostContextTestLostContextSucceeds()
+      : LayerTreeHostContextTest(),
+        test_case_(0),
+        num_losses_(0),
+        recovered_context_(true) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_TRUE(succeeded);
+    ++num_losses_;
+    recovered_context_ = true;
+  }
+
+  virtual void afterTest() OVERRIDE {
+    EXPECT_EQ(8, test_case_);
+    EXPECT_EQ(6 + 10 + 10, num_losses_);
+  }
+
+  virtual void didCommitAndDrawFrame() OVERRIDE {
+    // If the last frame had a context loss, then we'll commit again to
+    // recover.
+    if (!recovered_context_)
+      return;
+    if (times_to_lose_during_commit_)
+      return;
+    if (times_to_lose_during_draw_)
+      return;
+
+    recovered_context_ = false;
+    if (NextTestCase())
+      InvalidateAndSetNeedsCommit();
+    else
+      endTest();
+  }
+
+  virtual void InvalidateAndSetNeedsCommit() {
+    m_layerTreeHost->setNeedsCommit();
+  }
+
+  bool NextTestCase() {
+    static const TestCase kTests[] = {
+      // Losing the context and failing to recreate it (or losing it again
+      // immediately) a small number of times should succeed.
+      { 1, // times_to_lose_during_commit
+        0, // times_to_lose_during_draw
+        3, // times_to_fail_reinitialize
+        0, // times_to_fail_recreate
+        0, // times_to_lose_on_recreate
+      },
+      { 0, // times_to_lose_during_commit
+        1, // times_to_lose_during_draw
+        3, // times_to_fail_reinitialize
+        0, // times_to_fail_recreate
+        0, // times_to_lose_on_recreate
+      },
+      { 1, // times_to_lose_during_commit
+        0, // times_to_lose_during_draw
+        0, // times_to_fail_reinitialize
+        3, // times_to_fail_recreate
+        0, // times_to_lose_on_recreate
+      },
+      { 0, // times_to_lose_during_commit
+        1, // times_to_lose_during_draw
+        0, // times_to_fail_reinitialize
+        3, // times_to_fail_recreate
+        0, // times_to_lose_on_recreate
+      },
+      { 1, // times_to_lose_during_commit
+        0, // times_to_lose_during_draw
+        0, // times_to_fail_reinitialize
+        0, // times_to_fail_recreate
+        3, // times_to_lose_on_recreate
+      },
+      { 0, // times_to_lose_during_commit
+        1, // times_to_lose_during_draw
+        0, // times_to_fail_reinitialize
+        0, // times_to_fail_recreate
+        3, // times_to_lose_on_recreate
+      },
+      // Losing the context and recreating it any number of times should
+      // succeed.
+      { 10, // times_to_lose_during_commit
+        0, // times_to_lose_during_draw
+        0, // times_to_fail_reinitialize
+        0, // times_to_fail_recreate
+        0, // times_to_lose_on_recreate
+      },
+      { 0, // times_to_lose_during_commit
+        10, // times_to_lose_during_draw
+        0, // times_to_fail_reinitialize
+        0, // times_to_fail_recreate
+        0, // times_to_lose_on_recreate
+      },
+    };
+
+    if (test_case_ >= arraysize(kTests))
+      return false;
+
+    times_to_lose_during_commit_ =
+        kTests[test_case_].times_to_lose_during_commit;
+    times_to_lose_during_draw_ =
+        kTests[test_case_].times_to_lose_during_draw;
+    times_to_fail_reinitialize_ = kTests[test_case_].times_to_fail_reinitialize;
+    times_to_fail_recreate_ = kTests[test_case_].times_to_fail_recreate;
+    times_to_lose_on_recreate_ = kTests[test_case_].times_to_lose_on_recreate;
+    ++test_case_;
+    return true;
+  }
+
+  struct TestCase {
+    int times_to_lose_during_commit;
+    int times_to_lose_during_draw;
+    int times_to_fail_reinitialize;
+    int times_to_fail_recreate;
+    int times_to_lose_on_recreate;
+  };
+
+ private:
+  size_t test_case_;
+  int num_losses_;
+  bool recovered_context_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostContextTestLostContextSucceeds)
+
+class LayerTreeHostContextTestLostContextSucceedsWithContent :
+    public LayerTreeHostContextTestLostContextSucceeds {
+ public:
+
+  LayerTreeHostContextTestLostContextSucceedsWithContent()
+      : LayerTreeHostContextTestLostContextSucceeds() {
+  }
+
+  virtual void setupTree() OVERRIDE {
+    root_ = Layer::create();
+    root_->setBounds(gfx::Size(10, 10));
+    root_->setAnchorPoint(gfx::PointF());
+    root_->setIsDrawable(true);
+
+    content_ = FakeContentLayer::Create(&client_);
+    content_->setBounds(gfx::Size(10, 10));
+    content_->setAnchorPoint(gfx::PointF());
+    content_->setIsDrawable(true);
+    if (use_surface_) {
+      // TODO(danakj): Give the surface a filter to test more code when we can
+      // do so without crashing in the shared context creation.
+      content_->setForceRenderSurface(true);
+    }
+
+    root_->addChild(content_);
+
+    m_layerTreeHost->setRootLayer(root_);
+    LayerTreeHostContextTest::setupTree();
+  }
+
+  virtual void InvalidateAndSetNeedsCommit() OVERRIDE {
+    // Invalidate the render surface so we don't try to use a cached copy of the
+    // surface.  We want to make sure to test the drawing paths for drawing to
+    // a child surface.
+    content_->setNeedsDisplay();
+    LayerTreeHostContextTestLostContextSucceeds::InvalidateAndSetNeedsCommit();
+  }
+
+  virtual void drawLayersOnThread(LayerTreeHostImpl* host_impl) {
+    FakeContentLayerImpl* content_impl = static_cast<FakeContentLayerImpl*>(
+        host_impl->rootLayer()->children()[0]);
+    // Even though the context was lost, we should have a resource. The
+    // FakeWebGraphicsContext3D ensures that this resource is created with
+    // the active context.
+    EXPECT_TRUE(content_impl->HaveResourceForTileAt(0, 0));
+  }
+
+ protected:
+  bool use_surface_;
+  FakeContentLayerClient client_;
+  scoped_refptr<Layer> root_;
+  scoped_refptr<ContentLayer> content_;
+};
+
+TEST_F(LayerTreeHostContextTestLostContextSucceedsWithContent,
+       NoSurface_SingleThread) {
+  use_surface_ = false;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextSucceedsWithContent,
+       NoSurface_MultiThread) {
+  use_surface_ = false;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextSucceedsWithContent,
+       WithSurface_SingleThread) {
+  use_surface_ = true;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextSucceedsWithContent,
+       WithSurface_MultiThread) {
+  use_surface_ = true;
+  runTest(true);
+}
+
+class LayerTreeHostContextTestLostContextFails :
+    public LayerTreeHostContextTest {
+ public:
+  LayerTreeHostContextTestLostContextFails()
+      : LayerTreeHostContextTest(),
+        num_commits_(0) {
+    times_to_lose_during_commit_ = 1;
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_FALSE(succeeded);
+    endTest();
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* host_impl) OVERRIDE {
+    LayerTreeHostContextTest::commitCompleteOnThread(host_impl);
+
+    ++num_commits_;
+    if (num_commits_ == 1) {
+      // When the context is ok, we should have these things.
+      EXPECT_TRUE(host_impl->outputSurface());
+      EXPECT_TRUE(host_impl->renderer());
+      EXPECT_TRUE(host_impl->resourceProvider());
+      return;
+    }
+
+    // When context recreation fails we shouldn't be left with any of them.
+    EXPECT_FALSE(host_impl->outputSurface());
+    EXPECT_FALSE(host_impl->renderer());
+    EXPECT_FALSE(host_impl->resourceProvider());
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  int num_commits_;
+};
+
+TEST_F(LayerTreeHostContextTestLostContextFails, FailReinitialize100_SingleThread) {
+  times_to_fail_reinitialize_ = 100;
+  times_to_fail_recreate_ = 0;
+  times_to_lose_on_recreate_ = 0;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextFails, FailReinitialize100_MultiThread) {
+  times_to_fail_reinitialize_ = 100;
+  times_to_fail_recreate_ = 0;
+  times_to_lose_on_recreate_ = 0;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextFails, FailRecreate100_SingleThread) {
+  times_to_fail_reinitialize_ = 0;
+  times_to_fail_recreate_ = 100;
+  times_to_lose_on_recreate_ = 0;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextFails, FailRecreate100_MultiThread) {
+  times_to_fail_reinitialize_ = 0;
+  times_to_fail_recreate_ = 100;
+  times_to_lose_on_recreate_ = 0;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextFails, LoseOnRecreate100_SingleThread) {
+  times_to_fail_reinitialize_ = 0;
+  times_to_fail_recreate_ = 0;
+  times_to_lose_on_recreate_ = 100;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextFails, LoseOnRecreate100_MultiThread) {
+  times_to_fail_reinitialize_ = 0;
+  times_to_fail_recreate_ = 0;
+  times_to_lose_on_recreate_ = 100;
+  runTest(true);
+}
+
+class LayerTreeHostContextTestFinishAllRenderingAfterLoss :
+      public LayerTreeHostContextTest {
+ public:
+  virtual void beginTest() OVERRIDE {
+    // Lose the context until the compositor gives up on it.
+    times_to_lose_during_commit_ = 1;
+    times_to_fail_reinitialize_ = 10;
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_FALSE(succeeded);
+    m_layerTreeHost->finishAllRendering();
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostContextTestFinishAllRenderingAfterLoss)
+
+class LayerTreeHostContextTestLostContextAndEvictTextures :
+    public LayerTreeHostContextTest {
+ public:
+  LayerTreeHostContextTestLostContextAndEvictTextures()
+      : LayerTreeHostContextTest(),
+        layer_(FakeContentLayer::Create(&client_)),
+        impl_host_(0),
+        num_commits_(0) {
+  }
+
+  virtual void setupTree() OVERRIDE {
+    layer_->setBounds(gfx::Size(10, 20));
+    m_layerTreeHost->setRootLayer(layer_);
+    LayerTreeHostContextTest::setupTree();
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  void PostEvictTextures() {
+    if (implThread()) {
+      implThread()->postTask(
+          base::Bind(
+              &LayerTreeHostContextTestLostContextAndEvictTextures::
+              EvictTexturesOnImplThread,
+              base::Unretained(this)));
+    } else {
+      DebugScopedSetImplThread impl(proxy());
+      EvictTexturesOnImplThread();
+    }
+  }
+
+  void EvictTexturesOnImplThread() {
+    impl_host_->enforceManagedMemoryPolicy(ManagedMemoryPolicy(0));
+    if (lose_after_evict_)
+      LoseContext();
+  }
+
+  virtual void didCommitAndDrawFrame() OVERRIDE {
+    if (num_commits_ > 1)
+      return;
+    EXPECT_TRUE(layer_->HaveBackingAt(0, 0));
+    PostEvictTextures();
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    if (num_commits_ > 1)
+      return;
+    ++num_commits_;
+    if (!lose_after_evict_)
+      LoseContext();
+    impl_host_ = impl;
+  }
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_TRUE(succeeded);
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ protected:
+  bool lose_after_evict_;
+  FakeContentLayerClient client_;
+  scoped_refptr<FakeContentLayer> layer_;
+  LayerTreeHostImpl* impl_host_;
+  int num_commits_;
+};
+
+TEST_F(LayerTreeHostContextTestLostContextAndEvictTextures,
+       LoseAfterEvict_SingleThread) {
+  lose_after_evict_ = true;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextAndEvictTextures,
+       LoseAfterEvict_MultiThread) {
+  lose_after_evict_ = true;
+  runTest(true);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextAndEvictTextures,
+       LoseBeforeEvict_SingleThread) {
+  lose_after_evict_ = false;
+  runTest(false);
+}
+
+TEST_F(LayerTreeHostContextTestLostContextAndEvictTextures,
+       LoseBeforeEvict_MultiThread) {
+  lose_after_evict_ = false;
+  runTest(true);
+}
+
+class LayerTreeHostContextTestLostContextWhileUpdatingResources :
+    public LayerTreeHostContextTest {
+ public:
+  LayerTreeHostContextTestLostContextWhileUpdatingResources()
+      : parent_(FakeContentLayer::Create(&client_)),
+        num_children_(50),
+        times_to_lose_on_end_query_(3) {
+  }
+
+  virtual scoped_ptr<FakeWebGraphicsContext3D> CreateContext3d() {
+    scoped_ptr<FakeWebGraphicsContext3D> context =
+        LayerTreeHostContextTest::CreateContext3d();
+    if (times_to_lose_on_end_query_) {
+      --times_to_lose_on_end_query_;
+      context->set_times_end_query_succeeds(5);
+    }
+    return context.Pass();
+  }
+
+  virtual void setupTree() {
+    parent_->setBounds(gfx::Size(num_children_, 1));
+
+    for (int i = 0; i < num_children_; i++) {
+      scoped_refptr<FakeContentLayer> child =
+          FakeContentLayer::Create(&client_);
+      child->setPosition(gfx::PointF(i, 0.f));
+      child->setBounds(gfx::Size(1, 1));
+      parent_->addChild(child);
+    }
+
+    m_layerTreeHost->setRootLayer(parent_);
+    LayerTreeHostContextTest::setupTree();
+  }
+
+  virtual void beginTest() {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) {
+    endTest();
+  }
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_TRUE(succeeded);
+  }
+
+  virtual void afterTest() {
+    EXPECT_EQ(0, times_to_lose_on_end_query_);
+  }
+
+ private:
+  FakeContentLayerClient client_;
+  scoped_refptr<FakeContentLayer> parent_;
+  int num_children_;
+  int times_to_lose_on_end_query_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostContextTestLostContextWhileUpdatingResources)
+
+class LayerTreeHostContextTestLayersNotified :
+    public LayerTreeHostContextTest {
+ public:
+  LayerTreeHostContextTestLayersNotified()
+      : LayerTreeHostContextTest(),
+        num_commits_(0) {
+  }
+
+  virtual void setupTree() OVERRIDE {
+    root_ = FakeContentLayer::Create(&client_);
+    child_ = FakeContentLayer::Create(&client_);
+    grandchild_ = FakeContentLayer::Create(&client_);
+
+    root_->addChild(child_);
+    child_->addChild(grandchild_);
+
+    m_layerTreeHost->setRootLayer(root_);
+    LayerTreeHostContextTest::setupTree();
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* host_impl) OVERRIDE {
+    FakeContentLayerImpl* root = static_cast<FakeContentLayerImpl*>(
+        host_impl->rootLayer());
+    FakeContentLayerImpl* child = static_cast<FakeContentLayerImpl*>(
+        root->children()[0]);
+    FakeContentLayerImpl* grandchild = static_cast<FakeContentLayerImpl*>(
+        child->children()[0]);
+
+    ++num_commits_;
+    switch (num_commits_) {
+      case 1:
+        EXPECT_EQ(0u, root->lost_output_surface_count());
+        EXPECT_EQ(0u, child->lost_output_surface_count());
+        EXPECT_EQ(0u, grandchild->lost_output_surface_count());
+        // Lose the context and struggle to recreate it.
+        LoseContext();
+        times_to_fail_create_ = 1;
+        break;
+      case 2:
+        EXPECT_EQ(1u, root->lost_output_surface_count());
+        EXPECT_EQ(1u, child->lost_output_surface_count());
+        EXPECT_EQ(1u, grandchild->lost_output_surface_count());
+        // Lose the context and again during recreate.
+        LoseContext();
+        times_to_lose_on_create_ = 1;
+        break;
+      case 3:
+        EXPECT_EQ(3u, root->lost_output_surface_count());
+        EXPECT_EQ(3u, child->lost_output_surface_count());
+        EXPECT_EQ(3u, grandchild->lost_output_surface_count());
+        // Lose the context and again during reinitialization.
+        LoseContext();
+        times_to_fail_initialize_ = 1;
+        break;
+      case 4:
+        EXPECT_EQ(5u, root->lost_output_surface_count());
+        EXPECT_EQ(5u, child->lost_output_surface_count());
+        EXPECT_EQ(5u, grandchild->lost_output_surface_count());
+        endTest();
+        break;
+      default:
+        NOTREACHED();
+    }
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  int num_commits_;
+
+  FakeContentLayerClient client_;
+  scoped_refptr<FakeContentLayer> root_;
+  scoped_refptr<FakeContentLayer> child_;
+  scoped_refptr<FakeContentLayer> grandchild_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostContextTestLayersNotified)
+
+class LayerTreeHostContextTestDontUseLostResources :
+    public LayerTreeHostContextTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    context3d_->set_have_extension_io_surface(true);
+    context3d_->set_have_extension_egl_image(true);
+
+    scoped_refptr<Layer> root_ = Layer::create();
+    root_->setBounds(gfx::Size(10, 10));
+    root_->setAnchorPoint(gfx::PointF());
+    root_->setIsDrawable(true);
+
+    scoped_refptr<DelegatedRendererLayer> delegated_ =
+        DelegatedRendererLayer::Create();
+    delegated_->setBounds(gfx::Size(10, 10));
+    delegated_->setAnchorPoint(gfx::PointF());
+    delegated_->setIsDrawable(true);
+    root_->addChild(delegated_);
+
+    scoped_refptr<ContentLayer> content_ = ContentLayer::create(&client_);
+    content_->setBounds(gfx::Size(10, 10));
+    content_->setAnchorPoint(gfx::PointF());
+    content_->setIsDrawable(true);
+    root_->addChild(content_);
+
+    scoped_refptr<TextureLayer> texture_ = TextureLayer::create(NULL);
+    texture_->setBounds(gfx::Size(10, 10));
+    texture_->setAnchorPoint(gfx::PointF());
+    texture_->setTextureId(FakeWebGraphicsContext3D::kExternalTextureId);
+    texture_->setIsDrawable(true);
+    root_->addChild(texture_);
+
+    scoped_refptr<ContentLayer> mask_ = ContentLayer::create(&client_);
+    mask_->setBounds(gfx::Size(10, 10));
+    mask_->setAnchorPoint(gfx::PointF());
+
+    scoped_refptr<ContentLayer> content_with_mask_ =
+        ContentLayer::create(&client_);
+    content_with_mask_->setBounds(gfx::Size(10, 10));
+    content_with_mask_->setAnchorPoint(gfx::PointF());
+    content_with_mask_->setIsDrawable(true);
+    content_with_mask_->setMaskLayer(mask_.get());
+    root_->addChild(content_with_mask_);
+
+    scoped_refptr<VideoLayer> video_color_ = VideoLayer::create(
+        &color_frame_provider_);
+    video_color_->setBounds(gfx::Size(10, 10));
+    video_color_->setAnchorPoint(gfx::PointF());
+    video_color_->setIsDrawable(true);
+    root_->addChild(video_color_);
+
+    scoped_refptr<VideoLayer> video_hw_ = VideoLayer::create(
+        &hw_frame_provider_);
+    video_hw_->setBounds(gfx::Size(10, 10));
+    video_hw_->setAnchorPoint(gfx::PointF());
+    video_hw_->setIsDrawable(true);
+    root_->addChild(video_hw_);
+
+    scoped_refptr<VideoLayer> video_scaled_hw_ = VideoLayer::create(
+        &scaled_hw_frame_provider_);
+    video_scaled_hw_->setBounds(gfx::Size(10, 10));
+    video_scaled_hw_->setAnchorPoint(gfx::PointF());
+    video_scaled_hw_->setIsDrawable(true);
+    root_->addChild(video_scaled_hw_);
+
+    scoped_refptr<IOSurfaceLayer> io_surface_ = IOSurfaceLayer::create();
+    io_surface_->setBounds(gfx::Size(10, 10));
+    io_surface_->setAnchorPoint(gfx::PointF());
+    io_surface_->setIsDrawable(true);
+    io_surface_->setIOSurfaceProperties(1, gfx::Size(10, 10));
+    root_->addChild(io_surface_);
+
+    scoped_refptr<HeadsUpDisplayLayer> hud_ = HeadsUpDisplayLayer::create();
+    hud_->setBounds(gfx::Size(10, 10));
+    hud_->setAnchorPoint(gfx::PointF());
+    hud_->setIsDrawable(true);
+    root_->addChild(hud_);
+    // Enable the hud.
+    LayerTreeDebugState debug_state;
+    debug_state.showFPSCounter = true;
+    m_layerTreeHost->setDebugState(debug_state);
+
+    bool paint_scrollbar = true;
+    bool has_thumb = true;
+    scoped_refptr<ScrollbarLayer> scrollbar_ = ScrollbarLayer::create(
+        FakeWebScrollbar::create().PassAs<WebKit::WebScrollbar>(),
+        FakeScrollbarThemePainter::Create(paint_scrollbar)
+        .PassAs<ScrollbarThemePainter>(),
+        FakeWebScrollbarThemeGeometry::create(has_thumb)
+        .PassAs<WebKit::WebScrollbarThemeGeometry>(),
+        content_->id());
+    scrollbar_->setBounds(gfx::Size(10, 10));
+    scrollbar_->setAnchorPoint(gfx::PointF());
+    scrollbar_->setIsDrawable(true);
+    root_->addChild(scrollbar_);
+
+    m_layerTreeHost->setRootLayer(root_);
+    LayerTreeHostContextTest::setupTree();
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* host_impl) OVERRIDE {
+    ResourceProvider* resource_provider = host_impl->resourceProvider();
+
+    if (host_impl->activeTree()->source_frame_number() == 0) {
+      // Set up impl resources on the first commit.
+
+      scoped_ptr<TestRenderPass> pass_for_quad = TestRenderPass::Create();
+      pass_for_quad->SetNew(
+          // AppendOneOfEveryQuadType() makes a RenderPass quad with this id.
+          RenderPass::Id(1, 1),
+          gfx::Rect(0, 0, 10, 10),
+          gfx::Rect(0, 0, 10, 10),
+          gfx::Transform());
+
+      scoped_ptr<TestRenderPass> pass = TestRenderPass::Create();
+      pass->SetNew(
+          RenderPass::Id(2, 1),
+          gfx::Rect(0, 0, 10, 10),
+          gfx::Rect(0, 0, 10, 10),
+          gfx::Transform());
+      pass->AppendOneOfEveryQuadType(resource_provider, RenderPass::Id(2, 1));
+
+      ScopedPtrVector<RenderPass> pass_list;
+      pass_list.push_back(pass_for_quad.PassAs<RenderPass>());
+      pass_list.push_back(pass.PassAs<RenderPass>());
+
+      // First child is the delegated layer.
+      DelegatedRendererLayerImpl* delegated_impl =
+          static_cast<DelegatedRendererLayerImpl*>(
+              host_impl->rootLayer()->children()[0]);
+      delegated_impl->SetRenderPasses(pass_list);
+      EXPECT_TRUE(pass_list.empty());
+
+      color_video_frame_ = VideoFrame::CreateColorFrame(
+          gfx::Size(4, 4), 0x80, 0x80, 0x80, base::TimeDelta());
+      hw_video_frame_ = VideoFrame::WrapNativeTexture(
+          resource_provider->graphicsContext3D()->createTexture(),
+          GL_TEXTURE_2D,
+          gfx::Size(4, 4), gfx::Rect(0, 0, 4, 4), gfx::Size(4, 4),
+          base::TimeDelta(),
+          VideoFrame::ReadPixelsCB(),
+          base::Closure());
+      scaled_hw_video_frame_ = VideoFrame::WrapNativeTexture(
+          resource_provider->graphicsContext3D()->createTexture(),
+          GL_TEXTURE_2D,
+          gfx::Size(4, 4), gfx::Rect(0, 0, 3, 2), gfx::Size(4, 4),
+          base::TimeDelta(),
+          VideoFrame::ReadPixelsCB(),
+          base::Closure());
+
+      color_frame_provider_.set_frame(color_video_frame_);
+      hw_frame_provider_.set_frame(hw_video_frame_);
+      scaled_hw_frame_provider_.set_frame(scaled_hw_video_frame_);
+      return;
+    }
+
+    if (host_impl->activeTree()->source_frame_number() == 3) {
+      // On the third commit we're recovering from context loss. Hardware
+      // video frames should not be reused by the VideoFrameProvider, but
+      // software frames can be.
+      hw_frame_provider_.set_frame(NULL);
+      scaled_hw_frame_provider_.set_frame(NULL);
+    }
+  }
+
+  virtual bool prepareToDrawOnThread(
+      LayerTreeHostImpl* host_impl,
+      LayerTreeHostImpl::FrameData& frame,
+      bool result) OVERRIDE {
+    if (host_impl->activeTree()->source_frame_number() == 2) {
+      // Lose the context during draw on the second commit. This will cause
+      // a third commit to recover.
+      if (context3d_)
+        context3d_->set_times_bind_texture_succeeds(4);
+    }
+    return true;
+  }
+
+  virtual void didCommitAndDrawFrame() OVERRIDE {
+    // End the test once we know the 3nd frame drew.
+    if (m_layerTreeHost->commitNumber() == 4)
+      endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+ private:
+  FakeContentLayerClient client_;
+
+  scoped_refptr<Layer> root_;
+  scoped_refptr<DelegatedRendererLayer> delegated_;
+  scoped_refptr<ContentLayer> content_;
+  scoped_refptr<TextureLayer> texture_;
+  scoped_refptr<ContentLayer> mask_;
+  scoped_refptr<ContentLayer> content_with_mask_;
+  scoped_refptr<VideoLayer> video_color_;
+  scoped_refptr<VideoLayer> video_hw_;
+  scoped_refptr<VideoLayer> video_scaled_hw_;
+  scoped_refptr<IOSurfaceLayer> io_surface_;
+  scoped_refptr<HeadsUpDisplayLayer> hud_;
+  scoped_refptr<ScrollbarLayer> scrollbar_;
+
+  scoped_refptr<VideoFrame> color_video_frame_;
+  scoped_refptr<VideoFrame> hw_video_frame_;
+  scoped_refptr<VideoFrame> scaled_hw_video_frame_;
+
+  FakeVideoFrameProvider color_frame_provider_;
+  FakeVideoFrameProvider hw_frame_provider_;
+  FakeVideoFrameProvider scaled_hw_frame_provider_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostContextTestDontUseLostResources)
+
+class LayerTreeHostContextTestFailsImmediately :
+    public LayerTreeHostContextTest {
+ public:
+  LayerTreeHostContextTestFailsImmediately()
+      : LayerTreeHostContextTest() {
+  }
+
+  virtual ~LayerTreeHostContextTestFailsImmediately() {}
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void afterTest() OVERRIDE {
+  }
+
+  virtual scoped_ptr<FakeWebGraphicsContext3D> CreateContext3d() OVERRIDE {
+    scoped_ptr<FakeWebGraphicsContext3D> context =
+        LayerTreeHostContextTest::CreateContext3d();
+    context->loseContextCHROMIUM(GL_GUILTY_CONTEXT_RESET_ARB,
+                                 GL_INNOCENT_CONTEXT_RESET_ARB);
+    return context.Pass();
+  }
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_FALSE(succeeded);
+    // If we make it this far without crashing, we pass!
+    endTest();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostContextTestFailsImmediately);
+
+class ImplSidePaintingLayerTreeHostContextTest
+    : public LayerTreeHostContextTest {
+ public:
+  virtual void initializeSettings(LayerTreeSettings& settings) OVERRIDE {
+    settings.implSidePainting = true;
+  }
+};
+
+class LayerTreeHostContextTestImplSidePainting :
+    public ImplSidePaintingLayerTreeHostContextTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    scoped_refptr<Layer> root = Layer::create();
+    root->setBounds(gfx::Size(10, 10));
+    root->setAnchorPoint(gfx::PointF());
+    root->setIsDrawable(true);
+
+    scoped_refptr<PictureLayer> picture = PictureLayer::create(&client_);
+    picture->setBounds(gfx::Size(10, 10));
+    picture->setAnchorPoint(gfx::PointF());
+    picture->setIsDrawable(true);
+    root->addChild(picture);
+
+    m_layerTreeHost->setRootLayer(root);
+    LayerTreeHostContextTest::setupTree();
+  }
+
+  virtual void beginTest() OVERRIDE {
+    times_to_lose_during_commit_ = 1;
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+  virtual void didRecreateOutputSurface(bool succeeded) OVERRIDE {
+    EXPECT_TRUE(succeeded);
+    endTest();
+  }
+
+ private:
+  FakeContentLayerClient client_;
+};
+
+MULTI_THREAD_TEST_F(LayerTreeHostContextTestImplSidePainting)
+
+class ScrollbarLayerLostContext : public LayerTreeHostContextTest {
+ public:
+  ScrollbarLayerLostContext() : commits_(0) {}
+
+  virtual void beginTest() OVERRIDE {
+    scoped_refptr<Layer> scroll_layer = Layer::create();
+    scrollbar_layer_ = FakeScrollbarLayer::Create(
+        false, true, scroll_layer->id());
+    scrollbar_layer_->setBounds(gfx::Size(10, 100));
+    m_layerTreeHost->rootLayer()->addChild(scrollbar_layer_);
+    m_layerTreeHost->rootLayer()->addChild(scroll_layer);
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void afterTest() OVERRIDE {
+  }
+
+  virtual void commitCompleteOnThread(LayerTreeHostImpl* impl) OVERRIDE {
+    ++commits_;
+    size_t upload_count = scrollbar_layer_->last_update_full_upload_size() +
+        scrollbar_layer_->last_update_partial_upload_size();
+    switch(commits_) {
+      case 1:
+        // First (regular) update, we should upload 2 resources (thumb, and
+        // backtrack).
+        EXPECT_EQ(1, scrollbar_layer_->update_count());
+        EXPECT_EQ(2, upload_count);
+        LoseContext();
+        break;
+      case 2:
+        // Second update, after the lost context, we should still upload 2
+        // resources even if the contents haven't changed.
+        EXPECT_EQ(2, scrollbar_layer_->update_count());
+        EXPECT_EQ(2, upload_count);
+        endTest();
+        break;
+      default:
+        NOTREACHED();
+    }
+  }
+
+ private:
+  int commits_;
+  scoped_refptr<FakeScrollbarLayer> scrollbar_layer_;
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(ScrollbarLayerLostContext)
+
+}  // namespace
+}  // namespace cc
Index: src/cc/layer_tree_host_unittest_occlusion.cc
===================================================================
--- src/cc/layer_tree_host_unittest_occlusion.cc (revision 0)
+++ src/cc/layer_tree_host_unittest_occlusion.cc (revision 0)
@@ -0,0 +1,476 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/layer_tree_host.h"
+
+#include "cc/layer.h"
+#include "cc/test/layer_tree_test_common.h"
+#include "cc/test/occlusion_tracker_test_common.h"
+
+namespace cc {
+namespace {
+
+class TestLayer : public Layer {
+ public:
+  static scoped_refptr<TestLayer> Create() {
+    return make_scoped_refptr(new TestLayer());
+  }
+
+  virtual void update(
+      ResourceUpdateQueue& update_queue,
+      const OcclusionTracker* occlusion,
+      RenderingStats& stats) OVERRIDE {
+    if (!occlusion)
+      return;
+
+    // Gain access to internals of the OcclusionTracker.
+    const TestOcclusionTracker* test_occlusion =
+        static_cast<const TestOcclusionTracker*>(occlusion);
+    occlusion_ = UnionRegions(
+        test_occlusion->occlusionFromInsideTarget(),
+        test_occlusion->occlusionFromOutsideTarget());
+  }
+
+  const Region& occlusion() const { return occlusion_; }
+  const Region& expected_occlusion() const { return expected_occlusion_; }
+  void set_expected_occlusion(const Region& occlusion) {
+    expected_occlusion_ = occlusion;
+  }
+
+ private:
+  TestLayer() : Layer() {
+    setIsDrawable(true);
+  }
+  virtual ~TestLayer() { }
+
+  Region occlusion_;
+  Region expected_occlusion_;
+};
+
+class LayerTreeHostOcclusionTest : public ThreadedTest {
+ public:
+
+  LayerTreeHostOcclusionTest()
+      : root_(TestLayer::Create()),
+        child_(TestLayer::Create()),
+        child2_(TestLayer::Create()),
+        grand_child_(TestLayer::Create()),
+        mask_(TestLayer::Create()) {
+  }
+
+  virtual void beginTest() OVERRIDE {
+    postSetNeedsCommitToMainThread();
+  }
+
+  virtual void didCommit() OVERRIDE {
+    TestLayer* root = static_cast<TestLayer*>(m_layerTreeHost->rootLayer());
+    VerifyOcclusion(root);
+
+    endTest();
+  }
+
+  virtual void afterTest() OVERRIDE {}
+
+  void VerifyOcclusion(TestLayer* layer) const {
+    EXPECT_EQ(layer->expected_occlusion().ToString(),
+              layer->occlusion().ToString());
+
+    for (size_t i = 0; i < layer->children().size(); ++i) {
+      TestLayer* child = static_cast<TestLayer*>(layer->children()[i].get());
+      VerifyOcclusion(child);
+    }
+  }
+
+  void SetLayerPropertiesForTesting(
+      TestLayer* layer, TestLayer* parent, const gfx::Transform& transform,
+      const gfx::PointF& position, const gfx::Size& bounds, bool opaque) const {
+    layer->removeAllChildren();
+    if (parent)
+      parent->addChild(layer);
+    layer->setTransform(transform);
+    layer->setPosition(position);
+    layer->setBounds(bounds);
+    layer->setContentsOpaque(opaque);
+
+    layer->setAnchorPoint(gfx::PointF());
+  }
+
+ protected:
+  scoped_refptr<TestLayer> root_;
+  scoped_refptr<TestLayer> child_;
+  scoped_refptr<TestLayer> child2_;
+  scoped_refptr<TestLayer> grand_child_;
+  scoped_refptr<TestLayer> mask_;
+
+  gfx::Transform identity_matrix_;
+};
+
+
+class LayerTreeHostOcclusionTestOcclusionSurfaceClipping :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // The child layer is a surface and the grandChild is opaque, but clipped to
+    // the child and root
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), false);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(20, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+    
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 10, 190));
+    root_->set_expected_occlusion(gfx::Rect(10, 10, 10, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionSurfaceClipping)
+
+class LayerTreeHostOcclusionTestOcclusionSurfaceClippingOpaque :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // If the child layer is opaque, then it adds to the occlusion seen by the
+    // root_.
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(20, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 10, 190));
+    root_->set_expected_occlusion(gfx::Rect(10, 10, 190, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionSurfaceClippingOpaque);
+
+class LayerTreeHostOcclusionTestOcclusionTwoChildren :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // Add a second child to the root layer and the regions should merge
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), false);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(20, 500), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(20.f, 10.f), gfx::Size(10, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+
+    grand_child_->set_expected_occlusion(gfx::Rect(10, 0, 10, 190));
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 20, 190));
+    root_->set_expected_occlusion(gfx::Rect(10, 10, 20, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionTwoChildren)
+
+class LayerTreeHostOcclusionTestOcclusionMask :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // If the child layer has a mask on it, then it shouldn't contribute to
+    // occlusion on stuff below it.
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(20.f, 20.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(500, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+    child_->setMaskLayer(mask_.get());
+
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 180, 180));
+    root_->set_expected_occlusion(gfx::Rect(10, 10, 190, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostOcclusionTestOcclusionMask)
+
+class LayerTreeHostOcclusionTestOcclusionMaskBelowOcclusion :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // If the child layer with a mask is below child2, then child2 should
+    // contribute to occlusion on everything, and child shouldn't contribute
+    // to the root_.
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(20, 500), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(20.f, 10.f), gfx::Size(10, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+    child_->setMaskLayer(mask_.get());
+  
+    grand_child_->set_expected_occlusion(gfx::Rect(10, 0, 10, 190));
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 20, 190));
+    root_->set_expected_occlusion(gfx::Rect(20, 10, 10, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionMaskBelowOcclusion)
+
+class LayerTreeHostOcclusionTestOcclusionOpacity :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // If the child layer has a non-opaque opacity, then it shouldn't
+    // contribute to occlusion on stuff below it
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(20.f, 10.f), gfx::Size(10, 500), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(20, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+    child_->setOpacity(0.5f);
+
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 10, 190));
+    root_->set_expected_occlusion(gfx::Rect(20, 10, 10, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostOcclusionTestOcclusionOpacity)
+
+class LayerTreeHostOcclusionTestOcclusionOpacityBelowOcclusion :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // If the child layer with non-opaque opacity is below child2, then
+    // child2 should contribute to occlusion on everything, and child shouldn't
+    // contribute to the root_.
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(-10.f, -10.f), gfx::Size(20, 500), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(20.f, 10.f), gfx::Size(10, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setForceRenderSurface(true);
+    child_->setOpacity(0.5f);
+
+    grand_child_->set_expected_occlusion(gfx::Rect(10, 0, 10, 190));
+    child_->set_expected_occlusion(gfx::Rect(0, 0, 20, 190));
+    root_->set_expected_occlusion(gfx::Rect(20, 10, 10, 190));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionOpacityBelowOcclusion)
+
+class LayerTreeHostOcclusionTestOcclusionOpacityFilter :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    gfx::Transform childTransform;
+    childTransform.Translate(250.0, 250.0);
+    childTransform.Rotate(90.0);
+    childTransform.Translate(-250.0, -250.0);
+
+    WebKit::WebFilterOperations filters;
+    filters.append(WebKit::WebFilterOperation::createOpacityFilter(0.5));
+
+    // If the child layer has a filter that changes alpha values, and is below
+    // child2, then child2 should contribute to occlusion on everything,
+    // and child shouldn't contribute to the root
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), childTransform,
+        gfx::PointF(30.f, 30.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 70.f), gfx::Size(500, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setFilters(filters);
+
+    grand_child_->set_expected_occlusion(gfx::Rect(40, 330, 130, 190));
+    child_->set_expected_occlusion(UnionRegions(
+        gfx::Rect(10, 330, 160, 170), gfx::Rect(40, 500, 130, 20)));
+    root_->set_expected_occlusion(gfx::Rect(10, 70, 190, 130));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionOpacityFilter)
+
+class LayerTreeHostOcclusionTestOcclusionBlurFilter :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    gfx::Transform childTransform;
+    childTransform.Translate(250.0, 250.0);
+    childTransform.Rotate(90.0);
+    childTransform.Translate(-250.0, -250.0);
+
+    WebKit::WebFilterOperations filters;
+    filters.append(WebKit::WebFilterOperation::createBlurFilter(10));
+
+    // If the child layer has a filter that moves pixels/changes alpha, and is
+    // below child2, then child should not inherit occlusion from outside its
+    // subtree, and should not contribute to the root
+    SetLayerPropertiesForTesting(
+        root_.get(), NULL, identity_matrix_,
+        gfx::PointF(0.f, 0.f), gfx::Size(200, 200), true);
+    SetLayerPropertiesForTesting(
+        child_.get(), root_.get(), childTransform,
+        gfx::PointF(30.f, 30.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        grand_child_.get(), child_.get(), identity_matrix_,
+        gfx::PointF(10.f, 10.f), gfx::Size(500, 500), true);
+    SetLayerPropertiesForTesting(
+        child2_.get(), root_.get(), identity_matrix_,
+        gfx::PointF(10.f, 70.f), gfx::Size(500, 500), true);
+
+    child_->setMasksToBounds(true);
+    child_->setFilters(filters);
+
+    child_->set_expected_occlusion(gfx::Rect(10, 330, 160, 170));
+    root_->set_expected_occlusion(gfx::Rect(10, 70, 190, 130));
+
+    m_layerTreeHost->setRootLayer(root_);
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(
+    LayerTreeHostOcclusionTestOcclusionBlurFilter)
+
+class LayerTreeHostOcclusionTestManySurfaces :
+    public LayerTreeHostOcclusionTest {
+ public:
+  virtual void setupTree() OVERRIDE {
+    // We create enough RenderSurfaces that it will trigger Vector reallocation
+    // while computing occlusion.
+    std::vector<scoped_refptr<TestLayer> > layers;
+    int num_surfaces = 200;
+    int root_width = 400;
+    int root_height = 400;
+
+    for (int i = 0; i < num_surfaces; ++i) {
+      layers.push_back(TestLayer::Create());
+      if (!i) {
+        SetLayerPropertiesForTesting(
+            layers.back().get(), NULL, identity_matrix_,
+            gfx::PointF(0.f, 0.f),
+            gfx::Size(root_width, root_height), true);
+        layers.back()->createRenderSurface();
+      } else {
+        SetLayerPropertiesForTesting(
+            layers.back().get(), layers[layers.size() - 2].get(),
+            identity_matrix_,
+            gfx::PointF(1.f, 1.f),
+            gfx::Size(root_width-i, root_height-i), true);
+        layers.back()->setForceRenderSurface(true);
+      }
+    }
+
+    for (int i = 1; i < num_surfaces; ++i) {
+      scoped_refptr<TestLayer> child = TestLayer::Create();
+      SetLayerPropertiesForTesting(
+          child.get(), layers[i].get(), identity_matrix_,
+          gfx::PointF(0.f, 0.f), gfx::Size(root_width, root_height), false);
+    }
+
+    for (int i = 0; i < num_surfaces-1; ++i) {
+      gfx::Rect expected_occlusion(1, 1, root_width-i-1, root_height-i-1);
+      layers[i]->set_expected_occlusion(expected_occlusion);
+    }
+
+    m_layerTreeHost->setRootLayer(layers[0].get());
+    ThreadedTest::setupTree();
+  }
+};
+
+SINGLE_AND_MULTI_THREAD_TEST_F(LayerTreeHostOcclusionTestManySurfaces)
+
+}  // namespace
+}  // namespace cc
Index: src/cc/transform_operation.cc
===================================================================
--- src/cc/transform_operation.cc (revision 0)
+++ src/cc/transform_operation.cc (revision 0)
@@ -0,0 +1,184 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cmath>
+#include <limits>
+
+#include "cc/transform_operation.h"
+#include "ui/gfx/vector3d_f.h"
+
+namespace {
+const double kAngleEpsilon = 1e-4;
+}
+
+namespace cc {
+
+bool TransformOperation::IsIdentity() const {
+  return matrix.IsIdentity();
+}
+
+static bool IsOperationIdentity(const TransformOperation* operation) {
+  return !operation || operation->IsIdentity();
+}
+
+static bool ShareSameAxis(const TransformOperation* from,
+                          const TransformOperation* to,
+                          double& axis_x, double& axis_y, double& axis_z,
+                          double& angle_from) {
+  if (IsOperationIdentity(from) && IsOperationIdentity(to))
+    return false;
+
+  if (IsOperationIdentity(from) && !IsOperationIdentity(to)) {
+    axis_x = to->rotate.axis.x;
+    axis_y = to->rotate.axis.y;
+    axis_z = to->rotate.axis.z;
+    angle_from = 0;
+    return true;
+  }
+
+  if (!IsOperationIdentity(from) && IsOperationIdentity(to)) {
+    axis_x = from->rotate.axis.x;
+    axis_y = from->rotate.axis.y;
+    axis_z = from->rotate.axis.z;
+    angle_from = from->rotate.angle;
+    return true;
+  }
+
+  double length_2 = from->rotate.axis.x * from->rotate.axis.x +
+                    from->rotate.axis.y * from->rotate.axis.y +
+                    from->rotate.axis.z * from->rotate.axis.z;
+  double other_length_2 = to->rotate.axis.x * to->rotate.axis.x +
+                          to->rotate.axis.y * to->rotate.axis.y +
+                          to->rotate.axis.z * to->rotate.axis.z;
+
+  if (length_2 <= kAngleEpsilon || other_length_2 <= kAngleEpsilon)
+    return false;
+
+  double dot = to->rotate.axis.x * from->rotate.axis.x +
+               to->rotate.axis.y * from->rotate.axis.y +
+               to->rotate.axis.z * from->rotate.axis.z;
+  double error = std::fabs(1.0 - (dot * dot) / (length_2 * other_length_2));
+  bool result = error < kAngleEpsilon;
+  if (result) {
+    axis_x = to->rotate.axis.x;
+    axis_y = to->rotate.axis.y;
+    axis_z = to->rotate.axis.z;
+    // If the axes are pointing in opposite directions, we need to reverse
+    // the angle.
+    angle_from = dot > 0 ? from->rotate.angle : -from->rotate.angle;
+  }
+  return result;
+}
+
+static double BlendDoubles(double from, double to, double progress) {
+  if (progress <= 0.0)
+    return from;
+
+  if (progress >= 1.0)
+    return to;
+
+  return from * (1 - progress) + to * progress;
+}
+
+bool TransformOperation::BlendTransformOperations(
+    const TransformOperation* from,
+    const TransformOperation* to,
+    double progress,
+    gfx::Transform& result) {
+  if (IsOperationIdentity(from) && IsOperationIdentity(to))
+    return true;
+
+  TransformOperation::Type interpolation_type =
+      TransformOperation::TransformOperationIdentity;
+  if (IsOperationIdentity(to))
+    interpolation_type = from->type;
+  else
+    interpolation_type = to->type;
+
+  switch (interpolation_type) {
+  case TransformOperation::TransformOperationTranslate: {
+    double from_x = IsOperationIdentity(from) ? 0 : from->translate.x;
+    double from_y = IsOperationIdentity(from) ? 0 : from->translate.y;
+    double from_z = IsOperationIdentity(from) ? 0 : from->translate.z;
+    double to_x = IsOperationIdentity(to) ? 0 : to->translate.x;
+    double to_y = IsOperationIdentity(to) ? 0 : to->translate.y;
+    double to_z = IsOperationIdentity(to) ? 0 : to->translate.z;
+    result.Translate3d(BlendDoubles(from_x, to_x, progress),
+                       BlendDoubles(from_y, to_y, progress),
+                       BlendDoubles(from_z, to_z, progress));
+    break;
+  }
+  case TransformOperation::TransformOperationRotate: {
+    double axis_x = 0;
+    double axis_y = 0;
+    double axis_z = 1;
+    double from_angle = 0;
+    double to_angle = IsOperationIdentity(to) ? 0 : to->rotate.angle;
+    if (ShareSameAxis(from, to, axis_x, axis_y, axis_z, from_angle))
+      result.RotateAbout(gfx::Vector3dF(axis_x, axis_y, axis_z),
+                         BlendDoubles(from_angle, to_angle, progress));
+    else {
+      gfx::Transform to_matrix;
+      if (!IsOperationIdentity(to))
+        to_matrix = to->matrix;
+      gfx::Transform from_matrix;
+      if (!IsOperationIdentity(from))
+        from_matrix = from->matrix;
+      result = to_matrix;
+      if (!result.Blend(from_matrix, progress))
+        return false;
+    }
+    break;
+  }
+  case TransformOperation::TransformOperationScale: {
+    double from_x = IsOperationIdentity(from) ? 1 : from->scale.x;
+    double from_y = IsOperationIdentity(from) ? 1 : from->scale.y;
+    double from_z = IsOperationIdentity(from) ? 1 : from->scale.z;
+    double to_x = IsOperationIdentity(to) ? 1 : to->scale.x;
+    double to_y = IsOperationIdentity(to) ? 1 : to->scale.y;
+    double to_z = IsOperationIdentity(to) ? 1 : to->scale.z;
+    result.Scale3d(BlendDoubles(from_x, to_x, progress),
+                   BlendDoubles(from_y, to_y, progress),
+                   BlendDoubles(from_z, to_z, progress));
+    break;
+  }
+  case TransformOperation::TransformOperationSkew: {
+    double from_x = IsOperationIdentity(from) ? 0 : from->skew.x;
+    double from_y = IsOperationIdentity(from) ? 0 : from->skew.y;
+    double to_x = IsOperationIdentity(to) ? 0 : to->skew.x;
+    double to_y = IsOperationIdentity(to) ? 0 : to->skew.y;
+    result.SkewX(BlendDoubles(from_x, to_x, progress));
+    result.SkewY(BlendDoubles(from_y, to_y, progress));
+    break;
+  }
+  case TransformOperation::TransformOperationPerspective: {
+    double from_perspective_depth = IsOperationIdentity(from) ?
+        std::numeric_limits<double>::max() : from->perspective_depth;
+    double to_perspective_depth = IsOperationIdentity(to) ?
+        std::numeric_limits<double>::max() : to->perspective_depth;
+    result.ApplyPerspectiveDepth(
+        BlendDoubles(from_perspective_depth, to_perspective_depth, progress));
+    break;
+  }
+  case TransformOperation::TransformOperationMatrix: {
+    gfx::Transform to_matrix;
+    if (!IsOperationIdentity(to))
+      to_matrix = to->matrix;
+    gfx::Transform from_matrix;
+    if (!IsOperationIdentity(from))
+      from_matrix = from->matrix;
+    result = to_matrix;
+    if (!result.Blend(from_matrix, progress))
+      return false;
+    break;
+  }
+  case TransformOperation::TransformOperationIdentity:
+    // Do nothing.
+    break;
+  }
+
+  return true;
+}
+
+}  // namespace cc
Index: src/cc/vsync_time_source.h
===================================================================
--- src/cc/vsync_time_source.h (revision 0)
+++ src/cc/vsync_time_source.h (revision 0)
@@ -0,0 +1,67 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_VSYNC_TIME_SOURCE_H_
+#define CC_VSYNC_TIME_SOURCE_H_
+
+#include "cc/cc_export.h"
+#include "cc/time_source.h"
+
+namespace cc {
+
+class CC_EXPORT VSyncClient {
+ public:
+  virtual void DidVSync(base::TimeTicks frame_time) = 0;
+
+ protected:
+  virtual ~VSyncClient() {}
+};
+
+class VSyncProvider {
+ public:
+  // Request to be notified of future vsync events. The notifications will be
+  // delivered until they are disabled by calling this function with a null
+  // client.
+  virtual void RequestVSyncNotification(VSyncClient* client) = 0;
+
+ protected:
+  virtual ~VSyncProvider() {}
+};
+
+// This timer implements a time source that is explicitly triggered by an
+// external vsync signal.
+class CC_EXPORT VSyncTimeSource : public TimeSource, public VSyncClient {
+ public:
+  static scoped_refptr<VSyncTimeSource> create(VSyncProvider* vsync_provider);
+
+  // TimeSource implementation
+  virtual void setClient(TimeSourceClient* client) OVERRIDE;
+  virtual void setTimebaseAndInterval(base::TimeTicks timebase,
+                                      base::TimeDelta interval) OVERRIDE;
+  virtual void setActive(bool active) OVERRIDE;
+  virtual bool active() const OVERRIDE;
+  virtual base::TimeTicks lastTickTime() OVERRIDE;
+  virtual base::TimeTicks nextTickTime() OVERRIDE;
+
+  // VSyncClient implementation
+  virtual void DidVSync(base::TimeTicks frame_time) OVERRIDE;
+
+ protected:
+  explicit VSyncTimeSource(VSyncProvider* vsync_provider);
+  virtual ~VSyncTimeSource();
+
+  base::TimeTicks last_tick_time_;
+  base::TimeDelta interval_;
+  bool active_;
+  bool notification_requested_;
+
+  VSyncProvider* vsync_provider_;
+  TimeSourceClient* client_;
+
+  DISALLOW_COPY_AND_ASSIGN(VSyncTimeSource);
+};
+
+}  // namespace cc
+
+#endif  // CC_VSYNC_TIME_SOURCE_H_
Index: src/cc/vsync_time_source.cc
===================================================================
--- src/cc/vsync_time_source.cc (revision 0)
+++ src/cc/vsync_time_source.cc (revision 0)
@@ -0,0 +1,69 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/vsync_time_source.h"
+
+namespace cc {
+
+scoped_refptr<VSyncTimeSource> VSyncTimeSource::create(
+    VSyncProvider* vsync_provider) {
+  return make_scoped_refptr(new VSyncTimeSource(vsync_provider));
+}
+
+VSyncTimeSource::VSyncTimeSource(VSyncProvider* vsync_provider)
+  : vsync_provider_(vsync_provider)
+  , client_(0)
+  , active_(false)
+  , notification_requested_(false) {}
+
+VSyncTimeSource::~VSyncTimeSource() {}
+
+void VSyncTimeSource::setClient(TimeSourceClient* client) {
+  client_ = client;
+}
+
+void VSyncTimeSource::setActive(bool active) {
+  if (active_ == active)
+    return;
+  active_ = active;
+  // The notification will be lazily disabled in the callback to ensure
+  // we get notified of the frame immediately following a quick on-off-on
+  // transition.
+  if (active_ && !notification_requested_) {
+    notification_requested_ = true;
+    vsync_provider_->RequestVSyncNotification(this);
+  }
+}
+
+bool VSyncTimeSource::active() const {
+  return active_;
+}
+
+base::TimeTicks VSyncTimeSource::lastTickTime() {
+  return last_tick_time_;
+}
+
+base::TimeTicks VSyncTimeSource::nextTickTime() {
+  return active() ? last_tick_time_ + interval_ : base::TimeTicks();
+}
+
+void VSyncTimeSource::setTimebaseAndInterval(base::TimeTicks,
+                                             base::TimeDelta interval) {
+  interval_ = interval;
+}
+
+void VSyncTimeSource::DidVSync(base::TimeTicks frame_time) {
+  last_tick_time_ = frame_time;
+  if (!active_) {
+    if (notification_requested_) {
+      notification_requested_ = false;
+      vsync_provider_->RequestVSyncNotification(NULL);
+    }
+    return;
+  }
+  if (client_)
+    client_->onTimerTick();
+}
+
+}  // namespace cc
Index: src/cc/tiling_data_unittest.cc
===================================================================
--- src/cc/tiling_data_unittest.cc (revision 0)
+++ src/cc/tiling_data_unittest.cc (revision 0)
@@ -0,0 +1,1197 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/tiling_data.h"
+
+#include "cc/test/geometry_test_utils.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace cc {
+namespace {
+
+int NumTiles(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  int num_tiles = tiling.num_tiles_x() * tiling.num_tiles_y();
+
+  // Assert no overflow.
+  EXPECT_GE(num_tiles, 0);
+  if (num_tiles > 0)
+    EXPECT_EQ(num_tiles / tiling.num_tiles_x(), tiling.num_tiles_y());
+
+  return num_tiles;
+}
+
+int XIndex(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int x_coord) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.TileXIndexFromSrcCoord(x_coord);
+}
+
+int YIndex(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int y_coord) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.TileYIndexFromSrcCoord(y_coord);
+}
+
+int MinBorderXIndex(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int x_coord) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.FirstBorderTileXIndexFromSrcCoord(x_coord);
+}
+
+int MinBorderYIndex(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int y_coord) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.FirstBorderTileYIndexFromSrcCoord(y_coord);
+}
+
+int MaxBorderXIndex(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int x_coord) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.LastBorderTileXIndexFromSrcCoord(x_coord);
+}
+
+int MaxBorderYIndex(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int y_coord) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.LastBorderTileYIndexFromSrcCoord(y_coord);
+}
+
+int PosX(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int x_index) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.TilePositionX(x_index);
+}
+
+int PosY(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int y_index) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.TilePositionY(y_index);
+}
+
+int SizeX(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int x_index) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.TileSizeX(x_index);
+}
+
+int SizeY(
+    gfx::Size max_texture_size,
+    gfx::Size total_size,
+    bool has_border_texels,
+    int y_index) {
+  TilingData tiling(max_texture_size, total_size, has_border_texels);
+  return tiling.TileSizeY(y_index);
+}
+
+TEST(TilingDataTest, numTiles_NoTiling)
+{
+  EXPECT_EQ(1, NumTiles(gfx::Size(16, 16), gfx::Size(16, 16), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(16, 16), gfx::Size(15, 15), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(16, 16), gfx::Size(16, 16), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(16, 16), gfx::Size(1, 16), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(15, 15), gfx::Size(15, 15), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(32, 16), gfx::Size(32, 16), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(32, 16), gfx::Size(32, 16), true));
+}
+
+TEST(TilingDataTest, numTiles_TilingNoBorders)
+{
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(0, 0), false));
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(4, 0), false));
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(0, 4), false));
+  EXPECT_EQ(0, NumTiles(gfx::Size(4, 4), gfx::Size(4, 0), false));
+  EXPECT_EQ(0, NumTiles(gfx::Size(4, 4), gfx::Size(0, 4), false));
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(1, 1), false));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(1, 1), gfx::Size(1, 1), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(1, 1), gfx::Size(1, 2), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(1, 1), gfx::Size(2, 1), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(1, 1), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(1, 2), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(2, 1), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(2, 2), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(3, 3), gfx::Size(3, 3), false));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(1, 4), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(2, 4), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(3, 4), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(4, 4), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(4, 4), gfx::Size(5, 4), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(4, 4), gfx::Size(6, 4), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(4, 4), gfx::Size(7, 4), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(4, 4), gfx::Size(8, 4), false));
+  EXPECT_EQ(3, NumTiles(gfx::Size(4, 4), gfx::Size(9, 4), false));
+  EXPECT_EQ(3, NumTiles(gfx::Size(4, 4), gfx::Size(10, 4), false));
+  EXPECT_EQ(3, NumTiles(gfx::Size(4, 4), gfx::Size(11, 4), false));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(1, 5), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(2, 5), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(3, 5), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(4, 5), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(5, 5), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(6, 5), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(7, 5), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(8, 5), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(9, 5), false));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(10, 5), false));
+  EXPECT_EQ(3, NumTiles(gfx::Size(5, 5), gfx::Size(11, 5), false));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(16, 16), gfx::Size(16, 16), false));
+  EXPECT_EQ(1, NumTiles(gfx::Size(17, 17), gfx::Size(16, 16), false));
+  EXPECT_EQ(4, NumTiles(gfx::Size(15, 15), gfx::Size(16, 16), false));
+  EXPECT_EQ(4, NumTiles(gfx::Size(8, 8), gfx::Size(16, 16), false));
+  EXPECT_EQ(6, NumTiles(gfx::Size(8, 8), gfx::Size(17, 16), false));
+
+  EXPECT_EQ(8, NumTiles(gfx::Size(5, 8), gfx::Size(17, 16), false));
+}
+
+TEST(TilingDataTest, numTiles_TilingWithBorders)
+{
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(0, 0), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(4, 0), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(0, 4), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(4, 4), gfx::Size(4, 0), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(4, 4), gfx::Size(0, 4), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(0, 0), gfx::Size(1, 1), true));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(1, 1), gfx::Size(1, 1), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(1, 1), gfx::Size(1, 2), true));
+  EXPECT_EQ(0, NumTiles(gfx::Size(1, 1), gfx::Size(2, 1), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(1, 1), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(1, 2), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(2, 1), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(2, 2), gfx::Size(2, 2), true));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(3, 3), gfx::Size(1, 3), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(3, 3), gfx::Size(2, 3), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(3, 3), gfx::Size(3, 3), true));
+  EXPECT_EQ(2, NumTiles(gfx::Size(3, 3), gfx::Size(4, 3), true));
+  EXPECT_EQ(3, NumTiles(gfx::Size(3, 3), gfx::Size(5, 3), true));
+  EXPECT_EQ(4, NumTiles(gfx::Size(3, 3), gfx::Size(6, 3), true));
+  EXPECT_EQ(5, NumTiles(gfx::Size(3, 3), gfx::Size(7, 3), true));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(1, 4), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(2, 4), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(3, 4), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(4, 4), gfx::Size(4, 4), true));
+  EXPECT_EQ(2, NumTiles(gfx::Size(4, 4), gfx::Size(5, 4), true));
+  EXPECT_EQ(2, NumTiles(gfx::Size(4, 4), gfx::Size(6, 4), true));
+  EXPECT_EQ(3, NumTiles(gfx::Size(4, 4), gfx::Size(7, 4), true));
+  EXPECT_EQ(3, NumTiles(gfx::Size(4, 4), gfx::Size(8, 4), true));
+  EXPECT_EQ(4, NumTiles(gfx::Size(4, 4), gfx::Size(9, 4), true));
+  EXPECT_EQ(4, NumTiles(gfx::Size(4, 4), gfx::Size(10, 4), true));
+  EXPECT_EQ(5, NumTiles(gfx::Size(4, 4), gfx::Size(11, 4), true));
+
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(1, 5), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(2, 5), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(3, 5), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(4, 5), true));
+  EXPECT_EQ(1, NumTiles(gfx::Size(5, 5), gfx::Size(5, 5), true));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(6, 5), true));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(7, 5), true));
+  EXPECT_EQ(2, NumTiles(gfx::Size(5, 5), gfx::Size(8, 5), true));
+  EXPECT_EQ(3, NumTiles(gfx::Size(5, 5), gfx::Size(9, 5), true));
+  EXPECT_EQ(3, NumTiles(gfx::Size(5, 5), gfx::Size(10, 5), true));
+  EXPECT_EQ(3, NumTiles(gfx::Size(5, 5), gfx::Size(11, 5), true));
+
+  EXPECT_EQ(30, NumTiles(gfx::Size(8, 5), gfx::Size(16, 32), true));
+}
+
+TEST(TilingDataTest, tileXIndexFromSrcCoord)
+{
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 2));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 3));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 4));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 5));
+  EXPECT_EQ(2, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 6));
+  EXPECT_EQ(2, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 7));
+  EXPECT_EQ(2, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 8));
+  EXPECT_EQ(3, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 9));
+  EXPECT_EQ(3, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 10));
+  EXPECT_EQ(3, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 11));
+
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 2));
+  EXPECT_EQ(2, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 3));
+  EXPECT_EQ(3, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 4));
+  EXPECT_EQ(4, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 5));
+  EXPECT_EQ(5, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 6));
+  EXPECT_EQ(6, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 7));
+  EXPECT_EQ(7, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 8));
+  EXPECT_EQ(7, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 9));
+  EXPECT_EQ(7, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 10));
+  EXPECT_EQ(7, XIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 11));
+
+  EXPECT_EQ(0, XIndex(gfx::Size(1, 1), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 1));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 1));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 2));
+
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 1));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 2));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 3));
+
+  EXPECT_EQ(0, XIndex(gfx::Size(1, 1), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 1));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 1));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 2));
+
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 0));
+  EXPECT_EQ(0, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 1));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 2));
+  EXPECT_EQ(1, XIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 3));
+}
+
+TEST(TilingDataTest, firstBorderTileXIndexFromSrcCoord)
+{
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 2));
+  EXPECT_EQ(1, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 3));
+  EXPECT_EQ(1, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 4));
+  EXPECT_EQ(1, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 5));
+  EXPECT_EQ(2, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 6));
+  EXPECT_EQ(2, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 7));
+  EXPECT_EQ(2, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 8));
+  EXPECT_EQ(3, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 9));
+  EXPECT_EQ(3, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 10));
+  EXPECT_EQ(3, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 11));
+
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 2));
+  EXPECT_EQ(1, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 3));
+  EXPECT_EQ(2, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 4));
+  EXPECT_EQ(3, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 5));
+  EXPECT_EQ(4, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 6));
+  EXPECT_EQ(5, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 7));
+  EXPECT_EQ(6, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 8));
+  EXPECT_EQ(7, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 9));
+  EXPECT_EQ(7, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 10));
+  EXPECT_EQ(7, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 11));
+
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(1, 1), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 2));
+
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 2));
+  EXPECT_EQ(1, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 3));
+
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(1, 1), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 2));
+
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 0));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 1));
+  EXPECT_EQ(0, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 2));
+  EXPECT_EQ(1, MinBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 3));
+}
+
+TEST(TilingDataTest, lastBorderTileXIndexFromSrcCoord)
+{
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 2));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 3));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 4));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 5));
+  EXPECT_EQ(2, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 6));
+  EXPECT_EQ(2, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 7));
+  EXPECT_EQ(2, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 8));
+  EXPECT_EQ(3, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 9));
+  EXPECT_EQ(3, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 10));
+  EXPECT_EQ(3, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 11));
+
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(2, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 2));
+  EXPECT_EQ(3, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 3));
+  EXPECT_EQ(4, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 4));
+  EXPECT_EQ(5, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 5));
+  EXPECT_EQ(6, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 6));
+  EXPECT_EQ(7, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 7));
+  EXPECT_EQ(7, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 8));
+  EXPECT_EQ(7, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 9));
+  EXPECT_EQ(7, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 10));
+  EXPECT_EQ(7, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 11));
+
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(1, 1), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 1));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 1));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 2));
+
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 1));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 2));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), false, 3));
+
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(1, 1), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 1));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 0));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 1));
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 2));
+
+  EXPECT_EQ(0, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 0));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 1));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 2));
+  EXPECT_EQ(1, MaxBorderXIndex(gfx::Size(3, 3), gfx::Size(4, 3), true, 3));
+}
+
+TEST(TilingDataTest, tileYIndexFromSrcCoord)
+{
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 2));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 3));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 4));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 5));
+  EXPECT_EQ(2, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 6));
+  EXPECT_EQ(2, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 7));
+  EXPECT_EQ(2, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 8));
+  EXPECT_EQ(3, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 9));
+  EXPECT_EQ(3, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 10));
+  EXPECT_EQ(3, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 11));
+
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 2));
+  EXPECT_EQ(2, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 3));
+  EXPECT_EQ(3, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 4));
+  EXPECT_EQ(4, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 5));
+  EXPECT_EQ(5, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 6));
+  EXPECT_EQ(6, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 7));
+  EXPECT_EQ(7, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 8));
+  EXPECT_EQ(7, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 9));
+  EXPECT_EQ(7, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 10));
+  EXPECT_EQ(7, YIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 11));
+
+  EXPECT_EQ(0, YIndex(gfx::Size(1, 1), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 1));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 1));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 2));
+
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 1));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 2));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 3));
+
+  EXPECT_EQ(0, YIndex(gfx::Size(1, 1), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 1));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 1));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 2));
+
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 0));
+  EXPECT_EQ(0, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 1));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 2));
+  EXPECT_EQ(1, YIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 3));
+}
+
+TEST(TilingDataTest, firstBorderTileYIndexFromSrcCoord)
+{
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 2));
+  EXPECT_EQ(1, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 3));
+  EXPECT_EQ(1, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 4));
+  EXPECT_EQ(1, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 5));
+  EXPECT_EQ(2, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 6));
+  EXPECT_EQ(2, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 7));
+  EXPECT_EQ(2, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 8));
+  EXPECT_EQ(3, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 9));
+  EXPECT_EQ(3, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 10));
+  EXPECT_EQ(3, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 11));
+
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 2));
+  EXPECT_EQ(1, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 3));
+  EXPECT_EQ(2, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 4));
+  EXPECT_EQ(3, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 5));
+  EXPECT_EQ(4, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 6));
+  EXPECT_EQ(5, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 7));
+  EXPECT_EQ(6, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 8));
+  EXPECT_EQ(7, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 9));
+  EXPECT_EQ(7, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 10));
+  EXPECT_EQ(7, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 11));
+
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(1, 1), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 2));
+
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 2));
+  EXPECT_EQ(1, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 3));
+
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(1, 1), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 2));
+
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 0));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 1));
+  EXPECT_EQ(0, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 2));
+  EXPECT_EQ(1, MinBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 3));
+}
+
+TEST(TilingDataTest, lastBorderTileYIndexFromSrcCoord)
+{
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 2));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 3));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 4));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 5));
+  EXPECT_EQ(2, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 6));
+  EXPECT_EQ(2, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 7));
+  EXPECT_EQ(2, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 8));
+  EXPECT_EQ(3, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 9));
+  EXPECT_EQ(3, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 10));
+  EXPECT_EQ(3, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), false, 11));
+
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(2, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 2));
+  EXPECT_EQ(3, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 3));
+  EXPECT_EQ(4, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 4));
+  EXPECT_EQ(5, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 5));
+  EXPECT_EQ(6, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 6));
+  EXPECT_EQ(7, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 7));
+  EXPECT_EQ(7, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 8));
+  EXPECT_EQ(7, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 9));
+  EXPECT_EQ(7, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 10));
+  EXPECT_EQ(7, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(10, 10), true, 11));
+
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(1, 1), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), false, 1));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 1));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), false, 2));
+
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 1));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 2));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), false, 3));
+
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(1, 1), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(2, 2), gfx::Size(2, 2), true, 1));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 0));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 1));
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 3), true, 2));
+
+  EXPECT_EQ(0, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 0));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 1));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 2));
+  EXPECT_EQ(1, MaxBorderYIndex(gfx::Size(3, 3), gfx::Size(3, 4), true, 3));
+}
+
+TEST(TilingDataTest, tileSizeX)
+{
+  EXPECT_EQ(5, SizeX(gfx::Size(5, 5), gfx::Size(5, 5), false, 0));
+  EXPECT_EQ(5, SizeX(gfx::Size(5, 5), gfx::Size(5, 5), true, 0));
+
+  EXPECT_EQ(5, SizeX(gfx::Size(5, 5), gfx::Size(6, 6), false, 0));
+  EXPECT_EQ(1, SizeX(gfx::Size(5, 5), gfx::Size(6, 6), false, 1));
+  EXPECT_EQ(4, SizeX(gfx::Size(5, 5), gfx::Size(6, 6), true, 0));
+  EXPECT_EQ(2, SizeX(gfx::Size(5, 5), gfx::Size(6, 6), true, 1));
+
+  EXPECT_EQ(5, SizeX(gfx::Size(5, 5), gfx::Size(8, 8), false, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(5, 5), gfx::Size(8, 8), false, 1));
+  EXPECT_EQ(4, SizeX(gfx::Size(5, 5), gfx::Size(8, 8), true, 0));
+  EXPECT_EQ(4, SizeX(gfx::Size(5, 5), gfx::Size(8, 8), true, 1));
+
+  EXPECT_EQ(5, SizeX(gfx::Size(5, 5), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(5, SizeX(gfx::Size(5, 5), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(4, SizeX(gfx::Size(5, 5), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(5, 5), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(3, SizeX(gfx::Size(5, 5), gfx::Size(10, 10), true, 2));
+
+  EXPECT_EQ(4, SizeX(gfx::Size(5, 5), gfx::Size(11, 11), true, 2));
+  EXPECT_EQ(3, SizeX(gfx::Size(5, 5), gfx::Size(12, 12), true, 2));
+
+  EXPECT_EQ(3, SizeX(gfx::Size(5, 9), gfx::Size(12, 17), true, 2));
+}
+
+TEST(TilingDataTest, TileSizeY)
+{
+  EXPECT_EQ(5, SizeY(gfx::Size(5, 5), gfx::Size(5, 5), false, 0));
+  EXPECT_EQ(5, SizeY(gfx::Size(5, 5), gfx::Size(5, 5), true, 0));
+
+  EXPECT_EQ(5, SizeY(gfx::Size(5, 5), gfx::Size(6, 6), false, 0));
+  EXPECT_EQ(1, SizeY(gfx::Size(5, 5), gfx::Size(6, 6), false, 1));
+  EXPECT_EQ(4, SizeY(gfx::Size(5, 5), gfx::Size(6, 6), true, 0));
+  EXPECT_EQ(2, SizeY(gfx::Size(5, 5), gfx::Size(6, 6), true, 1));
+
+  EXPECT_EQ(5, SizeY(gfx::Size(5, 5), gfx::Size(8, 8), false, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(5, 5), gfx::Size(8, 8), false, 1));
+  EXPECT_EQ(4, SizeY(gfx::Size(5, 5), gfx::Size(8, 8), true, 0));
+  EXPECT_EQ(4, SizeY(gfx::Size(5, 5), gfx::Size(8, 8), true, 1));
+
+  EXPECT_EQ(5, SizeY(gfx::Size(5, 5), gfx::Size(10, 10), false, 0));
+  EXPECT_EQ(5, SizeY(gfx::Size(5, 5), gfx::Size(10, 10), false, 1));
+  EXPECT_EQ(4, SizeY(gfx::Size(5, 5), gfx::Size(10, 10), true, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(5, 5), gfx::Size(10, 10), true, 1));
+  EXPECT_EQ(3, SizeY(gfx::Size(5, 5), gfx::Size(10, 10), true, 2));
+
+  EXPECT_EQ(4, SizeY(gfx::Size(5, 5), gfx::Size(11, 11), true, 2));
+  EXPECT_EQ(3, SizeY(gfx::Size(5, 5), gfx::Size(12, 12), true, 2));
+
+  EXPECT_EQ(3, SizeY(gfx::Size(9, 5), gfx::Size(17, 12), true, 2));
+}
+
+TEST(TilingDataTest, TileSizeX_and_TilePositionX)
+{
+  // Single tile cases:
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 3), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 3), gfx::Size(1, 100), false, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(1, 100), false, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(3, 1), false, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(3, 1), false, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(3, 100), false, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(3, 100), false, 0));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 3), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 3), gfx::Size(1, 100), true, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(1, 100), true, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(3, 1), true, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(3, 1), true, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(3, 100), true, 0));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(3, 100), true, 0));
+
+  // Multiple tiles:
+  // no border
+  // positions 0, 3
+  EXPECT_EQ(2, NumTiles(gfx::Size(3, 3), gfx::Size(6, 1), false));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(6, 1), false, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(6, 1), false, 1));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(6, 1), false, 0));
+  EXPECT_EQ(3, PosX(gfx::Size(3, 3), gfx::Size(6, 1), false, 1));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(6, 100), false, 0));
+  EXPECT_EQ(3, SizeX(gfx::Size(3, 3), gfx::Size(6, 100), false, 1));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(6, 100), false, 0));
+  EXPECT_EQ(3, PosX(gfx::Size(3, 3), gfx::Size(6, 100), false, 1));
+
+  // Multiple tiles:
+  // with border
+  // positions 0, 2, 3, 4
+  EXPECT_EQ(4, NumTiles(gfx::Size(3, 3), gfx::Size(6, 1), true));
+  EXPECT_EQ(2, SizeX(gfx::Size(3, 3), gfx::Size(6, 1), true, 0));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 3), gfx::Size(6, 1), true, 1));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 3), gfx::Size(6, 1), true, 2));
+  EXPECT_EQ(2, SizeX(gfx::Size(3, 3), gfx::Size(6, 1), true, 3));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 3), gfx::Size(6, 1), true, 0));
+  EXPECT_EQ(2, PosX(gfx::Size(3, 3), gfx::Size(6, 1), true, 1));
+  EXPECT_EQ(3, PosX(gfx::Size(3, 3), gfx::Size(6, 1), true, 2));
+  EXPECT_EQ(4, PosX(gfx::Size(3, 3), gfx::Size(6, 1), true, 3));
+  EXPECT_EQ(2, SizeX(gfx::Size(3, 7), gfx::Size(6, 100), true, 0));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 7), gfx::Size(6, 100), true, 1));
+  EXPECT_EQ(1, SizeX(gfx::Size(3, 7), gfx::Size(6, 100), true, 2));
+  EXPECT_EQ(2, SizeX(gfx::Size(3, 7), gfx::Size(6, 100), true, 3));
+  EXPECT_EQ(0, PosX(gfx::Size(3, 7), gfx::Size(6, 100), true, 0));
+  EXPECT_EQ(2, PosX(gfx::Size(3, 7), gfx::Size(6, 100), true, 1));
+  EXPECT_EQ(3, PosX(gfx::Size(3, 7), gfx::Size(6, 100), true, 2));
+  EXPECT_EQ(4, PosX(gfx::Size(3, 7), gfx::Size(6, 100), true, 3));
+}
+
+TEST(TilingDataTest, TileSizeY_and_TilePositionY)
+{
+  // Single tile cases:
+  EXPECT_EQ(1, SizeY(gfx::Size(3, 3), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(1, 1), false, 0));
+  EXPECT_EQ(1, SizeY(gfx::Size(3, 3), gfx::Size(100, 1), false, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(100, 1), false, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(1, 3), false, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(1, 3), false, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(100, 3), false, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(100, 3), false, 0));
+  EXPECT_EQ(1, SizeY(gfx::Size(3, 3), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(1, 1), true, 0));
+  EXPECT_EQ(1, SizeY(gfx::Size(3, 3), gfx::Size(100, 1), true, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(100, 1), true, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(1, 3), true, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(1, 3), true, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(100, 3), true, 0));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(100, 3), true, 0));
+
+  // Multiple tiles:
+  // no border
+  // positions 0, 3
+  EXPECT_EQ(2, NumTiles(gfx::Size(3, 3), gfx::Size(1, 6), false));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(1, 6), false, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(1, 6), false, 1));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(1, 6), false, 0));
+  EXPECT_EQ(3, PosY(gfx::Size(3, 3), gfx::Size(1, 6), false, 1));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(100, 6), false, 0));
+  EXPECT_EQ(3, SizeY(gfx::Size(3, 3), gfx::Size(100, 6), false, 1));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(100, 6), false, 0));
+  EXPECT_EQ(3, PosY(gfx::Size(3, 3), gfx::Size(100, 6), false, 1));
+
+  // Multiple tiles:
+  // with border
+  // positions 0, 2, 3, 4
+  EXPECT_EQ(4, NumTiles(gfx::Size(3, 3), gfx::Size(1, 6), true));
+  EXPECT_EQ(2, SizeY(gfx::Size(3, 3), gfx::Size(1, 6), true, 0));
+  EXPECT_EQ(1, SizeY(gfx::Size(3, 3), gfx::Size(1, 6), true, 1));
+  EXPECT_EQ(1, SizeY(gfx::Size(3, 3), gfx::Size(1, 6), true, 2));
+  EXPECT_EQ(2, SizeY(gfx::Size(3, 3), gfx::Size(1, 6), true, 3));
+  EXPECT_EQ(0, PosY(gfx::Size(3, 3), gfx::Size(1, 6), true, 0));
+  EXPECT_EQ(2, PosY(gfx::Size(3, 3), gfx::Size(1, 6), true, 1));
+  EXPECT_EQ(3, PosY(gfx::Size(3, 3), gfx::Size(1, 6), true, 2));
+  EXPECT_EQ(4, PosY(gfx::Size(3, 3), gfx::Size(1, 6), true, 3));
+  EXPECT_EQ(2, SizeY(gfx::Size(7, 3), gfx::Size(100, 6), true, 0));
+  EXPECT_EQ(1, SizeY(gfx::Size(7, 3), gfx::Size(100, 6), true, 1));
+  EXPECT_EQ(1, SizeY(gfx::Size(7, 3), gfx::Size(100, 6), true, 2));
+  EXPECT_EQ(2, SizeY(gfx::Size(7, 3), gfx::Size(100, 6), true, 3));
+  EXPECT_EQ(0, PosY(gfx::Size(7, 3), gfx::Size(100, 6), true, 0));
+  EXPECT_EQ(2, PosY(gfx::Size(7, 3), gfx::Size(100, 6), true, 1));
+  EXPECT_EQ(3, PosY(gfx::Size(7, 3), gfx::Size(100, 6), true, 2));
+  EXPECT_EQ(4, PosY(gfx::Size(7, 3), gfx::Size(100, 6), true, 3));
+}
+
+TEST(TilingDataTest, SetTotalSize)
+{
+  TilingData data(gfx::Size(5, 5), gfx::Size(5, 5), false);
+  EXPECT_EQ(5, data.total_size().width());
+  EXPECT_EQ(5, data.total_size().height());
+  EXPECT_EQ(1, data.num_tiles_x());
+  EXPECT_EQ(5, data.TileSizeX(0));
+  EXPECT_EQ(1, data.num_tiles_y());
+  EXPECT_EQ(5, data.TileSizeY(0));
+
+  data.SetTotalSize(gfx::Size(6, 5));
+  EXPECT_EQ(6, data.total_size().width());
+  EXPECT_EQ(5, data.total_size().height());
+  EXPECT_EQ(2, data.num_tiles_x());
+  EXPECT_EQ(5, data.TileSizeX(0));
+  EXPECT_EQ(1, data.TileSizeX(1));
+  EXPECT_EQ(1, data.num_tiles_y());
+  EXPECT_EQ(5, data.TileSizeY(0));
+
+  data.SetTotalSize(gfx::Size(5, 12));
+  EXPECT_EQ(5, data.total_size().width());
+  EXPECT_EQ(12, data.total_size().height());
+  EXPECT_EQ(1, data.num_tiles_x());
+  EXPECT_EQ(5, data.TileSizeX(0));
+  EXPECT_EQ(3, data.num_tiles_y());
+  EXPECT_EQ(5, data.TileSizeY(0));
+  EXPECT_EQ(5, data.TileSizeY(1));
+  EXPECT_EQ(2, data.TileSizeY(2));
+}
+
+TEST(TilingDataTest, SetMaxTextureSizeNoBorders)
+{
+  TilingData data(gfx::Size(8, 8), gfx::Size(16, 32), false);
+  EXPECT_EQ(2, data.num_tiles_x());
+  EXPECT_EQ(4, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(32, 32));
+  EXPECT_EQ(gfx::Size(32, 32), data.max_texture_size());
+  EXPECT_EQ(1, data.num_tiles_x());
+  EXPECT_EQ(1, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(2, 2));
+  EXPECT_EQ(gfx::Size(2, 2), data.max_texture_size());
+  EXPECT_EQ(8, data.num_tiles_x());
+  EXPECT_EQ(16, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(5, 5));
+  EXPECT_EQ(gfx::Size(5, 5), data.max_texture_size());
+  EXPECT_EQ(4, data.num_tiles_x());
+  EXPECT_EQ(7, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(8, 5));
+  EXPECT_EQ(gfx::Size(8, 5), data.max_texture_size());
+  EXPECT_EQ(2, data.num_tiles_x());
+  EXPECT_EQ(7, data.num_tiles_y());
+}
+
+TEST(TilingDataTest, SetMaxTextureSizeBorders)
+{
+  TilingData data(gfx::Size(8, 8), gfx::Size(16, 32), true);
+  EXPECT_EQ(3, data.num_tiles_x());
+  EXPECT_EQ(5, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(32, 32));
+  EXPECT_EQ(gfx::Size(32, 32), data.max_texture_size());
+  EXPECT_EQ(1, data.num_tiles_x());
+  EXPECT_EQ(1, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(2, 2));
+  EXPECT_EQ(gfx::Size(2, 2), data.max_texture_size());
+  EXPECT_EQ(0, data.num_tiles_x());
+  EXPECT_EQ(0, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(5, 5));
+  EXPECT_EQ(gfx::Size(5, 5), data.max_texture_size());
+  EXPECT_EQ(5, data.num_tiles_x());
+  EXPECT_EQ(10, data.num_tiles_y());
+
+  data.SetMaxTextureSize(gfx::Size(8, 5));
+  EXPECT_EQ(gfx::Size(8, 5), data.max_texture_size());
+  EXPECT_EQ(3, data.num_tiles_x());
+  EXPECT_EQ(10, data.num_tiles_y());
+}
+
+TEST(TilingDataTest, assignment)
+{
+  {
+    TilingData source(gfx::Size(8, 8), gfx::Size(16, 32), true);
+    TilingData dest = source;
+    EXPECT_EQ(source.border_texels(), dest.border_texels());
+    EXPECT_EQ(source.max_texture_size(), dest.max_texture_size());
+    EXPECT_EQ(source.num_tiles_x(), dest.num_tiles_x());
+    EXPECT_EQ(source.num_tiles_y(), dest.num_tiles_y());
+    EXPECT_EQ(source.total_size().width(), dest.total_size().width());
+    EXPECT_EQ(source.total_size().height(), dest.total_size().height());
+  }
+  {
+    TilingData source(gfx::Size(7, 3), gfx::Size(6, 100), false);
+    TilingData dest(source);
+    EXPECT_EQ(source.border_texels(), dest.border_texels());
+    EXPECT_EQ(source.max_texture_size(), dest.max_texture_size());
+    EXPECT_EQ(source.num_tiles_x(), dest.num_tiles_x());
+    EXPECT_EQ(source.num_tiles_y(), dest.num_tiles_y());
+    EXPECT_EQ(source.total_size().width(), dest.total_size().width());
+    EXPECT_EQ(source.total_size().height(), dest.total_size().height());
+  }
+}
+
+TEST(TilingDataTest, setBorderTexels)
+{
+  TilingData data(gfx::Size(8, 8), gfx::Size(16, 32), false);
+  EXPECT_EQ(2, data.num_tiles_x());
+  EXPECT_EQ(4, data.num_tiles_y());
+
+  data.SetHasBorderTexels(true);
+  EXPECT_EQ(3, data.num_tiles_x());
+  EXPECT_EQ(5, data.num_tiles_y());
+
+  data.SetHasBorderTexels(true);
+  EXPECT_EQ(3, data.num_tiles_x());
+  EXPECT_EQ(5, data.num_tiles_y());
+
+  data.SetHasBorderTexels(false);
+  EXPECT_EQ(2, data.num_tiles_x());
+  EXPECT_EQ(4, data.num_tiles_y());
+}
+
+TEST(TilingDataTest, largeBorders)
+{
+  TilingData data(gfx::Size(100, 80), gfx::Size(200, 145), 30);
+  EXPECT_EQ(30, data.border_texels());
+
+  EXPECT_EQ(70, data.TileSizeX(0));
+  EXPECT_EQ(40, data.TileSizeX(1));
+  EXPECT_EQ(40, data.TileSizeX(2));
+  EXPECT_EQ(50, data.TileSizeX(3));
+  EXPECT_EQ(4, data.num_tiles_x());
+
+  EXPECT_EQ(50, data.TileSizeY(0));
+  EXPECT_EQ(20, data.TileSizeY(1));
+  EXPECT_EQ(20, data.TileSizeY(2));
+  EXPECT_EQ(20, data.TileSizeY(3));
+  EXPECT_EQ(35, data.TileSizeY(4));
+  EXPECT_EQ(5, data.num_tiles_y());
+
+  EXPECT_RECT_EQ(gfx::Rect(0, 0, 70, 50), data.TileBounds(0, 0));
+  EXPECT_RECT_EQ(gfx::Rect(70, 50, 40, 20), data.TileBounds(1, 1));
+  EXPECT_RECT_EQ(gfx::Rect(110, 110, 40, 35), data.TileBounds(2, 4));
+  EXPECT_RECT_EQ(gfx::Rect(150, 70, 50, 20), data.TileBounds(3, 2));
+  EXPECT_RECT_EQ(gfx::Rect(150, 110, 50, 35), data.TileBounds(3, 4));
+
+  EXPECT_RECT_EQ(gfx::Rect(0, 0, 100, 80), data.TileBoundsWithBorder(0, 0));
+  EXPECT_RECT_EQ(gfx::Rect(40, 20, 100, 80), data.TileBoundsWithBorder(1, 1));
+  EXPECT_RECT_EQ(gfx::Rect(80, 80, 100, 65), data.TileBoundsWithBorder(2, 4));
+  EXPECT_RECT_EQ(gfx::Rect(120, 40, 80, 80), data.TileBoundsWithBorder(3, 2));
+  EXPECT_RECT_EQ(gfx::Rect(120, 80, 80, 65), data.TileBoundsWithBorder(3, 4));
+
+  EXPECT_EQ(0, data.TileXIndexFromSrcCoord(0));
+  EXPECT_EQ(0, data.TileXIndexFromSrcCoord(69));
+  EXPECT_EQ(1, data.TileXIndexFromSrcCoord(70));
+  EXPECT_EQ(1, data.TileXIndexFromSrcCoord(109));
+  EXPECT_EQ(2, data.TileXIndexFromSrcCoord(110));
+  EXPECT_EQ(2, data.TileXIndexFromSrcCoord(149));
+  EXPECT_EQ(3, data.TileXIndexFromSrcCoord(150));
+  EXPECT_EQ(3, data.TileXIndexFromSrcCoord(199));
+
+  EXPECT_EQ(0, data.TileYIndexFromSrcCoord(0));
+  EXPECT_EQ(0, data.TileYIndexFromSrcCoord(49));
+  EXPECT_EQ(1, data.TileYIndexFromSrcCoord(50));
+  EXPECT_EQ(1, data.TileYIndexFromSrcCoord(69));
+  EXPECT_EQ(2, data.TileYIndexFromSrcCoord(70));
+  EXPECT_EQ(2, data.TileYIndexFromSrcCoord(89));
+  EXPECT_EQ(3, data.TileYIndexFromSrcCoord(90));
+  EXPECT_EQ(3, data.TileYIndexFromSrcCoord(109));
+  EXPECT_EQ(4, data.TileYIndexFromSrcCoord(110));
+  EXPECT_EQ(4, data.TileYIndexFromSrcCoord(144));
+
+  EXPECT_EQ(0, data.FirstBorderTileXIndexFromSrcCoord(0));
+  EXPECT_EQ(0, data.FirstBorderTileXIndexFromSrcCoord(99));
+  EXPECT_EQ(1, data.FirstBorderTileXIndexFromSrcCoord(100));
+  EXPECT_EQ(1, data.FirstBorderTileXIndexFromSrcCoord(139));
+  EXPECT_EQ(2, data.FirstBorderTileXIndexFromSrcCoord(140));
+  EXPECT_EQ(2, data.FirstBorderTileXIndexFromSrcCoord(179));
+  EXPECT_EQ(3, data.FirstBorderTileXIndexFromSrcCoord(180));
+  EXPECT_EQ(3, data.FirstBorderTileXIndexFromSrcCoord(199));
+
+  EXPECT_EQ(0, data.FirstBorderTileYIndexFromSrcCoord(0));
+  EXPECT_EQ(0, data.FirstBorderTileYIndexFromSrcCoord(79));
+  EXPECT_EQ(1, data.FirstBorderTileYIndexFromSrcCoord(80));
+  EXPECT_EQ(1, data.FirstBorderTileYIndexFromSrcCoord(99));
+  EXPECT_EQ(2, data.FirstBorderTileYIndexFromSrcCoord(100));
+  EXPECT_EQ(2, data.FirstBorderTileYIndexFromSrcCoord(119));
+  EXPECT_EQ(3, data.FirstBorderTileYIndexFromSrcCoord(120));
+  EXPECT_EQ(3, data.FirstBorderTileYIndexFromSrcCoord(139));
+  EXPECT_EQ(4, data.FirstBorderTileYIndexFromSrcCoord(140));
+  EXPECT_EQ(4, data.FirstBorderTileYIndexFromSrcCoord(144));
+
+  EXPECT_EQ(0, data.LastBorderTileXIndexFromSrcCoord(0));
+  EXPECT_EQ(0, data.LastBorderTileXIndexFromSrcCoord(39));
+  EXPECT_EQ(1, data.LastBorderTileXIndexFromSrcCoord(40));
+  EXPECT_EQ(1, data.LastBorderTileXIndexFromSrcCoord(79));
+  EXPECT_EQ(2, data.LastBorderTileXIndexFromSrcCoord(80));
+  EXPECT_EQ(2, data.LastBorderTileXIndexFromSrcCoord(119));
+  EXPECT_EQ(3, data.LastBorderTileXIndexFromSrcCoord(120));
+  EXPECT_EQ(3, data.LastBorderTileXIndexFromSrcCoord(199));
+
+  EXPECT_EQ(0, data.LastBorderTileYIndexFromSrcCoord(0));
+  EXPECT_EQ(0, data.LastBorderTileYIndexFromSrcCoord(19));
+  EXPECT_EQ(1, data.LastBorderTileYIndexFromSrcCoord(20));
+  EXPECT_EQ(1, data.LastBorderTileYIndexFromSrcCoord(39));
+  EXPECT_EQ(2, data.LastBorderTileYIndexFromSrcCoord(40));
+  EXPECT_EQ(2, data.LastBorderTileYIndexFromSrcCoord(59));
+  EXPECT_EQ(3, data.LastBorderTileYIndexFromSrcCoord(60));
+  EXPECT_EQ(3, data.LastBorderTileYIndexFromSrcCoord(79));
+  EXPECT_EQ(4, data.LastBorderTileYIndexFromSrcCoord(80));
+  EXPECT_EQ(4, data.LastBorderTileYIndexFromSrcCoord(144));
+}
+
+void TestIterate(
+    const TilingData& data,
+    gfx::Rect rect,
+    int expect_left,
+    int expect_top,
+    int expect_right,
+    int expect_bottom) {
+
+  EXPECT_GE(expect_left, 0);
+  EXPECT_GE(expect_top, 0);
+  EXPECT_LT(expect_right, data.num_tiles_x());
+  EXPECT_LT(expect_bottom, data.num_tiles_y());
+
+  std::vector<std::pair<int, int> > original_expected;
+  for (int x = 0; x < data.num_tiles_x(); ++x) {
+    for (int y = 0; y < data.num_tiles_y(); ++y) {
+      gfx::Rect bounds = data.TileBoundsWithBorder(x, y);
+      if (x >= expect_left && x <= expect_right &&
+          y >= expect_top && y <= expect_bottom) {
+        EXPECT_TRUE(bounds.Intersects(rect));
+        original_expected.push_back(std::make_pair(x, y));
+      } else {
+        EXPECT_FALSE(bounds.Intersects(rect));
+      }
+    }
+  }
+
+  // Verify with vanilla iterator.
+  {
+    std::vector<std::pair<int, int> > expected = original_expected;
+    for (TilingData::Iterator iter(&data, rect); iter; ++iter) {
+      bool found = false;
+      for (size_t i = 0; i < expected.size(); ++i) {
+        if (expected[i] == iter.index()) {
+          expected[i] = expected.back();
+          expected.pop_back();
+          found = true;
+          break;
+        }
+      }
+      EXPECT_TRUE(found);
+    }
+    EXPECT_EQ(0, expected.size());
+  }
+
+  // Make sure this also works with a difference iterator and an empty ignore.
+  {
+    std::vector<std::pair<int, int> > expected = original_expected;
+    for (TilingData::DifferenceIterator iter(&data, rect, gfx::Rect());
+         iter; ++iter) {
+      bool found = false;
+      for (size_t i = 0; i < expected.size(); ++i) {
+        if (expected[i] == iter.index()) {
+          expected[i] = expected.back();
+          expected.pop_back();
+          found = true;
+          break;
+        }
+      }
+      EXPECT_TRUE(found);
+    }
+    EXPECT_EQ(0, expected.size());
+  }
+}
+
+TEST(TilingDataTest, iteratorNoBorderTexels)
+{
+  TilingData data(gfx::Size(10, 10), gfx::Size(40, 25), false);
+  // X border index by src coord: [0-10), [10-20), [20, 30), [30, 40)
+  // Y border index by src coord: [0-10), [10-20), [20, 25)
+  TestIterate(data, gfx::Rect(0, 0, 40, 25), 0, 0, 3, 2);
+  TestIterate(data, gfx::Rect(15, 15, 8, 8), 1, 1, 2, 2);
+
+  // Oversized.
+  TestIterate(data, gfx::Rect(-100, -100, 1000, 1000), 0, 0, 3, 2);
+  TestIterate(data, gfx::Rect(-100, 20, 1000, 1), 0, 2, 3, 2);
+  TestIterate(data, gfx::Rect(29, -100, 31, 1000), 2, 0, 3, 2);
+  // Nonintersecting.
+  TestIterate(data, gfx::Rect(60, 80, 100, 100), 0, 0, -1, -1);
+}
+
+TEST(TilingDataTest, iteratorOneBorderTexel)
+{
+  TilingData data(gfx::Size(10, 20), gfx::Size(25, 45), true);
+  // X border index by src coord: [0-10), [8-18), [16-25)
+  // Y border index by src coord: [0-20), [18-38), [36-45)
+  TestIterate(data, gfx::Rect(0, 0, 25, 45), 0, 0, 2, 2);
+  TestIterate(data, gfx::Rect(18, 19, 3, 17), 2, 0, 2, 1);
+  TestIterate(data, gfx::Rect(10, 20, 6, 16), 1, 1, 1, 1);
+  TestIterate(data, gfx::Rect(9, 19, 8, 18), 0, 0, 2, 2);
+
+  // Oversized.
+  TestIterate(data, gfx::Rect(-100, -100, 1000, 1000), 0, 0, 2, 2);
+  TestIterate(data, gfx::Rect(-100, 20, 1000, 1), 0, 1, 2, 1);
+  TestIterate(data, gfx::Rect(18, -100, 6, 1000), 2, 0, 2, 2);
+  // Nonintersecting.
+  TestIterate(data, gfx::Rect(60, 80, 100, 100), 0, 0, -1, -1);
+}
+
+TEST(TilingDataTest, iteratorManyBorderTexels)
+{
+  TilingData data(gfx::Size(50, 60), gfx::Size(65, 110), 20);
+  // X border index by src coord: [0-50), [10-60), [20-65)
+  // Y border index by src coord: [0-60), [20-80), [40-100), [60-110)
+  TestIterate(data, gfx::Rect(0, 0, 65, 110), 0, 0, 2, 3);
+  TestIterate(data, gfx::Rect(50, 60, 15, 65), 1, 1, 2, 3);
+  TestIterate(data, gfx::Rect(60, 30, 2, 10), 2, 0, 2, 1);
+
+  // Oversized.
+  TestIterate(data, gfx::Rect(-100, -100, 1000, 1000), 0, 0, 2, 3);
+  TestIterate(data, gfx::Rect(-100, 10, 1000, 10), 0, 0, 2, 0);
+  TestIterate(data, gfx::Rect(10, -100, 10, 1000), 0, 0, 1, 3);
+  // Nonintersecting.
+  TestIterate(data, gfx::Rect(65, 110, 100, 100), 0, 0, -1, -1);
+}
+
+TEST(TilingDataTest, iteratorOneTile)
+{
+  TilingData no_border(gfx::Size(1000, 1000), gfx::Size(30, 40), false);
+  TestIterate(no_border, gfx::Rect(0, 0, 30, 40), 0, 0, 0, 0);
+  TestIterate(no_border, gfx::Rect(10, 10, 20, 20), 0, 0, 0, 0);
+  TestIterate(no_border, gfx::Rect(30, 40, 100, 100), 0, 0, -1, -1);
+
+  TilingData one_border(gfx::Size(1000, 1000), gfx::Size(30, 40), true);
+  TestIterate(one_border, gfx::Rect(0, 0, 30, 40), 0, 0, 0, 0);
+  TestIterate(one_border, gfx::Rect(10, 10, 20, 20), 0, 0, 0, 0);
+  TestIterate(one_border, gfx::Rect(30, 40, 100, 100), 0, 0, -1, -1);
+
+  TilingData big_border(gfx::Size(1000, 1000), gfx::Size(30, 40), 50);
+  TestIterate(big_border, gfx::Rect(0, 0, 30, 40), 0, 0, 0, 0);
+  TestIterate(big_border, gfx::Rect(10, 10, 20, 20), 0, 0, 0, 0);
+  TestIterate(big_border, gfx::Rect(30, 40, 100, 100), 0, 0, -1, -1);
+}
+
+TEST(TilingDataTest, iteratorNoTiles)
+{
+  TilingData data(gfx::Size(100, 100), gfx::Size(), false);
+  TestIterate(data, gfx::Rect(0, 0, 100, 100), 0, 0, -1, -1);
+}
+
+void TestDiff(
+    const TilingData& data,
+    gfx::Rect consider,
+    gfx::Rect ignore,
+    size_t num_tiles) {
+
+  std::vector<std::pair<int, int> > expected;
+  for (int y = 0; y < data.num_tiles_y(); ++y) {
+    for (int x = 0; x < data.num_tiles_x(); ++x) {
+      gfx::Rect bounds = data.TileBoundsWithBorder(x, y);
+      if (bounds.Intersects(consider) && !bounds.Intersects(ignore))
+        expected.push_back(std::make_pair(x, y));
+    }
+  }
+
+  // Sanity check the test.
+  EXPECT_EQ(num_tiles, expected.size());
+
+  for (TilingData::DifferenceIterator iter(&data, consider, ignore);
+       iter; ++iter) {
+    bool found = false;
+    for (size_t i = 0; i < expected.size(); ++i) {
+      if (expected[i] == iter.index()) {
+        expected[i] = expected.back();
+        expected.pop_back();
+        found = true;
+        break;
+      }
+    }
+    EXPECT_TRUE(found);
+  }
+  EXPECT_EQ(0, expected.size());
+}
+
+TEST(TilingDataTest, differenceIteratorIgnoreGeometry)
+{
+  // This test is checking that the iterator can handle different geometries of
+  // ignore rects relative to the consider rect.  The consider rect indices
+  // themselves are mostly tested by the non-difference iterator tests, so the
+  // full rect is mostly used here for simplicity.
+
+  // X border index by src coord: [0-10), [10-20), [20, 30), [30, 40)
+  // Y border index by src coord: [0-10), [10-20), [20, 25)
+  TilingData data(gfx::Size(10, 10), gfx::Size(40, 25), false);
+
+  // Fully ignored
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 0, 40, 25), 0);
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(-100, -100, 200, 200), 0);
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(9, 9, 30, 15), 0);
+  TestDiff(data, gfx::Rect(15, 15, 8, 8), gfx::Rect(15, 15, 8, 8), 0);
+
+  // Fully un-ignored
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(-30, -20, 8, 8), 12);
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(), 12);
+
+  // Top left, remove 2x2 tiles
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 0, 20, 19), 8);
+  // Bottom right, remove 2x2 tiles
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(20, 15, 20, 6), 8);
+  // Bottom left, remove 2x2 tiles
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 15, 20, 6), 8);
+  // Top right, remove 2x2 tiles
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(20, 0, 20, 19), 8);
+  // Center, remove only one tile
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(10, 10, 5, 5), 11);
+
+  // Left column, flush left, removing two columns
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 0, 11, 25), 6);
+  // Middle column, removing two columns
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(11, 0, 11, 25), 6);
+  // Right column, flush right, removing one column
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(30, 0, 2, 25), 9);
+
+  // Top row, flush top, removing one row
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 5, 40, 5), 8);
+  // Middle row, removing one row
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 13, 40, 5), 8);
+  // Bottom row, flush bottom, removing two rows
+  TestDiff(data, gfx::Rect(0, 0, 40, 25), gfx::Rect(0, 13, 40, 12), 4);
+
+  // Non-intersecting, but still touching two of the same tiles.
+  TestDiff(data, gfx::Rect(8, 0, 32, 25), gfx::Rect(0, 12, 5, 12), 10);
+
+  // Intersecting, but neither contains the other. 2x3 with one overlap.
+  TestDiff(data, gfx::Rect(5, 2, 20, 10), gfx::Rect(25, 15, 5, 10), 5);
+}
+
+TEST(TilingDataTest, differenceIteratorManyBorderTexels)
+{
+  // X border index by src coord: [0-50), [10-60), [20-65)
+  // Y border index by src coord: [0-60), [20-80), [40-100), [60-110)
+  TilingData data(gfx::Size(50, 60), gfx::Size(65, 110), 20);
+
+  // Ignore one column, three rows
+  TestDiff(data, gfx::Rect(0, 30, 55, 80), gfx::Rect(5, 30, 5, 15), 9);
+
+  // Knock out three columns, leaving only one.
+  TestDiff(data, gfx::Rect(10, 30, 55, 80), gfx::Rect(30, 59, 20, 1), 3);
+
+  // Overlap all tiles with ignore rect.
+  TestDiff(data, gfx::Rect(0, 0, 65, 110), gfx::Rect(30, 59, 1, 2), 0);
+}
+
+TEST(TilingDataTest, differenceIteratorOneTile)
+{
+  TilingData no_border(gfx::Size(1000, 1000), gfx::Size(30, 40), false);
+  TestDiff(no_border, gfx::Rect(0, 0, 30, 40), gfx::Rect(), 1);
+  TestDiff(no_border, gfx::Rect(5, 5, 100, 100), gfx::Rect(5, 5, 1, 1), 0);
+
+  TilingData one_border(gfx::Size(1000, 1000), gfx::Size(30, 40), true);
+  TestDiff(one_border, gfx::Rect(0, 0, 30, 40), gfx::Rect(), 1);
+  TestDiff(one_border, gfx::Rect(5, 5, 100, 100), gfx::Rect(5, 5, 1, 1), 0);
+
+  TilingData big_border(gfx::Size(1000, 1000), gfx::Size(30, 40), 50);
+  TestDiff(big_border, gfx::Rect(0, 0, 30, 40), gfx::Rect(), 1);
+  TestDiff(big_border, gfx::Rect(5, 5, 100, 100), gfx::Rect(5, 5, 1, 1), 0);
+}
+
+TEST(TilingDataTest, differenceIteratorNoTiles)
+{
+  TilingData data(gfx::Size(100, 100), gfx::Size(), false);
+  TestDiff(data, gfx::Rect(0, 0, 100, 100), gfx::Rect(0, 0, 5, 5), 0);
+}
+
+}  // namespace
+}  // namespace cc
Index: src/cc/video_frame_provider.h
===================================================================
--- src/cc/video_frame_provider.h (revision 0)
+++ src/cc/video_frame_provider.h (revision 0)
@@ -0,0 +1,59 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_VIDEO_FRAME_PROVIDER_H_
+#define CC_VIDEO_FRAME_PROVIDER_H_
+
+#include "base/memory/ref_counted.h"
+
+namespace media {
+class VideoFrame;
+}
+
+namespace cc {
+
+// Threading notes: This class may be used in a multi threaded manner.
+// Specifically, the implementation may call getCurrentFrame() or
+// putCurrentFrame() from the compositor thread. If so, the caller is
+// responsible for making sure Client::didReceiveFrame and
+// Client::didUpdateMatrix are only called from this same thread.
+class VideoFrameProvider {
+ public:
+  virtual ~VideoFrameProvider() {}
+
+  class Client {
+   public:
+    // Provider will call this method to tell the client to stop using it.
+    // StopUsingProvider() may be called from any thread. The client should
+    // block until it has PutCurrentFrame() any outstanding frames.
+    virtual void StopUsingProvider() = 0;
+
+    // Notifies the provider's client that a call to GetCurrentFrame() will
+    // return new data.
+    virtual void DidReceiveFrame() = 0;
+
+    // Notifies the provider's client of a new UV transform matrix to be used.
+    virtual void DidUpdateMatrix(const float*) = 0;
+  };
+
+  // May be called from any thread, but there must be some external guarantee
+  // that the provider is not destroyed before this call returns.
+  virtual void SetVideoFrameProviderClient(Client*) = 0;
+
+  // This function places a lock on the current frame and returns a pointer to
+  // it. Calls to this method should always be followed with a call to
+  // PutCurrentFrame().
+  // Only the current provider client should call this function.
+  virtual scoped_refptr<media::VideoFrame> GetCurrentFrame() = 0;
+
+  // This function releases the lock on the video frame. It should always be
+  // called after GetCurrentFrame(). Frames passed into this method
+  // should no longer be referenced after the call is made. Only the current
+  // provider client should call this function.
+  virtual void PutCurrentFrame(const scoped_refptr<media::VideoFrame>&) = 0;
+};
+
+}  // namespace cc
+
+#endif  // CC_VIDEO_FRAME_PROVIDER_H_
Index: src/cc/texture_mailbox.cc
===================================================================
--- src/cc/texture_mailbox.cc (revision 0)
+++ src/cc/texture_mailbox.cc (revision 0)
@@ -0,0 +1,69 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/logging.h"
+#include "cc/texture_mailbox.h"
+
+namespace cc {
+
+TextureMailbox::TextureMailbox()
+    : sync_point_(0) {
+}
+
+TextureMailbox::TextureMailbox(
+    const std::string& mailbox_name,
+    const ReleaseCallback& mailbox_callback)
+    : callback_(mailbox_callback),
+      sync_point_(0) {
+  DCHECK(mailbox_name.empty() == mailbox_callback.is_null());
+  if (!mailbox_name.empty()) {
+    CHECK(mailbox_name.size() == sizeof(name_.name));
+    name_.setName(reinterpret_cast<const int8*>(mailbox_name.data()));
+  }
+}
+
+TextureMailbox::TextureMailbox(
+    const Mailbox& mailbox_name,
+    const ReleaseCallback& mailbox_callback)
+    : callback_(mailbox_callback),
+      sync_point_(0) {
+  DCHECK(mailbox_name.isZero() == mailbox_callback.is_null());
+  name_.setName(mailbox_name.name);
+}
+
+TextureMailbox::TextureMailbox(
+    const Mailbox& mailbox_name,
+    const ReleaseCallback& mailbox_callback,
+    unsigned sync_point)
+    : callback_(mailbox_callback),
+      sync_point_(sync_point) {
+  DCHECK(mailbox_name.isZero() == mailbox_callback.is_null());
+  name_.setName(mailbox_name.name);
+}
+
+TextureMailbox::~TextureMailbox() {
+}
+
+bool TextureMailbox::Equals(const Mailbox& other) const {
+  return !memcmp(data(), other.name, sizeof(name_.name));
+}
+
+bool TextureMailbox::Equals(const TextureMailbox& other) const {
+  return Equals(other.name());
+}
+
+bool TextureMailbox::IsEmpty() const {
+  return name_.isZero();
+}
+
+void TextureMailbox::RunReleaseCallback(unsigned sync_point) const {
+  if (!callback_.is_null())
+    callback_.Run(sync_point);
+}
+
+void TextureMailbox::SetName(const Mailbox& other) {
+  name_.setName(other.name);
+}
+
+}  // namespace cc
Index: src/cc/test/fake_scrollbar_layer.cc
===================================================================
--- src/cc/test/fake_scrollbar_layer.cc (revision 0)
+++ src/cc/test/fake_scrollbar_layer.cc (revision 0)
@@ -0,0 +1,45 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/test/fake_scrollbar_layer.h"
+
+#include "cc/resource_update_queue.h"
+#include "cc/test/fake_scrollbar_theme_painter.h"
+#include "cc/test/fake_web_scrollbar.h"
+#include "cc/test/fake_web_scrollbar_theme_geometry.h"
+
+namespace cc {
+
+FakeScrollbarLayer::FakeScrollbarLayer(
+    bool paint_during_update, bool has_thumb, int scrolling_layer_id)
+    : ScrollbarLayer(
+        FakeWebScrollbar::create().PassAs<WebKit::WebScrollbar>(),
+        FakeScrollbarThemePainter::Create(paint_during_update)
+        .PassAs<ScrollbarThemePainter>(),
+        FakeWebScrollbarThemeGeometry::create(has_thumb)
+        .PassAs<WebKit::WebScrollbarThemeGeometry>(),
+        scrolling_layer_id),
+      update_count_(0),
+      last_update_full_upload_size_(0),
+      last_update_partial_upload_size_(0) {
+  setAnchorPoint(gfx::PointF(0, 0));
+  setBounds(gfx::Size(1, 1));
+  setIsDrawable(true);
+}
+
+FakeScrollbarLayer::~FakeScrollbarLayer() {}
+
+void FakeScrollbarLayer::update(
+    ResourceUpdateQueue& queue,
+    const OcclusionTracker* occlusion,
+    RenderingStats& stats) {
+  size_t full = queue.fullUploadSize();
+  size_t partial = queue.partialUploadSize();
+  ScrollbarLayer::update(queue, occlusion, stats);
+  update_count_++;
+  last_update_full_upload_size_ = queue.fullUploadSize() - full;
+  last_update_partial_upload_size_ = queue.partialUploadSize() - partial;
+}
+
+}  // namespace cc
Index: src/cc/test/fake_scrollbar_theme_painter.cc
===================================================================
--- src/cc/test/fake_scrollbar_theme_painter.cc (revision 0)
+++ src/cc/test/fake_scrollbar_theme_painter.cc (revision 0)
@@ -0,0 +1,69 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/test/fake_scrollbar_theme_painter.h"
+#include "third_party/skia/include/core/SkCanvas.h"
+#include "ui/gfx/rect.h"
+
+namespace cc {
+
+void FakeScrollbarThemePainter::PaintScrollbarBackground(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintTrackBackground(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintBackTrackPart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintForwardTrackPart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintBackButtonStart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintBackButtonEnd(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintForwardButtonStart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintForwardButtonEnd(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintTickmarks(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::PaintThumb(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  Paint(canvas, rect);
+}
+
+void FakeScrollbarThemePainter::Paint(SkCanvas* canvas, gfx::Rect rect) {
+  if (!paint_)
+    return;
+  // Fill the scrollbar with a different color each time.
+  ++fill_color_;
+  canvas->clear(SK_ColorBLACK | fill_color_);
+}
+
+}  // namespace cc
Index: src/cc/test/fake_content_layer_impl.h
===================================================================
--- src/cc/test/fake_content_layer_impl.h (revision 0)
+++ src/cc/test/fake_content_layer_impl.h (revision 0)
@@ -0,0 +1,38 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEST_FAKE_CONTENT_LAYER_IMPL_H_
+#define CC_TEST_FAKE_CONTENT_LAYER_IMPL_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/tiled_layer_impl.h"
+
+namespace cc {
+
+class FakeContentLayerImpl : public TiledLayerImpl {
+ public:
+  static scoped_ptr<FakeContentLayerImpl> Create(
+      LayerTreeImpl* tree_impl, int id) {
+    return make_scoped_ptr(new FakeContentLayerImpl(tree_impl, id));
+  }
+  virtual ~FakeContentLayerImpl();
+
+  bool HaveResourceForTileAt(int i, int j);
+
+  size_t lost_output_surface_count() const {
+    return lost_output_surface_count_;
+  }
+  void reset_lost_output_surface_count() { lost_output_surface_count_ = 0; }
+
+  virtual void didLoseOutputSurface() OVERRIDE;
+
+ private:
+  explicit FakeContentLayerImpl(LayerTreeImpl* tree_impl, int id);
+
+  size_t lost_output_surface_count_;
+};
+
+}  // namespace cc
+
+#endif  // CC_TEST_FAKE_CONTENT_LAYER_IMPL_H_
Index: src/cc/test/fake_content_layer.cc
===================================================================
--- src/cc/test/fake_content_layer.cc (revision 0)
+++ src/cc/test/fake_content_layer.cc (revision 0)
@@ -0,0 +1,40 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/test/fake_content_layer.h"
+
+#include "cc/prioritized_resource.h"
+#include "cc/test/fake_content_layer_impl.h"
+
+namespace cc {
+
+FakeContentLayer::FakeContentLayer(ContentLayerClient* client)
+    : ContentLayer(client),
+      update_count_(0) {
+  setAnchorPoint(gfx::PointF(0, 0));
+  setBounds(gfx::Size(1, 1));
+  setIsDrawable(true);
+}
+
+FakeContentLayer::~FakeContentLayer() {}
+
+scoped_ptr<LayerImpl> FakeContentLayer::createLayerImpl(
+    LayerTreeImpl* tree_impl) {
+  return FakeContentLayerImpl::Create(tree_impl, m_layerId).PassAs<LayerImpl>();
+}
+
+void FakeContentLayer::update(
+    ResourceUpdateQueue& queue,
+    const OcclusionTracker* occlusion,
+    RenderingStats& stats) {
+  ContentLayer::update(queue, occlusion, stats);
+  update_count_++;
+}
+
+bool FakeContentLayer::HaveBackingAt(int i, int j) {
+  const PrioritizedResource* resource = resourceAtForTesting(i, j);
+  return resource && resource->haveBackingTexture();
+}
+
+}  // namespace cc
Index: src/cc/test/fake_web_scrollbar.cc
===================================================================
--- src/cc/test/fake_web_scrollbar.cc (revision 0)
+++ src/cc/test/fake_web_scrollbar.cc (revision 0)
@@ -0,0 +1,76 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/test/fake_web_scrollbar.h"
+
+namespace cc {
+
+void FakeWebScrollbar::setOverlay(bool isOverlay) {
+  m_isOverlay = isOverlay;
+}
+
+bool FakeWebScrollbar::isOverlay() const {
+  return m_isOverlay;
+}
+
+int FakeWebScrollbar::value() const {
+  return 0;
+}
+
+WebKit::WebPoint FakeWebScrollbar::location() const {
+  return WebKit::WebPoint();
+}
+
+WebKit::WebSize FakeWebScrollbar::size() const {
+  return WebKit::WebSize();
+}
+
+bool FakeWebScrollbar::enabled() const {
+  return true;
+}
+
+int FakeWebScrollbar::maximum() const {
+  return 0;
+}
+
+int FakeWebScrollbar::totalSize() const {
+  return 0;
+}
+
+bool FakeWebScrollbar::isScrollViewScrollbar() const {
+  return false;
+}
+
+bool FakeWebScrollbar::isScrollableAreaActive() const {
+  return true;
+}
+
+WebKit::WebScrollbar::ScrollbarControlSize FakeWebScrollbar::controlSize() const {
+  return WebScrollbar::RegularScrollbar;
+}
+
+WebKit::WebScrollbar::ScrollbarPart FakeWebScrollbar::pressedPart() const {
+  return WebScrollbar::NoPart;
+}
+
+WebKit::WebScrollbar::ScrollbarPart FakeWebScrollbar::hoveredPart() const {
+  return WebScrollbar::NoPart;
+}
+
+WebKit::WebScrollbar::ScrollbarOverlayStyle FakeWebScrollbar::scrollbarOverlayStyle() const {
+  return WebScrollbar::ScrollbarOverlayStyleDefault;
+}
+
+bool FakeWebScrollbar::isCustomScrollbar() const {
+  return false;
+}
+
+WebKit::WebScrollbar::Orientation FakeWebScrollbar::orientation() const {
+  return WebScrollbar::Horizontal;
+}
+
+FakeWebScrollbar::FakeWebScrollbar() : m_isOverlay(false) {
+}
+
+}  // namespace cc
Index: src/cc/test/fake_scrollbar_layer.h
===================================================================
--- src/cc/test/fake_scrollbar_layer.h (revision 0)
+++ src/cc/test/fake_scrollbar_layer.h (revision 0)
@@ -0,0 +1,47 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEST_FAKE_SCROLLBAR_LAYER_H_
+#define CC_TEST_FAKE_SCROLLBAR_LAYER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/scrollbar_layer.h"
+
+namespace cc {
+
+class FakeScrollbarLayer : public ScrollbarLayer {
+public:
+  static scoped_refptr<FakeScrollbarLayer> Create(
+      bool paint_during_update, bool has_thumb, int scrolling_layer_id) {
+    return make_scoped_refptr(new FakeScrollbarLayer(
+        paint_during_update, has_thumb, scrolling_layer_id));
+  }
+
+  int update_count() const { return update_count_; }
+  void reset_update_count() { update_count_ = 0; }
+  size_t last_update_full_upload_size() const {
+    return last_update_full_upload_size_;
+  }
+  size_t last_update_partial_upload_size() const {
+    return last_update_partial_upload_size_;
+  }
+
+  virtual void update(
+      ResourceUpdateQueue& queue,
+      const OcclusionTracker* occlusion,
+      RenderingStats& stats) OVERRIDE;
+
+private:
+  FakeScrollbarLayer(
+      bool paint_during_update, bool has_thumb, int scrolling_layer_id);
+  virtual ~FakeScrollbarLayer();
+
+  int update_count_;
+  size_t last_update_full_upload_size_;
+  size_t last_update_partial_upload_size_;
+};
+
+}  // namespace cc
+
+#endif  // CC_TEST_FAKE_SCROLLBAR_LAYER_H_
Index: src/cc/test/fake_web_scrollbar.h
===================================================================
--- src/cc/test/fake_web_scrollbar.h (revision 0)
+++ src/cc/test/fake_web_scrollbar.h (revision 0)
@@ -0,0 +1,47 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEST_FAKE_WEB_SCROLLBAR_H_
+#define CC_TEST_FAKE_WEB_SCROLLBAR_H_
+
+#include "base/memory/scoped_ptr.h"
+#include <public/WebScrollbar.h>
+
+namespace cc {
+
+class FakeWebScrollbar : public WebKit::WebScrollbar {
+ public:
+  static scoped_ptr<FakeWebScrollbar> create() {
+    return make_scoped_ptr(new FakeWebScrollbar());
+  }
+
+  void setOverlay(bool isOverlay);
+
+  // WebScrollbar implementation
+  virtual bool isOverlay() const OVERRIDE;
+  virtual int value() const OVERRIDE;
+  virtual WebKit::WebPoint location() const OVERRIDE;
+  virtual WebKit::WebSize size() const OVERRIDE;
+  virtual bool enabled() const OVERRIDE;
+  virtual int maximum() const OVERRIDE;
+  virtual int totalSize() const OVERRIDE;
+  virtual bool isScrollViewScrollbar() const OVERRIDE;
+  virtual bool isScrollableAreaActive() const OVERRIDE;
+  virtual void getTickmarks(WebKit::WebVector<WebKit::WebRect>&) const OVERRIDE {}
+  virtual ScrollbarControlSize controlSize() const OVERRIDE;
+  virtual ScrollbarPart pressedPart() const OVERRIDE;
+  virtual ScrollbarPart hoveredPart() const OVERRIDE;
+  virtual ScrollbarOverlayStyle scrollbarOverlayStyle() const OVERRIDE;
+  virtual bool isCustomScrollbar() const OVERRIDE;
+  virtual Orientation orientation() const OVERRIDE;
+
+ private:
+  FakeWebScrollbar();
+
+  bool m_isOverlay;
+};
+
+}  // namespace cc
+
+#endif  // CC_TEST_FAKE_WEB_SCROLLBAR_H_
Index: src/cc/test/fake_content_layer_impl.cc
===================================================================
--- src/cc/test/fake_content_layer_impl.cc (revision 0)
+++ src/cc/test/fake_content_layer_impl.cc (revision 0)
@@ -0,0 +1,24 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/test/fake_content_layer_impl.h"
+
+namespace cc {
+
+FakeContentLayerImpl::FakeContentLayerImpl(LayerTreeImpl* tree_impl, int id)
+    : TiledLayerImpl(tree_impl, id),
+      lost_output_surface_count_(0) {
+}
+
+FakeContentLayerImpl::~FakeContentLayerImpl() {}
+
+bool FakeContentLayerImpl::HaveResourceForTileAt(int i, int j) {
+  return hasResourceIdForTileAt(i, j);
+}
+
+void FakeContentLayerImpl::didLoseOutputSurface() {
+  ++lost_output_surface_count_;
+}
+
+}  // namespace cc
Index: src/cc/test/fake_scrollbar_theme_painter.h
===================================================================
--- src/cc/test/fake_scrollbar_theme_painter.h (revision 0)
+++ src/cc/test/fake_scrollbar_theme_painter.h (revision 0)
@@ -0,0 +1,59 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEST_FAKE_SCROLLBAR_THEME_PAINTER_H_
+#define CC_TEST_FAKE_SCROLLBAR_THEME_PAINTER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/scrollbar_theme_painter.h"
+#include "third_party/skia/include/core/SkColor.h"
+
+namespace cc {
+
+class FakeScrollbarThemePainter : public ScrollbarThemePainter {
+ public:
+  static scoped_ptr<FakeScrollbarThemePainter> Create(bool paint) {
+    return make_scoped_ptr(new FakeScrollbarThemePainter(paint));
+  }
+  virtual ~FakeScrollbarThemePainter() {}
+
+  virtual void PaintScrollbarBackground(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintTrackBackground(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintBackTrackPart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintForwardTrackPart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintBackButtonStart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintBackButtonEnd(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintForwardButtonStart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintForwardButtonEnd(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintTickmarks(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintThumb(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+
+  void set_paint(bool paint) { paint_ = paint; }
+
+ private:
+  explicit FakeScrollbarThemePainter(bool paint)
+      : paint_(paint),
+        fill_color_(0) {}
+
+  void Paint(SkCanvas* canvas, gfx::Rect rect);
+
+  bool paint_;
+  SkColor fill_color_;
+
+  DISALLOW_COPY_AND_ASSIGN(FakeScrollbarThemePainter);
+};
+
+}  // namespace cc
+
+#endif  // CC_TEST_FAKE_SCROLLBAR_BACKGROUND_PAINTER_H_
Index: src/cc/test/fake_video_frame_provider.h
===================================================================
--- src/cc/test/fake_video_frame_provider.h (revision 0)
+++ src/cc/test/fake_video_frame_provider.h (revision 0)
@@ -0,0 +1,35 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEST_FAKE_VIDEO_FRAME_PROVIDER_H_
+#define CC_TEST_FAKE_VIDEO_FRAME_PROVIDER_H_
+
+#include "cc/video_frame_provider.h"
+#include "media/base/video_frame.h"
+
+namespace cc {
+
+// Fake video frame provider that always provides the same VideoFrame.
+class FakeVideoFrameProvider : public VideoFrameProvider {
+ public:
+  FakeVideoFrameProvider();
+  virtual ~FakeVideoFrameProvider();
+
+  virtual void SetVideoFrameProviderClient(Client* client) OVERRIDE;
+  virtual scoped_refptr<media::VideoFrame> GetCurrentFrame() OVERRIDE;
+  virtual void PutCurrentFrame(const scoped_refptr<media::VideoFrame>&)
+      OVERRIDE {}
+
+  void set_frame(const scoped_refptr<media::VideoFrame>& frame) {
+    frame_ = frame;
+  }
+
+ private:
+  scoped_refptr<media::VideoFrame> frame_;
+  Client* client_;
+};
+
+}  // namespace cc
+
+#endif  // CC_TEST_FAKE_VIDEO_FRAME_PROVIDER_H_
Index: src/cc/test/fake_video_frame_provider.cc
===================================================================
--- src/cc/test/fake_video_frame_provider.cc (revision 0)
+++ src/cc/test/fake_video_frame_provider.cc (revision 0)
@@ -0,0 +1,25 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/test/fake_video_frame_provider.h"
+
+namespace cc {
+
+FakeVideoFrameProvider::FakeVideoFrameProvider()
+    : frame_(NULL), client_(NULL) {}
+
+FakeVideoFrameProvider::~FakeVideoFrameProvider() {
+  if (client_)
+    client_->StopUsingProvider();
+}
+
+void FakeVideoFrameProvider::SetVideoFrameProviderClient(Client* client) {
+  client_ = client;
+}
+
+scoped_refptr<media::VideoFrame> FakeVideoFrameProvider::GetCurrentFrame() {
+  return frame_;
+}
+
+}  // namespace cc
Index: src/cc/test/fake_content_layer.h
===================================================================
--- src/cc/test/fake_content_layer.h (revision 0)
+++ src/cc/test/fake_content_layer.h (revision 0)
@@ -0,0 +1,41 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_TEST_FAKE_CONTENT_LAYER_H_
+#define CC_TEST_FAKE_CONTENT_LAYER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/content_layer.h"
+
+namespace cc {
+
+class FakeContentLayer : public ContentLayer {
+ public:
+  static scoped_refptr<FakeContentLayer> Create(ContentLayerClient* client) {
+    return make_scoped_refptr(new FakeContentLayer(client)); 
+  }
+
+  virtual scoped_ptr<LayerImpl> createLayerImpl(LayerTreeImpl* tree_impl)
+      OVERRIDE;
+
+  size_t update_count() const { return update_count_; }
+  void reset_update_count() { update_count_ = 0; }
+
+  virtual void update(
+      ResourceUpdateQueue& queue,
+      const OcclusionTracker* occlusion,
+      RenderingStats& stats) OVERRIDE;
+
+  bool HaveBackingAt(int i, int j);
+
+ private:
+  explicit FakeContentLayer(ContentLayerClient* client);
+  virtual ~FakeContentLayer();
+
+  size_t update_count_;
+};
+
+}  // namespace cc
+
+#endif  // CC_TEST_FAKE_CONTENT_LAYER_H_
Index: src/base/memory/discardable_memory_unittest.cc
===================================================================
--- src/base/memory/discardable_memory_unittest.cc (revision 0)
+++ src/base/memory/discardable_memory_unittest.cc (revision 0)
@@ -0,0 +1,61 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/memory/discardable_memory.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace base {
+
+#if defined(OS_ANDROID) || defined(OS_MACOSX)
+// Test Lock() and Unlock() functionalities.
+TEST(DiscardableMemoryTest, LockAndUnLock) {
+  ASSERT_TRUE(DiscardableMemory::Supported());
+
+  const size_t size = 1024;
+
+  DiscardableMemory memory;
+  ASSERT_TRUE(memory.InitializeAndLock(size));
+  void* addr = memory.Memory();
+  ASSERT_NE(static_cast<void*>(NULL), addr);
+
+  memory.Unlock();
+  // The system should have no reason to purge discardable blocks in this brief
+  // interval, though technically speaking this might flake.
+  EXPECT_EQ(DISCARDABLE_MEMORY_SUCCESS, memory.Lock());
+  addr = memory.Memory();
+  ASSERT_NE(static_cast<void*>(NULL), addr);
+
+  memory.Unlock();
+}
+
+// Test delete a discardable memory while it is locked.
+TEST(DiscardableMemoryTest, DeleteWhileLocked) {
+  ASSERT_TRUE(DiscardableMemory::Supported());
+
+  const size_t size = 1024;
+
+  DiscardableMemory memory;
+  ASSERT_TRUE(memory.InitializeAndLock(size));
+}
+
+#if defined(OS_MACOSX)
+// Test forced purging.
+TEST(DiscardableMemoryTest, Purge) {
+  ASSERT_TRUE(DiscardableMemory::Supported());
+  ASSERT_TRUE(DiscardableMemory::PurgeForTestingSupported());
+
+  const size_t size = 1024;
+
+  DiscardableMemory memory;
+  ASSERT_TRUE(memory.InitializeAndLock(size));
+  memory.Unlock();
+
+  DiscardableMemory::PurgeForTesting();
+  EXPECT_EQ(DISCARDABLE_MEMORY_PURGED, memory.Lock());
+}
+#endif  // OS_MACOSX
+
+#endif  // OS_*
+
+}
Index: src/base/memory/discardable_memory.cc
===================================================================
--- src/base/memory/discardable_memory.cc (revision 0)
+++ src/base/memory/discardable_memory.cc (revision 0)
@@ -0,0 +1,66 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/memory/discardable_memory.h"
+
+#include "base/logging.h"
+
+namespace base {
+
+DiscardableMemory::DiscardableMemory()
+    : memory_(NULL),
+      size_(0),
+      is_locked_(false)
+#if defined(OS_ANDROID)
+      , fd_(-1)
+#endif  // OS_ANDROID
+      {
+  DCHECK(Supported());
+}
+
+void* DiscardableMemory::Memory() const {
+  DCHECK(is_locked_);
+  return memory_;
+}
+
+// Stub implementations for platforms that don't support discardable memory.
+
+#if !defined(OS_ANDROID) && !defined(OS_MACOSX)
+
+DiscardableMemory::~DiscardableMemory() {
+  NOTIMPLEMENTED();
+}
+
+// static
+bool DiscardableMemory::Supported() {
+  return false;
+}
+
+bool DiscardableMemory::InitializeAndLock(size_t size) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+LockDiscardableMemoryStatus DiscardableMemory::Lock() {
+  NOTIMPLEMENTED();
+  return DISCARDABLE_MEMORY_FAILED;
+}
+
+void DiscardableMemory::Unlock() {
+  NOTIMPLEMENTED();
+}
+
+// static
+bool DiscardableMemory::PurgeForTestingSupported() {
+  return false;
+}
+
+// static
+void DiscardableMemory::PurgeForTesting() {
+  NOTIMPLEMENTED();
+}
+
+#endif  // OS_*
+
+}  // namespace base
Index: src/base/memory/discardable_memory_android.cc
===================================================================
--- src/base/memory/discardable_memory_android.cc (revision 0)
+++ src/base/memory/discardable_memory_android.cc (revision 0)
@@ -0,0 +1,164 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/memory/discardable_memory.h"
+
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "base/lazy_instance.h"
+#include "base/logging.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/synchronization/lock.h"
+#include "third_party/ashmem/ashmem.h"
+
+namespace {
+
+base::LazyInstance<base::Lock>::Leaky g_discardable_memory_lock =
+    LAZY_INSTANCE_INITIALIZER;
+
+// Total number of discardable memory in the process.
+int g_num_discardable_memory = 0;
+
+// Upper limit on the number of discardable memory to avoid hitting file
+// descriptor limit.
+const int kDiscardableMemoryNumLimit = 128;
+
+}
+
+namespace base {
+
+// static
+bool DiscardableMemory::Supported() {
+  return true;
+}
+
+DiscardableMemory::~DiscardableMemory() {
+  if (is_locked_)
+    Unlock();
+  // If fd_ is smaller than 0, initialization must have failed and
+  // g_num_discardable_memory is not incremented by the caller.
+  if (fd_ < 0)
+    return;
+  HANDLE_EINTR(close(fd_));
+  fd_ = -1;
+  ReleaseFileDescriptor();
+}
+
+bool DiscardableMemory::ReserveFileDescriptor() {
+  base::AutoLock lock(g_discardable_memory_lock.Get());
+  if (g_num_discardable_memory < kDiscardableMemoryNumLimit) {
+    ++g_num_discardable_memory;
+    return true;
+  }
+  return false;
+}
+
+void DiscardableMemory::ReleaseFileDescriptor() {
+  base::AutoLock lock(g_discardable_memory_lock.Get());
+  --g_num_discardable_memory;
+  DCHECK_LE(0, g_num_discardable_memory);
+}
+
+bool DiscardableMemory::InitializeAndLock(size_t size) {
+  // When this function returns true, fd_ should be larger or equal than 0
+  // and g_num_discardable_memory is incremented by 1. Otherwise, fd_
+  // is less than 0 and g_num_discardable_memory is not incremented by
+  // the caller.
+  DCHECK_EQ(fd_, -1);
+  DCHECK(!memory_);
+  if (!ReserveFileDescriptor())
+    return false;
+
+  size_ = size;
+  fd_ = ashmem_create_region("", size);
+
+  if (fd_ < 0) {
+    DLOG(ERROR) << "ashmem_create_region() failed";
+    ReleaseFileDescriptor();
+    return false;
+  }
+
+  int err = ashmem_set_prot_region(fd_, PROT_READ | PROT_WRITE);
+  if (err < 0) {
+    DLOG(ERROR) << "Error " << err << " when setting protection of ashmem";
+    HANDLE_EINTR(close(fd_));
+    fd_ = -1;
+    ReleaseFileDescriptor();
+    return false;
+  }
+
+  if (!Map()) {
+    // Close the file descriptor in case of any initialization errors.
+    HANDLE_EINTR(close(fd_));
+    fd_ = -1;
+    ReleaseFileDescriptor();
+    return false;
+  }
+
+  is_locked_ = true;
+  return true;
+}
+
+LockDiscardableMemoryStatus DiscardableMemory::Lock() {
+  DCHECK_NE(fd_, -1);
+  DCHECK(!is_locked_);
+
+  bool purged = false;
+  if (ashmem_pin_region(fd_, 0, 0) == ASHMEM_WAS_PURGED)
+    purged = true;
+
+  if (!Map())
+    return DISCARDABLE_MEMORY_FAILED;
+
+  is_locked_ = true;
+  return purged ? DISCARDABLE_MEMORY_PURGED : DISCARDABLE_MEMORY_SUCCESS;
+}
+
+void DiscardableMemory::Unlock() {
+  DCHECK_GE(fd_, 0);
+  DCHECK(is_locked_);
+
+  Unmap();
+  if (ashmem_unpin_region(fd_, 0, 0))
+    DLOG(ERROR) << "Failed to unpin memory.";
+  is_locked_ = false;
+}
+
+bool DiscardableMemory::Map() {
+  DCHECK(!memory_);
+  // There is a problem using MAP_PRIVATE here. As we are constantly calling
+  // Lock() and Unlock(), data could get lost if they are not written to the
+  // underlying file when Unlock() gets called.
+  memory_ = mmap(NULL, size_, PROT_READ | PROT_WRITE, MAP_SHARED, fd_, 0);
+  if (memory_ == (void*)-1) {
+    DPLOG(ERROR) << "Failed to map memory.";
+    memory_ = NULL;
+    if (ashmem_unpin_region(fd_, 0, 0))
+      DLOG(ERROR) << "Failed to unpin memory.";
+    return false;
+  }
+  return true;
+}
+
+void DiscardableMemory::Unmap() {
+  DCHECK(memory_);
+
+  if (-1 == munmap(memory_, size_))
+    DPLOG(ERROR) << "Failed to unmap memory.";
+
+  memory_ = NULL;
+}
+
+// static
+bool DiscardableMemory::PurgeForTestingSupported() {
+  return false;
+}
+
+// static
+void DiscardableMemory::PurgeForTesting() {
+  NOTIMPLEMENTED();
+}
+
+}  // namespace base
Index: src/base/memory/discardable_memory.h
===================================================================
--- src/base/memory/discardable_memory.h (revision 0)
+++ src/base/memory/discardable_memory.h (revision 0)
@@ -0,0 +1,118 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_MEMORY_DISCARDABLE_MEMORY_H_
+#define BASE_MEMORY_DISCARDABLE_MEMORY_H_
+
+#include "base/base_export.h"
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+
+namespace base {
+
+enum LockDiscardableMemoryStatus {
+  DISCARDABLE_MEMORY_FAILED = -1,
+  DISCARDABLE_MEMORY_PURGED = 0,
+  DISCARDABLE_MEMORY_SUCCESS = 1
+};
+
+// Platform abstraction for discardable memory. DiscardableMemory is used to
+// cache large objects without worrying about blowing out memory, both on mobile
+// devices where there is no swap, and desktop devices where unused free memory
+// should be used to help the user experience. This is preferable to releasing
+// memory in response to an OOM signal because it is simpler, though it has less
+// flexibility as to which objects get discarded.
+//
+// Discardable memory has two states: locked and unlocked. While the memory is
+// locked, it will not be discarded. Unlocking the memory allows the OS to
+// reclaim it if needed. Locks do not nest.
+//
+// Notes:
+//   - The paging behavior of memory while it is locked is not specified. While
+//     mobile platforms will not swap it out, it may qualify for swapping
+//     on desktop platforms. It is not expected that this will matter, as the
+//     preferred pattern of usage for DiscardableMemory is to lock down the
+//     memory, use it as quickly as possible, and then unlock it.
+//   - Because of memory alignment, the amount of memory allocated can be
+//     larger than the requested memory size. It is not very efficient for
+//     small allocations.
+//
+// References:
+//   - Linux: http://lwn.net/Articles/452035/
+//   - Mac: http://trac.webkit.org/browser/trunk/Source/WebCore/platform/mac/PurgeableBufferMac.cpp
+//          the comment starting with "vm_object_purgable_control" at
+//            http://www.opensource.apple.com/source/xnu/xnu-792.13.8/osfmk/vm/vm_object.c
+class BASE_EXPORT DiscardableMemory {
+ public:
+  DiscardableMemory();
+
+  // If the discardable memory is locked, the destructor will unlock it.
+  // The opened file will also be closed after this.
+  ~DiscardableMemory();
+
+  // Check whether the system supports discardable memory.
+  static bool Supported();
+
+  // Initialize the DiscardableMemory object. On success, this function returns
+  // true and the memory is locked. This should only be called once.
+  // This call could fail because of platform-specific limitations and the user
+  // should stop using the DiscardableMemory afterwards.
+  bool InitializeAndLock(size_t size);
+
+  // Lock the memory so that it will not be purged by the system. Returns
+  // DISCARDABLE_MEMORY_SUCCESS on success. If the return value is
+  // DISCARDABLE_MEMORY_FAILED then this object should be discarded and
+  // a new one should be created. If the return value is
+  // DISCARDABLE_MEMORY_PURGED then the memory is present but any data that
+  // was in it is gone.
+  LockDiscardableMemoryStatus Lock() WARN_UNUSED_RESULT;
+
+  // Unlock the memory so that it can be purged by the system. Must be called
+  // after every successful lock call.
+  void Unlock();
+
+  // Return the memory address held by this object. The object must be locked
+  // before calling this. Otherwise, this will cause a DCHECK error.
+  void* Memory() const;
+
+  // Testing utility calls.
+
+  // Check whether a purge of all discardable memory in the system is supported.
+  // Use only for testing!
+  static bool PurgeForTestingSupported();
+
+  // Purge all discardable memory in the system. This call has global effects
+  // across all running processes, so it should only be used for testing!
+  static void PurgeForTesting();
+
+ private:
+#if defined(OS_ANDROID)
+  // Maps the discardable memory into the caller's address space.
+  // Returns true on success, false otherwise.
+  bool Map();
+
+  // Unmaps the discardable memory from the caller's address space.
+  void Unmap();
+
+  // Reserve a file descriptor. When reaching the fd limit, this call returns
+  // false and initialization should fail.
+  bool ReserveFileDescriptor();
+
+  // Release a file descriptor so that others can reserve it.
+  void ReleaseFileDescriptor();
+#endif  // OS_ANDROID
+
+  void* memory_;
+  size_t size_;
+  bool is_locked_;
+#if defined(OS_ANDROID)
+  int fd_;
+#endif  // OS_ANDROID
+
+  DISALLOW_COPY_AND_ASSIGN(DiscardableMemory);
+};
+
+}  // namespace base
+
+#endif  // BASE_MEMORY_DISCARDABLE_MEMORY_H_
Index: src/base/memory/discardable_memory_mac.cc
===================================================================
--- src/base/memory/discardable_memory_mac.cc (revision 0)
+++ src/base/memory/discardable_memory_mac.cc (revision 0)
@@ -0,0 +1,105 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/memory/discardable_memory.h"
+
+#include <mach/mach.h>
+
+#include "base/logging.h"
+
+namespace base {
+
+namespace {
+
+// The VM subsystem allows tagging of memory and 240-255 is reserved for
+// application use (see mach/vm_statistics.h). Pick 252 (after chromium's atomic
+// weight of ~52).
+const int kDiscardableMemoryTag = VM_MAKE_TAG(252);
+
+}  // namespace
+
+// static
+bool DiscardableMemory::Supported() {
+  return true;
+}
+
+DiscardableMemory::~DiscardableMemory() {
+  if (memory_) {
+    vm_deallocate(mach_task_self(),
+                  reinterpret_cast<vm_address_t>(memory_),
+                  size_);
+  }
+}
+
+bool DiscardableMemory::InitializeAndLock(size_t size) {
+  DCHECK(!memory_);
+  size_ = size;
+
+  vm_address_t buffer = 0;
+  kern_return_t ret = vm_allocate(mach_task_self(),
+                                  &buffer,
+                                  size,
+                                  VM_FLAGS_PURGABLE |
+                                  VM_FLAGS_ANYWHERE |
+                                  kDiscardableMemoryTag);
+
+  if (ret != KERN_SUCCESS) {
+    DLOG(ERROR) << "vm_allocate() failed";
+    return false;
+  }
+
+  is_locked_ = true;
+  memory_ = reinterpret_cast<void*>(buffer);
+  return true;
+}
+
+LockDiscardableMemoryStatus DiscardableMemory::Lock() {
+  DCHECK(!is_locked_);
+
+  int state = VM_PURGABLE_NONVOLATILE;
+  kern_return_t ret = vm_purgable_control(
+      mach_task_self(),
+      reinterpret_cast<vm_address_t>(memory_),
+      VM_PURGABLE_SET_STATE,
+      &state);
+
+  if (ret != KERN_SUCCESS)
+    return DISCARDABLE_MEMORY_FAILED;
+
+  is_locked_ = true;
+  return state & VM_PURGABLE_EMPTY ? DISCARDABLE_MEMORY_PURGED
+                                   : DISCARDABLE_MEMORY_SUCCESS;
+}
+
+void DiscardableMemory::Unlock() {
+  DCHECK(is_locked_);
+
+  int state = VM_PURGABLE_VOLATILE | VM_VOLATILE_GROUP_DEFAULT;
+  kern_return_t ret = vm_purgable_control(
+      mach_task_self(),
+      reinterpret_cast<vm_address_t>(memory_),
+      VM_PURGABLE_SET_STATE,
+      &state);
+
+  if (ret != KERN_SUCCESS)
+    DLOG(ERROR) << "Failed to unlock memory.";
+
+  is_locked_ = false;
+}
+
+// static
+bool DiscardableMemory::PurgeForTestingSupported() {
+  return true;
+}
+
+// static
+void DiscardableMemory::PurgeForTesting() {
+  int state = 0;
+  vm_purgable_control(mach_task_self(),
+                      reinterpret_cast<vm_address_t>(0U),
+                      VM_PURGABLE_PURGE_ALL,
+                      &state);
+}
+
+}  // namespace base
Index: src/ui/android/java/src/org/chromium/ui/gfx/DeviceDisplayInfo.java
===================================================================
--- src/ui/android/java/src/org/chromium/ui/gfx/DeviceDisplayInfo.java (revision 0)
+++ src/ui/android/java/src/org/chromium/ui/gfx/DeviceDisplayInfo.java (revision 0)
@@ -0,0 +1,134 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.ui.gfx;
+
+import android.content.Context;
+import android.graphics.PixelFormat;
+import android.telephony.TelephonyManager;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
+
+import org.chromium.base.CalledByNative;
+import org.chromium.base.JNINamespace;
+
+/**
+ * This class facilitates access to android information typically only
+ * available using the Java SDK, including {@link Display} properties.
+ *
+ * Currently the information consists of very raw display information (height, width, DPI scale)
+ * regarding the main display.
+ */
+@JNINamespace("gfx")
+public class DeviceDisplayInfo {
+
+  private WindowManager mWinManager;
+
+  private DeviceDisplayInfo(Context context) {
+      Context appContext = context.getApplicationContext();
+      mWinManager = (WindowManager) appContext.getSystemService(Context.WINDOW_SERVICE);
+  }
+
+  /**
+   * @return Display height in physical pixels.
+   */
+  @CalledByNative
+  public int getDisplayHeight() {
+      return getMetrics().heightPixels;
+  }
+
+  /**
+   * @return Display width in physical pixels.
+   */
+  @CalledByNative
+  public int getDisplayWidth() {
+      return getMetrics().widthPixels;
+  }
+
+  /**
+   * @return Bits per pixel.
+   */
+  @CalledByNative
+  public int getBitsPerPixel() {
+      PixelFormat info = new PixelFormat();
+      PixelFormat.getPixelFormatInfo(getDisplay().getPixelFormat(), info);
+      return info.bitsPerPixel;
+  }
+
+  /**
+   * @return Bits per component.
+   */
+  @CalledByNative
+  public int getBitsPerComponent() {
+      int format = getDisplay().getPixelFormat();
+      switch (format) {
+      case PixelFormat.RGBA_4444:
+          return 4;
+
+      case PixelFormat.RGBA_5551:
+          return 5;
+
+      case PixelFormat.RGBA_8888:
+      case PixelFormat.RGBX_8888:
+      case PixelFormat.RGB_888:
+          return 8;
+
+      case PixelFormat.RGB_332:
+          return 2;
+
+      case PixelFormat.RGB_565:
+          return 5;
+
+      // Non-RGB formats.
+      case PixelFormat.A_8:
+      case PixelFormat.LA_88:
+      case PixelFormat.L_8:
+          return 0;
+
+      // Unknown format. Use 8 as a sensible default.
+      default:
+          return 8;
+      }
+  }
+
+  /**
+   * @return A scaling factor for the Density Independent Pixel unit.
+   *         1.0 is 160dpi, 0.75 is 120dpi, 2.0 is 320dpi.
+   */
+  @CalledByNative
+  public double getDIPScale() {
+      return getMetrics().density;
+  }
+
+  /**
+   * @return Display refresh rate in frames per second.
+   */
+  @CalledByNative
+  public double getRefreshRate() {
+      double result = getDisplay().getRefreshRate();
+      // Sanity check.
+      return (result >= 61 || result < 30) ? 0 : result;
+  }
+
+  private Display getDisplay() {
+      return mWinManager.getDefaultDisplay();
+  }
+
+  private DisplayMetrics getMetrics() {
+      DisplayMetrics metrics = new DisplayMetrics();
+      getDisplay().getMetrics(metrics);
+      return metrics;
+  }
+
+  /**
+   * Creates DeviceDisplayInfo for a given Context.
+   * @param context A context to use.
+   * @return DeviceDisplayInfo associated with a given Context.
+   */
+  @CalledByNative
+  public static DeviceDisplayInfo create(Context context) {
+      return new DeviceDisplayInfo(context);
+  }
+}
Index: src/ui/gfx/size_base_impl.h
===================================================================
--- src/ui/gfx/size_base_impl.h (revision 0)
+++ src/ui/gfx/size_base_impl.h (revision 0)
@@ -0,0 +1,37 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gfx/size_base.h"
+
+#include "base/logging.h"
+
+// This file provides the implementation for SizeBase template and
+// used to instantiate the base class for Size and SizeF classes.
+#if !defined(UI_IMPLEMENTATION)
+#error "This file is intended for UI implementation only"
+#endif
+
+namespace gfx {
+
+template<typename Class, typename Type>
+void SizeBase<Class, Type>::set_width(Type width) {
+  DCHECK(!(width < 0));
+  width_ = width < 0 ? 0 : width;
+}
+
+template<typename Class, typename Type>
+void SizeBase<Class, Type>::set_height(Type height) {
+  DCHECK(!(height < 0));
+  height_ = height < 0 ? 0 : height;
+}
+
+template<typename Class, typename Type>
+SizeBase<Class, Type>::SizeBase(Type width, Type height)
+    : width_(width < 0 ? 0 : width),
+      height_(height < 0 ? 0 : height) {
+  DCHECK(!(width < 0));
+  DCHECK(!(height < 0));
+}
+
+}  // namespace gfx
Index: src/ui/gfx/android/device_display_info.cc
===================================================================
--- src/ui/gfx/android/device_display_info.cc (revision 0)
+++ src/ui/gfx/android/device_display_info.cc (revision 0)
@@ -0,0 +1,73 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gfx/android/device_display_info.h"
+
+#include "base/android/jni_android.h"
+#include "base/android/jni_string.h"
+#include "base/logging.h"
+#include "jni/DeviceDisplayInfo_jni.h"
+
+using base::android::AttachCurrentThread;
+using base::android::ScopedJavaLocalRef;
+
+namespace gfx {
+
+DeviceDisplayInfo::DeviceDisplayInfo() {
+  JNIEnv* env = AttachCurrentThread();
+  j_device_info_.Reset(Java_DeviceDisplayInfo_create(env,
+      base::android::GetApplicationContext()));
+}
+
+DeviceDisplayInfo::~DeviceDisplayInfo() {
+}
+
+int DeviceDisplayInfo::GetDisplayHeight() {
+  JNIEnv* env = AttachCurrentThread();
+  jint result =
+      Java_DeviceDisplayInfo_getDisplayHeight(env, j_device_info_.obj());
+  return static_cast<int>(result);
+}
+
+int DeviceDisplayInfo::GetDisplayWidth() {
+  JNIEnv* env = AttachCurrentThread();
+  jint result =
+      Java_DeviceDisplayInfo_getDisplayWidth(env, j_device_info_.obj());
+  return static_cast<int>(result);
+}
+
+int DeviceDisplayInfo::GetBitsPerPixel() {
+  JNIEnv* env = AttachCurrentThread();
+  jint result =
+      Java_DeviceDisplayInfo_getBitsPerPixel(env, j_device_info_.obj());
+  return static_cast<int>(result);
+}
+
+int DeviceDisplayInfo::GetBitsPerComponent() {
+  JNIEnv* env = AttachCurrentThread();
+  jint result =
+      Java_DeviceDisplayInfo_getBitsPerComponent(env, j_device_info_.obj());
+  return static_cast<int>(result);
+}
+
+double DeviceDisplayInfo::GetDIPScale() {
+  JNIEnv* env = AttachCurrentThread();
+  jdouble result =
+      Java_DeviceDisplayInfo_getDIPScale(env, j_device_info_.obj());
+  return static_cast<double>(result);
+}
+
+double DeviceDisplayInfo::GetRefreshRate() {
+  JNIEnv* env = AttachCurrentThread();
+  jdouble result =
+      Java_DeviceDisplayInfo_getRefreshRate(env, j_device_info_.obj());
+  return static_cast<double>(result);
+}
+
+// static
+bool DeviceDisplayInfo::RegisterDeviceDisplayInfo(JNIEnv* env) {
+  return RegisterNativesImpl(env);
+}
+
+}  // namespace gfx
Index: src/ui/gfx/android/device_display_info.h
===================================================================
--- src/ui/gfx/android/device_display_info.h (revision 0)
+++ src/ui/gfx/android/device_display_info.h (revision 0)
@@ -0,0 +1,54 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GFX_ANDROID_DEVICE_DISPLAY_INFO_H_
+#define UI_GFX_ANDROID_DEVICE_DISPLAY_INFO_H_
+
+#include <jni.h>
+#include <string>
+
+#include "base/android/scoped_java_ref.h"
+#include "base/basictypes.h"
+#include "ui/base/ui_export.h"
+
+namespace gfx {
+
+// Facilitates access to device information typically only
+// available using the Android SDK, including Display properties.
+class UI_EXPORT DeviceDisplayInfo {
+ public:
+  DeviceDisplayInfo();
+  ~DeviceDisplayInfo();
+
+  // Returns display height in physical pixels.
+  int GetDisplayHeight();
+
+  // Returns display width in physical pixels.
+  int GetDisplayWidth();
+
+  // Returns number of bits per pixel.
+  int GetBitsPerPixel();
+
+  // Returns number of bits per component.
+  int GetBitsPerComponent();
+
+  // Returns a scaling factor for Density Independent Pixel unit
+  // (1.0 is 160dpi, 0.75 is 120dpi, 2.0 is 320dpi).
+  double GetDIPScale();
+
+  // Returns display refresh rate in number of frames per second.
+  double GetRefreshRate();
+
+  // Registers methods with JNI and returns true if succeeded.
+  static bool RegisterDeviceDisplayInfo(JNIEnv* env);
+
+ private:
+  base::android::ScopedJavaGlobalRef<jobject> j_device_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(DeviceDisplayInfo);
+};
+
+}  // namespace gfx
+
+#endif  // UI_GFX_ANDROID_DEVICE_DISPLAY_INFO_H_
Index: src/ui/compositor/transform_animation_curve_adapter.cc
===================================================================
--- src/ui/compositor/transform_animation_curve_adapter.cc (revision 0)
+++ src/ui/compositor/transform_animation_curve_adapter.cc (revision 0)
@@ -0,0 +1,54 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/compositor/transform_animation_curve_adapter.h"
+
+namespace ui {
+
+TransformAnimationCurveAdapter::TransformAnimationCurveAdapter(
+    Tween::Type tween_type,
+    gfx::Transform initial_value,
+    gfx::Transform target_value,
+    base::TimeDelta duration)
+    : tween_type_(tween_type),
+      initial_value_(initial_value),
+      target_value_(target_value),
+      duration_(duration) {
+  gfx::DecomposeTransform(&decomposed_initial_value_, initial_value_);
+  gfx::DecomposeTransform(&decomposed_target_value_, target_value_);
+}
+
+TransformAnimationCurveAdapter::~TransformAnimationCurveAdapter() {
+}
+
+double TransformAnimationCurveAdapter::duration() const {
+  return duration_.InSecondsF();
+}
+
+scoped_ptr<cc::AnimationCurve> TransformAnimationCurveAdapter::clone() const {
+  scoped_ptr<TransformAnimationCurveAdapter> to_return(
+      new TransformAnimationCurveAdapter(tween_type_,
+                                         initial_value_,
+                                         target_value_,
+                                         duration_));
+  return to_return.PassAs<cc::AnimationCurve>();
+}
+
+gfx::Transform TransformAnimationCurveAdapter::getValue(
+    double t) const {
+  if (t >= duration_.InSecondsF())
+    return target_value_;
+  if (t <= 0.0)
+    return initial_value_;
+  double progress = t / duration_.InSecondsF();
+
+  gfx::DecomposedTransform to_return;
+  gfx::BlendDecomposedTransforms(&to_return,
+                                 decomposed_initial_value_,
+                                 decomposed_target_value_,
+                                 Tween::CalculateValue(tween_type_, progress));
+  return gfx::ComposeTransform(to_return);
+}
+
+}  // namespace ui
Index: src/ui/compositor/float_animation_curve_adapter.cc
===================================================================
--- src/ui/compositor/float_animation_curve_adapter.cc (revision 0)
+++ src/ui/compositor/float_animation_curve_adapter.cc (revision 0)
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/compositor/float_animation_curve_adapter.h"
+
+namespace ui {
+
+FloatAnimationCurveAdapter::FloatAnimationCurveAdapter(
+    Tween::Type tween_type,
+    float initial_value,
+    float target_value,
+    base::TimeDelta duration)
+    : tween_type_(tween_type),
+      initial_value_(initial_value),
+      target_value_(target_value),
+      duration_(duration) {
+}
+
+double FloatAnimationCurveAdapter::duration() const {
+  return duration_.InSecondsF();
+}
+
+scoped_ptr<cc::AnimationCurve> FloatAnimationCurveAdapter::clone() const {
+  scoped_ptr<FloatAnimationCurveAdapter> to_return(
+      new FloatAnimationCurveAdapter(tween_type_,
+                                     initial_value_,
+                                     target_value_,
+                                     duration_));
+  return to_return.PassAs<cc::AnimationCurve>();
+}
+
+float FloatAnimationCurveAdapter::getValue(double t) const {
+  if (t >= duration_.InSecondsF())
+    return target_value_;
+  if (t <= 0.0)
+    return initial_value_;
+  double progress = t / duration_.InSecondsF();
+  return Tween::ValueBetween(Tween::CalculateValue(tween_type_, progress),
+                             initial_value_,
+                             target_value_);
+}
+
+}  // namespace ui
Index: src/ui/compositor/transform_animation_curve_adapter.h
===================================================================
--- src/ui/compositor/transform_animation_curve_adapter.h (revision 0)
+++ src/ui/compositor/transform_animation_curve_adapter.h (revision 0)
@@ -0,0 +1,42 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_COMPOSITOR_TRANSFORM_ANIMATION_CURVE_ADAPTER_H_
+#define UI_COMPOSITOR_TRANSFORM_ANIMATION_CURVE_ADAPTER_H_
+
+#include "base/time.h"
+#include "cc/animation_curve.h"
+#include "ui/base/animation/tween.h"
+#include "ui/gfx/transform.h"
+#include "ui/gfx/transform_util.h"
+
+namespace ui {
+
+class TransformAnimationCurveAdapter :public cc::TransformAnimationCurve {
+ public:
+  TransformAnimationCurveAdapter(Tween::Type tween_type,
+                                 gfx::Transform intial_value,
+                                 gfx::Transform target_value,
+                                 base::TimeDelta duration);
+
+  virtual ~TransformAnimationCurveAdapter();
+
+  // TransformAnimationCurve implementation.
+  virtual double duration() const OVERRIDE;
+  virtual scoped_ptr<AnimationCurve> clone() const OVERRIDE;
+  virtual gfx::Transform getValue(double t) const OVERRIDE;
+
+ private:
+  Tween::Type tween_type_;
+  gfx::Transform initial_value_;
+  gfx::Transform target_value_;
+  gfx::DecomposedTransform decomposed_initial_value_;
+  gfx::DecomposedTransform decomposed_target_value_;
+  base::TimeDelta duration_;
+};
+
+}  // namespace ui
+
+#endif  // UI_COMPOSITOR_TRANSFORM_ANIMATION_CURVE_ADAPTER_H_
+
Index: src/ui/compositor/float_animation_curve_adapter.h
===================================================================
--- src/ui/compositor/float_animation_curve_adapter.h (revision 0)
+++ src/ui/compositor/float_animation_curve_adapter.h (revision 0)
@@ -0,0 +1,37 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_COMPOSITOR_FLOAT_ANIMATION_CURVE_ADAPTER_H_
+#define UI_COMPOSITOR_FLOAT_ANIMATION_CURVE_ADAPTER_H_
+
+#include "base/time.h"
+#include "cc/animation_curve.h"
+#include "ui/base/animation/tween.h"
+
+namespace ui {
+
+class FloatAnimationCurveAdapter : public cc::FloatAnimationCurve {
+ public:
+  FloatAnimationCurveAdapter(Tween::Type tween_type,
+                             float initial_value,
+                             float target_value,
+                             base::TimeDelta duration);
+
+  virtual ~FloatAnimationCurveAdapter() { }
+
+  // FloatAnimationCurve implementation.
+  virtual double duration() const OVERRIDE;
+  virtual scoped_ptr<cc::AnimationCurve> clone() const OVERRIDE;
+  virtual float getValue(double t) const OVERRIDE;
+
+ private:
+  Tween::Type tween_type_;
+  float initial_value_;
+  float target_value_;
+  base::TimeDelta duration_;
+};
+
+}  // namespace ui
+
+#endif  // UI_COMPOSITOR_FLOAT_ANIMATION_CURVE_ADAPTER_H_
Index: src/ui/gl/safe_shared_memory_pool.cc
===================================================================
--- src/ui/gl/safe_shared_memory_pool.cc (revision 0)
+++ src/ui/gl/safe_shared_memory_pool.cc (revision 0)
@@ -0,0 +1,135 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/gl/safe_shared_memory_pool.h"
+
+#include "base/logging.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/process_util.h"
+#include "build/build_config.h"
+
+using base::SharedMemory;
+using base::SharedMemoryHandle;
+
+namespace gfx {
+
+ScopedSafeSharedMemory::ScopedSafeSharedMemory(SafeSharedMemoryPool* pool,
+                                               base::SharedMemory* memory,
+                                               size_t shm_size) {
+  DCHECK(pool);
+  DCHECK(memory);
+  DCHECK(memory->memory());
+  pool_ = pool;
+  original_handle_ = memory->handle();
+  safe_shared_memory_ = pool->AcquireSafeSharedMemory(memory, shm_size);
+  CHECK(safe_shared_memory_);
+}
+
+ScopedSafeSharedMemory::~ScopedSafeSharedMemory() {
+  // Release the handle. The pool will delete the SharedMemory
+  // object when it is no longer referenced.
+  pool_->ReleaseSafeSharedMemory(original_handle_);
+}
+
+base::SharedMemory* ScopedSafeSharedMemory::shared_memory() {
+  return safe_shared_memory_;
+}
+
+
+SafeSharedMemoryPool::SafeSharedMemoryPool()
+    : handles_consumed_(0),
+      address_space_consumed_(0),
+      max_handles_consumed_(0),
+      max_address_space_consumed_(0) {
+}
+
+SafeSharedMemoryPool::~SafeSharedMemoryPool() {
+}
+
+base::SharedMemory* SafeSharedMemoryPool::
+    AcquireSafeSharedMemory(base::SharedMemory* shared_memory,
+                            size_t shm_size) {
+  DCHECK(shared_memory);
+  DCHECK(shared_memory->memory());
+  base::AutoLock scoped_lock(lock_);
+
+  MemoryMap::iterator it = memory_.find(shared_memory->handle());
+  // If we don't already have it, duplicated it.
+  if (it == memory_.end()) {
+    // Duplicate a new shared memory and track it.
+    TrackedMemory tracker;
+    tracker.safe_shared_memory = DuplicateSharedMemory(shared_memory, shm_size);
+    tracker.reference_count = 1;
+    tracker.shm_size = shm_size;
+    memory_[shared_memory->handle()] = tracker;
+
+    // Adjust stats.
+    handles_consumed_++;
+    address_space_consumed_ += shm_size;
+    max_handles_consumed_ = std::max(max_handles_consumed_,
+                                         handles_consumed_);
+    max_address_space_consumed_ = std::max(max_address_space_consumed_,
+                                               address_space_consumed_);
+    return tracker.safe_shared_memory;
+  }
+
+  // Otherwise, add a reference and return the existing one.
+  DCHECK(it->second.reference_count);
+  DCHECK(it->second.safe_shared_memory);
+  DCHECK(it->second.safe_shared_memory->memory());
+  it->second.reference_count++;
+  return it->second.safe_shared_memory;
+}
+
+void SafeSharedMemoryPool::
+    ReleaseSafeSharedMemory(const base::SharedMemoryHandle& handle) {
+  base::AutoLock scoped_lock(lock_);
+
+  MemoryMap::iterator it = memory_.find(handle);
+  CHECK(it != memory_.end());
+  CHECK(it->second.reference_count);
+  CHECK(it->second.safe_shared_memory);
+  if (--it->second.reference_count == 0) {
+    // Adjust stats.
+    handles_consumed_--;
+    address_space_consumed_ -= it->second.shm_size;
+    DCHECK(handles_consumed_ >= 0);
+    DCHECK(address_space_consumed_ >= 0);
+    // Delete the safe memory and remove it.
+    delete it->second.safe_shared_memory;
+    memory_.erase(it);
+  }
+}
+
+SharedMemory* SafeSharedMemoryPool::DuplicateSharedMemory(
+    SharedMemory* shared_memory, size_t size) {
+  // Duplicate the handle.
+  SharedMemoryHandle duped_shared_memory_handle;
+  if (!shared_memory->ShareToProcess(
+      base::GetCurrentProcessHandle(),
+      &duped_shared_memory_handle)) {
+    LOG(ERROR) << "Failed SharedMemory::ShareToProcess";
+    LOG(ERROR) << "Total handles open " << handles_consumed_;
+    LOG(ERROR) << "Total address space " << address_space_consumed_;
+    LOG(ERROR) << "Max handles open " << max_handles_consumed_;
+    LOG(ERROR) << "Max address space " << max_address_space_consumed_;
+    CHECK(false); // Diagnosing a crash.
+    return NULL;
+  }
+  scoped_ptr<SharedMemory> duped_shared_memory(
+      new SharedMemory(duped_shared_memory_handle, false));
+  // Map the shared memory into this process. This validates the size.
+  if (!duped_shared_memory->Map(size)) {
+    LOG(ERROR) << "Failed SharedMemory::Map";
+    LOG(ERROR) << "Total handles open " << handles_consumed_;
+    LOG(ERROR) << "Total address space " << address_space_consumed_;
+    LOG(ERROR) << "Max handles open " << max_handles_consumed_;
+    LOG(ERROR) << "Max address space " << max_address_space_consumed_;
+    CHECK(false); // Diagnosing a crash.
+    return NULL;
+  }
+  return duped_shared_memory.release();
+}
+
+}  // namespace gfx
Index: src/ui/gl/safe_shared_memory_pool.h
===================================================================
--- src/ui/gl/safe_shared_memory_pool.h (revision 0)
+++ src/ui/gl/safe_shared_memory_pool.h (revision 0)
@@ -0,0 +1,88 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_GL_SAFE_SHARED_MEMORY_POOL_H_
+#define UI_GL_SAFE_SHARED_MEMORY_POOL_H_
+
+#include <map>
+
+#include "base/basictypes.h"
+#include "base/shared_memory.h"
+#include "base/synchronization/lock.h"
+#include "build/build_config.h"
+
+namespace base {
+class SharedMemory;
+}
+
+namespace gfx {
+class SafeSharedMemoryPool;
+class ScopedSafeSharedMemory;
+}
+
+namespace gfx {
+
+// These classes exist to help protect against deletion of shared
+// memory that is being used on a worker thread. It's mainly a
+// security measure to prevent use-after-free in the browser, due
+// to a misbehaving client. That said, this should be removed
+// in favor of higher-level reference counting of an appropriate
+// opaque 'memory blob' data-structure.
+
+class ScopedSafeSharedMemory {
+ public:
+  base::SharedMemory* shared_memory();
+  ScopedSafeSharedMemory(SafeSharedMemoryPool* pool,
+                         base::SharedMemory* memory,
+                         size_t shm_size);
+  ~ScopedSafeSharedMemory();
+ private:
+  base::SharedMemory* safe_shared_memory_;
+  base::SharedMemoryHandle original_handle_;
+  SafeSharedMemoryPool* pool_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScopedSafeSharedMemory);
+};
+
+class SafeSharedMemoryPool {
+ public:
+  SafeSharedMemoryPool();
+  virtual ~SafeSharedMemoryPool();
+
+ private:
+  friend class ScopedSafeSharedMemory;
+
+  // Acquires and release shared memory. The acquired shared memory
+  // is guaranteed to live until it is released.
+  base::SharedMemory* AcquireSafeSharedMemory(base::SharedMemory*, size_t size);
+  void ReleaseSafeSharedMemory(const base::SharedMemoryHandle&);
+
+  // Utility function to duplicate shared memory.
+  base::SharedMemory* DuplicateSharedMemory(base::SharedMemory*, size_t size);
+
+  // Track all SharedMemory's that we have already duplicated.
+  struct TrackedMemory {
+    base::SharedMemory* safe_shared_memory;
+    size_t shm_size;
+    int reference_count;
+  };
+
+  typedef std::map<base::SharedMemoryHandle, TrackedMemory> MemoryMap;
+  MemoryMap memory_;
+
+  // Track usage to diagnose crashes.
+  int handles_consumed_;
+  int address_space_consumed_;
+  int max_handles_consumed_;
+  int max_address_space_consumed_;
+
+  base::Lock lock_;
+
+  DISALLOW_COPY_AND_ASSIGN(SafeSharedMemoryPool);
+};
+
+}  // namespace gfx
+
+#endif  // UI_GL_ASYNC_TASK_DELEGATE_H_
+
Index: src/webkit/compositor_bindings/DEPS
===================================================================
--- src/webkit/compositor_bindings/DEPS (revision 0)
+++ src/webkit/compositor_bindings/DEPS (revision 0)
@@ -0,0 +1,3 @@
+include_rules = [
+  "+media",
+]
Index: src/webkit/compositor_bindings/web_layer_impl_fixed_bounds_unittest.cc
===================================================================
--- src/webkit/compositor_bindings/web_layer_impl_fixed_bounds_unittest.cc (revision 0)
+++ src/webkit/compositor_bindings/web_layer_impl_fixed_bounds_unittest.cc (revision 0)
@@ -0,0 +1,190 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/layer_tree_host_common.h"
+#include "cc/picture_image_layer.h"
+#include "cc/test/geometry_test_utils.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFloatPoint.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
+#include "third_party/skia/include/utils/SkMatrix44.h"
+#include "ui/gfx/point3_f.h"
+#include "webkit/compositor_bindings/web_layer_impl_fixed_bounds.h"
+
+using namespace WebKit;
+
+TEST(WebLayerImplFixedBoundsTest, IdentityBounds) {
+  scoped_ptr<WebLayerImplFixedBounds> layer(new WebLayerImplFixedBounds());
+  layer->setAnchorPoint(WebFloatPoint(0, 0));
+  layer->SetFixedBounds(gfx::Size(100, 100));
+  layer->setBounds(WebSize(100, 100));
+  EXPECT_EQ(WebSize(100, 100), layer->bounds());
+  EXPECT_EQ(gfx::Size(100, 100), layer->layer()->bounds());
+  EXPECT_EQ(gfx::Transform(), layer->layer()->transform());
+}
+
+gfx::Point3F TransformPoint(const gfx::Transform& transform,
+                            const gfx::Point3F& point) {
+  gfx::Point3F result = point;
+  transform.TransformPoint(result);
+  return result;
+}
+
+void CheckBoundsScaleSimple(WebLayerImplFixedBounds* layer,
+                            const WebSize& bounds,
+                            const gfx::Size& fixed_bounds) {
+  layer->setBounds(bounds);
+  layer->SetFixedBounds(fixed_bounds);
+
+  EXPECT_EQ(bounds, layer->bounds());
+  EXPECT_EQ(fixed_bounds, layer->layer()->bounds());
+  EXPECT_TRUE(layer->transform().isIdentity());
+  EXPECT_TRUE(layer->sublayerTransform().isIdentity());
+
+  // An arbitrary point to check the scale and transforms.
+  gfx::Point3F original_point(10, 20, 1);
+  gfx::Point3F scaled_point(
+      original_point.x() * bounds.width / fixed_bounds.width(),
+      original_point.y() * bounds.height / fixed_bounds.height(),
+      original_point.z());
+  // Test if the bounds scale is correctly applied in transform and
+  // sublayerTransform.
+  EXPECT_POINT3F_EQ(scaled_point,
+                    TransformPoint(layer->layer()->transform(),
+                                   original_point));
+  EXPECT_POINT3F_EQ(original_point,
+                    TransformPoint(layer->layer()->sublayerTransform(),
+                                   scaled_point));
+}
+
+TEST(WebLayerImplFixedBoundsTest, BoundsScaleSimple) {
+  scoped_ptr<WebLayerImplFixedBounds> layer(new WebLayerImplFixedBounds());
+  layer->setAnchorPoint(WebFloatPoint(0, 0));
+  CheckBoundsScaleSimple(layer.get(), WebSize(100, 200), gfx::Size(150, 250));
+  // Change fixedBounds.
+  CheckBoundsScaleSimple(layer.get(), WebSize(100, 200), gfx::Size(75, 100));
+  // Change bounds.
+  CheckBoundsScaleSimple(layer.get(), WebSize(300, 100), gfx::Size(75, 100));
+}
+
+void ExpectEqualLayerRectsInTarget(cc::Layer* layer1, cc::Layer* layer2) {
+  gfx::RectF layer1_rect_in_target(layer1->contentBounds());
+  layer1->drawTransform().TransformRect(&layer1_rect_in_target);
+
+  gfx::RectF layer2_rect_in_target(layer2->contentBounds());
+  layer2->drawTransform().TransformRect(&layer2_rect_in_target);
+
+  EXPECT_FLOAT_RECT_EQ(layer1_rect_in_target, layer2_rect_in_target);
+}
+
+void CompareFixedBoundsLayerAndNormalLayer(
+    const WebFloatPoint& anchor_point,
+    const gfx::Transform& transform,
+    const gfx::Transform& sublayer_transform) {
+  const gfx::Size kDeviceViewportSize(800, 600);
+  const float kDeviceScaleFactor = 2.f;
+  const float kPageScaleFactor = 1.5f;
+  const int kMaxTextureSize = 512;
+
+  WebSize bounds(150, 200);
+  WebFloatPoint position(20, 30);
+  WebSize sublayer_bounds(88, 99);
+  WebFloatPoint sublayer_position(50, 60);
+  gfx::Size fixed_bounds(160, 70);
+
+  scoped_ptr<WebLayerImplFixedBounds> root_layer(new WebLayerImplFixedBounds());
+
+  WebLayerImplFixedBounds* fixed_bounds_layer =
+      new WebLayerImplFixedBounds(cc::PictureImageLayer::create());
+  WebLayerImpl* sublayer_under_fixed_bounds_layer = new WebLayerImpl();
+  sublayer_under_fixed_bounds_layer->setBounds(sublayer_bounds);
+  sublayer_under_fixed_bounds_layer->setPosition(sublayer_position);
+  fixed_bounds_layer->addChild(sublayer_under_fixed_bounds_layer);
+  fixed_bounds_layer->setBounds(bounds);
+  fixed_bounds_layer->SetFixedBounds(fixed_bounds);
+  fixed_bounds_layer->setAnchorPoint(anchor_point);
+  fixed_bounds_layer->setTransform(transform.matrix());
+  fixed_bounds_layer->setSublayerTransform(sublayer_transform.matrix());
+  fixed_bounds_layer->setPosition(position);
+  root_layer->addChild(fixed_bounds_layer);
+
+  WebLayerImpl* normal_layer(new WebLayerImpl(cc::PictureImageLayer::create()));
+  WebLayerImpl* sublayer_under_normal_layer = new WebLayerImpl();
+  sublayer_under_normal_layer->setBounds(sublayer_bounds);
+  sublayer_under_normal_layer->setPosition(sublayer_position);
+
+  normal_layer->addChild(sublayer_under_normal_layer);
+  normal_layer->setBounds(bounds);
+  normal_layer->setAnchorPoint(anchor_point);
+  normal_layer->setTransform(transform.matrix());
+  normal_layer->setSublayerTransform(sublayer_transform.matrix());
+  normal_layer->setPosition(position);
+  root_layer->addChild(normal_layer);
+
+  std::vector<scoped_refptr<cc::Layer> > renderSurfaceLayerList;
+  cc::LayerTreeHostCommon::calculateDrawProperties(
+      root_layer->layer(),
+      kDeviceViewportSize,
+      kDeviceScaleFactor,
+      kPageScaleFactor,
+      kMaxTextureSize,
+      false,
+      renderSurfaceLayerList);
+  ExpectEqualLayerRectsInTarget(normal_layer->layer(),
+                                fixed_bounds_layer->layer());
+  ExpectEqualLayerRectsInTarget(sublayer_under_normal_layer->layer(),
+                                sublayer_under_fixed_bounds_layer->layer());
+
+  // Change of fixed bounds should not affect the target geometries.
+  fixed_bounds_layer->SetFixedBounds(gfx::Size(fixed_bounds.width() / 2,
+                                               fixed_bounds.height() * 2));
+  cc::LayerTreeHostCommon::calculateDrawProperties(
+      root_layer->layer(),
+      kDeviceViewportSize,
+      kDeviceScaleFactor,
+      kPageScaleFactor,
+      kMaxTextureSize,
+      false,
+      renderSurfaceLayerList);
+  ExpectEqualLayerRectsInTarget(normal_layer->layer(),
+                                fixed_bounds_layer->layer());
+  ExpectEqualLayerRectsInTarget(sublayer_under_normal_layer->layer(),
+                                sublayer_under_fixed_bounds_layer->layer());
+
+}
+
+// A black box test that ensures WebLayerImplFixedBounds won't change target
+// geometries. Simple case: identity transforms and zero anchor point.
+TEST(WebLayerImplFixedBoundsTest, CompareToWebLayerImplSimple) {
+  CompareFixedBoundsLayerAndNormalLayer(WebFloatPoint(0, 0),
+                                        gfx::Transform(),
+                                        gfx::Transform());
+}
+
+// A black box test that ensures WebLayerImplFixedBounds won't change target
+// geometries. Complex case: complex transforms and non-zero anchor point.
+TEST(WebLayerImplFixedBoundsTest, CompareToWebLayerImplComplex) {
+  gfx::Transform transform;
+  // These are arbitrary values that should not affect the results.
+  transform.Translate3d(50, 60, 70);
+  transform.Scale3d(2, 3, 4);
+  transform.RotateAbout(gfx::Vector3dF(33, 44, 55), 99);
+
+  gfx::Transform sublayer_transform;
+  // These are arbitrary values that should not affect the results.
+  sublayer_transform.Scale3d(1.1, 2.2, 3.3);
+  sublayer_transform.Translate3d(11, 22, 33);
+  sublayer_transform.RotateAbout(gfx::Vector3dF(10, 30, 20), 88);
+
+  CompareFixedBoundsLayerAndNormalLayer(WebFloatPoint(0, 0),
+                                        transform,
+                                        sublayer_transform);
+
+  // With non-zero anchor point, WebLayerImplFixedBounds will fall back to
+  // WebLayerImpl.
+  CompareFixedBoundsLayerAndNormalLayer(WebFloatPoint(0.4f, 0.6f),
+                                        transform,
+                                        sublayer_transform);
+}
Index: src/webkit/compositor_bindings/web_to_ccvideo_frame_provider.cc
===================================================================
--- src/webkit/compositor_bindings/web_to_ccvideo_frame_provider.cc (revision 0)
+++ src/webkit/compositor_bindings/web_to_ccvideo_frame_provider.cc (revision 0)
@@ -0,0 +1,85 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "webkit/compositor_bindings/web_to_ccvideo_frame_provider.h"
+
+#include "base/logging.h"
+#include "media/base/video_frame.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebVideoFrameProvider.h"
+#include "webkit/media/webvideoframe_impl.h"
+
+using WebKit::WebVideoFrameProvider;
+using webkit_media::WebVideoFrameImpl;
+
+namespace webkit {
+
+scoped_ptr<WebToCCVideoFrameProvider> WebToCCVideoFrameProvider::Create(
+    WebVideoFrameProvider* web_provider) {
+  return make_scoped_ptr(new WebToCCVideoFrameProvider(web_provider));
+}
+
+WebToCCVideoFrameProvider::WebToCCVideoFrameProvider(
+    WebVideoFrameProvider* web_provider)
+    : web_provider_(web_provider),
+      web_frame_(NULL) {
+}
+
+WebToCCVideoFrameProvider::~WebToCCVideoFrameProvider() {
+}
+
+class WebToCCVideoFrameProvider::ClientAdapter
+    : public WebVideoFrameProvider::Client {
+ public:
+  explicit ClientAdapter(cc::VideoFrameProvider::Client* cc_client)
+      : cc_client_(cc_client) {}
+  virtual ~ClientAdapter() {}
+
+  // WebVideoFrameProvider::Client implementation.
+  virtual void stopUsingProvider() {
+    cc_client_->StopUsingProvider();
+  }
+
+  virtual void didReceiveFrame() {
+    cc_client_->DidReceiveFrame();
+  }
+
+  virtual void didUpdateMatrix(const float* matrix) {
+    cc_client_->DidUpdateMatrix(matrix);
+  }
+
+ private:
+  cc::VideoFrameProvider::Client* cc_client_;
+};
+   
+void WebToCCVideoFrameProvider::SetVideoFrameProviderClient(Client* client) {
+  scoped_ptr<ClientAdapter> client_adapter;
+  if (client)
+    client_adapter.reset(new ClientAdapter(client));
+  web_provider_->setVideoFrameProviderClient(client_adapter.get());
+  client_adapter_ = client_adapter.Pass();
+}
+
+scoped_refptr<media::VideoFrame> WebToCCVideoFrameProvider::GetCurrentFrame() {
+  web_frame_ = web_provider_->getCurrentFrame();
+  if (!web_frame_)
+    return scoped_refptr<media::VideoFrame>();
+  WebVideoFrameImpl* impl = static_cast<WebVideoFrameImpl*>(web_frame_);
+  return impl->video_frame;
+}
+
+void WebToCCVideoFrameProvider::PutCurrentFrame(
+    const scoped_refptr<media::VideoFrame>& frame) {
+  if (!frame) {
+    DCHECK(!web_frame_);
+    web_provider_->putCurrentFrame(web_frame_);
+    return;
+  }
+  DCHECK(web_frame_);
+  WebVideoFrameImpl* impl = static_cast<WebVideoFrameImpl*>(web_frame_);
+  DCHECK_EQ(impl->video_frame.get(), frame.get());
+  web_provider_->putCurrentFrame(web_frame_);
+  web_frame_ = NULL;
+}
+
+}  // namespace webkit
Index: src/webkit/compositor_bindings/web_layer_impl_fixed_bounds.cc
===================================================================
--- src/webkit/compositor_bindings/web_layer_impl_fixed_bounds.cc (revision 0)
+++ src/webkit/compositor_bindings/web_layer_impl_fixed_bounds.cc (revision 0)
@@ -0,0 +1,143 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "webkit/compositor_bindings/web_layer_impl_fixed_bounds.h"
+
+#include "cc/layer.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebFloatPoint.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebSize.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
+#include "third_party/skia/include/utils/SkMatrix44.h"
+#include "webkit/compositor_bindings/web_transformation_matrix_util.h"
+
+using cc::Layer;
+using webkit::WebTransformationMatrixUtil;
+
+namespace WebKit {
+
+WebLayerImplFixedBounds::WebLayerImplFixedBounds() {
+}
+
+WebLayerImplFixedBounds::WebLayerImplFixedBounds(scoped_refptr<Layer> layer)
+    : WebLayerImpl(layer) {
+}
+
+
+WebLayerImplFixedBounds::~WebLayerImplFixedBounds() {
+}
+
+void WebLayerImplFixedBounds::invalidateRect(const WebFloatRect& rect) {
+  // Partial invalidations seldom occur for such layers.
+  // Simply invalidate the whole layer to avoid transformation of coordinates.
+  invalidate();
+}
+
+void WebLayerImplFixedBounds::setAnchorPoint(
+    const WebFloatPoint& anchor_point) {
+  if (anchor_point != this->anchorPoint()) {
+    m_layer->setAnchorPoint(anchor_point);
+    UpdateLayerBoundsAndTransform();
+  }
+}
+
+void WebLayerImplFixedBounds::setBounds(const WebSize& bounds) {
+  if (original_bounds_ != gfx::Size(bounds)) {
+      original_bounds_ = bounds;
+      UpdateLayerBoundsAndTransform();
+  }
+}
+
+WebSize WebLayerImplFixedBounds::bounds() const {
+  return original_bounds_;
+}
+
+void WebLayerImplFixedBounds::setSublayerTransform(const SkMatrix44& matrix) {
+  gfx::Transform transform;
+  transform.matrix() = matrix;
+  SetSublayerTransformInternal(transform);
+}
+
+void WebLayerImplFixedBounds::setSublayerTransform(
+    const WebTransformationMatrix& matrix) {
+  SetSublayerTransformInternal(
+      WebTransformationMatrixUtil::ToTransform(matrix));
+}
+
+SkMatrix44 WebLayerImplFixedBounds::sublayerTransform() const {
+  return original_sublayer_transform_.matrix();
+}
+
+void WebLayerImplFixedBounds::setTransform(const SkMatrix44& matrix) {
+  gfx::Transform transform;
+  transform.matrix() = matrix;
+  SetTransformInternal(transform);
+}
+
+void WebLayerImplFixedBounds::setTransform(
+    const WebTransformationMatrix& matrix) {
+  SetTransformInternal(WebTransformationMatrixUtil::ToTransform(matrix));
+}
+
+SkMatrix44 WebLayerImplFixedBounds::transform() const {
+  return original_transform_.matrix();
+}
+
+void WebLayerImplFixedBounds::SetFixedBounds(const gfx::Size& fixed_bounds) {
+  if (fixed_bounds_ != fixed_bounds) {
+    fixed_bounds_ = fixed_bounds;
+    UpdateLayerBoundsAndTransform();
+  }
+}
+
+void WebLayerImplFixedBounds::SetSublayerTransformInternal(
+    const gfx::Transform& transform) {
+  if (original_sublayer_transform_ != transform) {
+    original_sublayer_transform_ = transform;
+    UpdateLayerBoundsAndTransform();
+  }
+}
+
+void WebLayerImplFixedBounds::SetTransformInternal(
+    const gfx::Transform& transform) {
+  if (original_transform_ != transform) {
+    original_transform_ = transform;
+    UpdateLayerBoundsAndTransform();
+  }
+}
+
+void WebLayerImplFixedBounds::UpdateLayerBoundsAndTransform()
+{
+  if (fixed_bounds_.IsEmpty() || original_bounds_.IsEmpty() ||
+      fixed_bounds_ == original_bounds_ ||
+      // For now fall back to non-fixed bounds for non-zero anchor point.
+      // TODO(wangxianzhu): Support non-zero anchor point for fixed bounds.
+      anchorPoint().x || anchorPoint().y) {
+    m_layer->setBounds(original_bounds_);
+    m_layer->setTransform(original_transform_);
+    m_layer->setSublayerTransform(original_sublayer_transform_);
+    return;
+  }
+
+  m_layer->setBounds(fixed_bounds_);
+
+  // Apply bounds scale (bounds/fixedBounds) over original transform.
+  gfx::Transform transform_with_bounds_scale(original_transform_);
+  float boundsScaleX =
+      static_cast<float>(original_bounds_.width()) / fixed_bounds_.width();
+  float boundsScaleY =
+      static_cast<float>(original_bounds_.height()) / fixed_bounds_.height();
+  transform_with_bounds_scale.Scale(boundsScaleX, boundsScaleY);
+  m_layer->setTransform(transform_with_bounds_scale);
+
+  // As we apply extra scale transform on this layer which will propagate to the
+  // sublayers, here undo the scale on sublayers.
+  gfx::Transform sublayer_transform_with_inverse_bounds_scale;
+  sublayer_transform_with_inverse_bounds_scale.Scale(1.f / boundsScaleX,
+                                                     1.f / boundsScaleY);
+  sublayer_transform_with_inverse_bounds_scale.PreconcatTransform(
+      original_sublayer_transform_);
+  m_layer->setSublayerTransform(sublayer_transform_with_inverse_bounds_scale);
+}
+
+} // namespace WebKit
Index: src/webkit/compositor_bindings/webkit_compositor_bindings_export.h
===================================================================
--- src/webkit/compositor_bindings/webkit_compositor_bindings_export.h (revision 0)
+++ src/webkit/compositor_bindings/webkit_compositor_bindings_export.h (revision 0)
@@ -0,0 +1,29 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WEBKIT_COMPOSITOR_BINDINGS_WEBKIT_COMPOSITOR_BINDINGS_EXPORT_H_
+#define WEBKIT_COMPOSITOR_BINDINGS_WEBKIT_COMPOSITOR_BINDINGS_EXPORT_H_
+
+#if defined(COMPONENT_BUILD)
+#if defined(WIN32)
+
+#if defined(WEBKIT_COMPOSITOR_BINDINGS_IMPLEMENTATION)
+#define WEBKIT_COMPOSITOR_BINDINGS_EXPORT __declspec(dllexport)
+#else
+#define WEBKIT_COMPOSITOR_BINDINGS_EXPORT __declspec(dllimport)
+#endif  // defined(WEBKIT_COMPOSITOR_BINDINGS_IMPLEMENTATION)
+
+#else // defined(WIN32)
+#if defined(WEBKIT_COMPOSITOR_BINDINGS_IMPLEMENTATION)
+#define WEBKIT_COMPOSITOR_BINDINGS_EXPORT __attribute__((visibility("default")))
+#else
+#define WEBKIT_COMPOSITOR_BINDINGS_EXPORT
+#endif
+#endif
+
+#else // defined(COMPONENT_BUILD)
+#define WEBKIT_COMPOSITOR_BINDINGS_EXPORT
+#endif
+
+#endif  // WEBKIT_COMPOSITOR_BINDINGS_WEBKIT_COMPOSITOR_BINDINGS_EXPORT_H_
Index: src/webkit/compositor_bindings/web_transformation_matrix_util.cc
===================================================================
--- src/webkit/compositor_bindings/web_transformation_matrix_util.cc (revision 0)
+++ src/webkit/compositor_bindings/web_transformation_matrix_util.cc (revision 0)
@@ -0,0 +1,40 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "webkit/compositor_bindings/web_transformation_matrix_util.h"
+
+using WebKit::WebTransformationMatrix;
+
+namespace webkit {
+
+gfx::Transform WebTransformationMatrixUtil::ToTransform(
+    const WebTransformationMatrix& matrix) {
+  return gfx::Transform(matrix.m11(), matrix.m21(), matrix.m31(), matrix.m41(),
+                        matrix.m12(), matrix.m22(), matrix.m32(), matrix.m42(),
+                        matrix.m13(), matrix.m23(), matrix.m33(), matrix.m43(),
+                        matrix.m14(), matrix.m24(), matrix.m34(), matrix.m44());
+}
+
+WebTransformationMatrix WebTransformationMatrixUtil::ToWebTransformationMatrix(
+    const gfx::Transform& transform) {
+  return WebTransformationMatrix(transform.matrix().getDouble(0, 0),
+                                 transform.matrix().getDouble(1, 0),
+                                 transform.matrix().getDouble(2, 0),
+                                 transform.matrix().getDouble(3, 0),
+                                 transform.matrix().getDouble(0, 1),
+                                 transform.matrix().getDouble(1, 1),
+                                 transform.matrix().getDouble(2, 1),
+                                 transform.matrix().getDouble(3, 1),
+                                 transform.matrix().getDouble(0, 2),
+                                 transform.matrix().getDouble(1, 2),
+                                 transform.matrix().getDouble(2, 2),
+                                 transform.matrix().getDouble(3, 2),
+                                 transform.matrix().getDouble(0, 3),
+                                 transform.matrix().getDouble(1, 3),
+                                 transform.matrix().getDouble(2, 3),
+                                 transform.matrix().getDouble(3, 3));
+
+}
+
+}  // namespace webkit
Index: src/webkit/compositor_bindings/web_transform_operations_impl.cc
===================================================================
--- src/webkit/compositor_bindings/web_transform_operations_impl.cc (revision 0)
+++ src/webkit/compositor_bindings/web_transform_operations_impl.cc (revision 0)
@@ -0,0 +1,63 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "webkit/compositor_bindings/web_transform_operations_impl.h"
+#include "webkit/compositor_bindings/web_transformation_matrix_util.h"
+
+namespace webkit {
+
+WebTransformOperationsImpl::WebTransformOperationsImpl() {
+}
+
+const cc::TransformOperations&
+WebTransformOperationsImpl::AsTransformOperations() const {
+  return transform_operations_;
+}
+
+bool WebTransformOperationsImpl::canBlendWith(
+    const WebKit::WebTransformOperations& other) const {
+  const WebTransformOperationsImpl& other_impl =
+    static_cast<const WebTransformOperationsImpl&>(other);
+  return transform_operations_.CanBlendWith(other_impl.transform_operations_);
+}
+
+void WebTransformOperationsImpl::appendTranslate(double x, double y, double z) {
+  transform_operations_.AppendTranslate(x, y, z);
+}
+
+void WebTransformOperationsImpl::appendRotate(
+    double x, double y, double z, double degrees) {
+  transform_operations_.AppendRotate(x, y, z, degrees);
+}
+
+void WebTransformOperationsImpl::appendScale(double x, double y, double z) {
+  transform_operations_.AppendScale(x, y, z);
+}
+
+void WebTransformOperationsImpl::appendSkew(double x, double y) {
+  transform_operations_.AppendSkew(x, y);
+}
+
+void WebTransformOperationsImpl::appendPerspective(double depth) {
+  transform_operations_.AppendPerspective(depth);
+}
+
+void WebTransformOperationsImpl::appendMatrix(
+    const WebKit::WebTransformationMatrix& matrix) {
+  transform_operations_.AppendMatrix(
+      WebTransformationMatrixUtil::ToTransform(matrix));
+}
+
+void WebTransformOperationsImpl::appendIdentity() {
+  transform_operations_.AppendIdentity();
+}
+
+bool WebTransformOperationsImpl::isIdentity() const {
+  return transform_operations_.IsIdentity();
+}
+
+WebTransformOperationsImpl::~WebTransformOperationsImpl() {
+}
+
+}  // namespace webkit
Index: src/webkit/compositor_bindings/web_transformation_matrix_util.h
===================================================================
--- src/webkit/compositor_bindings/web_transformation_matrix_util.h (revision 0)
+++ src/webkit/compositor_bindings/web_transformation_matrix_util.h (revision 0)
@@ -0,0 +1,24 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WEBKIT_COMPOSITOR_BINDINGS_WEB_TRANSFORMATION_MATRIX_UTIL_H_
+#define WEBKIT_COMPOSITOR_BINDINGS_WEB_TRANSFORMATION_MATRIX_UTIL_H_
+
+#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformationMatrix.h"
+#include "ui/gfx/transform.h"
+
+namespace webkit {
+
+class WebTransformationMatrixUtil {
+ public:
+  static gfx::Transform ToTransform(
+      const WebKit::WebTransformationMatrix& matrix);
+
+  static WebKit::WebTransformationMatrix ToWebTransformationMatrix(
+      const gfx::Transform& transform);
+};
+
+}  // namespace webkit
+
+#endif  // WEBKIT_COMPOSITOR_BINDINGS_WEB_TRANSFORMATION_MATRIX_UTIL_H_
Index: src/webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.cc
===================================================================
--- src/webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.cc (revision 0)
+++ src/webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.cc (revision 0)
@@ -0,0 +1,65 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.h"
+
+#include "third_party/WebKit/Source/Platform/chromium/public/WebRect.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebScrollbarThemePainter.h"
+
+namespace WebKit {
+
+WebToCCScrollbarThemePainterAdapter::~WebToCCScrollbarThemePainterAdapter() {
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintScrollbarBackground(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintScrollbarBackground(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintTrackBackground(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintTrackBackground(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintBackTrackPart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintBackTrackPart(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintForwardTrackPart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintForwardTrackPart(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintBackButtonStart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintBackButtonStart(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintBackButtonEnd(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintBackButtonEnd(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintForwardButtonStart(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintForwardButtonStart(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintForwardButtonEnd(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintForwardButtonEnd(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintTickmarks(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintTickmarks(canvas, rect);
+}
+
+void WebToCCScrollbarThemePainterAdapter::PaintThumb(
+    SkCanvas* canvas, const gfx::Rect& rect) {
+  painter_->paintThumb(canvas, rect);
+}
+
+}  // namespace WebKit
Index: src/webkit/compositor_bindings/web_transform_operations_impl.h
===================================================================
--- src/webkit/compositor_bindings/web_transform_operations_impl.h (revision 0)
+++ src/webkit/compositor_bindings/web_transform_operations_impl.h (revision 0)
@@ -0,0 +1,43 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WEBKIT_COMPOSITOR_BINDINGS_WEB_TRANSFORM_OPERATIONS_IMPL_H_
+#define WEBKIT_COMPOSITOR_BINDINGS_WEB_TRANSFORM_OPERATIONS_IMPL_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/transform_operations.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h"
+#include "webkit/compositor_bindings/webkit_compositor_bindings_export.h"
+
+namespace webkit {
+
+class WebTransformOperationsImpl : public WebKit::WebTransformOperations {
+ public:
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebTransformOperationsImpl();
+  virtual ~WebTransformOperationsImpl();
+
+  const cc::TransformOperations& AsTransformOperations() const;
+
+  // Implementation of WebKit::WebTransformOperations methods
+  virtual bool canBlendWith(
+      const WebKit::WebTransformOperations& other) const OVERRIDE;
+  virtual void appendTranslate(double x, double y, double z) OVERRIDE;
+  virtual void appendRotate(
+      double x, double y, double z, double degrees) OVERRIDE;
+  virtual void appendScale(double x, double y, double z) OVERRIDE;
+  virtual void appendSkew(double x, double y) OVERRIDE;
+  virtual void appendPerspective(double depth) OVERRIDE;
+  virtual void appendMatrix(const WebKit::WebTransformationMatrix&) OVERRIDE;
+  virtual void appendIdentity() OVERRIDE;
+  virtual bool isIdentity() const OVERRIDE;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WebTransformOperationsImpl);
+
+  cc::TransformOperations transform_operations_;
+};
+
+}  // namespace webkit
+
+#endif  // WEBKIT_COMPOSITOR_BINDINGS_WEB_TRANSFORM_OPERATIONS_IMPL_H_
Index: src/webkit/compositor_bindings/web_to_ccvideo_frame_provider.h
===================================================================
--- src/webkit/compositor_bindings/web_to_ccvideo_frame_provider.h (revision 0)
+++ src/webkit/compositor_bindings/web_to_ccvideo_frame_provider.h (revision 0)
@@ -0,0 +1,42 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WEBKIT_COMPOSITOR_BINDINGS_WEB_TO_CCVIDEO_FRAME_PROVIDER_H_
+#define WEBKIT_COMPOSITOR_BINDINGS_WEB_TO_CCVIDEO_FRAME_PROVIDER_H_
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "cc/video_frame_provider.h"
+
+namespace WebKit {
+class WebVideoFrame;
+class WebVideoFrameProvider;
+}
+
+namespace webkit {
+
+class WebToCCVideoFrameProvider : public cc::VideoFrameProvider {
+ public:
+  static scoped_ptr<WebToCCVideoFrameProvider> Create(
+      WebKit::WebVideoFrameProvider* web_provider);
+  virtual ~WebToCCVideoFrameProvider();
+
+  // cc::VideoFrameProvider implementation.
+  virtual void SetVideoFrameProviderClient(Client*) OVERRIDE;
+  virtual scoped_refptr<media::VideoFrame> GetCurrentFrame() OVERRIDE;
+  virtual void PutCurrentFrame(const scoped_refptr<media::VideoFrame>& frame)
+      OVERRIDE;
+
+ private:
+  explicit WebToCCVideoFrameProvider(WebKit::WebVideoFrameProvider*);
+
+  class ClientAdapter;
+  scoped_ptr<ClientAdapter> client_adapter_;
+  WebKit::WebVideoFrameProvider* web_provider_;
+  WebKit::WebVideoFrame* web_frame_;
+};
+
+}  // namespace webkit
+
+#endif // WEBKIT_COMPOSITOR_BINDINGS_WEB_TO_CCVIDEO_FRAME_PROVIDER_H_
Index: src/webkit/compositor_bindings/web_layer_impl_fixed_bounds.h
===================================================================
--- src/webkit/compositor_bindings/web_layer_impl_fixed_bounds.h (revision 0)
+++ src/webkit/compositor_bindings/web_layer_impl_fixed_bounds.h (revision 0)
@@ -0,0 +1,53 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WebLayerImplFixedBounds_h
+#define WebLayerImplFixedBounds_h
+
+#include "ui/gfx/size.h"
+#include "ui/gfx/transform.h"
+#include "webkit/compositor_bindings/web_layer_impl.h"
+
+namespace WebKit {
+
+// A special implementation of WebLayerImpl for layers that its contents
+// need to be automatically scaled when the bounds changes. The compositor
+// can efficiently handle the bounds change of such layers if the bounds
+// is fixed to a given value and the change of bounds are converted to
+// transformation scales.
+class WebLayerImplFixedBounds : public WebLayerImpl {
+ public:
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT WebLayerImplFixedBounds();
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT explicit WebLayerImplFixedBounds(
+      scoped_refptr<cc::Layer>);
+  virtual ~WebLayerImplFixedBounds();
+
+  // WebLayerImpl overrides.
+  virtual void invalidateRect(const WebFloatRect&) OVERRIDE;
+  virtual void setAnchorPoint(const WebFloatPoint&) OVERRIDE;
+  virtual void setBounds(const WebSize&) OVERRIDE;
+  virtual WebSize bounds() const OVERRIDE;
+  virtual void setSublayerTransform(const SkMatrix44&) OVERRIDE;
+  virtual void setSublayerTransform(const WebTransformationMatrix&) OVERRIDE;
+  virtual SkMatrix44 sublayerTransform() const OVERRIDE;
+  virtual void setTransform(const SkMatrix44&) OVERRIDE;
+  virtual void setTransform(const WebTransformationMatrix&) OVERRIDE;
+  virtual SkMatrix44 transform() const OVERRIDE;
+
+  WEBKIT_COMPOSITOR_BINDINGS_EXPORT void SetFixedBounds(const gfx::Size&);
+
+ protected:
+  void SetTransformInternal(const gfx::Transform&);
+  void SetSublayerTransformInternal(const gfx::Transform&);
+  void UpdateLayerBoundsAndTransform();
+
+  gfx::Transform original_sublayer_transform_;
+  gfx::Transform original_transform_;
+  gfx::Size original_bounds_;
+  gfx::Size fixed_bounds_;
+};
+
+} // namespace WebKit
+
+#endif // WebLayerImplFixedBounds_h
Index: src/webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.h
===================================================================
--- src/webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.h (revision 0)
+++ src/webkit/compositor_bindings/web_to_ccscrollbar_theme_painter_adapter.h (revision 0)
@@ -0,0 +1,55 @@
+// Copyright 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WEBKIT_COMPOSITOR_BINDINGS_WEB_TO_CCSCROLLBAR_THEME_PAINTER_ADAPTER_H_
+#define WEBKIT_COMPOSITOR_BINDINGS_WEB_TO_CCSCROLLBAR_THEME_PAINTER_ADAPTER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "cc/scrollbar_theme_painter.h"
+
+namespace WebKit {
+
+class WebScrollbarThemePainter;
+
+class WebToCCScrollbarThemePainterAdapter : public cc::ScrollbarThemePainter {
+ public:
+  static scoped_ptr<WebToCCScrollbarThemePainterAdapter> Create(
+      scoped_ptr<WebScrollbarThemePainter> webPainter) {
+    return make_scoped_ptr(new WebToCCScrollbarThemePainterAdapter(
+        webPainter.Pass()));
+  }
+  virtual ~WebToCCScrollbarThemePainterAdapter();
+
+  virtual void PaintScrollbarBackground(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintTrackBackground(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintBackTrackPart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintForwardTrackPart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintBackButtonStart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintBackButtonEnd(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintForwardButtonStart(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintForwardButtonEnd(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintTickmarks(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+  virtual void PaintThumb(SkCanvas* canvas, const gfx::Rect& rect)
+      OVERRIDE;
+
+ private:
+  WebToCCScrollbarThemePainterAdapter(
+      scoped_ptr<WebScrollbarThemePainter> webPainter)
+      : painter_(webPainter.Pass()) {}
+
+  scoped_ptr<WebScrollbarThemePainter> painter_;
+};
+
+}  // namespace WebKit
+
+#endif  // WEBKIT_COMPOSITOR_BINDINGS_WEB_TO_CCSCROLLBAR_THEME_PAINTER_ADAPTER_H_
Index: src/webkit/glue/web_discardable_memory_impl.h
===================================================================
--- src/webkit/glue/web_discardable_memory_impl.h (revision 0)
+++ src/webkit/glue/web_discardable_memory_impl.h (revision 0)
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef WEBKIT_GLUE_WEB_DISCARDABLE_MEMORY_IMPL_H_
+#define WEBKIT_GLUE_WEB_DISCARDABLE_MEMORY_IMPL_H_
+
+#include "base/memory/discardable_memory.h"
+#include "base/memory/scoped_ptr.h"
+#include "third_party/WebKit/Source/Platform/chromium/public/WebDiscardableMemory.h"
+#include "webkit/glue/webkit_glue_export.h"
+
+namespace WebKit {
+class WebDiscardableMemory;
+}
+
+namespace webkit_glue {
+
+// Implementation of WebDiscardableMemory that is responsible for allocating
+// discardable memory.
+class WEBKIT_GLUE_EXPORT WebDiscardableMemoryImpl
+    : NON_EXPORTED_BASE(public WebKit::WebDiscardableMemory) {
+ public:
+  WebDiscardableMemoryImpl();
+  virtual ~WebDiscardableMemoryImpl();
+
+  // WebKit::WebDiscardableMemory implementation.
+  virtual bool lock();
+  virtual void unlock();
+  virtual void* data();
+
+  // Initialize the WebDiscardableMemoryImpl object and lock the memory.
+  // Returns true on success. No memory is allocated if this call returns
+  // false. This call should only be called once.
+  bool InitializeAndLock(size_t size);
+
+ private:
+  scoped_ptr<base::DiscardableMemory> discardable_;
+  DISALLOW_COPY_AND_ASSIGN(WebDiscardableMemoryImpl);
+};
+
+}  // namespace webkit_glue
+
+#endif  // WEBKIT_GLUE_WEB_DISCARDABLE_MEMORY_IMPL_H_
Index: src/webkit/glue/web_discardable_memory_impl.cc
===================================================================
--- src/webkit/glue/web_discardable_memory_impl.cc (revision 0)
+++ src/webkit/glue/web_discardable_memory_impl.cc (revision 0)
@@ -0,0 +1,41 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "webkit/glue/web_discardable_memory_impl.h"
+
+namespace webkit_glue {
+
+WebDiscardableMemoryImpl::WebDiscardableMemoryImpl()
+    : discardable_(new base::DiscardableMemory()) {
+}
+
+WebDiscardableMemoryImpl::~WebDiscardableMemoryImpl() {}
+
+bool WebDiscardableMemoryImpl::InitializeAndLock(size_t size) {
+  return discardable_->InitializeAndLock(size);
+}
+
+bool WebDiscardableMemoryImpl::lock() {
+  base::LockDiscardableMemoryStatus status = discardable_->Lock();
+  switch (status) {
+    case base::DISCARDABLE_MEMORY_SUCCESS:
+      return true;
+    case base::DISCARDABLE_MEMORY_PURGED:
+      discardable_->Unlock();
+      return false;
+    default:
+      discardable_.reset();
+      return false;
+  }
+}
+
+void* WebDiscardableMemoryImpl::data() {
+  return discardable_->Memory();
+}
+
+void WebDiscardableMemoryImpl::unlock() {
+  discardable_->Unlock();
+}
+
+}  // namespace webkit_glue
Index: src/content/browser/gpu/gpu_memory_test.cc
===================================================================
--- src/content/browser/gpu/gpu_memory_test.cc (revision 0)
+++ src/content/browser/gpu/gpu_memory_test.cc (revision 0)
@@ -0,0 +1,171 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/callback.h"
+#include "base/command_line.h"
+#include "base/path_service.h"
+#include "content/public/browser/gpu_data_manager.h"
+#include "content/public/browser/gpu_data_manager_observer.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/content_paths.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/test/browser_test_utils.h"
+#include "content/public/test/test_utils.h"
+#include "content/shell/shell.h"
+#include "content/test/content_browser_test.h"
+#include "content/test/content_browser_test_utils.h"
+#include "gpu/command_buffer/service/gpu_switches.h"
+#include "net/base/net_util.h"
+
+namespace {
+
+// Observer to report GPU memory usage when requested.
+class GpuMemoryBytesAllocatedObserver
+    : public content::GpuDataManagerObserver {
+ public:
+  GpuMemoryBytesAllocatedObserver()
+      : bytes_allocated_(0) {
+  }
+
+  virtual ~GpuMemoryBytesAllocatedObserver() {
+  }
+
+  virtual void OnGpuInfoUpdate() OVERRIDE {}
+
+  virtual void OnVideoMemoryUsageStatsUpdate(
+      const content::GPUVideoMemoryUsageStats& video_memory_usage_stats)
+          OVERRIDE {
+    bytes_allocated_ = video_memory_usage_stats.bytes_allocated;
+    message_loop_runner_->Quit();
+  }
+
+  size_t GetBytesAllocated() {
+    message_loop_runner_ = new content::MessageLoopRunner;
+    content::GpuDataManager::GetInstance()->AddObserver(this);
+    content::GpuDataManager::GetInstance()->
+        RequestVideoMemoryUsageStatsUpdate();
+    message_loop_runner_->Run();
+    content::GpuDataManager::GetInstance()->RemoveObserver(this);
+    message_loop_runner_ = NULL;
+    return bytes_allocated_;
+  }
+
+ private:
+  size_t bytes_allocated_;
+  scoped_refptr<content::MessageLoopRunner> message_loop_runner_;
+};
+
+class GpuMemoryTest : public content::ContentBrowserTest {
+ public:
+  GpuMemoryTest()
+      : allow_tests_to_run_(false),
+        has_used_first_shell_(false) {
+  }
+  virtual ~GpuMemoryTest() {
+  }
+
+  virtual void SetUpInProcessBrowserTestFixture() {
+    FilePath test_dir;
+    ASSERT_TRUE(PathService::Get(content::DIR_TEST_DATA, &test_dir));
+    gpu_test_dir_ = test_dir.AppendASCII("gpu");
+  }
+
+  virtual void SetUpCommandLine(CommandLine* command_line) {
+    command_line->AppendSwitch(switches::kEnableLogging);
+    command_line->AppendSwitch(switches::kForceCompositingMode);
+    // TODO: Use switches::kForceGpuMemAvailableMb to fix the memory limit
+    // (this is failing some bots (probably because of differing meanings of
+    // GPU_EXPORT)
+    // Only run this on GPU bots for now. These tests should work with
+    // any GPU process, but may be slow.
+    if (command_line->HasSwitch(switches::kUseGpuInTests)) {
+      allow_tests_to_run_ = true;
+    }
+    // Don't enable these tests on Android just yet (they use lots of memory and
+    // may not be stable).
+#if defined(OS_ANDROID)
+    allow_tests_to_run_ = false;
+#endif
+  }
+
+  enum PageType {
+    PAGE_CSS3D,
+    PAGE_WEBGL,
+  };
+
+  // Load a page and consume a specified amount of GPU memory.
+  void LoadPage(content::Shell* shell_to_load,
+                PageType page_type,
+                size_t mb_to_use) {
+    FilePath url;
+    switch (page_type) {
+      case PAGE_CSS3D:
+        url = gpu_test_dir_.AppendASCII("mem_css3d.html");
+        break;
+      case PAGE_WEBGL:
+        url = gpu_test_dir_.AppendASCII("mem_webgl.html");
+        break;
+    }
+
+    content::NavigateToURL(shell_to_load, net::FilePathToFileURL(url));
+    std::ostringstream js_call;
+    js_call << "useGpuMemory(";
+    js_call << mb_to_use;
+    js_call << ");";
+    content::DOMMessageQueue message_queue;
+    std::string message;
+    ASSERT_TRUE(content::ExecuteScript(
+        shell_to_load->web_contents(), js_call.str()));
+    ASSERT_TRUE(message_queue.WaitForMessage(&message));
+    EXPECT_EQ("\"DONE_USE_GPU_MEMORY\"", message);
+  }
+
+  // Create a new tab.
+  content::Shell* CreateNewTab() {
+    // The ContentBrowserTest will create one shell by default, use that one
+    // first so that we don't confuse the memory manager into thinking there
+    // are more windows than there are.
+    content::Shell* new_shell =
+        has_used_first_shell_ ? CreateBrowser() : shell();
+    has_used_first_shell_ = true;
+    visible_shells_.insert(new_shell);
+    return new_shell;
+  }
+
+  void SetTabBackgrounded(content::Shell* shell_to_background) {
+    ASSERT_TRUE(
+        visible_shells_.find(shell_to_background) != visible_shells_.end());
+    visible_shells_.erase(shell_to_background);
+    shell_to_background->web_contents()->WasHidden();
+  }
+
+  size_t GetMemoryUsageMbytes() {
+    // TODO: This should wait until all effects of memory management complete.
+    // We will need to wait until all
+    // 1. pending commits from the main thread to the impl thread in the
+    //    compositor complete (for visible compositors).
+    // 2. allocations that the renderer's impl thread will make due to the
+    //    compositor and WebGL are completed.
+    // 3. pending GpuMemoryManager::Manage() calls to manage are made.
+    // 4. renderers' OnMemoryAllocationChanged callbacks in response to
+    //    manager are made.
+    // Each step in this sequence can cause trigger the next (as a 1-2-3-4-1
+    // cycle), so we will need to pump this cycle until it stabilizes.
+    GpuMemoryBytesAllocatedObserver observer;
+    observer.GetBytesAllocated();
+    return observer.GetBytesAllocated() / 1048576;
+  }
+
+  bool AllowTestsToRun() const {
+    return allow_tests_to_run_;
+  }
+
+ private:
+  bool allow_tests_to_run_;
+  std::set<content::Shell*> visible_shells_;
+  bool has_used_first_shell_;
+  FilePath gpu_test_dir_;
+};
+
+}  // namespace
Index: src/content/test/data/gpu/mem_css3d.html
===================================================================
--- src/content/test/data/gpu/mem_css3d.html (revision 0)
+++ src/content/test/data/gpu/mem_css3d.html (revision 0)
@@ -0,0 +1,52 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>GPU Memory Test: Use N MB of GPU Memory with 3D CSS</title>
+<style>
+.block {
+  background: #FF0000;
+  font-size: 150px;
+  height: 512px;
+  position: absolute;
+  width: 512px;
+  
+}
+.perspective
+{
+  border: 1px solid black;
+  height: 512px;
+  text-align: center;
+  width:  512px;
+  -webkit-perspective: 600px;
+  -webkit-perspective-origin: center center;
+  -webkit-transform-style: preserve-3d;
+}
+</style>
+<script type="text/javascript">
+// Generate n 3D CSS elements that are each about 1 MB in size 
+function useGpuMemory(mb_to_use) {
+  n = mb_to_use;
+  var blocks = document.getElementById("blocks");
+  var blockArray = document.getElementsByClassName("block");
+  for (var i = 0; i < n; i++) {
+    var block = document.createElement("div");
+    block.className = "block";
+    block.style.WebkitTransform = "translate3d(0px, 0px, " + (i-n+1) + "px)";
+    block.style.opacity = 0.1;
+    block.style.background = "#00FF00";
+    block.textContent = i;
+    blocks.appendChild(block);
+  }
+
+  // Touch offsetTop to trigger a layout.
+  document.body.offsetTop;
+
+  // Signal back to the test runner that we're done allocating memory.
+  domAutomationController.send("DONE_USE_GPU_MEMORY");
+}
+</script>
+</head>
+<body>
+<div id="blocks" class="perspective"/>
+</body>
+</html>
Index: src/content/test/data/gpu/mem_webgl.html
===================================================================
--- src/content/test/data/gpu/mem_webgl.html (revision 0)
+++ src/content/test/data/gpu/mem_webgl.html (revision 0)
@@ -0,0 +1,136 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>GPU Memory Test: Use N MB of GPU Memory with WebGL</title>
+
+<script id="vertex-shader" type="x-shader/x-vertex">
+attribute vec2 a_position;
+varying vec2 v_position;
+void main() {
+    v_position = a_position;
+    gl_Position = vec4(a_position, 0, 1);
+}
+</script>
+
+<script id="fragment-shader" type="x-shader/x-fragment">
+precision mediump float;
+uniform sampler2D u_image;
+varying vec2 v_position;
+void main() {
+    gl_FragColor = texture2D(u_image, v_position);
+}
+</script>
+
+<script>
+var gl = null;
+var shaderProgram = null;
+var textures = [];
+var fbos = [];
+var t = 0.0;
+var n = 1;
+
+// Create n textures of about 1MB each.
+function useGpuMemory(mb_to_use)
+{
+  n = mb_to_use;
+
+  var canvas = document.getElementById("canvas_id");
+  gl = canvas.getContext("experimental-webgl");
+  if (!gl) {
+    throw "Unable to fetch WebGL rendering context for Canvas";
+  }
+
+  // Create n textures that are each about 1MB and FBOs to render to them.
+  for (var i = 0; i < n; ++i) {
+    var texture = gl.createTexture();
+    var fbo = gl.createFramebuffer();
+    textures.push(texture);
+    fbos.push(fbo);
+
+    gl.bindTexture(gl.TEXTURE_2D, texture);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0,
+                  gl.RGBA, gl.UNSIGNED_BYTE, null)
+
+    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
+    gl.framebufferTexture2D(gl.FRAMEBUFFER,
+                            gl.COLOR_ATTACHMENT0,
+                            gl.TEXTURE_2D,
+                            texture,
+                            0);
+  }
+
+  // Create a shader that samples a 2D image.
+  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
+  gl.shaderSource(vertexShader,
+                  document.getElementById("vertex-shader").textContent);
+  gl.compileShader(vertexShader);
+
+  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
+  gl.shaderSource(fragmentShader,
+                  document.getElementById("fragment-shader").textContent);
+  gl.compileShader(fragmentShader);
+
+  shaderProgram = gl.createProgram();
+  gl.attachShader(shaderProgram, vertexShader);
+  gl.attachShader(shaderProgram, fragmentShader);
+  gl.linkProgram(shaderProgram);
+  gl.useProgram(shaderProgram);
+
+  // Bind a vertex buffer with a single triangle
+  var buffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
+  var bufferData = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0]);
+  gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);
+  gl.enableVertexAttribArray(shaderProgram.a_position);
+  gl.vertexAttribPointer(shaderProgram.a_position, 2, gl.FLOAT, false, 0, 0);
+
+  // Signal back to the test runner that we're done allocating memory.
+  domAutomationController.send("DONE_USE_GPU_MEMORY");
+
+  // Start the event loop.
+  tick();
+}
+
+function drawScene()
+{
+  // Render a solid color to each texture.
+  for (var i = 0; i < n; ++i) {
+    gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[i]);
+    gl.viewport(0, 0, 512, 512);
+    gl.clearColor(0.0, Math.sin(t/60.0)*0.25 + 0.75*(i+1.0)/n, 0.0, 1.0);
+    gl.clear(gl.COLOR_BUFFER_BIT);
+  }
+
+  // Draw these textures to the screen, offset by 1 pixel increments
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, 256, 256);
+  gl.clearColor(0.0, 0.0, 0.0, 1.0);
+  gl.clear(gl.COLOR_BUFFER_BIT);
+  for (var i = 0; i < n; ++i) {
+    gl.viewport(i, i, 256-i, 256-i);
+    gl.activeTexture(gl.TEXTURE0);
+    gl.bindTexture(gl.TEXTURE_2D, textures[i]);
+    gl.uniform1i(shaderProgram.u_image, 0);
+    gl.drawArrays(gl.TRIANGLES, 0, 3);
+  }
+
+  t += 1;
+}
+
+function tick()
+{
+  window.webkitRequestAnimationFrame(tick);
+  drawScene();
+}
+</script>
+</head>
+
+<body>
+<canvas id="canvas_id" width=256px height=256px style="width:256px; height:256px;"/>
+</body>
+</html>
+
Index: src/content/common/gpu/gpu_memory_tracking.cc
===================================================================
--- src/content/common/gpu/gpu_memory_tracking.cc (revision 0)
+++ src/content/common/gpu/gpu_memory_tracking.cc (revision 0)
@@ -0,0 +1,43 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/common/gpu/gpu_memory_tracking.h"
+
+#if defined(ENABLE_GPU)
+
+#include "content/common/gpu/gpu_memory_manager.h"
+
+namespace content {
+
+GpuMemoryTrackingGroup::GpuMemoryTrackingGroup(
+    base::ProcessId pid,
+    gpu::gles2::MemoryTracker* memory_tracker,
+    GpuMemoryManager* memory_manager)
+    : pid_(pid),
+      size_(0),
+      hibernated_(false),
+      memory_tracker_(memory_tracker),
+      memory_manager_(memory_manager) {
+}
+
+GpuMemoryTrackingGroup::~GpuMemoryTrackingGroup() {
+  memory_manager_->OnDestroyTrackingGroup(this);
+}
+
+void GpuMemoryTrackingGroup::TrackMemoryAllocatedChange(
+    uint64 old_size,
+    uint64 new_size,
+    gpu::gles2::MemoryTracker::Pool tracking_pool) {
+  memory_manager_->TrackMemoryAllocatedChange(
+      this, old_size, new_size, tracking_pool);
+}
+
+bool GpuMemoryTrackingGroup::EnsureGPUMemoryAvailable(uint64 size_needed) {
+  return memory_manager_->EnsureGPUMemoryAvailable(size_needed);
+}
+
+
+}  // namespace content
+
+#endif
Index: src/content/common/gpu/gpu_memory_manager_client.h
===================================================================
--- src/content/common/gpu/gpu_memory_manager_client.h (revision 0)
+++ src/content/common/gpu/gpu_memory_manager_client.h (revision 0)
@@ -0,0 +1,113 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_COMMON_GPU_GPU_MEMORY_MANAGER_CLIENT_H_
+#define CONTENT_COMMON_GPU_GPU_MEMORY_MANAGER_CLIENT_H_
+
+#if defined(ENABLE_GPU)
+
+#include <list>
+
+#include "base/basictypes.h"
+#include "content/common/content_export.h"
+#include "content/common/gpu/gpu_memory_allocation.h"
+#include "gpu/command_buffer/service/memory_tracking.h"
+#include "ui/gfx/size.h"
+
+namespace content {
+
+class GpuMemoryManager;
+class GpuMemoryTrackingGroup;
+
+// The interface that the GPU memory manager uses to manipulate a client (to
+// send it allocation information and query its properties).
+class CONTENT_EXPORT GpuMemoryManagerClient {
+ public:
+  virtual ~GpuMemoryManagerClient() {}
+
+  // Returns surface size.
+  virtual gfx::Size GetSurfaceSize() const = 0;
+
+  // Returns the memory tracker for this stub.
+  virtual gpu::gles2::MemoryTracker* GetMemoryTracker() const = 0;
+
+  // Sets buffer usage depending on Memory Allocation
+  virtual void SetMemoryAllocation(
+      const GpuMemoryAllocation& allocation) = 0;
+
+  // Returns in bytes the total amount of GPU memory for the GPU which this
+  // context is currently rendering on. Returns false if no extension exists
+  // to get the exact amount of GPU memory.
+  virtual bool GetTotalGpuMemory(uint64* bytes) = 0;
+};
+
+// The state associated with a GPU memory manager client. This acts as the
+// handle through which the client interacts with the GPU memory manager.
+class CONTENT_EXPORT GpuMemoryManagerClientState {
+ public:
+  ~GpuMemoryManagerClientState();
+  void SetVisible(bool visible);
+  void SetManagedMemoryStats(const GpuManagedMemoryStats& stats);
+
+ private:
+  friend class GpuMemoryManager;
+
+  GpuMemoryManagerClientState(GpuMemoryManager* memory_manager,
+                              GpuMemoryManagerClient* client,
+                              GpuMemoryTrackingGroup* tracking_group,
+                              bool has_surface,
+                              bool visible);
+
+  // The memory manager this client is hanging off of.
+  GpuMemoryManager* memory_manager_;
+
+  // The client to send allocations to.
+  GpuMemoryManagerClient* client_;
+
+  // The tracking group for this client.
+  GpuMemoryTrackingGroup* tracking_group_;
+
+  // Offscreen commandbuffers will not have a surface.
+  const bool has_surface_;
+
+  // Whether or not this client is visible.
+  bool visible_;
+
+  // If the client has a surface, then this is an iterator in the
+  // clients_visible_mru_ if this client is visible and
+  // clients_nonvisible_mru_ if this is non-visible. Otherwise this is an
+  // iterator in clients_nonsurface_.
+  std::list<GpuMemoryManagerClientState*>::iterator list_iterator_;
+  bool list_iterator_valid_;
+
+  // Statistics about memory usage.
+  GpuManagedMemoryStats managed_memory_stats_;
+  bool managed_memory_stats_received_;
+
+  // When managed_memory_stats_.bytes_nicetohave leaves the range
+  // [low_, high_], then re-adjust memory limits.
+  uint64 bytes_nicetohave_limit_low_;
+  uint64 bytes_nicetohave_limit_high_;
+
+  // The allocation for this client, used transiently during memory policy
+  // calculation.
+  uint64 bytes_allocation_when_visible_;
+  uint64 bytes_allocation_when_nonvisible_;
+
+  // The ideal allocation for this client for three performance levels, used
+  // transiently during memory policy calculation.
+  uint64 bytes_allocation_ideal_nicetohave_;
+  uint64 bytes_allocation_ideal_required_;
+  uint64 bytes_allocation_ideal_minimum_;
+
+  // Set to disable allocating a frontbuffer or to disable allocations
+  // for clients that don't have surfaces.
+  bool hibernated_;
+};
+
+}  // namespace content
+
+#endif
+
+#endif  // CONTENT_COMMON_GPU_GPU_MEMORY_MANAGER_CLIENT_H_
Index: src/content/common/gpu/gpu_memory_manager_client.cc
===================================================================
--- src/content/common/gpu/gpu_memory_manager_client.cc (revision 0)
+++ src/content/common/gpu/gpu_memory_manager_client.cc (revision 0)
@@ -0,0 +1,51 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/common/gpu/gpu_memory_manager_client.h"
+
+#if defined(ENABLE_GPU)
+
+#include "content/common/gpu/gpu_memory_manager.h"
+
+namespace content {
+
+GpuMemoryManagerClientState::GpuMemoryManagerClientState(
+    GpuMemoryManager* memory_manager,
+    GpuMemoryManagerClient* client,
+    GpuMemoryTrackingGroup* tracking_group,
+    bool has_surface,
+    bool visible)
+    : memory_manager_(memory_manager),
+      client_(client),
+      tracking_group_(tracking_group),
+      has_surface_(has_surface),
+      visible_(visible),
+      list_iterator_valid_(false),
+      managed_memory_stats_received_(false),
+      bytes_nicetohave_limit_low_(0),
+      bytes_nicetohave_limit_high_(0),
+      bytes_allocation_when_visible_(0),
+      bytes_allocation_when_nonvisible_(0),
+      bytes_allocation_ideal_nicetohave_(0),
+      bytes_allocation_ideal_required_(0),
+      bytes_allocation_ideal_minimum_(0),
+      hibernated_(false) {
+}
+
+GpuMemoryManagerClientState::~GpuMemoryManagerClientState() {
+  memory_manager_->OnDestroyClientState(this);
+}
+
+void GpuMemoryManagerClientState::SetVisible(bool visible) {
+  memory_manager_->SetClientStateVisible(this, visible);
+}
+
+void GpuMemoryManagerClientState::SetManagedMemoryStats(
+    const GpuManagedMemoryStats& stats) {
+  memory_manager_->SetClientStateManagedMemoryStats(this, stats);
+}
+
+}  // namespace content
+
+#endif
Index: src/third_party/WebKit/Source/Platform/Platform.gypi
===================================================================
--- src/third_party/WebKit/Source/Platform/Platform.gypi	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/Platform.gypi	(working copy)
@@ -51,7 +51,7 @@
             'chromium/public/WebCookie.h',
             'chromium/public/WebCookieJar.h',
             'chromium/public/WebData.h',
-            'chromium/public/WebDelegatedRendererLayer.h',
+            'chromium/public/WebDiscardableMemory.h',
             'chromium/public/WebDragData.h',
             'chromium/public/WebExternalTextureLayer.h',
             'chromium/public/WebExternalTextureLayerClient.h',
Index: src/third_party/WebKit/Source/Platform/chromium/public/Platform.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/Platform.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/Platform.h	(working copy)
@@ -51,6 +51,7 @@
 class WebClipboard;
 class WebCompositorSupport;
 class WebCookieJar;
+class WebDiscardableMemory;
 class WebFileSystem;
 class WebFileUtilities;
 class WebFlingAnimator;
@@ -216,7 +217,14 @@
     // Returns true if the size has been reported, or false otherwise.
     virtual bool memoryAllocatorWasteInBytes(size_t*) { return false; }
 
+    // Allocates discardable memory. May return 0, even if the platform supports
+    // discardable memory. If nonzero, however, then the WebDiscardableMmeory is
+    // returned in an locked state. You may use its underlying data() member
+    // directly, taking care to unlock it when you are ready to let it become
+    // discardable.
+    virtual WebDiscardableMemory* allocateAndLockDiscardableMemory(size_t bytes) { return 0; }
 
+
     // Message Ports -------------------------------------------------------
 
     // Creates a Message Port Channel. This can be called on any thread.
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeView.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeView.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebLayerTreeView.h	(working copy)
@@ -107,9 +107,8 @@
     // mode).
     virtual WebSize deviceViewportSize() const = 0;
 
-    // Gives the corrected location for an event, accounting for the pinch-zoom transformation
-    // in the compositor.
-    virtual WebFloatPoint adjustEventPointForPinchZoom(const WebFloatPoint&) const = 0;
+    // FIXME: remove this after WebKit roll
+    virtual WebFloatPoint adjustEventPointForPinchZoom(const WebFloatPoint& p) const { return p; }
 
     virtual void setDeviceScaleFactor(float) = 0;
     virtual float deviceScaleFactor() const = 0;
@@ -188,8 +187,11 @@
     // Toggles the paint rects in the HUD layer
     virtual void setShowPaintRects(bool) { }
 
-    // Simulates a lost context. For testing only.
-    virtual void loseCompositorContext(int numTimes) = 0;
+    // Toggles continuous painting
+    virtual void setContinuousPaintingEnabled(bool) { }
+
+    // FIXME: Remove this.
+    virtual void loseCompositorContext(int numTimes) { }
 };
 
 } // namespace WebKit
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebCompositorTransferableResourceList.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebCompositorTransferableResourceList.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebCompositorTransferableResourceList.h	(working copy)
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef WebCompositorTransferableResourceList_h
-#define WebCompositorTransferableResourceList_h
-
-namespace WebKit {
-
-// This class represents data, opaque to WebKit, representing resources that can
-// be transfered between compositors. See WebDelegatedRendererLayer.
-struct WebCompositorTransferableResourceList {
-};
-
-} // namespace WebKit
-
-#endif // WebCompositorTransferableResourceList_h
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebInputHandlerClient.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebInputHandlerClient.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebInputHandlerClient.h	(working copy)
@@ -39,7 +39,8 @@
     };
     enum ScrollInputType {
         ScrollInputTypeGesture,
-        ScrollInputTypeWheel
+        ScrollInputTypeWheel,
+        ScrollInputTypeNonBubblingGesture
     };
 
     // Selects a layer to be scrolled at a given point in window coordinates.
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebTransformOperations.h	(working copy)
@@ -27,69 +27,28 @@
 
 #include <public/WebTransformationMatrix.h>
 
+#define WEB_TRANSFORM_OPERATIONS_IS_VIRTUAL 1
+
 namespace WebKit {
 
-class WebTransformOperationsPrivate;
-
-// Transform operations are a decomposed transformation matrix. It can be
-// applied to obtain a WebTransformationMatrix at any time, and can be blended
-// intelligently with other transform operations, so long as they represent the
-// same decomposition. For example, if we have a transform that is made up of
-// a rotation followed by skew, it can be blended intelligently with another
-// transform made up of a rotation followed by a skew. Blending is possible if
-// we have two dissimilar sets of transform operations, but the effect may not
-// be what was intended. For more information, see the comments for the blend
-// function below.
 class WebTransformOperations {
 public:
-    ~WebTransformOperations() { reset(); }
+    virtual ~WebTransformOperations() { }
 
-    WebTransformOperations() { initialize(); }
-    WebTransformOperations(const WebTransformOperations& other) { initialize(other); }
-    WebTransformOperations& operator=(const WebTransformOperations& other)
-    {
-        initialize(other);
-        return *this;
-    }
-
-    // Returns a transformation matrix representing these transform operations.
-    WEBKIT_EXPORT WebTransformationMatrix apply() const;
-
-    // Given another set of transform operations and a progress in the range
-    // [0, 1], returns a transformation matrix representing the intermediate
-    // value. If this->matchesTypes(from), then each of the operations are
-    // blended separately and then combined. Otherwise, the two sets of
-    // transforms are baked to matrices (using apply), and the matrices are
-    // then decomposed and interpolated. For more information, see
-    // http://www.w3.org/TR/2011/WD-css3-2d-transforms-20111215/#matrix-decomposition.
-    WEBKIT_EXPORT WebTransformationMatrix blend(const WebTransformOperations& from, double progress) const;
-
-    // Returns true if this operation and its descendants have the same types
-    // as other and its descendants.
-    WEBKIT_EXPORT bool matchesTypes(const WebTransformOperations& other) const;
-
     // Returns true if these operations can be blended. It will only return
     // false if we must resort to matrix interpolation, and matrix interpolation
     // fails (this can happen if either matrix cannot be decomposed).
-    WEBKIT_EXPORT bool canBlendWith(const WebTransformOperations& other) const;
+    virtual bool canBlendWith(const WebTransformOperations& other) const = 0;
 
-    WEBKIT_EXPORT void appendTranslate(double x, double y, double z);
-    WEBKIT_EXPORT void appendRotate(double x, double y, double z, double degrees);
-    WEBKIT_EXPORT void appendScale(double x, double y, double z);
-    WEBKIT_EXPORT void appendSkew(double x, double y);
-    WEBKIT_EXPORT void appendPerspective(double depth);
-    WEBKIT_EXPORT void appendMatrix(const WebTransformationMatrix&);
-    WEBKIT_EXPORT void appendIdentity();
+    virtual void appendTranslate(double x, double y, double z) = 0;
+    virtual void appendRotate(double x, double y, double z, double degrees) = 0;
+    virtual void appendScale(double x, double y, double z) = 0;
+    virtual void appendSkew(double x, double y) = 0;
+    virtual void appendPerspective(double depth) = 0;
+    virtual void appendMatrix(const WebTransformationMatrix&) = 0;
+    virtual void appendIdentity() = 0;
 
-    WEBKIT_EXPORT bool isIdentity() const;
-
-private:
-    WEBKIT_EXPORT void reset();
-    WEBKIT_EXPORT void initialize();
-    WEBKIT_EXPORT void initialize(const WebTransformOperations& prototype);
-    WEBKIT_EXPORT bool blendInternal(const WebTransformOperations& from, double progress, WebTransformationMatrix& result) const;
-
-    WebPrivateOwnPtr<WebTransformOperationsPrivate> m_private;
+    virtual bool isIdentity() const = 0;
 };
 
 } // namespace WebKit
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebCompositorSupport.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebCompositorSupport.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebCompositorSupport.h	(working copy)
@@ -37,7 +37,6 @@
 class WebCompositorOutputSurface;
 class WebContentLayer;
 class WebContentLayerClient;
-class WebDelegatedRendererLayer;
 class WebExternalTextureLayer;
 class WebExternalTextureLayerClient;
 class WebFloatAnimationCurve;
@@ -51,6 +50,7 @@
 class WebSolidColorLayer;
 class WebThread;
 class WebTransformAnimationCurve;
+class WebTransformOperations;
 class WebVideoFrameProvider;
 class WebVideoLayer;
 
@@ -84,8 +84,6 @@
 
     virtual WebContentLayer* createContentLayer(WebContentLayerClient*) { return 0; }
 
-    virtual WebDelegatedRendererLayer* createDelegatedRendererLayer() { return 0; }
-
     virtual WebExternalTextureLayer* createExternalTextureLayer(WebExternalTextureLayerClient* = 0) { return 0; }
 
     virtual WebIOSurfaceLayer* createIOSurfaceLayer() { return 0; }
@@ -107,6 +105,8 @@
 
     virtual WebTransformAnimationCurve* createTransformAnimationCurve() { return 0; }
 
+    virtual WebTransformOperations* createTransformOperations() { return 0; }
+
 protected:
     virtual ~WebCompositorSupport() { }
 };
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebTransformKeyframe.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebTransformKeyframe.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebTransformKeyframe.h	(working copy)
@@ -25,19 +25,25 @@
 #ifndef WebTransformKeyframe_h
 #define WebTransformKeyframe_h
 
+#include "WebPrivateOwnPtr.h"
 #include "WebTransformOperations.h"
 
 namespace WebKit {
 
-struct WebTransformKeyframe {
-    WebTransformKeyframe(double time, const WebTransformOperations& value)
-        : time(time)
-        , value(value)
-    {
-    }
+class WebTransformKeyframe {
+public:
+    // Takes ownership of the WebTranformOperations object.
+    WEBKIT_EXPORT WebTransformKeyframe(double time, WebTransformOperations* value);
 
-    double time;
-    WebTransformOperations value;
+    WEBKIT_EXPORT ~WebTransformKeyframe();
+
+    WEBKIT_EXPORT double time() const;
+
+    WEBKIT_EXPORT const WebTransformOperations& value() const;
+
+private:
+    double m_time;
+    WebPrivateOwnPtr<WebTransformOperations> m_value;
 };
 
 } // namespace WebKit
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebDelegatedRendererLayer.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebDelegatedRendererLayer.h	(revision 143973)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebDelegatedRendererLayer.h	(working copy)
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef WebDelegatedRendererLayer_h
-#define WebDelegatedRendererLayer_h
-
-#include "WebCommon.h"
-
-namespace WebKit {
-
-struct WebCompositorFrame;
-struct WebCompositorTransferableResourceList;
-
-// This class represents a layer that renders the output of another
-// delegating compositor. It is created and owned by the embedder, who
-// provides the layer with a set of RenderPasses generated by the
-// compositor that the layer represents. This layer's output becomes the
-// same RenderPasses it received from the embedder.
-class WebDelegatedRendererLayer {
-public:
-    virtual ~WebDelegatedRendererLayer() { }
-
-    virtual WebLayer* layer() = 0;
-    virtual void setFrameData(const WebCompositorFrame&) { }
-    virtual void getRecycledResources(WebCompositorTransferableResourceList*) { }
-};
-
-} // namespace WebKit
-
-#endif // WebDelegatedRendererLayer_h
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebSettings.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebSettings.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebSettings.h	(working copy)
@@ -50,7 +50,8 @@
     enum EditingBehavior {
         EditingBehaviorMac,
         EditingBehaviorWin,
-        EditingBehaviorUnix
+        EditingBehaviorUnix,
+        EditingBehaviorAndroid
     };
 
     virtual bool scrollAnimatorEnabled() const = 0;
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebViewClient.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebViewClient.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebViewClient.h	(working copy)
@@ -144,9 +144,6 @@
     // Called to retrieve the provider of desktop notifications.
     virtual WebNotificationPresenter* notificationPresenter() { return 0; }
 
-    // Called when a gesture event is handled.
-    virtual void didHandleGestureEvent(const WebGestureEvent& event, bool eventSwallowed) { }
-
     // Called to request an icon for the specified filenames.
     // The icon is shown in a file upload control.
     virtual bool queryIconForFiles(const WebVector<WebString>& filenames, WebIconLoadingCompletion*) { return false; }
@@ -193,6 +190,7 @@
     virtual bool isSelectTrailingWhitespaceEnabled() { return true; }
 
     virtual void didBeginEditing() { }
+    virtual void didCancelCompositionOnSelectionChange() { }
     virtual void didChangeSelection(bool isSelectionEmpty) { }
     virtual void didChangeContents() { }
     virtual void didExecuteCommand(const WebString& commandName) { }
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebWidget.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebWidget.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebWidget.h	(working copy)
@@ -215,6 +215,10 @@
     // If the selection range is empty, it returns false.
     virtual bool selectionTextDirection(WebTextDirection& start, WebTextDirection& end) const { return false; }
 
+    // Returns true if the selection range is nonempty and its anchor is first
+    // (i.e its anchor is its start).
+    virtual bool isSelectionAnchorFirst() const { return false; }
+
     // Fetch the current selection range of this WebWidget. If there is no
     // selection, it will output a 0-length range with the location at the
     // caret. Returns true and fills the out-paramters on success; returns false
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebFrame.h	(working copy)
@@ -170,6 +170,9 @@
     // Returns true if the contents (minus scrollbars) has non-zero area.
     virtual bool hasVisibleContent() const = 0;
 
+    // Returns the visible content rect (minus scrollbars, in absolute coordinate)
+    virtual WebRect visibleContentRect() const = 0;
+
     virtual bool hasHorizontalScrollbar() const = 0;
     virtual bool hasVerticalScrollbar() const = 0;
 
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebInputEvent.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebInputEvent.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebInputEvent.h	(working copy)
@@ -405,23 +405,23 @@
     union {
         struct {
             int tapCount;
-            int width;
-            int height;
+            float width;
+            float height;
         } tap;
 
         struct {
-            int width;
-            int height;
+            float width;
+            float height;
         } tapDown;
 
         struct {
-            int width;
-            int height;
+            float width;
+            float height;
         } longPress;
 
         struct {
-            int firstFingerWidth;
-            int firstFingerHeight;
+            float firstFingerWidth;
+            float firstFingerHeight;
         } twoFingerTap;
 
         struct {
@@ -441,7 +441,7 @@
         struct {
             float scale;
         } pinchUpdate;
-    } data; 
+    } data;
 
     WebGestureEvent(unsigned sizeParam = sizeof(WebGestureEvent))
         : WebInputEvent(sizeParam)
@@ -450,7 +450,7 @@
         , globalX(0)
         , globalY(0)
     {
-      memset(&data, 0, sizeof(data)); 
+        memset(&data, 0, sizeof(data));
     }
 };
 
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebView.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebView.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebView.h	(working copy)
@@ -472,6 +472,7 @@
 
     virtual void setShowPaintRects(bool) = 0;
     virtual void setShowFPSCounter(bool) = 0;
+    virtual void setContinuousPaintingEnabled(bool) = 0;
 
     // Benchmarking support -------------------------------------------------
 
@@ -505,9 +506,6 @@
 
     // Testing functionality for TestRunner ---------------------------------
 
-    // Simulates a compositor lost context.
-    virtual void loseCompositorContext(int numTimes) = 0;
-
 protected:
     ~WebView() {}
 };
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebAutofillClient.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebAutofillClient.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebAutofillClient.h	(working copy)
@@ -90,8 +90,11 @@
     virtual void textFieldDidChange(const WebInputElement&) { }
     virtual void textFieldDidReceiveKeyDown(const WebInputElement&, const WebKeyboardEvent&) { }
 
+    // Informs the client whether or not any subsequent text changes should be ignored.
+    virtual void setIgnoreTextChanges(bool ignore) { }
+
 protected:
-    ~WebAutofillClient() { }
+    virtual ~WebAutofillClient() { }
 };
 
 } // namespace WebKit
Index: src/third_party/WebKit/Source/WebKit/chromium/public/WebWidgetClient.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/public/WebWidgetClient.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/public/WebWidgetClient.h	(working copy)
@@ -39,6 +39,7 @@
 
 namespace WebKit {
 
+class WebGestureEvent;
 class WebString;
 class WebWidget;
 struct WebCursorInfo;
@@ -163,6 +164,9 @@
     // Returns true iff the pointer is locked to this widget.
     virtual bool isPointerLocked() { return false; }
 
+    // Called when a gesture event is handled.
+    virtual void didHandleGestureEvent(const WebGestureEvent& event, bool eventCancelled) { }
+
 protected:
     ~WebWidgetClient() { }
 };
Index: src/third_party/WebKit/Source/WebKit/chromium/WebKit.gyp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/WebKit.gyp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/WebKit.gyp	(working copy)
@@ -447,6 +447,8 @@
                 'src/MediaPlayerPrivateChromium.cpp',
                 'src/NotificationPresenterImpl.h',
                 'src/NotificationPresenterImpl.cpp',
+                'src/painting/ContinuousPainter.h',
+                'src/painting/ContinuousPainter.cpp',
                 'src/painting/GraphicsContextBuilder.h',
                 'src/painting/PaintAggregator.h',
                 'src/painting/PaintAggregator.cpp',
Index: src/third_party/WebKit/Source/WebKit/chromium/src/EditorClientImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/EditorClientImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/EditorClientImpl.cpp	(working copy)
@@ -268,8 +268,11 @@
 void EditorClientImpl::respondToChangedSelection(Frame* frame)
 {
     if (m_webView->client()) {
-        if (frame)
+        if (frame) {
             m_webView->client()->didChangeSelection(!frame->selection()->isRange());
+            if (frame->editor()->cancelCompositionIfSelectionIsInvalid())
+                m_webView->client()->didCancelCompositionOnSelectionChange();
+        }
     }
 }
 
Index: src/third_party/WebKit/Source/WebKit/chromium/src/AssertMatchingEnums.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/AssertMatchingEnums.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/AssertMatchingEnums.cpp	(working copy)
@@ -464,6 +464,7 @@
 COMPILE_ASSERT_MATCHING_ENUM(WebSettings::EditingBehaviorMac, EditingMacBehavior);
 COMPILE_ASSERT_MATCHING_ENUM(WebSettings::EditingBehaviorWin, EditingWindowsBehavior);
 COMPILE_ASSERT_MATCHING_ENUM(WebSettings::EditingBehaviorUnix, EditingUnixBehavior);
+COMPILE_ASSERT_MATCHING_ENUM(WebSettings::EditingBehaviorAndroid, EditingAndroidBehavior);
 
 COMPILE_ASSERT_MATCHING_ENUM(WebTextAffinityUpstream, UPSTREAM);
 COMPILE_ASSERT_MATCHING_ENUM(WebTextAffinityDownstream, DOWNSTREAM);
Index: src/third_party/WebKit/Source/WebKit/chromium/src/InspectorClientImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/InspectorClientImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/InspectorClientImpl.cpp	(working copy)
@@ -172,6 +172,16 @@
     m_inspectedWebView->setShowFPSCounter(show);
 }
 
+bool InspectorClientImpl::canContinuouslyPaint()
+{
+    return true;
+}
+
+void InspectorClientImpl::setContinuousPaintingEnabled(bool enabled)
+{
+    m_inspectedWebView->setContinuousPaintingEnabled(enabled);
+}
+
 bool InspectorClientImpl::supportsFrameInstrumentation()
 {
     return true;
Index: src/third_party/WebKit/Source/WebKit/chromium/src/InspectorClientImpl.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/InspectorClientImpl.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/InspectorClientImpl.h	(working copy)
@@ -79,6 +79,9 @@
     virtual bool canShowFPSCounter();
     virtual void setShowFPSCounter(bool);
 
+    virtual bool canContinuouslyPaint();
+    virtual void setContinuousPaintingEnabled(bool);
+
     virtual bool supportsFrameInstrumentation();
 
     virtual void getAllocatedObjects(HashSet<const void*>&);
Index: src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlay.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlay.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlay.h	(working copy)
@@ -59,6 +59,8 @@
     void update();
     void paintWebFrame(WebCore::GraphicsContext&);
 
+    WebCore::GraphicsLayer* graphicsLayer() const { return m_layer.get(); }
+
 private:
     PageOverlay(WebViewImpl*, WebPageOverlay*);
     void invalidateWebFrame();
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebCompositorInputHandlerImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebCompositorInputHandlerImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebCompositorInputHandlerImpl.cpp	(working copy)
@@ -216,18 +216,18 @@
 
 WebCompositorInputHandlerImpl::EventDisposition WebCompositorInputHandlerImpl::handleGestureFling(const WebGestureEvent& gestureEvent)
 {
-    WebInputHandlerClient::ScrollStatus scrollStatus = m_inputHandlerClient->scrollBegin(WebPoint(gestureEvent.x, gestureEvent.y), WebInputHandlerClient::ScrollInputTypeGesture);
+    WebInputHandlerClient::ScrollStatus scrollStatus = m_inputHandlerClient->scrollBegin(WebPoint(gestureEvent.x, gestureEvent.y), WebInputHandlerClient::ScrollInputTypeNonBubblingGesture);
     switch (scrollStatus) {
     case WebInputHandlerClient::ScrollStatusStarted: {
-        if (gestureEvent.data.flingStart.sourceDevice == WebGestureEvent::Touchpad)
+        if (gestureEvent.sourceDevice == WebGestureEvent::Touchpad)
             m_inputHandlerClient->scrollEnd();
-        m_flingCurve = adoptPtr(Platform::current()->createFlingAnimationCurve(gestureEvent.data.flingStart.sourceDevice, WebFloatPoint(gestureEvent.data.flingStart.velocityX, gestureEvent.data.flingStart.velocityY), WebSize()));
+        m_flingCurve = adoptPtr(Platform::current()->createFlingAnimationCurve(gestureEvent.sourceDevice, WebFloatPoint(gestureEvent.data.flingStart.velocityX, gestureEvent.data.flingStart.velocityY), WebSize()));
         TRACE_EVENT_ASYNC_BEGIN0("webkit", "WebCompositorInputHandlerImpl::handleGestureFling::started", this);
         m_flingParameters.delta = WebFloatPoint(gestureEvent.data.flingStart.velocityX, gestureEvent.data.flingStart.velocityY);
         m_flingParameters.point = WebPoint(gestureEvent.x, gestureEvent.y);
         m_flingParameters.globalPoint = WebPoint(gestureEvent.globalX, gestureEvent.globalY);
         m_flingParameters.modifiers = gestureEvent.modifiers;
-        m_flingParameters.sourceDevice = gestureEvent.data.flingStart.sourceDevice;
+        m_flingParameters.sourceDevice = gestureEvent.sourceDevice;
         m_inputHandlerClient->scheduleAnimation();
         return DidHandle;
     }
@@ -238,7 +238,7 @@
     }
     case WebInputHandlerClient::ScrollStatusIgnored: {
         TRACE_EVENT_INSTANT0("webkit", "WebCompositorInputHandlerImpl::handleGestureFling::ignored");
-        if (gestureEvent.data.flingStart.sourceDevice == WebGestureEvent::Touchpad) {
+        if (gestureEvent.sourceDevice == WebGestureEvent::Touchpad) {
             // We still pass the curve to the main thread if there's nothing scrollable, in case something
             // registers a handler before the curve is over.
             return DidNotHandle;
Index: src/third_party/WebKit/Source/WebKit/chromium/src/ChromeClientImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/ChromeClientImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/ChromeClientImpl.cpp	(working copy)
@@ -95,6 +95,7 @@
 #include "WebPopupMenuInfo.h"
 #include "WebPopupType.h"
 #include "WebSettings.h"
+#include "WebSettingsImpl.h"
 #include "WebTextDirection.h"
 #include "WebViewClient.h"
 #include "WebViewImpl.h"
@@ -622,38 +623,38 @@
 void ChromeClientImpl::dispatchViewportPropertiesDidChange(const ViewportArguments& arguments) const
 {
 #if ENABLE(VIEWPORT)
-    if (!m_webView->settings()->viewportEnabled() || !m_webView->isFixedLayoutModeEnabled() || !m_webView->client() || !m_webView->page())
+    if (!m_webView->isFixedLayoutModeEnabled() || !m_webView->client() || !m_webView->page())
         return;
 
-    WebViewClient* client = m_webView->client();
-    WebSize deviceSize = m_webView->size();
-    // If the window size has not been set yet don't attempt to set the viewport
-    if (!deviceSize.width || !deviceSize.height)
+    IntSize viewportSize = m_webView->dipSize();
+    float deviceScaleFactor = m_webView->client()->screenInfo().deviceScaleFactor;
+
+    // If the window size has not been set yet don't attempt to set the viewport.
+    if (!viewportSize.width() || !viewportSize.height())
         return;
 
-    Settings* settings = m_webView->page()->settings();
-    float devicePixelRatio = client->screenInfo().deviceScaleFactor;
-    // Call the common viewport computing logic in ViewportArguments.cpp.
-    ViewportAttributes computed = computeViewportAttributes(
-        arguments, settings->layoutFallbackWidth(), deviceSize.width, deviceSize.height,
-        devicePixelRatio, IntSize(deviceSize.width, deviceSize.height));
-
+    ViewportAttributes computed;
+    if (m_webView->settings()->viewportEnabled()) {
+        computed = arguments.resolve(viewportSize, viewportSize, m_webView->page()->settings()->layoutFallbackWidth());
+    } else {
+        // If viewport tag is disabled but fixed layout is still enabled, (for
+        // example, on Android WebView with UseWideViewport false), compute
+        // based on the default viewport arguments.
+        computed = ViewportArguments().resolve(viewportSize, viewportSize, viewportSize.width());
+    }
     restrictScaleFactorToInitialScaleIfNotUserScalable(computed);
 
     if (m_webView->ignoreViewportTagMaximumScale()) {
         computed.maximumScale = max(computed.maximumScale, m_webView->maxPageScaleFactor);
         computed.userScalable = true;
     }
+    if (!m_webView->settingsImpl()->applyDeviceScaleFactorInCompositor())
+        computed.initialScale *= deviceScaleFactor;
 
-    int layoutWidth = computed.layoutSize.width();
-    int layoutHeight = computed.layoutSize.height();
-    m_webView->setFixedLayoutSize(IntSize(layoutWidth, layoutHeight));
-
-    bool needInitializePageScale = !m_webView->isPageScaleFactorSet();
-    m_webView->setDeviceScaleFactor(devicePixelRatio);
+    m_webView->setInitialPageScaleFactor(computed.initialScale);
+    m_webView->setFixedLayoutSize(flooredIntSize(computed.layoutSize));
+    m_webView->setDeviceScaleFactor(deviceScaleFactor);
     m_webView->setPageScaleFactorLimits(computed.minimumScale, computed.maximumScale);
-    if (needInitializePageScale)
-        m_webView->setPageScaleFactorPreservingScrollOffset(computed.initialScale * devicePixelRatio);
 #endif
 }
 
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.h	(working copy)
@@ -89,6 +89,7 @@
     virtual int contentsPreferredWidth() const;
     virtual int documentElementScrollHeight() const;
     virtual bool hasVisibleContent() const;
+    virtual WebRect visibleContentRect() const;
     virtual bool hasHorizontalScrollbar() const;
     virtual bool hasVerticalScrollbar() const;
     virtual WebView* view() const;
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebViewImpl.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebViewImpl.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebViewImpl.h	(working copy)
@@ -35,6 +35,7 @@
 #include "ContextMenuClientImpl.h"
 #include "DragClientImpl.h"
 #include "EditorClientImpl.h"
+#include "FloatSize.h"
 #include "GraphicsContext3D.h"
 #include "GraphicsLayer.h"
 #include "InspectorClientImpl.h"
@@ -64,6 +65,7 @@
 class ChromiumDataObject;
 class Color;
 class DocumentLoader;
+class FloatSize;
 class Frame;
 class GraphicsContext3D;
 class HistoryItem;
@@ -133,7 +135,7 @@
 
     // WebWidget methods:
     virtual void close();
-    virtual WebSize size() { return m_size; }
+    virtual WebSize size();
     virtual void willStartLiveResize();
     virtual void resize(const WebSize&);
     virtual void willEndLiveResize();
@@ -173,6 +175,7 @@
     virtual WebColor backgroundColor() const;
     virtual bool selectionBounds(WebRect& anchor, WebRect& focus) const;
     virtual bool selectionTextDirection(WebTextDirection& start, WebTextDirection& end) const;
+    virtual bool isSelectionAnchorFirst() const;
     virtual bool caretOrSelectionRange(size_t* location, size_t* length);
     virtual void setTextDirection(WebTextDirection direction);
     virtual bool isAcceleratedCompositingActive() const;
@@ -312,6 +315,7 @@
     virtual WebViewBenchmarkSupport* benchmarkSupport();
     virtual void setShowPaintRects(bool);
     virtual void setShowFPSCounter(bool);
+    virtual void setContinuousPaintingEnabled(bool);
 
     // WebLayerTreeViewClient
     virtual void willBeginFrame();
@@ -401,7 +405,7 @@
     void mouseDoubleClick(const WebMouseEvent&);
 
     bool detectContentOnTouch(const WebPoint&);
-    void startPageScaleAnimation(const WebCore::IntPoint& targetPosition, bool useAnchor, float newScale, double durationInSeconds);
+    bool startPageScaleAnimation(const WebCore::IntPoint& targetPosition, bool useAnchor, float newScale, double durationInSeconds);
 
     void numberOfWheelEventHandlersChanged(unsigned);
     void hasTouchEventHandlers(bool);
@@ -456,6 +460,10 @@
         return m_maxAutoSize;
     }
 
+    WebCore::IntSize dipSize() const;
+    WebCore::IntSize layoutSize() const;
+    WebCore::IntSize scaledSize(float) const;
+
     // Set the disposition for how this webview is to be initially shown.
     void setInitialNavigationPolicy(WebNavigationPolicy policy)
     {
@@ -477,6 +485,7 @@
         return m_emulatedTextZoomFactor;
     }
 
+    void setInitialPageScaleFactor(float initialPageScaleFactor) { m_initialPageScaleFactor = initialPageScaleFactor; }
     bool ignoreViewportTagMaximumScale() const { return m_ignoreViewportTagMaximumScale; }
 
     // Determines whether a page should e.g. be opened in a background tab.
@@ -569,15 +578,18 @@
 
 #if ENABLE(GESTURE_EVENTS)
     void computeScaleAndScrollForHitRect(const WebRect& hitRect, AutoZoomType, float& scale, WebPoint& scroll, bool& isAnchor);
-    WebCore::Node* bestTouchLinkNode(const WebGestureEvent& touchEvent);
-    void enableTouchHighlight(const WebGestureEvent& touchEvent);
+    WebCore::Node* bestTapNode(const WebCore::PlatformGestureEvent& tapEvent);
+    void enableTapHighlight(const WebCore::PlatformGestureEvent& tapEvent);
+    void computeScaleAndScrollForFocusedNode(WebCore::Node* focusedNode, float& scale, WebCore::IntPoint& scroll, bool& needAnimation);
 #endif
     void animateZoomAroundPoint(const WebCore::IntPoint&, AutoZoomType);
 
-    void shouldUseAnimateDoubleTapTimeZeroForTesting(bool);
+    void enableFakeDoubleTapAnimationForTesting(bool);
+    bool fakeDoubleTapAnimationPendingForTesting() const { return m_doubleTapZoomPending; }
+    WebCore::IntPoint fakeDoubleTapTargetPositionForTesting() const { return m_fakeDoubleTapTargetPosition; }
+    float fakeDoubleTapPageScaleFactorForTesting() const { return m_fakeDoubleTapPageScaleFactor; }
+    bool fakeDoubleTapUseAnchorForTesting() const { return m_fakeDoubleTapUseAnchor; }
 
-    void loseCompositorContext(int numTimes);
-
     void enterFullScreenForElement(WebCore::Element*);
     void exitFullScreenForElement(WebCore::Element*);
 
@@ -608,9 +620,10 @@
     WebSettingsImpl* settingsImpl();
 
 private:
-    bool computePageScaleFactorLimits();
+    void computePageScaleFactorLimits();
     float clampPageScaleFactorToLimits(float scale);
-    WebPoint clampOffsetAtScale(const WebPoint& offset, float scale);
+    WebCore::IntPoint clampOffsetAtScale(const WebCore::IntPoint& offset, float scale) const;
+    WebCore::IntSize contentsSize() const;
 
     void resetSavedScrollAndScaleState();
 
@@ -746,6 +759,7 @@
     float m_pageDefinedMaximumPageScaleFactor;
     float m_minimumPageScaleFactor;
     float m_maximumPageScaleFactor;
+    float m_initialPageScaleFactor;
     bool m_ignoreViewportTagMaximumScale;
     bool m_pageScaleFactorIsSet;
 
@@ -753,11 +767,16 @@
     float m_savedPageScaleFactor; // 0 means that no page scale factor is saved.
     WebCore::IntSize m_savedScrollOffset;
 
-    // Whether the current scale was achieved by zooming in with double tap.
-    bool m_doubleTapZoomInEffect;
+    // The scale moved to by the latest double tap zoom, if any.
+    float m_doubleTapZoomPageScaleFactor;
+    // Have we sent a double-tap zoom and not yet heard back the scale?
+    bool m_doubleTapZoomPending;
 
     // Used for testing purposes.
-    bool m_shouldUseDoubleTapTimeZero;
+    bool m_enableFakeDoubleTapAnimationForTesting;
+    WebCore::IntPoint m_fakeDoubleTapTargetPosition;
+    float m_fakeDoubleTapPageScaleFactor;
+    bool m_fakeDoubleTapUseAnchor;
 
     bool m_contextMenuAllowed;
 
@@ -851,7 +870,6 @@
     // If true, the graphics context is being restored.
     bool m_recreatingGraphicsContext;
     bool m_compositorSurfaceReady;
-    float m_deviceScaleInCompositor;
     int m_inputHandlerIdentifier;
 #endif
     static const WebInputEvent* m_currentInputEvent;
@@ -878,9 +896,10 @@
     OwnPtr<NavigatorContentUtilsClientImpl> m_navigatorContentUtilsClient;
 #endif
     OwnPtr<WebActiveGestureAnimation> m_gestureAnimation;
-    WebPoint m_lastWheelPosition;
-    WebPoint m_lastWheelGlobalPosition;
+    WebPoint m_positionOnFlingStart;
+    WebPoint m_globalPositionOnFlingStart;
     int m_flingModifier;
+    bool m_flingSourceDevice;
 #if ENABLE(GESTURE_EVENTS)
     OwnPtr<LinkHighlight> m_linkHighlight;
 #endif
@@ -890,6 +909,7 @@
 
     bool m_showFPSCounter;
     bool m_showPaintRects;
+    bool m_continuousPaintingEnabled;
 };
 
 } // namespace WebKit
Index: src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlayList.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlayList.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlayList.h	(working copy)
@@ -35,6 +35,7 @@
 
 namespace WebCore {
 class GraphicsContext;
+class GraphicsLayer;
 }
 
 namespace WebKit {
@@ -58,6 +59,8 @@
     void update();
     void paintWebFrame(WebCore::GraphicsContext&);
 
+    size_t findGraphicsLayer(WebCore::GraphicsLayer*);
+
 private:
     typedef Vector<OwnPtr<PageOverlay>, 2> PageOverlays;
 
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebPluginContainerImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebPluginContainerImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebPluginContainerImpl.cpp	(working copy)
@@ -833,14 +833,33 @@
     }
 }
 
+static inline bool gestureScrollHelper(ScrollbarGroup* scrollbarGroup, ScrollDirection positiveDirection, ScrollDirection negativeDirection, float delta)
+{
+    if (!delta)
+        return false;
+    float absDelta = delta > 0 ? delta : -delta;
+    return scrollbarGroup->scroll(delta < 0 ? negativeDirection : positiveDirection, ScrollByPrecisePixel, absDelta);
+}
+
 void WebPluginContainerImpl::handleGestureEvent(GestureEvent* event)
 {
     WebGestureEventBuilder webEvent(this, m_element->renderer(), *event);
     if (webEvent.type == WebInputEvent::Undefined)
         return;
     WebCursorInfo cursorInfo;
-    if (m_webPlugin->handleInputEvent(webEvent, cursorInfo))
+    if (m_webPlugin->handleInputEvent(webEvent, cursorInfo)) {
         event->setDefaultHandled();
+        return;
+    }
+
+    if (webEvent.type == WebInputEvent::GestureScrollUpdate) {
+        if (!m_scrollbarGroup)
+            return;
+        if (gestureScrollHelper(m_scrollbarGroup.get(), ScrollLeft, ScrollRight, webEvent.data.scrollUpdate.deltaX))
+            event->setDefaultHandled();
+        if (gestureScrollHelper(m_scrollbarGroup.get(), ScrollUp, ScrollDown, webEvent.data.scrollUpdate.deltaY))
+            event->setDefaultHandled();
+    }
     // FIXME: Can a plugin change the cursor from a touch-event callback?
 }
 
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebInputEventConversion.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebInputEventConversion.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebInputEventConversion.cpp	(working copy)
@@ -54,16 +54,29 @@
 
 static const double millisPerSecond = 1000.0;
 
+static float widgetScaleFactor(const Widget* widget)
+{
+    if (!widget)
+        return 1;
+
+    ScrollView* rootView = widget->root();
+    if (!rootView)
+        return 1;
+
+    return rootView->visibleContentScaleFactor();
+}
+
 // MakePlatformMouseEvent -----------------------------------------------------
 
 PlatformMouseEventBuilder::PlatformMouseEventBuilder(Widget* widget, const WebMouseEvent& e)
 {
+    float scale = widgetScaleFactor(widget);
     // FIXME: widget is always toplevel, unless it's a popup.  We may be able
     // to get rid of this once we abstract popups into a WebKit API.
-    m_position = widget->convertFromContainingWindow(IntPoint(e.x, e.y));
+    m_position = widget->convertFromContainingWindow(IntPoint(e.x / scale, e.y / scale));
     m_globalPosition = IntPoint(e.globalX, e.globalY);
 #if ENABLE(POINTER_LOCK)
-    m_movementDelta = IntPoint(e.movementX, e.movementY);
+    m_movementDelta = IntPoint(e.movementX / scale, e.movementY / scale);
 #endif
     m_button = static_cast<MouseButton>(e.button);
 
@@ -104,7 +117,8 @@
 
 PlatformWheelEventBuilder::PlatformWheelEventBuilder(Widget* widget, const WebMouseWheelEvent& e)
 {
-    m_position = widget->convertFromContainingWindow(IntPoint(e.x, e.y));
+    float scale = widgetScaleFactor(widget);
+    m_position = widget->convertFromContainingWindow(IntPoint(e.x / scale, e.y / scale));
     m_globalPosition = IntPoint(e.globalX, e.globalY);
     m_deltaX = e.deltaX;
     m_deltaY = e.deltaY;
@@ -141,6 +155,7 @@
 #if ENABLE(GESTURE_EVENTS)
 PlatformGestureEventBuilder::PlatformGestureEventBuilder(Widget* widget, const WebGestureEvent& e)
 {
+    float scale = widgetScaleFactor(widget);
     switch (e.type) {
     case WebInputEvent::GestureScrollBegin:
         m_type = PlatformEvent::GestureScrollBegin;
@@ -150,18 +165,18 @@
         break;
     case WebInputEvent::GestureScrollUpdate:
         m_type = PlatformEvent::GestureScrollUpdate;
-        m_deltaX = e.data.scrollUpdate.deltaX;
-        m_deltaY = e.data.scrollUpdate.deltaY;
+        m_deltaX = e.data.scrollUpdate.deltaX / scale;
+        m_deltaY = e.data.scrollUpdate.deltaY / scale;
         break;
     case WebInputEvent::GestureTap:
         m_type = PlatformEvent::GestureTap;
-        m_area = IntSize(e.data.tap.width, e.data.tap.height);
+        m_area = expandedIntSize(FloatSize(e.data.tap.width / scale, e.data.tap.height / scale));
         // FIXME: PlatformGestureEvent deltaX is overloaded - wkb.ug/93123
         m_deltaX = static_cast<int>(e.data.tap.tapCount);
         break;
     case WebInputEvent::GestureTapDown:
         m_type = PlatformEvent::GestureTapDown;
-        m_area = IntSize(e.data.tapDown.width, e.data.tapDown.height);
+        m_area = expandedIntSize(FloatSize(e.data.tapDown.width / scale, e.data.tapDown.height / scale));
         break;
     case WebInputEvent::GestureTapCancel:
         m_type = PlatformEvent::GestureTapDownCancel;
@@ -171,15 +186,15 @@
         break;
     case WebInputEvent::GestureTwoFingerTap:
         m_type = PlatformEvent::GestureTwoFingerTap;
-        m_area = IntSize(e.data.twoFingerTap.firstFingerWidth, e.data.twoFingerTap.firstFingerHeight);
+        m_area = expandedIntSize(FloatSize(e.data.twoFingerTap.firstFingerWidth / scale, e.data.twoFingerTap.firstFingerHeight / scale));
         break;
     case WebInputEvent::GestureLongPress:
         m_type = PlatformEvent::GestureLongPress;
-        m_area = IntSize(e.data.longPress.width, e.data.longPress.height);
+        m_area = expandedIntSize(FloatSize(e.data.longPress.width / scale, e.data.longPress.height / scale));
         break;
     case WebInputEvent::GestureLongTap:
         m_type = PlatformEvent::GestureLongTap;
-        m_area = IntSize(e.data.longPress.width, e.data.longPress.height);
+        m_area = expandedIntSize(FloatSize(e.data.longPress.width / scale, e.data.longPress.height / scale));
         break;
     case WebInputEvent::GesturePinchBegin:
         m_type = PlatformEvent::GesturePinchBegin;
@@ -195,7 +210,7 @@
     default:
         ASSERT_NOT_REACHED();
     }
-    m_position = widget->convertFromContainingWindow(IntPoint(e.x, e.y));
+    m_position = widget->convertFromContainingWindow(IntPoint(e.x / scale, e.y / scale));
     m_globalPosition = IntPoint(e.globalX, e.globalY);
     m_timestamp = e.timeStampSeconds;
 
@@ -357,12 +372,13 @@
 
 PlatformTouchPointBuilder::PlatformTouchPointBuilder(Widget* widget, const WebTouchPoint& point)
 {
+    float scale = widgetScaleFactor(widget);
     m_id = point.id;
     m_state = toPlatformTouchPointState(point.state);
-    m_pos = widget->convertFromContainingWindow(point.position);
+    m_pos = widget->convertFromContainingWindow(IntPoint(point.position.x / scale, point.position.y / scale));
     m_screenPos = point.screenPosition;
-    m_radiusY = point.radiusY;
-    m_radiusX = point.radiusX;
+    m_radiusY = point.radiusY / scale;
+    m_radiusX = point.radiusX / scale;
     m_rotationAngle = point.rotationAngle;
     m_force = point.force;
 }
@@ -412,7 +428,7 @@
     webEvent.timeStampSeconds = event.timeStamp() / millisPerSecond;
     webEvent.modifiers = getWebInputModifiers(event);
 
-    ScrollView* view = widget.parent();
+    ScrollView* view = widget.root();
     IntPoint windowPoint = view->contentsToWindow(IntPoint(event.absoluteLocation().x(), event.absoluteLocation().y()));
     webEvent.globalX = event.screenX();
     webEvent.globalY = event.screenY();
@@ -557,7 +573,7 @@
 
 #if ENABLE(TOUCH_EVENTS)
 
-static void addTouchPoints(const AtomicString& touchType, TouchList* touches, WebTouchPoint* touchPoints, unsigned* touchPointsLength, const WebCore::RenderObject* renderObject)
+static void addTouchPoints(const Widget* widget, const AtomicString& touchType, TouchList* touches, WebTouchPoint* touchPoints, unsigned* touchPointsLength, const WebCore::RenderObject* renderObject)
 {
     unsigned numberOfTouches = std::min(touches->length(), static_cast<unsigned>(WebTouchEvent::touchesLengthCap));
     for (unsigned i = 0; i < numberOfTouches; ++i) {
@@ -597,9 +613,9 @@
     modifiers = getWebInputModifiers(event);
     timeStampSeconds = event.timeStamp() / millisPerSecond;
 
-    addTouchPoints(event.type(), event.touches(), touches, &touchesLength, renderObject);
-    addTouchPoints(event.type(), event.changedTouches(), changedTouches, &changedTouchesLength, renderObject);
-    addTouchPoints(event.type(), event.targetTouches(), targetTouches, &targetTouchesLength, renderObject);
+    addTouchPoints(widget, event.type(), event.touches(), touches, &touchesLength, renderObject);
+    addTouchPoints(widget, event.type(), event.changedTouches(), changedTouches, &changedTouchesLength, renderObject);
+    addTouchPoints(widget, event.type(), event.targetTouches(), targetTouches, &targetTouchesLength, renderObject);
 }
 
 #endif // ENABLE(TOUCH_EVENTS)
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebFrameImpl.cpp	(working copy)
@@ -645,6 +645,11 @@
     return frame()->view()->visibleWidth() > 0 && frame()->view()->visibleHeight() > 0;
 }
 
+WebRect WebFrameImpl::visibleContentRect() const
+{
+    return frame()->view()->visibleContentRect();
+}
+
 bool WebFrameImpl::hasHorizontalScrollbar() const
 {
     return frame() && frame()->view() && frame()->view()->horizontalScrollbar();
@@ -1375,8 +1380,14 @@
 
 void WebFrameImpl::selectRange(const WebPoint& base, const WebPoint& extent)
 {
-    VisiblePosition basePosition = visiblePositionForWindowPoint(base);
-    VisiblePosition extentPosition = visiblePositionForWindowPoint(extent);
+    IntPoint unscaledBase = base;
+    IntPoint unscaledExtent = extent;
+    if (frame()->page()->settings()->applyPageScaleFactorInCompositor()) {
+        unscaledExtent.scale(1 / view()->pageScaleFactor(), 1 / view()->pageScaleFactor());
+        unscaledBase.scale(1 / view()->pageScaleFactor(), 1 / view()->pageScaleFactor());
+    }
+    VisiblePosition basePosition = visiblePositionForWindowPoint(unscaledBase);
+    VisiblePosition extentPosition = visiblePositionForWindowPoint(unscaledExtent);
     VisibleSelection newSelection = VisibleSelection(basePosition, extentPosition);
     if (frame()->selection()->shouldChangeSelection(newSelection))
         frame()->selection()->setSelection(newSelection, CharacterGranularity);
@@ -1390,8 +1401,15 @@
 
 void WebFrameImpl::moveCaretSelectionTowardsWindowPoint(const WebPoint& point)
 {
+    IntPoint unscaledPoint(point);
+    if (frame()->page()->settings()->applyPageScaleFactorInCompositor())
+        unscaledPoint.scale(1 / view()->pageScaleFactor(), 1 / view()->pageScaleFactor());
+
     Element* editable = frame()->selection()->rootEditableElement();
-    IntPoint contentsPoint = frame()->view()->windowToContents(IntPoint(point));
+    if (!editable)
+        return;
+
+    IntPoint contentsPoint = frame()->view()->windowToContents(unscaledPoint);
     LayoutPoint localPoint(editable->convertFromPage(contentsPoint));
     VisiblePosition position = editable->renderer()->positionForPoint(localPoint);
     if (frame()->selection()->shouldChangeSelection(position))
Index: src/third_party/WebKit/Source/WebKit/chromium/src/WebViewImpl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/WebViewImpl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/WebViewImpl.cpp	(working copy)
@@ -143,6 +143,7 @@
 #include "WebTextInputInfo.h"
 #include "WebViewClient.h"
 #include "WheelEvent.h"
+#include "painting/ContinuousPainter.h"
 #include "painting/GraphicsContextBuilder.h"
 #include "src/WebActiveGestureAnimation.h"
 #include <public/Platform.h>
@@ -396,11 +397,15 @@
     , m_pageDefinedMaximumPageScaleFactor(-1)
     , m_minimumPageScaleFactor(minPageScaleFactor)
     , m_maximumPageScaleFactor(maxPageScaleFactor)
+    , m_initialPageScaleFactor(-1)
     , m_ignoreViewportTagMaximumScale(false)
     , m_pageScaleFactorIsSet(false)
     , m_savedPageScaleFactor(0)
-    , m_doubleTapZoomInEffect(false)
-    , m_shouldUseDoubleTapTimeZero(false)
+    , m_doubleTapZoomPageScaleFactor(0)
+    , m_doubleTapZoomPending(false)
+    , m_enableFakeDoubleTapAnimationForTesting(false)
+    , m_fakeDoubleTapPageScaleFactor(0)
+    , m_fakeDoubleTapUseAnchor(false)
     , m_contextMenuAllowed(false)
     , m_doingDragAndDrop(false)
     , m_ignoreInputEvents(false)
@@ -427,7 +432,6 @@
     , m_compositorCreationFailed(false)
     , m_recreatingGraphicsContext(false)
     , m_compositorSurfaceReady(false)
-    , m_deviceScaleInCompositor(1)
     , m_inputHandlerIdentifier(-1)
 #endif
 #if ENABLE(INPUT_SPEECH)
@@ -449,10 +453,12 @@
     , m_navigatorContentUtilsClient(NavigatorContentUtilsClientImpl::create(this))
 #endif
     , m_flingModifier(0)
+    , m_flingSourceDevice(false)
     , m_validationMessage(ValidationMessageClientImpl::create(*client))
     , m_suppressInvalidations(false)
     , m_showFPSCounter(false)
     , m_showPaintRects(false)
+    , m_continuousPaintingEnabled(false)
 {
     // WebKit/win/WebView.cpp does the same thing, except they call the
     // KJS specific wrapper around this method. We need to have threading
@@ -651,29 +657,83 @@
 
 void WebViewImpl::scrollBy(const WebPoint& delta)
 {
-    WebMouseWheelEvent syntheticWheel;
-    const float tickDivisor = WebCore::WheelEvent::tickMultiplier;
+    if (m_flingSourceDevice == WebGestureEvent::Touchpad) {
+        WebMouseWheelEvent syntheticWheel;
+        const float tickDivisor = WebCore::WheelEvent::tickMultiplier;
 
-    syntheticWheel.deltaX = delta.x;
-    syntheticWheel.deltaY = delta.y;
-    syntheticWheel.wheelTicksX = delta.x / tickDivisor;
-    syntheticWheel.wheelTicksY = delta.y / tickDivisor;
-    syntheticWheel.hasPreciseScrollingDeltas = true;
-    syntheticWheel.x = m_lastWheelPosition.x;
-    syntheticWheel.y = m_lastWheelPosition.y;
-    syntheticWheel.globalX = m_lastWheelGlobalPosition.x;
-    syntheticWheel.globalY = m_lastWheelGlobalPosition.y;
-    syntheticWheel.modifiers = m_flingModifier;
+        syntheticWheel.deltaX = delta.x;
+        syntheticWheel.deltaY = delta.y;
+        syntheticWheel.wheelTicksX = delta.x / tickDivisor;
+        syntheticWheel.wheelTicksY = delta.y / tickDivisor;
+        syntheticWheel.hasPreciseScrollingDeltas = true;
+        syntheticWheel.x = m_positionOnFlingStart.x;
+        syntheticWheel.y = m_positionOnFlingStart.y;
+        syntheticWheel.globalX = m_globalPositionOnFlingStart.x;
+        syntheticWheel.globalY = m_globalPositionOnFlingStart.y;
+        syntheticWheel.modifiers = m_flingModifier;
 
-    if (m_page && m_page->mainFrame() && m_page->mainFrame()->view())
-        handleMouseWheel(*m_page->mainFrame(), syntheticWheel);
+        if (m_page && m_page->mainFrame() && m_page->mainFrame()->view())
+            handleMouseWheel(*m_page->mainFrame(), syntheticWheel);
+    } else {
+        WebGestureEvent syntheticGestureEvent;
+
+        syntheticGestureEvent.type = WebInputEvent::GestureScrollUpdate;
+        syntheticGestureEvent.data.scrollUpdate.deltaX = delta.x;
+        syntheticGestureEvent.data.scrollUpdate.deltaY = delta.y;
+        syntheticGestureEvent.x = m_positionOnFlingStart.x;
+        syntheticGestureEvent.y = m_positionOnFlingStart.y;
+        syntheticGestureEvent.globalX = m_globalPositionOnFlingStart.x;
+        syntheticGestureEvent.globalY = m_globalPositionOnFlingStart.y;
+        syntheticGestureEvent.modifiers = m_flingModifier;
+        syntheticGestureEvent.sourceDevice = WebGestureEvent::Touchscreen;
+
+        if (m_page && m_page->mainFrame() && m_page->mainFrame()->view())
+            handleGestureEvent(syntheticGestureEvent);
+    }
 }
 
 #if ENABLE(GESTURE_EVENTS)
 bool WebViewImpl::handleGestureEvent(const WebGestureEvent& event)
 {
     bool eventSwallowed = false;
+    bool eventCancelled = false; // for disambiguation
 
+    // Special handling for slow-path fling gestures, which have no PlatformGestureEvent equivalent.
+    switch (event.type) {
+    case WebInputEvent::GestureFlingStart: {
+        if (mainFrameImpl()->frame()->eventHandler()->isScrollbarHandlingGestures()) {
+            m_client->didHandleGestureEvent(event, eventCancelled);
+            return eventSwallowed;
+        }
+        m_client->cancelScheduledContentIntents();
+        m_positionOnFlingStart = WebPoint(event.x / pageScaleFactor(), event.y / pageScaleFactor());
+        m_globalPositionOnFlingStart = WebPoint(event.globalX, event.globalY);
+        m_flingModifier = event.modifiers;
+        m_flingSourceDevice = event.sourceDevice;
+        OwnPtr<WebGestureCurve> flingCurve = adoptPtr(Platform::current()->createFlingAnimationCurve(event.sourceDevice, WebFloatPoint(event.data.flingStart.velocityX, event.data.flingStart.velocityY), WebSize()));
+        m_gestureAnimation = WebActiveGestureAnimation::createAtAnimationStart(flingCurve.release(), this);
+        scheduleAnimation();
+        eventSwallowed = true;
+
+        m_client->didHandleGestureEvent(event, eventCancelled);
+        return eventSwallowed;
+    }
+    case WebInputEvent::GestureFlingCancel:
+        if (m_gestureAnimation) {
+            m_gestureAnimation.clear();
+            if (m_layerTreeView)
+                m_layerTreeView->didStopFlinging();
+            eventSwallowed = true;
+        }
+
+        m_client->didHandleGestureEvent(event, eventCancelled);
+        return eventSwallowed;
+    default:
+        break;
+    }
+
+    PlatformGestureEventBuilder platformEvent(mainFrameImpl()->frameView(), event);
+
     // Handle link highlighting outside the main switch to avoid getting lost in the
     // complicated set of cases handled below.
     switch (event.type) {
@@ -681,7 +741,7 @@
         // Queue a highlight animation, then hand off to regular handler.
 #if OS(LINUX)
         if (settingsImpl()->gestureTapHighlightEnabled())
-            enableTouchHighlight(event);
+            enableTapHighlight(platformEvent);
 #endif
         break;
     case WebInputEvent::GestureTapCancel:
@@ -695,30 +755,9 @@
     }
 
     switch (event.type) {
-    case WebInputEvent::GestureFlingStart: {
-        if (mainFrameImpl()->frame()->eventHandler()->isScrollbarHandlingGestures())
-            break;
-        m_client->cancelScheduledContentIntents();
-        m_lastWheelPosition = WebPoint(event.x, event.y);
-        m_lastWheelGlobalPosition = WebPoint(event.globalX, event.globalY);
-        m_flingModifier = event.modifiers;
-        OwnPtr<WebGestureCurve> flingCurve = adoptPtr(Platform::current()->createFlingAnimationCurve(event.data.flingStart.sourceDevice, WebFloatPoint(event.data.flingStart.velocityX, event.data.flingStart.velocityY), WebSize()));
-        m_gestureAnimation = WebActiveGestureAnimation::createAtAnimationStart(flingCurve.release(), this);
-        scheduleAnimation();
-        eventSwallowed = true;
-        break;
-    }
-    case WebInputEvent::GestureFlingCancel:
-        if (m_gestureAnimation) {
-            m_gestureAnimation.clear();
-            if (m_layerTreeView)
-                m_layerTreeView->didStopFlinging();
-            eventSwallowed = true;
-        }
-        break;
     case WebInputEvent::GestureTap: {
         m_client->cancelScheduledContentIntents();
-        if (detectContentOnTouch(WebPoint(event.x, event.y))) {
+        if (detectContentOnTouch(platformEvent.position())) {
             eventSwallowed = true;
             break;
         }
@@ -731,18 +770,25 @@
         // Don't trigger a disambiguation popup on sites designed for mobile devices.
         // Instead, assume that the page has been designed with big enough buttons and links.
         if (event.data.tap.width > 0 && !shouldDisableDesktopWorkarounds()) {
-            IntRect boundingBox(event.x - event.data.tap.width / 2, event.y - event.data.tap.height / 2, event.data.tap.width, event.data.tap.height);
+            // FIXME: didTapMultipleTargets should just take a rect instead of
+            // an event.
+            WebGestureEvent scaledEvent = event;
+            scaledEvent.x = event.x / pageScaleFactor();
+            scaledEvent.y = event.y / pageScaleFactor();
+            scaledEvent.data.tap.width = event.data.tap.width / pageScaleFactor();
+            scaledEvent.data.tap.height = event.data.tap.height / pageScaleFactor();
+            IntRect boundingBox(scaledEvent.x - scaledEvent.data.tap.width / 2, scaledEvent.y - scaledEvent.data.tap.height / 2, scaledEvent.data.tap.width, scaledEvent.data.tap.height);
             Vector<IntRect> goodTargets;
-            findGoodTouchTargets(boundingBox, mainFrameImpl()->frame(), pageScaleFactor(), goodTargets);
+            findGoodTouchTargets(boundingBox, mainFrameImpl()->frame(), goodTargets);
             // FIXME: replace touch adjustment code when numberOfGoodTargets == 1?
             // Single candidate case is currently handled by: https://bugs.webkit.org/show_bug.cgi?id=85101
-            if (goodTargets.size() >= 2 && m_client && m_client->didTapMultipleTargets(event, goodTargets)) {
+            if (goodTargets.size() >= 2 && m_client && m_client->didTapMultipleTargets(scaledEvent, goodTargets)) {
                 eventSwallowed = true;
+                eventCancelled = true;
                 break;
             }
         }
 
-        PlatformGestureEventBuilder platformEvent(mainFrameImpl()->frameView(), event);
         eventSwallowed = mainFrameImpl()->frame()->eventHandler()->handleGestureEvent(platformEvent);
 
         if (m_selectPopup && m_selectPopup == selectPopup) {
@@ -764,7 +810,6 @@
         m_client->cancelScheduledContentIntents();
         m_page->contextMenuController()->clearContextMenu();
         m_contextMenuAllowed = true;
-        PlatformGestureEventBuilder platformEvent(mainFrameImpl()->frameView(), event);
         eventSwallowed = mainFrameImpl()->frame()->eventHandler()->handleGestureEvent(platformEvent);
         m_contextMenuAllowed = false;
 
@@ -772,14 +817,13 @@
     }
     case WebInputEvent::GestureTapDown: {
         m_client->cancelScheduledContentIntents();
-        PlatformGestureEventBuilder platformEvent(mainFrameImpl()->frameView(), event);
         eventSwallowed = mainFrameImpl()->frame()->eventHandler()->handleGestureEvent(platformEvent);
         break;
     }
     case WebInputEvent::GestureDoubleTap:
         if (m_webSettings->doubleTapToZoomEnabled() && m_minimumPageScaleFactor != m_maximumPageScaleFactor) {
             m_client->cancelScheduledContentIntents();
-            animateZoomAroundPoint(WebPoint(event.x, event.y), DoubleTap);
+            animateZoomAroundPoint(platformEvent.position(), DoubleTap);
             eventSwallowed = true;
             break;
         }
@@ -791,14 +835,13 @@
     case WebInputEvent::GestureTapCancel:
     case WebInputEvent::GesturePinchEnd:
     case WebInputEvent::GesturePinchUpdate: {
-        PlatformGestureEventBuilder platformEvent(mainFrameImpl()->frameView(), event);
         eventSwallowed = mainFrameImpl()->frame()->eventHandler()->handleGestureEvent(platformEvent);
         break;
     }
     default:
         ASSERT_NOT_REACHED();
     }
-    m_client->didHandleGestureEvent(event, eventSwallowed);
+    m_client->didHandleGestureEvent(event, eventCancelled);
     return eventSwallowed;
 }
 
@@ -806,8 +849,8 @@
 {
     TRACE_EVENT0("webkit", "WebViewImpl::transferActiveWheelFlingAnimation");
     ASSERT(!m_gestureAnimation);
-    m_lastWheelPosition = parameters.point;
-    m_lastWheelGlobalPosition = parameters.globalPoint;
+    m_positionOnFlingStart = parameters.point;
+    m_globalPositionOnFlingStart = parameters.globalPoint;
     m_flingModifier = parameters.modifiers;
     OwnPtr<WebGestureCurve> curve = adoptPtr(Platform::current()->createFlingAnimationCurve(parameters.sourceDevice, WebFloatPoint(parameters.delta), parameters.cumulativeScroll));
     m_gestureAnimation = WebActiveGestureAnimation::createWithTimeOffset(curve.release(), this, parameters.startTime);
@@ -820,20 +863,35 @@
         m_layerTreeView->renderingStats(stats);
 }
 
-void WebViewImpl::startPageScaleAnimation(const IntPoint& targetPosition, bool useAnchor, float newScale, double durationInSeconds)
+bool WebViewImpl::startPageScaleAnimation(const IntPoint& targetPosition, bool useAnchor, float newScale, double durationInSeconds)
 {
     WebPoint clampedPoint = targetPosition;
-    if (!useAnchor)
+    if (!useAnchor) {
         clampedPoint = clampOffsetAtScale(targetPosition, newScale);
-    if ((!durationInSeconds && !useAnchor) || m_shouldUseDoubleTapTimeZero) {
-        setPageScaleFactor(newScale, clampedPoint);
-        return;
+        if (!durationInSeconds) {
+            setPageScaleFactor(newScale, clampedPoint);
+            return false;
+        }
     }
-    if (!m_layerTreeView)
-        return;
+    if (useAnchor && newScale == pageScaleFactor())
+        return false;
 
-    m_layerTreeView->startPageScaleAnimation(targetPosition, useAnchor, newScale, durationInSeconds);
+    if (m_enableFakeDoubleTapAnimationForTesting) {
+        m_fakeDoubleTapTargetPosition = targetPosition;
+        m_fakeDoubleTapUseAnchor = useAnchor;
+        m_fakeDoubleTapPageScaleFactor = newScale;
+    } else {
+        if (!m_layerTreeView)
+            return false;
+        m_layerTreeView->startPageScaleAnimation(targetPosition, useAnchor, newScale, durationInSeconds);
+    }
+    return true;
 }
+
+void WebViewImpl::enableFakeDoubleTapAnimationForTesting(bool enable)
+{
+    m_enableFakeDoubleTapAnimationForTesting = enable;
+}
 #endif
 
 WebViewBenchmarkSupport* WebViewImpl::benchmarkSupport()
@@ -859,6 +917,15 @@
     m_showPaintRects = show;
 }
 
+void WebViewImpl::setContinuousPaintingEnabled(bool enabled)
+{
+    if (isAcceleratedCompositingActive()) {
+        TRACE_EVENT0("webkit", "WebViewImpl::setContinuousPaintingEnabled");
+        m_layerTreeView->setContinuousPaintingEnabled(enabled);
+    }
+    m_continuousPaintingEnabled = enabled;
+}
+
 bool WebViewImpl::handleKeyEvent(const WebKeyboardEvent& event)
 {
     ASSERT((event.type == WebInputEvent::RawKeyDown)
@@ -1101,11 +1168,6 @@
     return WebRect(newX, source.y, newWidth, source.height);
 }
 
-void WebViewImpl::shouldUseAnimateDoubleTapTimeZeroForTesting(bool setToZero)
-{
-    m_shouldUseDoubleTapTimeZero = setToZero;
-}
-
 void WebViewImpl::computeScaleAndScrollForHitRect(const WebRect& hitRect, AutoZoomType zoomType, float& scale, WebPoint& scroll, bool& isAnchor)
 {
     scale = pageScaleFactor();
@@ -1129,7 +1191,7 @@
         // (after double tap, find in page, etc), though the user should still
         // be allowed to manually pinch zoom in further if they desire.
         const float defaultScaleWhenAlreadyLegible = m_minimumPageScaleFactor * doubleTapZoomAlreadyLegibleRatio;
-        float legibleScale = deviceScaleFactor();
+        float legibleScale = settingsImpl()->applyDeviceScaleFactorInCompositor() ? 1 : deviceScaleFactor();
 #if ENABLE(TEXT_AUTOSIZING)
         if (page() && page()->settings())
             legibleScale *= page()->settings()->textAutosizingFontScaleFactor();
@@ -1137,8 +1199,12 @@
         if (legibleScale < defaultScaleWhenAlreadyLegible)
             legibleScale = (scale == m_minimumPageScaleFactor) ? defaultScaleWhenAlreadyLegible : m_minimumPageScaleFactor;
 
-        const float defaultMargin = doubleTapZoomContentDefaultMargin * deviceScaleFactor();
-        const float minimumMargin = doubleTapZoomContentMinimumMargin * deviceScaleFactor();
+        float defaultMargin = doubleTapZoomContentDefaultMargin;
+        float minimumMargin = doubleTapZoomContentMinimumMargin;
+        if (!settingsImpl()->applyDeviceScaleFactorInCompositor()) {
+            defaultMargin *= deviceScaleFactor();
+            minimumMargin *= deviceScaleFactor();
+        }
         // We want the margins to have the same physical size, which means we
         // need to express them in post-scale size. To do that we'd need to know
         // the scale we're scaling to, but that depends on the margins. Instead
@@ -1149,24 +1215,25 @@
                 static_cast<int>(defaultMargin * rect.width / m_size.width),
                 static_cast<int>(minimumMargin * rect.width / m_size.width));
         // Fit block to screen, respecting limits.
-        scale *= static_cast<float>(m_size.width) / rect.width;
+        if (settingsImpl()->applyPageScaleFactorInCompositor())
+            scale = static_cast<float>(m_size.width) / rect.width;
+        else
+            scale *= static_cast<float>(m_size.width) / rect.width;
         scale = min(scale, legibleScale);
         scale = clampPageScaleFactorToLimits(scale);
 
         scaleUnchanged = fabs(pageScaleFactor() - scale) < minScaleDifference;
     }
 
-    if (zoomType == DoubleTap && (rect.isEmpty() || scaleUnchanged || m_doubleTapZoomInEffect)) {
+    bool stillAtPreviousDoubleTapScale = (pageScaleFactor() == m_doubleTapZoomPageScaleFactor
+        && m_doubleTapZoomPageScaleFactor != m_minimumPageScaleFactor)
+        || m_doubleTapZoomPending;
+    if (zoomType == DoubleTap && (rect.isEmpty() || scaleUnchanged || stillAtPreviousDoubleTapScale)) {
         // Zoom out to minimum scale.
         scale = m_minimumPageScaleFactor;
         scroll = WebPoint(hitRect.x, hitRect.y);
         isAnchor = true;
-        m_doubleTapZoomInEffect = false;
     } else {
-        if (zoomType == DoubleTap && scale != m_minimumPageScaleFactor)
-            m_doubleTapZoomInEffect = true;
-        else
-            m_doubleTapZoomInEffect = false;
         // FIXME: If this is being called for auto zoom during find in page,
         // then if the user manually zooms in it'd be nice to preserve the
         // relative increase in zoom they caused (if they zoom out then it's ok
@@ -1174,8 +1241,12 @@
         // double-tap zoom strategy (fitting the containing block to the screen)
         // though.
 
-        float screenHeight = m_size.height / scale * pageScaleFactor();
-        float screenWidth = m_size.width / scale * pageScaleFactor();
+        float screenHeight = m_size.height / scale;
+        float screenWidth = m_size.width / scale;
+        if (!settingsImpl()->applyPageScaleFactorInCompositor()) {
+            screenHeight *= pageScaleFactor();
+            screenWidth *= pageScaleFactor();
+        }
 
         // Scroll to vertically align the block.
         if (rect.height < screenHeight) {
@@ -1199,8 +1270,10 @@
 
     scale = clampPageScaleFactorToLimits(scale);
     scroll = mainFrameImpl()->frameView()->windowToContents(scroll);
-    float scaleDelta = scale / pageScaleFactor();
-    scroll = WebPoint(scroll.x * scaleDelta, scroll.y * scaleDelta);
+    if (!settingsImpl()->applyPageScaleFactorInCompositor()) {
+        float scaleDelta = scale / pageScaleFactor();
+        scroll = WebPoint(scroll.x * scaleDelta, scroll.y * scaleDelta);
+    }
     if (!isAnchor)
         scroll = clampOffsetAtScale(scroll, scale);
 }
@@ -1215,36 +1288,41 @@
         || (cursor == CURSOR_AUTO && frame->eventHandler()->useHandCursor(node, node->isLink(), shiftKey));
 }
 
-Node* WebViewImpl::bestTouchLinkNode(const WebGestureEvent& touchEvent)
+Node* WebViewImpl::bestTapNode(const PlatformGestureEvent& tapEvent)
 {
     if (!m_page || !m_page->mainFrame())
         return 0;
 
     Node* bestTouchNode = 0;
 
-    // FIXME: Should accept a search region from the caller instead of hard-coding the size.
-    IntSize touchEventSearchRegionSize(4, 2);
-    IntPoint touchEventLocation(touchEvent.x, touchEvent.y);
-    m_page->mainFrame()->eventHandler()->bestClickableNodeForTouchPoint(touchEventLocation, touchEventSearchRegionSize, touchEventLocation, bestTouchNode);
-    // bestClickableNodeForTouchPoint() doesn't always return a node that is a link, so let's try and find
-    // a link to highlight.
-    bool shiftKey = touchEvent.modifiers & WebGestureEvent::ShiftKey;
-    while (bestTouchNode && !invokesHandCursor(bestTouchNode, shiftKey, m_page->mainFrame()))
+    IntPoint touchEventLocation(tapEvent.position());
+#if ENABLE(TOUCH_ADJUSTMENT)
+    m_page->mainFrame()->eventHandler()->adjustGesturePosition(tapEvent, touchEventLocation);
+#endif
+
+    IntPoint hitTestPoint = m_page->mainFrame()->view()->windowToContents(touchEventLocation);
+    HitTestResult result = m_page->mainFrame()->eventHandler()->hitTestResultAtPoint(
+        hitTestPoint, false, false, DontHitTestScrollbars, HitTestRequest::TouchEvent);
+    bestTouchNode = result.targetNode();
+
+    // Make sure our highlight candidate uses a hand cursor as a heuristic to
+    // choose appropriate targets.
+    while (bestTouchNode && !invokesHandCursor(bestTouchNode, false, m_page->mainFrame()))
         bestTouchNode = bestTouchNode->parentNode();
 
     // We should pick the largest enclosing node with hand cursor set.
-    while (bestTouchNode && bestTouchNode->parentNode() && invokesHandCursor(bestTouchNode->parentNode(), shiftKey, m_page->mainFrame()))
+    while (bestTouchNode && bestTouchNode->parentNode() && invokesHandCursor(bestTouchNode->parentNode(), false, m_page->mainFrame()))
         bestTouchNode = bestTouchNode->parentNode();
 
     return bestTouchNode;
 }
 
-void WebViewImpl::enableTouchHighlight(const WebGestureEvent& touchEvent)
+void WebViewImpl::enableTapHighlight(const PlatformGestureEvent& tapEvent)
 {
     // Always clear any existing highlight when this is invoked, even if we don't get a new target to highlight.
     m_linkHighlight.clear();
 
-    Node* touchNode = bestTouchLinkNode(touchEvent);
+    Node* touchNode = bestTapNode(tapEvent);
 
     if (!touchNode || !touchNode->renderer() || !touchNode->renderer()->enclosingLayer())
         return;
@@ -1274,8 +1352,13 @@
     computeScaleAndScrollForHitRect(WebRect(webPoint.x, webPoint.y, 0, 0), zoomType, scale, scroll, isAnchor);
 
     bool isDoubleTap = (zoomType == DoubleTap);
-    double durationInSeconds = (isDoubleTap && !m_shouldUseDoubleTapTimeZero) ? doubleTapZoomAnimationDurationInSeconds : 0;
-    startPageScaleAnimation(scroll, isAnchor, scale, durationInSeconds);
+    double durationInSeconds = isDoubleTap ? doubleTapZoomAnimationDurationInSeconds : 0;
+    bool isAnimating = startPageScaleAnimation(scroll, isAnchor, scale, durationInSeconds);
+
+    if (isDoubleTap && isAnimating) {
+        m_doubleTapZoomPageScaleFactor = scale;
+        m_doubleTapZoomPending = true;
+    }
 #endif
 }
 
@@ -1298,6 +1381,7 @@
 
 bool WebViewImpl::hasTouchEventHandlersAt(const WebPoint& point)
 {
+    // FIXME: Implement this. Note that the point must be divided by pageScaleFactor.
     return true;
 }
 
@@ -1571,6 +1655,18 @@
         pluginContainer->willStartLiveResize();
 }
 
+IntSize WebViewImpl::scaledSize(float pageScaleFactor) const
+{
+    FloatSize scaledSize = dipSize();
+    scaledSize.scale(1 / pageScaleFactor);
+    return expandedIntSize(scaledSize);
+}
+
+WebSize WebViewImpl::size()
+{
+    return m_size;
+}
+
 void WebViewImpl::resize(const WebSize& newSize)
 {
     if (m_shouldAutoResize || m_size == newSize)
@@ -1588,18 +1684,8 @@
     m_size = newSize;
 
 #if ENABLE(VIEWPORT)
-    if (settings()->viewportEnabled()) {
-        // Fallback width is used to layout sites designed for desktop. The
-        // conventional size used by all mobile browsers is 980. When a mobile
-        // device has a particularly wide screen (such as a 10" tablet held in
-        // landscape), it can be larger.
-        const int standardFallbackWidth = 980;
-        int dpiIndependentViewportWidth = newSize.width / page()->deviceScaleFactor();
-        settings()->setLayoutFallbackWidth(std::max(standardFallbackWidth, dpiIndependentViewportWidth));
-
-        ViewportArguments viewportArguments = mainFrameImpl()->frame()->document()->viewportArguments();
-        m_page->chrome()->client()->dispatchViewportPropertiesDidChange(viewportArguments);
-    }
+    ViewportArguments viewportArguments = mainFrameImpl()->frame()->document()->viewportArguments();
+    m_page->chrome()->client()->dispatchViewportPropertiesDidChange(viewportArguments);
 #endif
 
     WebDevToolsAgentPrivate* agentPrivate = devToolsAgentPrivate();
@@ -1608,15 +1694,15 @@
     if (!agentPrivate || !agentPrivate->metricsOverridden()) {
         WebFrameImpl* webFrame = mainFrameImpl();
         if (webFrame->frameView())
-            webFrame->frameView()->resize(newSize.width, newSize.height);
+            webFrame->frameView()->resize(m_size);
     }
 
 #if ENABLE(VIEWPORT)
     if (settings()->viewportEnabled()) {
-        // Relayout immediately to obtain the new content width, which is needed
-        // to calculate the minimum scale limit.
-        view->layout();
-        computePageScaleFactorLimits();
+        // Relayout immediately to recalculate the minimum scale limit.
+        if (view->needsLayout())
+            view->layout();
+
         // When the device rotates:
         // - If the page width is unchanged, then zoom by new width/old width
         //   such as to keep the same content horizontally onscreen.
@@ -1632,7 +1718,8 @@
         float scaleMultiplier = viewportWidthRatio / fixedLayoutWidthRatio;
         if (scaleMultiplier != 1) {
             IntSize scrollOffsetAtNewScale = oldScrollOffset;
-            scrollOffsetAtNewScale.scale(scaleMultiplier);
+            if (!settingsImpl()->applyPageScaleFactorInCompositor())
+                scrollOffsetAtNewScale.scale(scaleMultiplier);
             setPageScaleFactor(oldPageScaleFactor * scaleMultiplier, IntPoint(scrollOffsetAtNewScale));
         }
     }
@@ -1769,6 +1856,9 @@
 void WebViewImpl::didBeginFrame()
 {
     InspectorInstrumentation::didComposite(m_page.get());
+
+    if (m_continuousPaintingEnabled)
+        ContinuousPainter::setNeedsDisplayRecursive(m_rootGraphicsLayer, m_pageOverlays.get());
 }
 
 void WebViewImpl::updateAnimations(double monotonicFrameBeginTime)
@@ -1929,14 +2019,6 @@
     return false;
 }
 
-void WebViewImpl::loseCompositorContext(int numTimes)
-{
-#if USE(ACCELERATED_COMPOSITING)
-    if (m_layerTreeView)
-        m_layerTreeView->loseCompositorContext(numTimes);
-#endif
-}
-
 void WebViewImpl::enterFullScreenForElement(WebCore::Element* element)
 {
     // We are already transitioning to fullscreen for a different element.
@@ -2050,30 +2132,7 @@
         return true;
     }
 
-    if (!m_layerTreeView)
-        return PageWidgetDelegate::handleInputEvent(m_page.get(), *this, inputEvent);
-
-    const WebInputEvent* inputEventTransformed = &inputEvent;
-    WebMouseEvent mouseEvent;
-    WebGestureEvent gestureEvent;
-    if (WebInputEvent::isMouseEventType(inputEvent.type)) {
-        mouseEvent = *static_cast<const WebMouseEvent*>(&inputEvent);
-
-        IntPoint transformedLocation = roundedIntPoint(m_layerTreeView->adjustEventPointForPinchZoom(WebFloatPoint(mouseEvent.x, mouseEvent.y)));
-        mouseEvent.x = transformedLocation.x();
-        mouseEvent.y = transformedLocation.y();
-        inputEventTransformed = static_cast<const WebInputEvent*>(&mouseEvent);
-    } else if (WebInputEvent::isGestureEventType(inputEvent.type)) {
-        gestureEvent = *static_cast<const WebGestureEvent*>(&inputEvent);
-
-        IntPoint transformedLocation = roundedIntPoint(m_layerTreeView->adjustEventPointForPinchZoom(WebFloatPoint(gestureEvent.x, gestureEvent.y)));
-        gestureEvent.x = transformedLocation.x();
-        gestureEvent.y = transformedLocation.y();
-        inputEventTransformed = static_cast<const WebInputEvent*>(&gestureEvent);
-    }
-
-    bool handled = PageWidgetDelegate::handleInputEvent(m_page.get(), *this, *inputEventTransformed);
-    return handled;
+    return PageWidgetDelegate::handleInputEvent(m_page.get(), *this, inputEvent);
 }
 
 void WebViewImpl::mouseCaptureLost()
@@ -2125,8 +2184,15 @@
         if (focusedFrame) {
             // Finish an ongoing composition to delete the composition node.
             Editor* editor = focusedFrame->editor();
-            if (editor && editor->hasComposition())
+            if (editor && editor->hasComposition()) {
+                if (m_autofillClient)
+                    m_autofillClient->setIgnoreTextChanges(true);
+
                 editor->confirmComposition();
+
+                if (m_autofillClient)
+                    m_autofillClient->setIgnoreTextChanges(false);
+            }
             m_imeAcceptEvents = false;
         }
     }
@@ -2348,32 +2414,37 @@
     if (!selection)
         return false;
 
-    if (selection->isCaret()) {
-        anchor = focus = frame->view()->contentsToWindow(selection->absoluteCaretBounds());
-        return true;
-    }
+    if (selection->isCaret())
+        anchor = focus = selection->absoluteCaretBounds();
+    else {
+        RefPtr<Range> selectedRange = frame->selection()->toNormalizedRange();
+        if (!selectedRange)
+            return false;
 
-    RefPtr<Range> selectedRange = frame->selection()->toNormalizedRange();
-    if (!selectedRange)
-        return false;
+        RefPtr<Range> range(Range::create(selectedRange->startContainer()->document(),
+            selectedRange->startContainer(),
+            selectedRange->startOffset(),
+            selectedRange->startContainer(),
+            selectedRange->startOffset()));
+        anchor = frame->editor()->firstRectForRange(range.get());
 
-    RefPtr<Range> range(Range::create(selectedRange->startContainer()->document(),
-                                      selectedRange->startContainer(),
-                                      selectedRange->startOffset(),
-                                      selectedRange->startContainer(),
-                                      selectedRange->startOffset()));
-    anchor = frame->editor()->firstRectForRange(range.get());
+        range = Range::create(selectedRange->endContainer()->document(),
+            selectedRange->endContainer(),
+            selectedRange->endOffset(),
+            selectedRange->endContainer(),
+            selectedRange->endOffset());
+        focus = frame->editor()->firstRectForRange(range.get());
+    }
 
-    range = Range::create(selectedRange->endContainer()->document(),
-                          selectedRange->endContainer(),
-                          selectedRange->endOffset(),
-                          selectedRange->endContainer(),
-                          selectedRange->endOffset());
-    focus = frame->editor()->firstRectForRange(range.get());
+    IntRect scaledAnchor(frame->view()->contentsToWindow(anchor));
+    IntRect scaledFocus(frame->view()->contentsToWindow(focus));
+    if (m_webSettings->applyPageScaleFactorInCompositor()) {
+        scaledAnchor.scale(pageScaleFactor());
+        scaledFocus.scale(pageScaleFactor());
+    }
+    anchor = scaledAnchor;
+    focus = scaledFocus;
 
-    anchor = frame->view()->contentsToWindow(anchor);
-    focus = frame->view()->contentsToWindow(focus);
-
     if (!frame->selection()->selection().isBaseFirst())
         std::swap(anchor, focus);
     return true;
@@ -2394,6 +2465,17 @@
     return true;
 }
 
+bool WebViewImpl::isSelectionAnchorFirst() const
+{
+    const Frame* frame = focusedWebCoreFrame();
+    if (!frame)
+        return false;
+    FrameSelection* selection = frame->selection();
+    if (!selection)
+        return false;
+    return selection->selection().isBaseFirst();
+}
+
 bool WebViewImpl::setEditableSelectionOffsets(int start, int end)
 {
     const Frame* focused = focusedWebCoreFrame();
@@ -2739,71 +2821,93 @@
     }
 
 #if ENABLE(GESTURE_EVENTS)
+    float scale;
+    IntPoint scroll;
+    bool needAnimation;
+    computeScaleAndScrollForFocusedNode(focusedNode, scale, scroll, needAnimation);
+    if (needAnimation)
+        startPageScaleAnimation(scroll, false, scale, scrollAndScaleAnimationDurationInSeconds);
+#endif
+}
+
+#if ENABLE(GESTURE_EVENTS)
+void WebViewImpl::computeScaleAndScrollForFocusedNode(Node* focusedNode, float& newScale, IntPoint& newScroll, bool& needAnimation)
+{
     focusedNode->document()->updateLayoutIgnorePendingStylesheets();
 
     // 'caret' is rect encompassing the blinking cursor.
     IntRect textboxRect = focusedNode->document()->view()->contentsToWindow(pixelSnappedIntRect(focusedNode->Node::boundingBox()));
-    WebRect caret, end;
-    selectionBounds(caret, end);
+    WebRect caret, unusedEnd;
+    selectionBounds(caret, unusedEnd);
+    if (settingsImpl()->applyPageScaleFactorInCompositor()) {
+        IntRect unscaledCaret = caret;
+        unscaledCaret.scale(1 / pageScaleFactor());
+        caret = unscaledCaret;
+    }
 
     // Pick a scale which is reasonably readable. This is the scale at which
     // the caret height will become minReadableCaretHeight (adjusted for dpi
     // and font scale factor).
-    float targetScale = deviceScaleFactor();
+    float targetScale = settingsImpl()->applyDeviceScaleFactorInCompositor() ? 1 : deviceScaleFactor();
 #if ENABLE(TEXT_AUTOSIZING)
     if (page() && page()->settings())
         targetScale *= page()->settings()->textAutosizingFontScaleFactor();
 #endif
-    const float newScale = clampPageScaleFactorToLimits(pageScaleFactor() * minReadableCaretHeight * targetScale / caret.height);
+    const float caretHeight = settingsImpl()->applyPageScaleFactorInCompositor() ? caret.height : caret.height / pageScaleFactor();
+    newScale = clampPageScaleFactorToLimits(minReadableCaretHeight * targetScale / caretHeight);
     const float deltaScale = newScale / pageScaleFactor();
 
     // Convert the rects to absolute space in the new scale.
     IntRect textboxRectInDocumentCoordinates = textboxRect;
     textboxRectInDocumentCoordinates.move(mainFrame()->scrollOffset());
-    textboxRectInDocumentCoordinates.scale(deltaScale);
     IntRect caretInDocumentCoordinates = caret;
     caretInDocumentCoordinates.move(mainFrame()->scrollOffset());
-    caretInDocumentCoordinates.scale(deltaScale);
 
-    IntPoint newOffset;
-    if (textboxRectInDocumentCoordinates.width() <= m_size.width) {
+    int viewWidth = m_size.width;
+    int viewHeight = m_size.height;
+    if (settingsImpl()->applyPageScaleFactorInCompositor()) {
+        viewWidth /= newScale;
+        viewHeight /= newScale;
+    } else {
+        textboxRectInDocumentCoordinates.scale(deltaScale);
+        caretInDocumentCoordinates.scale(deltaScale);
+    }
+
+    if (textboxRectInDocumentCoordinates.width() <= viewWidth) {
         // Field is narrower than screen. Try to leave padding on left so field's
         // label is visible, but it's more important to ensure entire field is
         // onscreen.
-        int idealLeftPadding = m_size.width * leftBoxRatio;
-        int maxLeftPaddingKeepingBoxOnscreen = m_size.width - textboxRectInDocumentCoordinates.width();
-        newOffset.setX(textboxRectInDocumentCoordinates.x() - min<int>(idealLeftPadding, maxLeftPaddingKeepingBoxOnscreen));
+        int idealLeftPadding = viewWidth * leftBoxRatio;
+        int maxLeftPaddingKeepingBoxOnscreen = viewWidth - textboxRectInDocumentCoordinates.width();
+        newScroll.setX(textboxRectInDocumentCoordinates.x() - min<int>(idealLeftPadding, maxLeftPaddingKeepingBoxOnscreen));
     } else {
         // Field is wider than screen. Try to left-align field, unless caret would
         // be offscreen, in which case right-align the caret.
-        newOffset.setX(max<int>(textboxRectInDocumentCoordinates.x(), caretInDocumentCoordinates.x() + caretInDocumentCoordinates.width() + caretPadding - m_size.width));
+        newScroll.setX(max<int>(textboxRectInDocumentCoordinates.x(), caretInDocumentCoordinates.x() + caretInDocumentCoordinates.width() + caretPadding - viewWidth));
     }
-    if (textboxRectInDocumentCoordinates.height() <= m_size.height) {
+    if (textboxRectInDocumentCoordinates.height() <= viewHeight) {
         // Field is shorter than screen. Vertically center it.
-        newOffset.setY(textboxRectInDocumentCoordinates.y() - (m_size.height - textboxRectInDocumentCoordinates.height()) / 2);
+        newScroll.setY(textboxRectInDocumentCoordinates.y() - (viewHeight - textboxRectInDocumentCoordinates.height()) / 2);
     } else {
         // Field is taller than screen. Try to top align field, unless caret would
         // be offscreen, in which case bottom-align the caret.
-        newOffset.setY(max<int>(textboxRectInDocumentCoordinates.y(), caretInDocumentCoordinates.y() + caretInDocumentCoordinates.height() + caretPadding - m_size.height));
+        newScroll.setY(max<int>(textboxRectInDocumentCoordinates.y(), caretInDocumentCoordinates.y() + caretInDocumentCoordinates.height() + caretPadding - viewHeight));
     }
 
-    bool needAnimation = false;
+    needAnimation = false;
     // If we are at less than the target zoom level, zoom in.
     if (deltaScale > minScaleChangeToTriggerZoom)
         needAnimation = true;
     // If the caret is offscreen, then animate.
-    IntRect sizeRect(0, 0, m_size.width, m_size.height);
+    IntRect sizeRect(0, 0, viewWidth, viewHeight);
     if (!sizeRect.contains(caret))
         needAnimation = true;
     // If the box is partially offscreen and it's possible to bring it fully
     // onscreen, then animate.
     if (sizeRect.contains(textboxRectInDocumentCoordinates.width(), textboxRectInDocumentCoordinates.height()) && !sizeRect.contains(textboxRect))
         needAnimation = true;
-
-    if (needAnimation)
-        startPageScaleAnimation(newOffset, false, newScale, scrollAndScaleAnimationDurationInSeconds);
+}
 #endif
-}
 
 void WebViewImpl::advanceFocus(bool reverse)
 {
@@ -2884,34 +2988,40 @@
     return min(max(scaleFactor, m_minimumPageScaleFactor), m_maximumPageScaleFactor);
 }
 
-WebPoint WebViewImpl::clampOffsetAtScale(const WebPoint& offset, float scale)
+IntPoint WebViewImpl::clampOffsetAtScale(const IntPoint& offset, float scale) const
 {
-    // This is the scaled content size. We need to convert it to the new scale factor.
-    WebSize contentSize = mainFrame()->contentsSize();
-    float deltaScale = scale / pageScaleFactor();
-    int docWidthAtNewScale = contentSize.width * deltaScale;
-    int docHeightAtNewScale = contentSize.height * deltaScale;
-    int viewWidth = m_size.width;
-    int viewHeight = m_size.height;
+    IntPoint clampedOffset = offset;
+    if (!m_page->settings()->applyPageScaleFactorInCompositor()) {
+        // This is the scaled content size. We need to convert it to the new scale factor.
+        WebSize contentSize = contentsSize();
+        int docWidthAtNewScale = contentSize.width * scale;
+        int docHeightAtNewScale = contentSize.height * scale;
+        int viewWidth = m_size.width;
+        int viewHeight = m_size.height;
 
-    // Enforce the maximum and minimum scroll positions at the new scale.
-    IntPoint clampedOffset = offset;
-    clampedOffset = clampedOffset.shrunkTo(IntPoint(docWidthAtNewScale - viewWidth, docHeightAtNewScale - viewHeight));
-    clampedOffset.clampNegativeToZero();
+        // Enforce the maximum and minimum scroll positions at the new scale.
+        clampedOffset = clampedOffset.shrunkTo(IntPoint(docWidthAtNewScale - viewWidth, docHeightAtNewScale - viewHeight));
+        clampedOffset.clampNegativeToZero();
+    } else {
+        clampedOffset = clampedOffset.shrunkTo(IntPoint(contentsSize() - scaledSize(scale)));
+        clampedOffset.clampNegativeToZero();
+    }
+
     return clampedOffset;
 }
 
 void WebViewImpl::setPageScaleFactorPreservingScrollOffset(float scaleFactor)
 {
-    // Pick a scale factor that is within the expected limits
     scaleFactor = clampPageScaleFactorToLimits(scaleFactor);
 
-    IntPoint scrollOffsetAtNewScale(mainFrame()->scrollOffset().width, mainFrame()->scrollOffset().height);
-    float deltaScale = scaleFactor / pageScaleFactor();
-    scrollOffsetAtNewScale.scale(deltaScale, deltaScale);
+    IntPoint scrollOffset(mainFrame()->scrollOffset().width, mainFrame()->scrollOffset().height);
+    if (!m_page->settings()->applyPageScaleFactorInCompositor()) {
+        float deltaScale = scaleFactor / pageScaleFactor();
+        scrollOffset.scale(deltaScale, deltaScale);
+    }
+    scrollOffset = clampOffsetAtScale(scrollOffset, scaleFactor);
 
-    WebPoint clampedOffsetAtNewScale = clampOffsetAtScale(scrollOffsetAtNewScale, scaleFactor);
-    setPageScaleFactor(scaleFactor, clampedOffsetAtNewScale);
+    setPageScaleFactor(scaleFactor, scrollOffset);
 }
 
 void WebViewImpl::setPageScaleFactor(float scaleFactor, const WebPoint& origin)
@@ -2922,28 +3032,17 @@
     if (!scaleFactor)
         scaleFactor = 1;
 
-    if (m_deviceScaleInCompositor != 1) {
-        // Don't allow page scaling when compositor scaling is being used,
-        // as they are currently incompatible.
-        ASSERT(scaleFactor == 1);
-    }
-
+    IntPoint scrollOffset = origin;
     scaleFactor = clampPageScaleFactorToLimits(scaleFactor);
-    WebPoint scrollOffset;
-    if (!m_page->settings()->applyPageScaleFactorInCompositor()) {
-        // If page scale is not applied in the compositor, then the scroll offsets should
-        // be modified by the scale factor.
-        scrollOffset = clampOffsetAtScale(origin, scaleFactor);
-    } else {
-        IntPoint offset = origin;
-        WebSize contentSize = mainFrame()->contentsSize();
-        offset.shrunkTo(IntPoint(contentSize.width - m_size.width, contentSize.height - m_size.height));
-        offset.clampNegativeToZero();
-        scrollOffset = offset;
-    }
+    scrollOffset = clampOffsetAtScale(scrollOffset, scaleFactor);
 
-    page()->setPageScaleFactor(scaleFactor, scrollOffset);
+    page()->setPageScaleFactor(scaleFactor, IntPoint(scrollOffset));
+
     m_pageScaleFactorIsSet = true;
+
+#if USE(ACCELERATED_COMPOSITING)
+    updateLayerTreeViewport();
+#endif
 }
 
 float WebViewImpl::deviceScaleFactor() const
@@ -2961,16 +3060,8 @@
 
     page()->setDeviceScaleFactor(scaleFactor);
 
-    if (m_layerTreeView && m_webSettings->applyDeviceScaleFactorInCompositor()) {
-        m_deviceScaleInCompositor = page()->deviceScaleFactor();
-        m_layerTreeView->setDeviceScaleFactor(m_deviceScaleInCompositor);
-    }
-    if (m_deviceScaleInCompositor != 1) {
-        // Don't allow page scaling when compositor scaling is being used,
-        // as they are currently incompatible. This means the deviceScale
-        // needs to match the one in the compositor.
-        ASSERT(scaleFactor == m_deviceScaleInCompositor);
-    }
+    if (m_layerTreeView && m_webSettings->applyDeviceScaleFactorInCompositor())
+        m_layerTreeView->setDeviceScaleFactor(scaleFactor);
 }
 
 bool WebViewImpl::isFixedLayoutModeEnabled() const
@@ -3020,9 +3111,22 @@
 
 void WebViewImpl::setPageScaleFactorLimits(float minPageScale, float maxPageScale)
 {
+    if (minPageScale == m_pageDefinedMinimumPageScaleFactor && maxPageScale == m_pageDefinedMaximumPageScaleFactor)
+        return;
+
     m_pageDefinedMinimumPageScaleFactor = minPageScale;
     m_pageDefinedMaximumPageScaleFactor = maxPageScale;
-    computePageScaleFactorLimits();
+
+    if (settings()->viewportEnabled()) {
+        // If we're in viewport tag mode, we need to layout to obtain the latest
+        // contents size and compute the final limits.
+        FrameView* view = mainFrameImpl()->frameView();
+        if (view)
+            view->setNeedsLayout();
+    } else {
+        // Otherwise just compute the limits immediately.
+        computePageScaleFactorLimits();
+    }
 }
 
 void WebViewImpl::setIgnoreViewportTagMaximumScale(bool flag)
@@ -3035,45 +3139,76 @@
     m_page->chrome()->client()->dispatchViewportPropertiesDidChange(page()->mainFrame()->document()->viewportArguments());
 }
 
-static IntSize unscaledContentsSize(Frame* frame)
+IntSize WebViewImpl::contentsSize() const
 {
+    Frame* frame = page()->mainFrame();
     RenderView* root = frame->contentRenderer();
     if (!root)
         return IntSize();
-    return root->unscaledDocumentRect().size();
+
+    // If page scale is not applied by compositor, then the CSS transform will
+    // scale by an arbitrary amount. Return the unscaled contents size in this
+    // case.
+    if (!m_page->settings()->applyPageScaleFactorInCompositor())
+        return root->unscaledDocumentRect().size();
+
+    return root->documentRect().size();
 }
 
-bool WebViewImpl::computePageScaleFactorLimits()
+IntSize WebViewImpl::layoutSize() const
 {
+    if (!isFixedLayoutModeEnabled())
+        return m_size;
+
+    IntSize contentSize = contentsSize();
+
+    if (fixedLayoutSize().width >= contentSize.width())
+        return fixedLayoutSize();
+
+    float aspectRatio = static_cast<float>(m_size.height) / m_size.width;
+    return IntSize(contentSize.width(), contentSize.width() * aspectRatio);
+}
+
+void WebViewImpl::computePageScaleFactorLimits()
+{
     if (m_pageDefinedMinimumPageScaleFactor == -1 || m_pageDefinedMaximumPageScaleFactor == -1)
-        return false;
+        return;
 
     if (!mainFrame() || !page() || !page()->mainFrame() || !page()->mainFrame()->view())
-        return false;
+        return;
 
-    m_minimumPageScaleFactor = min(max(m_pageDefinedMinimumPageScaleFactor, minPageScaleFactor), maxPageScaleFactor) * (deviceScaleFactor() / m_deviceScaleInCompositor);
-    m_maximumPageScaleFactor = max(min(m_pageDefinedMaximumPageScaleFactor, maxPageScaleFactor), minPageScaleFactor) * (deviceScaleFactor() / m_deviceScaleInCompositor);
+    FrameView* view = page()->mainFrame()->view();
 
-    int viewWidthNotIncludingScrollbars = page()->mainFrame()->view()->visibleContentRect(false).width();
-    int unscaledContentsWidth = unscaledContentsSize(page()->mainFrame()).width();
-    if (viewWidthNotIncludingScrollbars && unscaledContentsWidth) {
-        // Limit page scaling down to the document width.
-        m_minimumPageScaleFactor = max(m_minimumPageScaleFactor, static_cast<float>(viewWidthNotIncludingScrollbars) / unscaledContentsWidth);
+    m_minimumPageScaleFactor = min(max(m_pageDefinedMinimumPageScaleFactor, minPageScaleFactor), maxPageScaleFactor);
+    m_maximumPageScaleFactor = max(min(m_pageDefinedMaximumPageScaleFactor, maxPageScaleFactor), minPageScaleFactor);
+
+    if (settings()->viewportEnabled()) {
+        if (!contentsSize().width() || !m_size.width)
+            return;
+
+        // When viewport tag is enabled, the scale needed to see the full
+        // content width is the default minimum.
+        int viewWidthNotIncludingScrollbars = m_size.width;
+        if (view->verticalScrollbar() && !view->verticalScrollbar()->isOverlayScrollbar())
+            viewWidthNotIncludingScrollbars -= view->verticalScrollbar()->width();
+        m_minimumPageScaleFactor = max(m_minimumPageScaleFactor, static_cast<float>(viewWidthNotIncludingScrollbars) / contentsSize().width());
         m_maximumPageScaleFactor = max(m_minimumPageScaleFactor, m_maximumPageScaleFactor);
     }
     ASSERT(m_minimumPageScaleFactor <= m_maximumPageScaleFactor);
 
-    float clampedScale = clampPageScaleFactorToLimits(pageScaleFactor());
+    // Initialize and/or clamp the page scale factor if needed.
+    float newPageScaleFactor = pageScaleFactor();
+    if (!m_pageScaleFactorIsSet && m_initialPageScaleFactor != -1) {
+        newPageScaleFactor = m_initialPageScaleFactor;
+        m_pageScaleFactorIsSet = true;
+    }
+    newPageScaleFactor = clampPageScaleFactorToLimits(newPageScaleFactor);
 #if USE(ACCELERATED_COMPOSITING)
     if (m_layerTreeView)
-        m_layerTreeView->setPageScaleFactorAndLimits(clampedScale, m_minimumPageScaleFactor, m_maximumPageScaleFactor);
+        m_layerTreeView->setPageScaleFactorAndLimits(newPageScaleFactor, m_minimumPageScaleFactor, m_maximumPageScaleFactor);
 #endif
-    if (clampedScale != pageScaleFactor()) {
-        setPageScaleFactorPreservingScrollOffset(clampedScale);
-        return true;
-    }
-
-    return false;
+    if (newPageScaleFactor != pageScaleFactor())
+        setPageScaleFactorPreservingScrollOffset(newPageScaleFactor);
 }
 
 float WebViewImpl::minimumPageScaleFactor() const
@@ -3153,6 +3288,14 @@
     frame->view()->setFixedLayoutSize(layoutSize);
 }
 
+WebCore::IntSize WebViewImpl::dipSize() const
+{
+    IntSize dipSize = m_size;
+    if (!m_webSettings->applyDeviceScaleFactorInCompositor())
+        dipSize.scale(1 / m_client->screenInfo().deviceScaleFactor);
+    return dipSize;
+}
+
 void WebViewImpl::performMediaPlayerAction(const WebMediaPlayerAction& action,
                                            const WebPoint& location)
 {
@@ -3662,10 +3805,8 @@
     m_newNavigationLoader = 0;
 #endif
     m_observedNewNavigation = false;
-    if (*isNewNavigation && !isNavigationWithinPage) {
+    if (*isNewNavigation && !isNavigationWithinPage)
         m_pageScaleFactorIsSet = false;
-        m_doubleTapZoomInEffect = false;
-    }
 
     // Make sure link highlight from previous page is cleared.
     m_linkHighlight.clear();
@@ -3689,35 +3830,31 @@
         }
     }
 
+    if (settings()->viewportEnabled()) {
+        if (!isPageScaleFactorSet()) {
+            // If the viewport tag failed to be processed earlier, we need
+            // to recompute it now.
+            ViewportArguments viewportArguments = mainFrameImpl()->frame()->document()->viewportArguments();
+            m_page->chrome()->client()->dispatchViewportPropertiesDidChange(viewportArguments);
+        }
+
+        // Contents size is an input to the page scale limits, so a good time to
+        // recalculate is after layout has occurred.
+        computePageScaleFactorLimits();
+
+        // Relayout immediately to avoid violating the rule that needsLayout()
+        // isn't set at the end of a layout.
+        FrameView* view = mainFrameImpl()->frameView();
+        if (view && view->needsLayout())
+            view->layout();
+    }
+
     m_client->didUpdateLayout();
+
 }
 
 void WebViewImpl::didChangeContentsSize()
 {
-#if ENABLE(VIEWPORT)
-    if (!settings()->viewportEnabled())
-        return;
-
-    bool didChangeScale = false;
-    if (!isPageScaleFactorSet()) {
-        // If the viewport tag failed to be processed earlier, we need
-        // to recompute it now.
-        ViewportArguments viewportArguments = mainFrameImpl()->frame()->document()->viewportArguments();
-        m_page->chrome()->client()->dispatchViewportPropertiesDidChange(viewportArguments);
-        didChangeScale = true;
-    } else
-        didChangeScale = computePageScaleFactorLimits();
-
-    if (!didChangeScale)
-        return;
-
-    if (!mainFrameImpl())
-        return;
-
-    FrameView* view = mainFrameImpl()->frameView();
-    if (view && view->needsLayout())
-        view->layout();
-#endif
 }
 
 bool WebViewImpl::useExternalPopupMenus()
@@ -4046,13 +4183,9 @@
             m_ownsLayerTreeView = true;
         }
         if (m_layerTreeView) {
-            if (m_webSettings->applyDeviceScaleFactorInCompositor() && page()->deviceScaleFactor() != 1) {
-                ASSERT(page()->deviceScaleFactor());
+            if (m_webSettings->applyDeviceScaleFactorInCompositor() && page()->deviceScaleFactor() != 1)
+                setDeviceScaleFactor(page()->deviceScaleFactor());
 
-                m_deviceScaleInCompositor = page()->deviceScaleFactor();
-                setDeviceScaleFactor(m_deviceScaleInCompositor);
-            }
-
             bool visible = page()->visibilityState() == PageVisibilityStateVisible;
             m_layerTreeView->setVisible(visible);
             m_layerTreeView->setPageScaleFactorAndLimits(pageScaleFactor(), m_minimumPageScaleFactor, m_maximumPageScaleFactor);
@@ -4067,6 +4200,7 @@
                 m_pageOverlays->update();
             m_layerTreeView->setShowFPSCounter(m_showFPSCounter);
             m_layerTreeView->setShowPaintRects(m_showPaintRects);
+            m_layerTreeView->setContinuousPaintingEnabled(m_continuousPaintingEnabled);
         } else {
             m_nonCompositedContentHost.clear();
             m_isAcceleratedCompositingActive = false;
@@ -4117,7 +4251,7 @@
         }
 
         setPageScaleFactor(pageScaleFactor() * pageScaleDelta, scrollPoint);
-        m_doubleTapZoomInEffect = false;
+        m_doubleTapZoomPending = false;
     }
 }
 
@@ -4185,17 +4319,14 @@
         return;
 
     FrameView* view = page()->mainFrame()->view();
-    IntRect visibleRect = view->visibleContentRect(true /* include scrollbars */);
-    IntPoint scroll(view->scrollX(), view->scrollY());
 
-    m_nonCompositedContentHost->setViewport(visibleRect.size(), view->contentsSize(), scroll, view->scrollOrigin());
+    IntSize layoutViewportSize = layoutSize();
+    IntSize deviceViewportSize = m_size;
+    if (m_webSettings->applyDeviceScaleFactorInCompositor())
+        deviceViewportSize.scale(deviceScaleFactor());
 
-    IntSize layoutViewportSize = size();
-    IntSize deviceViewportSize = size();
+    m_nonCompositedContentHost->setViewport(deviceViewportSize, view->contentsSize(), view->scrollPosition(), view->scrollOrigin());
 
-    // This part of the deviceScale will be used to scale the contents of
-    // the NCCH's GraphicsLayer.
-    deviceViewportSize.scale(m_deviceScaleInCompositor);
     m_layerTreeView->setViewportSize(layoutViewportSize, deviceViewportSize);
     m_layerTreeView->setPageScaleFactorAndLimits(pageScaleFactor(), m_minimumPageScaleFactor, m_maximumPageScaleFactor);
 }
Index: src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlayList.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlayList.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/PageOverlayList.cpp	(working copy)
@@ -127,4 +127,13 @@
     return WTF::notFound;
 }
 
+size_t PageOverlayList::findGraphicsLayer(WebCore::GraphicsLayer* layer)
+{
+    for (size_t i = 0; i < m_pageOverlays.size(); ++i) {
+        if (m_pageOverlays[i]->graphicsLayer() == layer)
+            return i;
+    }
+    return WTF::notFound;
+}
+
 } // namespace WebKit
Index: src/third_party/WebKit/Source/WebKit/chromium/WebKit.gypi
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/WebKit.gypi	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/WebKit.gypi	(working copy)
@@ -83,6 +83,7 @@
             'tests/ImageDecodingStoreTest.cpp',
             'tests/ImageFrameGeneratorTest.cpp',
             'tests/ImageLayerChromiumTest.cpp',
+            'tests/MockDiscardablePixelRef.h',
             'tests/MockImageDecoder.h',
             'tests/KeyboardTest.cpp',
             'tests/KURLTest.cpp',
@@ -111,7 +112,6 @@
             'tests/URLTestHelpers.h',
             'tests/WebCompositorInitializer.h',
             'tests/WebCompositorInputHandlerImplTest.cpp',
-            'tests/WebFrameTest.cpp',
             'tests/WebImageTest.cpp',
             'tests/WebInputEventConversionTest.cpp',
             'tests/WebInputEventFactoryTestMac.mm',
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/WebCompositorInputHandlerImplTest.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/WebCompositorInputHandlerImplTest.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/WebCompositorInputHandlerImplTest.cpp	(working copy)
@@ -345,14 +345,14 @@
 
     gesture.type = WebInputEvent::GestureFlingStart;
     gesture.data.flingStart.velocityX = 10;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     m_inputHandler->handleInputEvent(gesture);
 
     VERIFY_AND_RESET_MOCKS();
 
     // Verify that a GestureFlingCancel during an animation cancels it.
     gesture.type = WebInputEvent::GestureFlingCancel;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     m_inputHandler->handleInputEvent(gesture);
 }
 
@@ -366,14 +366,14 @@
         .WillOnce(testing::Return(WebInputHandlerClient::ScrollStatusOnMainThread));
 
     gesture.type = WebInputEvent::GestureFlingStart;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     m_inputHandler->handleInputEvent(gesture);
 
     VERIFY_AND_RESET_MOCKS();
 
     // Even if we didn't start a fling ourselves, we still need to send the cancel event to the widget.
     gesture.type = WebInputEvent::GestureFlingCancel;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     m_inputHandler->handleInputEvent(gesture);
 }
 
@@ -386,7 +386,7 @@
         .WillOnce(testing::Return(WebInputHandlerClient::ScrollStatusIgnored));
 
     gesture.type = WebInputEvent::GestureFlingStart;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     m_inputHandler->handleInputEvent(gesture);
 
     m_expectedDisposition = DropEvent;
@@ -394,7 +394,7 @@
 
     // Since the previous fling was ignored, we should also be dropping the next flingCancel.
     gesture.type = WebInputEvent::GestureFlingCancel;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     m_inputHandler->handleInputEvent(gesture);
 }
 
@@ -413,7 +413,7 @@
     int modifiers = 7;
     gesture.data.flingStart.velocityX = flingDelta.x;
     gesture.data.flingStart.velocityY = flingDelta.y;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     gesture.x = flingPoint.x;
     gesture.y = flingPoint.y;
     gesture.globalX = flingGlobalPoint.x;
@@ -499,7 +499,7 @@
     int modifiers = 1;
     gesture.data.flingStart.velocityX = flingDelta.x;
     gesture.data.flingStart.velocityY = flingDelta.y;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     gesture.x = flingPoint.x;
     gesture.y = flingPoint.y;
     gesture.globalX = flingGlobalPoint.x;
@@ -582,7 +582,7 @@
     modifiers = 2;
     gesture.data.flingStart.velocityX = flingDelta.x;
     gesture.data.flingStart.velocityY = flingDelta.y;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchpad;
+    gesture.sourceDevice = WebGestureEvent::Touchpad;
     gesture.x = flingPoint.x;
     gesture.y = flingPoint.y;
     gesture.globalX = flingGlobalPoint.x;
@@ -645,7 +645,7 @@
 
     gesture.type = WebInputEvent::GestureFlingStart;
     gesture.data.flingStart.velocityX = 10;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     m_inputHandler->handleInputEvent(gesture);
 
     VERIFY_AND_RESET_MOCKS();
@@ -654,7 +654,7 @@
 
     // Verify that a GestureFlingCancel during an animation cancels it.
     gesture.type = WebInputEvent::GestureFlingCancel;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     m_inputHandler->handleInputEvent(gesture);
 }
 
@@ -668,14 +668,14 @@
         .WillOnce(testing::Return(WebInputHandlerClient::ScrollStatusOnMainThread));
 
     gesture.type = WebInputEvent::GestureFlingStart;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     m_inputHandler->handleInputEvent(gesture);
 
     VERIFY_AND_RESET_MOCKS();
 
     // Even if we didn't start a fling ourselves, we still need to send the cancel event to the widget.
     gesture.type = WebInputEvent::GestureFlingCancel;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     m_inputHandler->handleInputEvent(gesture);
 }
 
@@ -688,14 +688,14 @@
         .WillOnce(testing::Return(WebInputHandlerClient::ScrollStatusIgnored));
 
     gesture.type = WebInputEvent::GestureFlingStart;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     m_inputHandler->handleInputEvent(gesture);
 
     VERIFY_AND_RESET_MOCKS();
 
     // Even if we didn't start a fling ourselves, we still need to send the cancel event to the widget.
     gesture.type = WebInputEvent::GestureFlingCancel;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     m_inputHandler->handleInputEvent(gesture);
 }
 
@@ -714,7 +714,7 @@
     int modifiers = 7;
     gesture.data.flingStart.velocityX = flingDelta.x;
     gesture.data.flingStart.velocityY = flingDelta.y;
-    gesture.data.flingStart.sourceDevice = WebGestureEvent::Touchscreen;
+    gesture.sourceDevice = WebGestureEvent::Touchscreen;
     gesture.x = flingPoint.x;
     gesture.y = flingPoint.y;
     gesture.globalX = flingGlobalPoint.x;
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/WebViewTest.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/WebViewTest.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/WebViewTest.cpp	(working copy)
@@ -37,6 +37,7 @@
 #include "FrameView.h"
 #include "HTMLDocument.h"
 #include "URLTestHelpers.h"
+#include "WebAutofillClient.h"
 #include "WebContentDetectionResult.h"
 #include "WebDocument.h"
 #include "WebElement.h"
@@ -123,7 +124,7 @@
 class TapHandlingWebViewClient : public WebViewClient {
 public:
     // WebViewClient methods
-    virtual void didHandleGestureEvent(const WebGestureEvent& event, bool handled)
+    virtual void didHandleGestureEvent(const WebGestureEvent& event, bool eventCancelled)
     {
         if (event.type == WebInputEvent::GestureTap) {
             m_tapX = event.x;
@@ -456,6 +457,23 @@
     webView->close();
 }
 
+TEST_F(WebViewTest, IsSelectionAnchorFirst)
+{
+    URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8("input_field_populated.html"));
+    WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "input_field_populated.html");
+    WebFrame* frame = webView->mainFrame();
+
+    webView->setInitialFocus(false);
+    webView->setEditableSelectionOffsets(4, 10);
+    EXPECT_TRUE(webView->isSelectionAnchorFirst());
+    WebRect anchor;
+    WebRect focus;
+    webView->selectionBounds(anchor, focus);
+    frame->selectRange(WebPoint(focus.x, focus.y), WebPoint(anchor.x, anchor.y));
+    EXPECT_FALSE(webView->isSelectionAnchorFirst());
+    webView->close();
+}
+
 TEST_F(WebViewTest, ResetScrollAndScaleState)
 {
     URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8("hello_world.html"));
@@ -652,4 +670,96 @@
 }
 #endif
 
+class MockAutofillClient : public WebAutofillClient {
+public:
+    MockAutofillClient()
+        : m_ignoreTextChanges(false)
+        , m_textChangesWhileIgnored(0)
+        , m_textChangesWhileNotIgnored(0) { }
+
+    virtual ~MockAutofillClient() { }
+
+    virtual void setIgnoreTextChanges(bool ignore) OVERRIDE { m_ignoreTextChanges = ignore; }
+    virtual void textFieldDidChange(const WebInputElement&) OVERRIDE
+    {
+        if (m_ignoreTextChanges)
+            ++m_textChangesWhileIgnored;
+        else
+            ++m_textChangesWhileNotIgnored;
+    }
+
+    void clearChangeCounts()
+    {
+        m_textChangesWhileIgnored = 0;
+        m_textChangesWhileNotIgnored = 0;
+    }
+
+    int textChangesWhileIgnored() { return m_textChangesWhileIgnored; }
+    int textChangesWhileNotIgnored() { return m_textChangesWhileNotIgnored; }
+
+private:
+    bool m_ignoreTextChanges;
+    int m_textChangesWhileIgnored;
+    int m_textChangesWhileNotIgnored;
+};
+
+
+TEST_F(WebViewTest, LosingFocusDoesNotTriggerAutofillTextChange)
+{
+    URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8("input_field_populated.html"));
+    MockAutofillClient client;
+    WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "input_field_populated.html");
+    webView->setAutofillClient(&client);
+    webView->setInitialFocus(false);
+
+    // Set up a composition that needs to be committed.
+    WebVector<WebCompositionUnderline> emptyUnderlines;
+    webView->setEditableSelectionOffsets(4, 10);
+    webView->setCompositionFromExistingText(8, 12, emptyUnderlines);
+    WebTextInputInfo info = webView->textInputInfo();
+    EXPECT_EQ(4, info.selectionStart);
+    EXPECT_EQ(10, info.selectionEnd);
+    EXPECT_EQ(8, info.compositionStart);
+    EXPECT_EQ(12, info.compositionEnd);
+
+    // Clear the focus and track that the subsequent composition commit does not trigger a
+    // text changed notification for autofill.
+    client.clearChangeCounts();
+    webView->setFocus(false);
+    EXPECT_EQ(1, client.textChangesWhileIgnored());
+    EXPECT_EQ(0, client.textChangesWhileNotIgnored());
+
+    webView->setAutofillClient(0);
+    webView->close();
 }
+
+TEST_F(WebViewTest, ConfirmCompositionTriggersAutofillTextChange)
+{
+    URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8("input_field_populated.html"));
+    MockAutofillClient client;
+    WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "input_field_populated.html");
+    webView->setAutofillClient(&client);
+    webView->setInitialFocus(false);
+
+    // Set up a composition that needs to be committed.
+    std::string compositionText("testingtext");
+
+    WebVector<WebCompositionUnderline> emptyUnderlines;
+    webView->setComposition(WebString::fromUTF8(compositionText.c_str()), emptyUnderlines, 0, compositionText.length());
+
+    WebTextInputInfo info = webView->textInputInfo();
+    EXPECT_EQ(0, info.selectionStart);
+    EXPECT_EQ((int) compositionText.length(), info.selectionEnd);
+    EXPECT_EQ(0, info.compositionStart);
+    EXPECT_EQ((int) compositionText.length(), info.compositionEnd);
+
+    client.clearChangeCounts();
+    webView->confirmComposition();
+    EXPECT_EQ(0, client.textChangesWhileIgnored());
+    EXPECT_EQ(1, client.textChangesWhileNotIgnored());
+
+    webView->setAutofillClient(0);
+    webView->close();
+}
+
+}
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/WebInputEventConversionTest.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/WebInputEventConversionTest.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/WebInputEventConversionTest.cpp	(working copy)
@@ -32,14 +32,23 @@
 
 #include "WebInputEventConversion.h"
 
+#include "Frame.h"
+#include "FrameTestHelpers.h"
+#include "FrameView.h"
+#include "GestureEvent.h"
 #include "KeyboardEvent.h"
+#include "MouseEvent.h"
+#include "Touch.h"
 #include "TouchEvent.h"
+#include "TouchList.h"
+#include "URLTestHelpers.h"
+#include "WebFrame.h"
+#include "WebSettings.h"
+#include "WebViewImpl.h"
 #include <gtest/gtest.h>
 
-using WebKit::WebInputEvent;
-using WebKit::WebKeyboardEvent;
-using WebKit::WebKeyboardEventBuilder;
-using WebKit::WebMouseEventBuilder;
+using namespace WebKit;
+using namespace WebCore;
 
 namespace {
 
@@ -81,4 +90,179 @@
     EXPECT_EQ(WebInputEvent::Undefined, mouse.type);
 }
 
+TEST(WebInputEventConversionTest, InputEventsScaling)
+{
+    const std::string baseURL("http://www.test.com/");
+    const std::string fileName("fixed_layout.html");
+
+    URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(baseURL.c_str()), WebString::fromUTF8("fixed_layout.html"));
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(baseURL + fileName, true));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    int pageWidth = 640;
+    int pageHeight = 480;
+    webViewImpl->resize(WebSize(pageWidth, pageHeight));
+    webViewImpl->layout();
+
+    webViewImpl->setPageScaleFactor(2, WebPoint());
+
+    FrameView* view = webViewImpl->page()->mainFrame()->view();
+    RefPtr<Document> document = webViewImpl->page()->mainFrame()->document();
+    DOMWindow* domWindow = webViewImpl->page()->mainFrame()->document()->defaultView();
+    RenderObject* docRenderer = webViewImpl->page()->mainFrame()->document()->renderer();
+
+    {
+        WebMouseEvent webMouseEvent;
+        webMouseEvent.type = WebInputEvent::MouseMove;
+        webMouseEvent.x = 10;
+        webMouseEvent.y = 10;
+        webMouseEvent.windowX = 10;
+        webMouseEvent.windowY = 10;
+        webMouseEvent.globalX = 10;
+        webMouseEvent.globalY = 10;
+        webMouseEvent.movementX = 10;
+        webMouseEvent.movementY = 10;
+
+        PlatformMouseEventBuilder platformMouseBuilder(view, webMouseEvent);
+        EXPECT_EQ(5, platformMouseBuilder.position().x());
+        EXPECT_EQ(5, platformMouseBuilder.position().y());
+        EXPECT_EQ(10, platformMouseBuilder.globalPosition().x());
+        EXPECT_EQ(10, platformMouseBuilder.globalPosition().y());
+        EXPECT_EQ(5, platformMouseBuilder.movementDelta().x());
+        EXPECT_EQ(5, platformMouseBuilder.movementDelta().y());
+    }
+
+    {
+        WebGestureEvent webGestureEvent;
+        webGestureEvent.type = WebInputEvent::GestureScrollUpdate;
+        webGestureEvent.x = 10;
+        webGestureEvent.y = 10;
+        webGestureEvent.globalX = 10;
+        webGestureEvent.globalY = 10;
+        webGestureEvent.data.scrollUpdate.deltaX = 10;
+        webGestureEvent.data.scrollUpdate.deltaY = 10;
+
+        PlatformGestureEventBuilder platformGestureBuilder(view, webGestureEvent);
+        EXPECT_EQ(5, platformGestureBuilder.position().x());
+        EXPECT_EQ(5, platformGestureBuilder.position().y());
+        EXPECT_EQ(10, platformGestureBuilder.globalPosition().x());
+        EXPECT_EQ(10, platformGestureBuilder.globalPosition().y());
+        EXPECT_EQ(5, platformGestureBuilder.deltaX());
+        EXPECT_EQ(5, platformGestureBuilder.deltaY());
+    }
+
+    {
+        WebGestureEvent webGestureEvent;
+        webGestureEvent.type = WebInputEvent::GestureTap;
+        webGestureEvent.data.tap.width = 10;
+        webGestureEvent.data.tap.height = 10;
+
+        PlatformGestureEventBuilder platformGestureBuilder(view, webGestureEvent);
+        EXPECT_EQ(5, platformGestureBuilder.area().width());
+        EXPECT_EQ(5, platformGestureBuilder.area().height());
+    }
+
+    {
+        WebGestureEvent webGestureEvent;
+        webGestureEvent.type = WebInputEvent::GestureTapDown;
+        webGestureEvent.data.tapDown.width = 10;
+        webGestureEvent.data.tapDown.height = 10;
+
+        PlatformGestureEventBuilder platformGestureBuilder(view, webGestureEvent);
+        EXPECT_EQ(5, platformGestureBuilder.area().width());
+        EXPECT_EQ(5, platformGestureBuilder.area().height());
+    }
+
+    {
+        WebGestureEvent webGestureEvent;
+        webGestureEvent.type = WebInputEvent::GestureLongPress;
+        webGestureEvent.data.longPress.width = 10;
+        webGestureEvent.data.longPress.height = 10;
+
+        PlatformGestureEventBuilder platformGestureBuilder(view, webGestureEvent);
+        EXPECT_EQ(5, platformGestureBuilder.area().width());
+        EXPECT_EQ(5, platformGestureBuilder.area().height());
+    }
+
+    {
+        WebGestureEvent webGestureEvent;
+        webGestureEvent.type = WebInputEvent::GestureTwoFingerTap;
+        webGestureEvent.data.twoFingerTap.firstFingerWidth = 10;
+        webGestureEvent.data.twoFingerTap.firstFingerHeight = 10;
+
+        PlatformGestureEventBuilder platformGestureBuilder(view, webGestureEvent);
+        EXPECT_EQ(5, platformGestureBuilder.area().width());
+        EXPECT_EQ(5, platformGestureBuilder.area().height());
+    }
+
+    {
+        WebTouchEvent webTouchEvent;
+        webTouchEvent.type = WebInputEvent::TouchMove;
+        webTouchEvent.touchesLength = 1;
+        webTouchEvent.touches[0].state = WebTouchPoint::StateMoved;
+        webTouchEvent.touches[0].screenPosition.x = 10;
+        webTouchEvent.touches[0].screenPosition.y = 10;
+        webTouchEvent.touches[0].position.x = 10;
+        webTouchEvent.touches[0].position.y = 10;
+        webTouchEvent.touches[0].radiusX = 10;
+        webTouchEvent.touches[0].radiusY = 10;
+
+        PlatformTouchEventBuilder platformTouchBuilder(view, webTouchEvent);
+        EXPECT_EQ(10, platformTouchBuilder.touchPoints()[0].screenPos().x());
+        EXPECT_EQ(10, platformTouchBuilder.touchPoints()[0].screenPos().y());
+        EXPECT_EQ(5, platformTouchBuilder.touchPoints()[0].pos().x());
+        EXPECT_EQ(5, platformTouchBuilder.touchPoints()[0].pos().y());
+        EXPECT_EQ(5, platformTouchBuilder.touchPoints()[0].radiusX());
+        EXPECT_EQ(5, platformTouchBuilder.touchPoints()[0].radiusY());
+    }
+
+    // Reverse builders should *not* go back to physical pixels, as they are used for plugins
+    // which expect CSS pixel coordinates.
+    {
+        PlatformMouseEvent platformMouseEvent(IntPoint(10, 10), IntPoint(10, 10), LeftButton, PlatformEvent::MouseMoved, 1, false, false, false, false, 0);
+        RefPtr<MouseEvent> mouseEvent = MouseEvent::create(WebCore::eventNames().mousemoveEvent, domWindow, platformMouseEvent, 0, document);
+        WebMouseEventBuilder webMouseBuilder(view, docRenderer, *mouseEvent);
+
+        EXPECT_EQ(10, webMouseBuilder.x);
+        EXPECT_EQ(10, webMouseBuilder.y);
+        EXPECT_EQ(10, webMouseBuilder.globalX);
+        EXPECT_EQ(10, webMouseBuilder.globalY);
+        EXPECT_EQ(10, webMouseBuilder.windowX);
+        EXPECT_EQ(10, webMouseBuilder.windowY);
+    }
+
+    {
+        PlatformGestureEvent platformGestureEvent(PlatformEvent::GestureScrollUpdate, IntPoint(10, 10), IntPoint(10, 10), 0, IntSize(10, 10), FloatPoint(10, 10), false, false, false, false);
+        RefPtr<GestureEvent> gestureEvent = GestureEvent::create(domWindow, platformGestureEvent);
+        WebGestureEventBuilder webGestureBuilder(view, docRenderer, *gestureEvent);
+
+        EXPECT_EQ(10, webGestureBuilder.x);
+        EXPECT_EQ(10, webGestureBuilder.y);
+        EXPECT_EQ(10, webGestureBuilder.globalX);
+        EXPECT_EQ(10, webGestureBuilder.globalY);
+        EXPECT_EQ(10, webGestureBuilder.data.scrollUpdate.deltaX);
+        EXPECT_EQ(10, webGestureBuilder.data.scrollUpdate.deltaY);
+    }
+
+    {
+        RefPtr<Touch> touch = Touch::create(webViewImpl->page()->mainFrame(), document.get(), 0, 10, 10, 10, 10, 10, 10, 0, 0);
+        RefPtr<TouchList> touchList = TouchList::create();
+        touchList->append(touch);
+        RefPtr<TouchEvent> touchEvent = TouchEvent::create(touchList.get(), touchList.get(), touchList.get(), WebCore::eventNames().touchmoveEvent, domWindow, 10, 10, 10, 10, false, false, false, false);
+
+        WebTouchEventBuilder webTouchBuilder(view, docRenderer, *touchEvent);
+        ASSERT_EQ(1u, webTouchBuilder.touchesLength);
+        EXPECT_EQ(10, webTouchBuilder.touches[0].screenPosition.x);
+        EXPECT_EQ(10, webTouchBuilder.touches[0].screenPosition.y);
+        EXPECT_EQ(10, webTouchBuilder.touches[0].position.x);
+        EXPECT_EQ(10, webTouchBuilder.touches[0].position.y);
+        EXPECT_EQ(10, webTouchBuilder.touches[0].radiusX);
+        EXPECT_EQ(10, webTouchBuilder.touches[0].radiusY);
+    }
+
+    webViewImpl->close();
+}
+
 } // anonymous namespace
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/data/get_scale_for_zoom_into_editable_test.html
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/data/get_scale_for_zoom_into_editable_test.html	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/data/get_scale_for_zoom_into_editable_test.html	(working copy)
@@ -1,16 +1,14 @@
 <html>
 <head>
-<script>
-function getfocus()
-{
-var textfield = document.getElementById('EditBoxWithText');
-textfield.focus();
-textfield.setSelectionRange(textfield.value.length,textfield.value.length);
-}
-</script>
+  <style>
+    input {
+      font-size: 13px;
+      font-family: monospace;
+    }
+  </style>
 </head>
-  <body onload="getfocus()">
-      <input id="EditBoxWithText" style=" position: absolute; left: 200px; top: 200px; width: 250; height:20" value = "Long text to fill the edit box" type="text">
-      <input id="EditBoxWithNoText" style=" position: absolute; left: 200px; top: 250px; width: 250; height:20" type="text">
-  </body>
+<body>
+  <input id="EditBoxWithText" style=" position: absolute; left: 200px; top: 200px; width: 250px; height:20" value = "Long long long long text to fill the edit box" type="text">
+  <input id="EditBoxWithNoText" style=" position: absolute; left: 200px; top: 250px; width: 250px; height:20" type="text">
+</body>
 </html>
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/ImageDecodingStoreTest.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/ImageDecodingStoreTest.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/ImageDecodingStoreTest.cpp	(working copy)
@@ -28,6 +28,7 @@
 #include "ImageDecodingStore.h"
 
 #include "ImageFrameGenerator.h"
+#include "MockDiscardablePixelRef.h"
 #include "MockImageDecoder.h"
 #include "SharedBuffer.h"
 #include <gtest/gtest.h>
@@ -68,19 +69,25 @@
     }
 
 protected:
-    PassOwnPtr<ScaledImageFragment> createCompleteImage(const SkISize& size)
+    PassOwnPtr<ScaledImageFragment> createCompleteImage(const SkISize& size, bool discardable = false)
     {
         SkBitmap bitmap;
         bitmap.setConfig(SkBitmap::kARGB_8888_Config, size.width(), size.height());
-        bitmap.allocPixels();
+        if (!discardable)
+            bitmap.allocPixels();
+        else
+            bitmap.setPixelRef(new MockDiscardablePixelRef())->unref();
         return ScaledImageFragment::create(size, bitmap, true);
     }
 
-    PassOwnPtr<ScaledImageFragment> createIncompleteImage(const SkISize& size)
+    PassOwnPtr<ScaledImageFragment> createIncompleteImage(const SkISize& size, bool discardable = false)
     {
         SkBitmap bitmap;
         bitmap.setConfig(SkBitmap::kARGB_8888_Config, size.width(), size.height());
-        bitmap.allocPixels();
+        if (!discardable)
+            bitmap.allocPixels();
+        else
+            bitmap.setPixelRef(new MockDiscardablePixelRef())->unref();
         return ScaledImageFragment::create(size, bitmap, false);
     }
 
@@ -281,4 +288,59 @@
     ImageDecodingStore::instance()->unlockCache(m_generator.get(), cachedImage);
 }
 
+TEST_F(ImageDecodingStoreTest, lockCacheFailedAfterMemoryDiscarded)
+{
+    const ScaledImageFragment* cachedImage = ImageDecodingStore::instance()->insertAndLockCache(
+        m_generator.get(), createCompleteImage(SkISize::Make(1, 1), true), MockImageDecoder::create(this));
+    unlockCache(cachedImage);
+    MockDiscardablePixelRef* pixelRef = static_cast<MockDiscardablePixelRef*>(cachedImage->bitmap().pixelRef());
+    pixelRef->discard();
+    EXPECT_EQ(0, lockCache(SkISize::Make(1, 1)));
+    EXPECT_EQ(0u, ImageDecodingStore::instance()->cacheEntries());
+}
+
+TEST_F(ImageDecodingStoreTest, overwriteNonDiscardableCacheWithDiscardable)
+{
+
+    const SkISize size = SkISize::Make(1, 1);
+    const ScaledImageFragment* cachedImage = ImageDecodingStore::instance()->insertAndLockCache(
+        m_generator.get(), createIncompleteImage(size), MockImageDecoder::create(this));
+    ImageDecodingStore::instance()->unlockCache(m_generator.get(), cachedImage);
+    EXPECT_EQ(1u, ImageDecodingStore::instance()->cacheEntries());
+    EXPECT_LT(0u, ImageDecodingStore::instance()->memoryUsageInBytes());
+
+    ImageDecoder* decoder = 0;
+    EXPECT_TRUE(ImageDecodingStore::instance()->lockCache(m_generator.get(), size, ImageDecodingStore::CacheCanBeIncomplete, &cachedImage, &decoder));
+    EXPECT_FALSE(cachedImage->isComplete());
+
+    cachedImage = ImageDecodingStore::instance()->overwriteAndLockCache(
+        m_generator.get(), cachedImage, createCompleteImage(size, true));
+    EXPECT_TRUE(cachedImage->isComplete());
+    EXPECT_EQ(1u, ImageDecodingStore::instance()->cacheEntries());
+    EXPECT_EQ(0u, ImageDecodingStore::instance()->memoryUsageInBytes());
+    ImageDecodingStore::instance()->unlockCache(m_generator.get(), cachedImage);
+}
+
+TEST_F(ImageDecodingStoreTest, overwriteDiscardableCacheWithNonDiscardable)
+{
+
+    const SkISize size = SkISize::Make(1, 1);
+    const ScaledImageFragment* cachedImage = ImageDecodingStore::instance()->insertAndLockCache(
+        m_generator.get(), createIncompleteImage(size, true), MockImageDecoder::create(this));
+    ImageDecodingStore::instance()->unlockCache(m_generator.get(), cachedImage);
+    EXPECT_EQ(1u, ImageDecodingStore::instance()->cacheEntries());
+    EXPECT_EQ(0u, ImageDecodingStore::instance()->memoryUsageInBytes());
+
+    ImageDecoder* decoder = 0;
+    EXPECT_TRUE(ImageDecodingStore::instance()->lockCache(m_generator.get(), size, ImageDecodingStore::CacheCanBeIncomplete, &cachedImage, &decoder));
+    EXPECT_FALSE(cachedImage->isComplete());
+
+    cachedImage = ImageDecodingStore::instance()->overwriteAndLockCache(
+        m_generator.get(), cachedImage, createCompleteImage(size));
+    EXPECT_TRUE(cachedImage->isComplete());
+    EXPECT_EQ(1u, ImageDecodingStore::instance()->cacheEntries());
+    EXPECT_LT(0u, ImageDecodingStore::instance()->memoryUsageInBytes());
+    ImageDecodingStore::instance()->unlockCache(m_generator.get(), cachedImage);
+}
+
 } // namespace
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/WebFrameTest.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/WebFrameTest.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/WebFrameTest.cpp	(working copy)
@@ -36,9 +36,13 @@
 #include "Frame.h"
 #include "FrameTestHelpers.h"
 #include "FrameView.h"
+#include "PlatformContextSkia.h"
 #include "Range.h"
+#include "RenderView.h"
 #include "ResourceError.h"
 #include "Settings.h"
+#include "SkBitmap.h"
+#include "SkCanvas.h"
 #include "URLTestHelpers.h"
 #include "WebDataSource.h"
 #include "WebDocument.h"
@@ -68,6 +72,12 @@
 
 namespace {
 
+#define EXPECT_EQ_RECT(a, b) \
+    EXPECT_EQ(a.x(), b.x()); \
+    EXPECT_EQ(a.y(), b.y()); \
+    EXPECT_EQ(a.width(), b.width()); \
+    EXPECT_EQ(a.height(), b.height());
+
 class WebFrameTest : public testing::Test {
 public:
     WebFrameTest()
@@ -226,6 +236,34 @@
     WebScreenInfo m_screenInfo;
 };
 
+TEST_F(WebFrameTest, FrameViewNeedsLayoutOnFixedLayoutResize)
+{
+    registerMockedHttpURLLoad("fixed_layout.html");
+
+    FixedLayoutTestWebViewClient client;
+    int viewportWidth = 640;
+    int viewportHeight = 480;
+
+    // Make sure we initialize to minimum scale, even if the window size
+    // only becomes available after the load begins.
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "fixed_layout.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    webViewImpl->mainFrameImpl()->frameView()->setFixedLayoutSize(WebCore::IntSize(100, 100));
+    EXPECT_TRUE(webViewImpl->mainFrameImpl()->frameView()->needsLayout());
+
+    int prevLayoutCount = webViewImpl->mainFrameImpl()->frameView()->layoutCount();
+    webViewImpl->mainFrameImpl()->frameView()->setFrameRect(WebCore::IntRect(0, 0, 641, 481));
+    EXPECT_EQ(prevLayoutCount, webViewImpl->mainFrameImpl()->frameView()->layoutCount());
+
+    webViewImpl->layout();
+}
+
 TEST_F(WebFrameTest, DeviceScaleFactorUsesDefaultWithoutViewportTag)
 {
     registerMockedHttpURLLoad("no_viewport_tag.html");
@@ -238,6 +276,8 @@
 
     WebView* webView = static_cast<WebView*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "no_viewport_tag.html", true, 0, &client));
 
+    webView->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webView->settings()->setApplyPageScaleFactorInCompositor(true);
     webView->settings()->setViewportEnabled(true);
     webView->enableFixedLayoutMode(true);
     webView->resize(WebSize(viewportWidth, viewportHeight));
@@ -245,9 +285,11 @@
 
     EXPECT_EQ(2, webView->deviceScaleFactor());
 
-    // Device scale factor should be a component of page scale factor in fixed-layout, so a scale of 1 becomes 2.
+    // Device scale factor should be independent of page scale.
     webView->setPageScaleFactorLimits(1, 2);
-    EXPECT_EQ(2, webView->pageScaleFactor());
+    webView->setPageScaleFactorPreservingScrollOffset(0.5);
+    webView->layout();
+    EXPECT_EQ(1, webView->pageScaleFactor());
 
     // Force the layout to happen before leaving the test.
     webView->mainFrame()->contentAsText(1024).utf8();
@@ -305,8 +347,156 @@
     webViewImpl->layout();
 }
 
+TEST_F(WebFrameTest, setPageScaleFactorDoesNotLayout)
+{
+    registerMockedHttpURLLoad("fixed_layout.html");
+
+    FixedLayoutTestWebViewClient client;
+    client.m_screenInfo.deviceScaleFactor = 1;
+    int viewportWidth = 640;
+    int viewportHeight = 480;
+
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "fixed_layout.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    int prevLayoutCount = webViewImpl->mainFrameImpl()->frameView()->layoutCount();
+    webViewImpl->setPageScaleFactor(3, WebPoint());
+    EXPECT_EQ(false, webViewImpl->mainFrameImpl()->frameView()->needsLayout());
+    EXPECT_EQ(prevLayoutCount, webViewImpl->mainFrameImpl()->frameView()->layoutCount());
+}
+
+TEST_F(WebFrameTest, pageScaleFactorWrittenToHistoryItem)
+{
+    registerMockedHttpURLLoad("fixed_layout.html");
+
+    FixedLayoutTestWebViewClient client;
+    client.m_screenInfo.deviceScaleFactor = 1;
+    int viewportWidth = 640;
+    int viewportHeight = 480;
+
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "fixed_layout.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    webViewImpl->setPageScaleFactor(3, WebPoint());
+    webViewImpl->page()->mainFrame()->loader()->history()->saveDocumentAndScrollState();
+    webViewImpl->setPageScaleFactor(1, WebPoint());
+    webViewImpl->page()->mainFrame()->loader()->history()->restoreScrollPositionAndViewState();
+    EXPECT_EQ(3, webViewImpl->pageScaleFactor());
+}
+
+// Disabled, pending investigation after http://trac.webkit.org/changeset/141053
+TEST_F(WebFrameTest, DISABLED_pageScaleFactorShrinksViewport)
+{
+    registerMockedHttpURLLoad("fixed_layout.html");
+
+    FixedLayoutTestWebViewClient client;
+    client.m_screenInfo.deviceScaleFactor = 1;
+    int viewportWidth = 640;
+    int viewportHeight = 480;
+    int viewportWidthMinusScrollbar = 640 - 15;
+    int viewportHeightMinusScrollbar = 480 - 15;
+
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "fixed_layout.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    webViewImpl->setPageScaleFactor(2, WebPoint());
+
+    WebCore::IntSize unscaledSize = webViewImpl->mainFrameImpl()->frameView()->unscaledVisibleContentSize(true);
+    EXPECT_EQ(viewportWidth, unscaledSize.width());
+    EXPECT_EQ(viewportHeight, unscaledSize.height());
+
+    WebCore::IntSize unscaledSizeMinusScrollbar = webViewImpl->mainFrameImpl()->frameView()->unscaledVisibleContentSize(false);
+    EXPECT_EQ(viewportWidthMinusScrollbar, unscaledSizeMinusScrollbar.width());
+    EXPECT_EQ(viewportHeightMinusScrollbar, unscaledSizeMinusScrollbar.height());
+
+    WebCore::IntSize scaledSize = webViewImpl->mainFrameImpl()->frameView()->visibleContentRect().size();
+    EXPECT_EQ(ceil(viewportWidthMinusScrollbar / 2.0), scaledSize.width());
+    EXPECT_EQ(ceil(viewportHeightMinusScrollbar / 2.0), scaledSize.height());
+}
+
+TEST_F(WebFrameTest, pageScaleFactorDoesNotApplyCssTransform)
+{
+    registerMockedHttpURLLoad("fixed_layout.html");
+
+    FixedLayoutTestWebViewClient client;
+    client.m_screenInfo.deviceScaleFactor = 1;
+    int viewportWidth = 640;
+    int viewportHeight = 480;
+
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "fixed_layout.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    webViewImpl->setPageScaleFactor(2, WebPoint());
+
+    EXPECT_EQ(1, webViewImpl->page()->mainFrame()->frameScaleFactor());
+    EXPECT_EQ(980, webViewImpl->page()->mainFrame()->contentRenderer()->unscaledDocumentRect().width());
+    EXPECT_EQ(980, webViewImpl->mainFrameImpl()->frameView()->contentsSize().width());
+}
 #endif
 
+TEST_F(WebFrameTest, pageScaleFactorScalesPaintClip)
+{
+    registerMockedHttpURLLoad("fixed_layout.html");
+
+    FixedLayoutTestWebViewClient client;
+    client.m_screenInfo.deviceScaleFactor = 1;
+    int viewportWidth = 50;
+    int viewportHeight = 50;
+
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "fixed_layout.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->enableFixedLayoutMode(true);
+    webViewImpl->settings()->setViewportEnabled(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    // Set <1 page scale so that the clip rect should be larger than
+    // the viewport size as passed into resize().
+    webViewImpl->setPageScaleFactor(0.5, WebPoint());
+
+    SkBitmap bitmap;
+    bitmap.setConfig(SkBitmap::kARGB_8888_Config, 200, 200);
+    bitmap.allocPixels();
+    bitmap.eraseColor(0);
+    SkCanvas canvas(bitmap);
+
+    WebCore::PlatformContextSkia platformContext(&canvas);
+    platformContext.setTrackOpaqueRegion(true);
+    WebCore::GraphicsContext context(&platformContext);
+
+    EXPECT_EQ_RECT(WebCore::IntRect(0, 0, 0, 0), platformContext.opaqueRegion().asRect());
+
+    WebCore::FrameView* view = webViewImpl->mainFrameImpl()->frameView();
+    WebCore::IntRect paintRect(0, 0, 200, 200);
+    view->paint(&context, paintRect);
+
+    int viewportWidthMinusScrollbar = 50 - (view->verticalScrollbar()->isOverlayScrollbar() ? 0 : 15);
+    int viewportHeightMinusScrollbar = 50 - (view->horizontalScrollbar()->isOverlayScrollbar() ? 0 : 15);
+    WebCore::IntRect clippedRect(0, 0, viewportWidthMinusScrollbar * 2, viewportHeightMinusScrollbar * 2);
+    EXPECT_EQ_RECT(clippedRect, platformContext.opaqueRegion().asRect());
+}
+
 TEST_F(WebFrameTest, CanOverrideMaximumScaleFactor)
 {
     registerMockedHttpURLLoad("no_scale_for_you.html");
@@ -335,25 +525,27 @@
     webView->layout();
 }
 
-TEST_F(WebFrameTest, DivAutoZoomParamsTest)
+TEST_F(WebFrameTest, DivAutoZoomParamsTestCompositorScaling)
 {
     registerMockedHttpURLLoad("get_scale_for_auto_zoom_into_div_test.html");
 
-    int viewportWidth = 640;
-    int viewportHeight = 480;
-    WebKit::WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "get_scale_for_auto_zoom_into_div_test.html");
+    const float deviceScaleFactor = 2.0f;
+    int viewportWidth = 640 / deviceScaleFactor;
+    int viewportHeight = 1280 / deviceScaleFactor;
+    WebKit::WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "get_scale_for_auto_zoom_into_div_test.html"); //
+    webView->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webView->settings()->setApplyPageScaleFactorInCompositor(true);
+    webView->setDeviceScaleFactor(deviceScaleFactor);
+    webView->setPageScaleFactorLimits(0.01f, 4);
+    webView->setPageScaleFactor(0.5f, WebPoint(0, 0));
+    webView->resize(WebSize(viewportWidth, viewportHeight));
     webView->enableFixedLayoutMode(true);
-    webView->setDeviceScaleFactor(2.0f);
-    webView->resize(WebSize(viewportWidth, viewportHeight));
-    webView->setPageScaleFactorLimits(0.01f, 4);
     webView->layout();
 
     WebRect wideDiv(200, 100, 400, 150);
     WebRect tallDiv(200, 300, 400, 800);
-    WebRect doubleTapPointWide((wideDiv.x + 50) * webView->pageScaleFactor(),
-        (wideDiv.y + 50) * webView->pageScaleFactor(), 0, 0);
-    WebRect doubleTapPointTall((tallDiv.x + 50) * webView->pageScaleFactor(),
-        (tallDiv.y + 50) * webView->pageScaleFactor(), 0, 0);
+    WebRect doubleTapPointWide(wideDiv.x + 50, wideDiv.y + 50, 0, 0);
+    WebRect doubleTapPointTall(tallDiv.x + 50, tallDiv.y + 50, 0, 0);
     float scale;
     WebPoint scroll;
     bool isAnchor;
@@ -364,9 +556,8 @@
     // The div should horizontally fill the screen (modulo margins), and
     // vertically centered (modulo integer rounding).
     EXPECT_NEAR(viewportWidth / (float) wideDiv.width, scale, 0.1);
-    EXPECT_NEAR(wideDiv.x * scale, scroll.x, 20);
-    int vScroll = (wideDiv.y + wideDiv.height / 2) * scale - (viewportHeight / 2);
-    EXPECT_NEAR(vScroll, scroll.y, 1);
+    EXPECT_NEAR(wideDiv.x, scroll.x, 20);
+    EXPECT_EQ(0, scroll.y);
     EXPECT_FALSE(isAnchor);
 
     setScaleAndScrollAndLayout(webViewImpl, scroll, scale);
@@ -382,8 +573,8 @@
     webViewImpl->computeScaleAndScrollForHitRect(doubleTapPointTall, WebViewImpl::DoubleTap, scale, scroll, isAnchor);
     // The div should start at the top left of the viewport.
     EXPECT_NEAR(viewportWidth / (float) tallDiv.width, scale, 0.1);
-    EXPECT_NEAR(tallDiv.x * scale, scroll.x, 20);
-    EXPECT_NEAR(tallDiv.y * scale, scroll.y, 20);
+    EXPECT_NEAR(tallDiv.x, scroll.x, 20);
+    EXPECT_NEAR(tallDiv.y, scroll.y, 20);
     EXPECT_FALSE(isAnchor);
 
     // Test for Non-doubletap scaling
@@ -401,19 +592,23 @@
     scale = webViewImpl->pageScaleFactor();
 }
 
-TEST_F(WebFrameTest, DivAutoZoomMultipleDivsTest)
+TEST_F(WebFrameTest, DivAutoZoomMultipleDivsTestCompositorScaling)
 {
     registerMockedHttpURLLoad("get_multiple_divs_for_auto_zoom_test.html");
 
-    int viewportWidth = 640;
-    int viewportHeight = 480;
+    const float deviceScaleFactor = 2.0f;
+    int viewportWidth = 640 / deviceScaleFactor;
+    int viewportHeight = 1280 / deviceScaleFactor;
     float doubleTapZoomAlreadyLegibleRatio = 1.2f;
     WebKit::WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "get_multiple_divs_for_auto_zoom_test.html");
+    webView->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webView->settings()->setApplyPageScaleFactorInCompositor(true);
     webView->enableFixedLayoutMode(true);
     webView->resize(WebSize(viewportWidth, viewportHeight));
-    webView->setPageScaleFactorLimits(1, 4);
+    webView->setPageScaleFactorLimits(0.5f, 4);
+    webView->setDeviceScaleFactor(deviceScaleFactor);
+    webView->setPageScaleFactor(0.5f, WebPoint(0, 0));
     webView->layout();
-    webView->setDeviceScaleFactor(1.5f);
 
     WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(webView);
     webViewImpl->shouldUseAnimateDoubleTapTimeZeroForTesting(true);
@@ -428,54 +623,57 @@
     // Test double tap on two different divs
     // After first zoom, we should go back to minimum page scale with a second double tap.
     simulateDoubleTap(webViewImpl, topPoint, scale);
-    EXPECT_FLOAT_EQ(webViewImpl->deviceScaleFactor(), scale);
+    EXPECT_FLOAT_EQ(1, scale);
     simulateDoubleTap(webViewImpl, bottomPoint, scale);
     EXPECT_FLOAT_EQ(webViewImpl->minimumPageScaleFactor(), scale);
 
     // If the user pinch zooms after double tap, a second double tap should zoom back to the div.
     simulateDoubleTap(webViewImpl, topPoint, scale);
-    EXPECT_FLOAT_EQ(webViewImpl->deviceScaleFactor(), scale);
+    EXPECT_FLOAT_EQ(1, scale);
     webViewImpl->applyScrollAndScale(WebSize(), 0.6f);
     simulateDoubleTap(webViewImpl, bottomPoint, scale);
-    EXPECT_FLOAT_EQ(webViewImpl->deviceScaleFactor(), scale);
+    EXPECT_FLOAT_EQ(1, scale);
 }
 
-TEST_F(WebFrameTest, DivAutoZoomScaleBoundsTest)
+TEST_F(WebFrameTest, DivAutoZoomScaleBoundsTestCompositorScaling)
 {
     registerMockedHttpURLLoad("get_scale_bounds_check_for_auto_zoom_test.html");
 
-    int viewportWidth = 640;
+    int viewportWidth = 320;
     int viewportHeight = 480;
     float doubleTapZoomAlreadyLegibleRatio = 1.2f;
     WebKit::WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "get_scale_bounds_check_for_auto_zoom_test.html");
+    webView->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webView->settings()->setApplyPageScaleFactorInCompositor(true);
     webView->enableFixedLayoutMode(true);
     webView->resize(WebSize(viewportWidth, viewportHeight));
-    webView->setPageScaleFactorLimits(1, 4);
+    webView->setDeviceScaleFactor(1.5f);
     webView->layout();
 
     WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(webView);
     webViewImpl->shouldUseAnimateDoubleTapTimeZeroForTesting(true);
-    float doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
 
     WebRect div(200, 100, 200, 150);
     WebPoint doubleTapPoint(div.x + 50, div.y + 50);
     float scale;
 
     // Test double tap scale bounds.
-    // minimumPageScale < doubleTapZoomAlreadyLegibleScale < deviceDpiScale
-    webViewImpl->setDeviceScaleFactor(1.5f);
+    // minimumPageScale < doubleTapZoomAlreadyLegibleScale < 1
+    webView->setPageScaleFactorLimits(0.5f, 4);
+    float doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
-    EXPECT_FLOAT_EQ(webViewImpl->deviceScaleFactor(), scale);
+    EXPECT_FLOAT_EQ(1, scale);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(webViewImpl->minimumPageScaleFactor(), scale);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
-    EXPECT_FLOAT_EQ(webViewImpl->deviceScaleFactor(), scale);
+    EXPECT_FLOAT_EQ(1, scale);
 
     // Zoom in to reset double_tap_zoom_in_effect flag.
     webViewImpl->applyScrollAndScale(WebSize(), 1.1f);
-    // deviceDpiScale < minimumPageScale < doubleTapZoomAlreadyLegibleScale
-    webViewImpl->setDeviceScaleFactor(0.5f);
+    // 1 < minimumPageScale < doubleTapZoomAlreadyLegibleScale
+    webView->setPageScaleFactorLimits(1.1f, 4);
+    doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(webViewImpl->minimumPageScaleFactor(), scale);
@@ -486,8 +684,9 @@
 
     // Zoom in to reset double_tap_zoom_in_effect flag.
     webViewImpl->applyScrollAndScale(WebSize(), 1.1f);
-    // minimumPageScale < deviceDpiScale < doubleTapZoomAlreadyLegibleScale
-    webViewImpl->setDeviceScaleFactor(1.1f);
+    // minimumPageScale < 1 < doubleTapZoomAlreadyLegibleScale
+    webView->setPageScaleFactorLimits(0.95f, 4);
+    doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(webViewImpl->minimumPageScaleFactor(), scale);
@@ -498,34 +697,35 @@
 }
 
 #if ENABLE(TEXT_AUTOSIZING)
-TEST_F(WebFrameTest, DivAutoZoomScaleFontScaleFactorTest)
+TEST_F(WebFrameTest, DivAutoZoomScaleFontScaleFactorTestCompositorScaling)
 {
     registerMockedHttpURLLoad("get_scale_bounds_check_for_auto_zoom_test.html");
 
-    int viewportWidth = 640;
+    int viewportWidth = 320;
     int viewportHeight = 480;
     float doubleTapZoomAlreadyLegibleRatio = 1.2f;
     float textAutosizingFontScaleFactor = 1.13f;
     WebKit::WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "get_scale_bounds_check_for_auto_zoom_test.html");
+    webView->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webView->settings()->setApplyPageScaleFactorInCompositor(true);
     webView->enableFixedLayoutMode(true);
     webView->resize(WebSize(viewportWidth, viewportHeight));
-    webView->setPageScaleFactorLimits(1, 4);
     webView->layout();
 
     WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(webView);
     webViewImpl->shouldUseAnimateDoubleTapTimeZeroForTesting(true);
     webViewImpl->page()->settings()->setTextAutosizingFontScaleFactor(textAutosizingFontScaleFactor);
-    float doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
 
     WebRect div(200, 100, 200, 150);
     WebPoint doubleTapPoint(div.x + 50, div.y + 50);
     float scale;
 
     // Test double tap scale bounds.
-    // minimumPageScale < doubleTapZoomAlreadyLegibleScale < deviceDpiScale < deviceDpiScale * textAutosizingFontScaleFactor
-    webViewImpl->setDeviceScaleFactor(1.5f);
-    float legibleScale = webViewImpl->deviceScaleFactor() * textAutosizingFontScaleFactor;
+    // minimumPageScale < doubleTapZoomAlreadyLegibleScale < 1 < textAutosizingFontScaleFactor
+    float legibleScale = textAutosizingFontScaleFactor;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
+    webView->setPageScaleFactorLimits(0.5f, 4);
+    float doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(legibleScale, scale);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
@@ -535,9 +735,9 @@
 
     // Zoom in to reset double_tap_zoom_in_effect flag.
     webViewImpl->applyScrollAndScale(WebSize(), 1.1f);
-    // deviceDpiScale < deviceDpiScale * textAutosizingFontScaleFactor < minimumPageScale < doubleTapZoomAlreadyLegibleScale
-    webViewImpl->setDeviceScaleFactor(0.5f);
-    legibleScale = webViewImpl->deviceScaleFactor() * textAutosizingFontScaleFactor;
+    // 1 < textAutosizingFontScaleFactor < minimumPageScale < doubleTapZoomAlreadyLegibleScale
+    webView->setPageScaleFactorLimits(1.0f, 4);
+    doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(webViewImpl->minimumPageScaleFactor(), scale);
@@ -548,9 +748,9 @@
 
     // Zoom in to reset double_tap_zoom_in_effect flag.
     webViewImpl->applyScrollAndScale(WebSize(), 1.1f);
-    // minimumPageScale < deviceDpiScale < deviceDpiScale * textAutosizingFontScaleFactor < doubleTapZoomAlreadyLegibleScale
-    webViewImpl->setDeviceScaleFactor(1.05f);
-    legibleScale = webViewImpl->deviceScaleFactor() * textAutosizingFontScaleFactor;
+    // minimumPageScale < 1 < textAutosizingFontScaleFactor < doubleTapZoomAlreadyLegibleScale
+    webView->setPageScaleFactorLimits(0.95f, 4);
+    doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(webViewImpl->minimumPageScaleFactor(), scale);
@@ -561,9 +761,9 @@
 
     // Zoom in to reset double_tap_zoom_in_effect flag.
     webViewImpl->applyScrollAndScale(WebSize(), 1.1f);
-    // minimumPageScale < deviceDpiScale < doubleTapZoomAlreadyLegibleScale < deviceDpiScale * textAutosizingFontScaleFactor
-    webViewImpl->setDeviceScaleFactor(1.1f);
-    legibleScale = webViewImpl->deviceScaleFactor() * textAutosizingFontScaleFactor;
+    // minimumPageScale < 1 < doubleTapZoomAlreadyLegibleScale < textAutosizingFontScaleFactor
+    webView->setPageScaleFactorLimits(0.9f, 4);
+    doubleTapZoomAlreadyLegibleScale = webViewImpl->minimumPageScaleFactor() * doubleTapZoomAlreadyLegibleRatio;
     setScaleAndScrollAndLayout(webViewImpl, WebPoint(0, 0), (webViewImpl->minimumPageScaleFactor()) * (1 + doubleTapZoomAlreadyLegibleRatio) / 2);
     simulateDoubleTap(webViewImpl, doubleTapPoint, scale);
     EXPECT_FLOAT_EQ(legibleScale, scale);
@@ -574,22 +774,21 @@
 }
 #endif
 
-// This test depends on code that is compiled conditionally. We likely need to
-// add the proper ifdef when re-enabling it. See
-// https://bugs.webkit.org/show_bug.cgi?id=98558
-TEST_F(WebFrameTest, DISABLED_DivScrollIntoEditableTest)
+TEST_F(WebFrameTest, DivScrollIntoEditableTest)
 {
     registerMockedHttpURLLoad("get_scale_for_zoom_into_editable_test.html");
 
-    int viewportWidth = 640;
-    int viewportHeight = 480;
+    int viewportWidth = 450;
+    int viewportHeight = 300;
     float leftBoxRatio = 0.3f;
     int caretPadding = 10;
-    int minReadableCaretHeight = 18;
+    float minReadableCaretHeight = 18.0f;
     WebKit::WebView* webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + "get_scale_for_zoom_into_editable_test.html");
+    webView->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webView->settings()->setApplyPageScaleFactorInCompositor(true);
     webView->enableFixedLayoutMode(true);
     webView->resize(WebSize(viewportWidth, viewportHeight));
-    webView->setPageScaleFactorLimits(1, 10);
+    webView->setPageScaleFactorLimits(1, 4);
     webView->layout();
     webView->setDeviceScaleFactor(1.5f);
     webView->settings()->setAutoZoomFocusedNodeToLegibleScale(true);
@@ -602,46 +801,60 @@
 
     // Test scrolling the focused node
     // The edit box is shorter and narrower than the viewport when legible.
+    webView->advanceFocus(false);
+    // Set the caret to the end of the input box.
+    webView->mainFrame()->document().getElementById("EditBoxWithText").to<WebInputElement>().setSelectionRange(1000, 1000);
     setScaleAndScrollAndLayout(webView, WebPoint(0, 0), 1);
     WebRect rect, caret;
     webViewImpl->selectionBounds(caret, rect);
-    webView->scrollFocusedNodeIntoRect(rect);
+
+    float scale;
+    WebCore::IntPoint scroll;
+    bool needAnimation;
+    webViewImpl->computeScaleAndScrollForFocusedNode(webViewImpl->focusedWebCoreNode(), scale, scroll, needAnimation);
+    EXPECT_TRUE(needAnimation);
     // The edit box should be left aligned with a margin for possible label.
-    int hScroll = editBoxWithText.x * webView->pageScaleFactor() - leftBoxRatio * viewportWidth;
-    EXPECT_EQ(hScroll, webView->mainFrame()->scrollOffset().width);
-    int vScroll = editBoxWithText.y * webView->pageScaleFactor() - (viewportHeight - editBoxWithText.height * webView->pageScaleFactor()) / 2;
-    EXPECT_EQ(vScroll, webView->mainFrame()->scrollOffset().height);
-    EXPECT_FLOAT_EQ(webView->deviceScaleFactor() * minReadableCaretHeight / caret.height, webView->pageScaleFactor());
+    int hScroll = editBoxWithText.x - leftBoxRatio * viewportWidth / scale;
+    EXPECT_NEAR(hScroll, scroll.x(), 1);
+    int vScroll = editBoxWithText.y - (viewportHeight / scale - editBoxWithText.height) / 2;
+    EXPECT_NEAR(vScroll, scroll.y(), 1);
+    EXPECT_NEAR(minReadableCaretHeight / caret.height, scale, 0.1);
 
     // The edit box is wider than the viewport when legible.
-    webView->setDeviceScaleFactor(4);
+    viewportWidth = 200;
+    viewportHeight = 150;
+    webView->resize(WebSize(viewportWidth, viewportHeight));
     setScaleAndScrollAndLayout(webView, WebPoint(0, 0), 1);
     webViewImpl->selectionBounds(caret, rect);
-    webView->scrollFocusedNodeIntoRect(rect);
+    webViewImpl->computeScaleAndScrollForFocusedNode(webViewImpl->focusedWebCoreNode(), scale, scroll, needAnimation);
+    EXPECT_TRUE(needAnimation);
     // The caret should be right aligned since the caret would be offscreen when the edit box is left aligned.
-    hScroll = (caret.x + caret.width) * webView->pageScaleFactor() + caretPadding - viewportWidth;
-    EXPECT_EQ(hScroll, webView->mainFrame()->scrollOffset().width);
-    EXPECT_FLOAT_EQ(webView->deviceScaleFactor() * minReadableCaretHeight / caret.height, webView->pageScaleFactor());
+    hScroll = caret.x + caret.width + caretPadding - viewportWidth / scale;
+    EXPECT_NEAR(hScroll, scroll.x(), 1);
+    EXPECT_NEAR(minReadableCaretHeight / caret.height, scale, 0.1);
 
     setScaleAndScrollAndLayout(webView, WebPoint(0, 0), 1);
     // Move focus to edit box with text.
     webView->advanceFocus(false);
     webViewImpl->selectionBounds(caret, rect);
-    webView->scrollFocusedNodeIntoRect(rect);
+    webViewImpl->computeScaleAndScrollForFocusedNode(webViewImpl->focusedWebCoreNode(), scale, scroll, needAnimation);
+    EXPECT_TRUE(needAnimation);
     // The edit box should be left aligned.
-    hScroll = editBoxWithNoText.x * webView->pageScaleFactor();
-    EXPECT_EQ(hScroll, webView->mainFrame()->scrollOffset().width);
-    vScroll = editBoxWithNoText.y * webView->pageScaleFactor() - (viewportHeight - editBoxWithNoText.height * webView->pageScaleFactor()) / 2;
-    EXPECT_EQ(vScroll, webView->mainFrame()->scrollOffset().height);
-    EXPECT_FLOAT_EQ(webView->deviceScaleFactor() * minReadableCaretHeight / caret.height, webView->pageScaleFactor());
+    hScroll = editBoxWithNoText.x;
+    EXPECT_NEAR(hScroll, scroll.x(), 1);
+    vScroll = editBoxWithNoText.y - (viewportHeight / scale - editBoxWithNoText.height) / 2;
+    EXPECT_NEAR(vScroll, scroll.y(), 1);
+    EXPECT_NEAR(minReadableCaretHeight / caret.height, scale, 0.1);
 
+    setScaleAndScrollAndLayout(webViewImpl, scroll, scale);
+
     // Move focus back to the first edit box.
     webView->advanceFocus(true);
-    webViewImpl->selectionBounds(caret, rect);
+    webViewImpl->computeScaleAndScrollForFocusedNode(webViewImpl->focusedWebCoreNode(), scale, scroll, needAnimation);
     // The position should have stayed the same since this box was already on screen with the right scale.
-    EXPECT_EQ(vScroll, webView->mainFrame()->scrollOffset().height);
-    EXPECT_EQ(hScroll, webView->mainFrame()->scrollOffset().width);
+    EXPECT_FALSE(needAnimation);
 }
+
 #endif
 
 class TestReloadDoesntRedirectWebFrameClient : public WebFrameClient {
@@ -1611,6 +1824,41 @@
     webView->close();
 }
 
+#if OS(ANDROID)
+TEST_F(WebFrameTest, MoveCaretStaysHorizontallyAlignedWhenMoved)
+{
+    WebView* webView;
+    WebFrameImpl* frame;
+    registerMockedHttpURLLoad("move_caret.html");
+
+    webView = createWebViewForTextSelection(m_baseURL + "move_caret.html");
+    frame = (WebFrameImpl*)webView->mainFrame();
+
+    WebRect initialStartRect;
+    WebRect initialEndRect;
+    WebRect startRect;
+    WebRect endRect;
+
+    frame->executeScript(WebScriptSource("select();"));
+    webView->selectionBounds(initialStartRect, initialEndRect);
+    WebPoint moveTo(topLeft(initialStartRect));
+
+    moveTo.y += 40;
+    frame->moveCaretSelectionTowardsWindowPoint(moveTo);
+    webView->selectionBounds(startRect, endRect);
+    EXPECT_EQ(startRect, initialStartRect);
+    EXPECT_EQ(endRect, initialEndRect);
+
+    moveTo.y -= 80;
+    frame->moveCaretSelectionTowardsWindowPoint(moveTo);
+    webView->selectionBounds(startRect, endRect);
+    EXPECT_EQ(startRect, initialStartRect);
+    EXPECT_EQ(endRect, initialEndRect);
+
+    webView->close();
+}
+#endif
+
 class DisambiguationPopupTestWebViewClient : public WebViewClient {
 public:
     virtual bool didTapMultipleTargets(const WebGestureEvent&, const WebVector<WebRect>& targetRects) OVERRIDE
@@ -1646,6 +1894,8 @@
     // Make sure we initialize to minimum scale, even if the window size
     // only becomes available after the load begins.
     WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + htmlFile, true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
     webViewImpl->resize(WebSize(1000, 1000));
     webViewImpl->layout();
 
@@ -1690,6 +1940,8 @@
     // Make sure we initialize to minimum scale, even if the window size
     // only becomes available after the load begins.
     WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "disambiguation_popup_no_container.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
     webViewImpl->resize(WebSize(1000, 1000));
     webViewImpl->layout();
 
@@ -1698,7 +1950,7 @@
     EXPECT_FALSE(client.triggered());
 }
 
-TEST_F(WebFrameTest, DisambiguationPopupMobileSite)
+TEST_F(WebFrameTest, DISABLED_DisambiguationPopupMobileSite)
 {
     const std::string htmlFile = "disambiguation_popup_mobile_site.html";
     registerMockedHttpURLLoad(htmlFile);
@@ -1708,6 +1960,8 @@
     // Make sure we initialize to minimum scale, even if the window size
     // only becomes available after the load begins.
     WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + htmlFile, true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
     webViewImpl->resize(WebSize(1000, 1000));
     webViewImpl->layout();
 
@@ -1732,6 +1986,74 @@
     }
 }
 
+TEST_F(WebFrameTest, DisambiguationPopupBlacklist)
+{
+    const unsigned viewportWidth = 500;
+    const unsigned viewportHeight = 1000;
+    const unsigned divHeight = 100;
+    const std::string htmlFile = "disambiguation_popup_blacklist.html";
+    registerMockedHttpURLLoad(htmlFile);
+
+    DisambiguationPopupTestWebViewClient client;
+
+    // Make sure we initialize to minimum scale, even if the window size
+    // only becomes available after the load begins.
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + htmlFile, true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->resize(WebSize(viewportWidth, viewportHeight));
+    webViewImpl->layout();
+
+    // Click somewhere where the popup shouldn't appear.
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(viewportWidth / 2, 0));
+    EXPECT_FALSE(client.triggered());
+
+    // Click directly in between two container divs with click handlers, with children that don't handle clicks.
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(viewportWidth / 2, divHeight));
+    EXPECT_TRUE(client.triggered());
+
+    // The third div container should be blacklisted if you click on the link it contains.
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(viewportWidth / 2, divHeight * 3.25));
+    EXPECT_FALSE(client.triggered());
+}
+
+TEST_F(WebFrameTest, DisambiguationPopupPageScale)
+{
+    registerMockedHttpURLLoad("disambiguation_popup_page_scale.html");
+
+    DisambiguationPopupTestWebViewClient client;
+
+    // Make sure we initialize to minimum scale, even if the window size
+    // only becomes available after the load begins.
+    WebViewImpl* webViewImpl = static_cast<WebViewImpl*>(FrameTestHelpers::createWebViewAndLoad(m_baseURL + "disambiguation_popup_page_scale.html", true, 0, &client));
+    webViewImpl->settings()->setApplyDeviceScaleFactorInCompositor(true);
+    webViewImpl->settings()->setApplyPageScaleFactorInCompositor(true);
+    webViewImpl->resize(WebSize(1000, 1000));
+    webViewImpl->layout();
+
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(80, 80));
+    EXPECT_TRUE(client.triggered());
+
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(230, 190));
+    EXPECT_TRUE(client.triggered());
+
+    webViewImpl->setPageScaleFactor(3.0f, WebPoint(0, 0));
+    webViewImpl->layout();
+
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(240, 240));
+    EXPECT_TRUE(client.triggered());
+
+    client.resetTriggered();
+    webViewImpl->handleInputEvent(fatTap(690, 570));
+    EXPECT_FALSE(client.triggered());
+}
+
 class TestSubstituteDataWebFrameClient : public WebFrameClient {
 public:
     TestSubstituteDataWebFrameClient()
@@ -1791,4 +2113,13 @@
     EXPECT_TRUE(webFrameClient.commitCalled());
 }
 
+TEST_F(WebFrameTest, MoveCaretSelectionTowardsWindowPointWithNoSelection)
+{
+    WebView* webView = FrameTestHelpers::createWebViewAndLoad("about:blank", true);
+    WebFrame* frame = webView->mainFrame();
+
+    // This test passes if this doesn't crash.
+    frame->moveCaretSelectionTowardsWindowPoint(WebPoint(0, 0));
+}
+
 } // namespace
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/LinkHighlightTest.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/LinkHighlightTest.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/LinkHighlightTest.cpp	(working copy)
@@ -27,12 +27,15 @@
 #include "LinkHighlight.h"
 
 #include "FrameTestHelpers.h"
+#include "FrameView.h"
 #include "IntRect.h"
 #include "Node.h"
 #include "URLTestHelpers.h"
 #include "WebCompositorInitializer.h"
 #include "WebFrame.h"
+#include "WebFrameImpl.h"
 #include "WebInputEvent.h"
+#include "WebInputEventConversion.h"
 #include "WebViewImpl.h"
 #include <gtest/gtest.h>
 #include <public/WebContentLayer.h>
@@ -61,20 +64,32 @@
     webViewImpl->layout();
 
     WebGestureEvent touchEvent;
+    touchEvent.type = WebInputEvent::GestureTapDown;
 
     // The coordinates below are linked to absolute positions in the referenced .html file.
     touchEvent.x = 20;
     touchEvent.y = 20;
-    Node* touchNode = webViewImpl->bestTouchLinkNode(touchEvent);
-    ASSERT_TRUE(touchNode);
 
+    {
+        PlatformGestureEventBuilder platformEvent(webViewImpl->mainFrameImpl()->frameView(), touchEvent);
+        Node* touchNode = webViewImpl->bestTapNode(platformEvent);
+        ASSERT_TRUE(touchNode);
+    }
+
     touchEvent.y = 40;
-    EXPECT_FALSE(webViewImpl->bestTouchLinkNode(touchEvent));
+    {
+        PlatformGestureEventBuilder platformEvent(webViewImpl->mainFrameImpl()->frameView(), touchEvent);
+        EXPECT_FALSE(webViewImpl->bestTapNode(platformEvent));
+    }
 
     touchEvent.y = 20;
     // Shouldn't crash.
 
-    webViewImpl->enableTouchHighlight(touchEvent);
+    {
+        PlatformGestureEventBuilder platformEvent(webViewImpl->mainFrameImpl()->frameView(), touchEvent);
+        webViewImpl->enableTapHighlight(platformEvent);
+    }
+
     EXPECT_TRUE(webViewImpl->linkHighlight());
     EXPECT_TRUE(webViewImpl->linkHighlight()->contentLayer());
     EXPECT_TRUE(webViewImpl->linkHighlight()->clipLayer());
@@ -82,16 +97,26 @@
     // Find a target inside a scrollable div
 
     touchEvent.y = 100;
-    webViewImpl->enableTouchHighlight(touchEvent);
+    {
+        PlatformGestureEventBuilder platformEvent(webViewImpl->mainFrameImpl()->frameView(), touchEvent);
+        webViewImpl->enableTapHighlight(platformEvent);
+    }
+
     ASSERT_TRUE(webViewImpl->linkHighlight());
 
     // Don't highlight if no "hand cursor"
     touchEvent.y = 220; // An A-link with cross-hair cursor.
-    webViewImpl->enableTouchHighlight(touchEvent);
+    {
+        PlatformGestureEventBuilder platformEvent(webViewImpl->mainFrameImpl()->frameView(), touchEvent);
+        webViewImpl->enableTapHighlight(platformEvent);
+    }
     ASSERT_FALSE(webViewImpl->linkHighlight());
 
     touchEvent.y = 260; // A text input box.
-    webViewImpl->enableTouchHighlight(touchEvent);
+    {
+        PlatformGestureEventBuilder platformEvent(webViewImpl->mainFrameImpl()->frameView(), touchEvent);
+        webViewImpl->enableTapHighlight(platformEvent);
+    }
     ASSERT_FALSE(webViewImpl->linkHighlight());
 
     webViewImpl->close();
Index: src/third_party/WebKit/Source/WebKit/gtk/WebCoreSupport/EditorClientGtk.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/gtk/WebCoreSupport/EditorClientGtk.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/gtk/WebCoreSupport/EditorClientGtk.cpp	(working copy)
@@ -262,12 +262,7 @@
     setSelectionPrimaryClipboardIfNeeded(m_webView);
 #endif
 
-    if (!frame->editor()->hasComposition() || frame->editor()->ignoreCompositionSelectionChange())
-        return;
-
-    unsigned start;
-    unsigned end;
-    if (!frame->editor()->getCompositionSelection(start, end))
+    if (frame->editor()->cancelCompositionIfSelectionIsInvalid())
         m_webView->priv->imFilter.resetContext();
 }
 
Index: src/third_party/WebKit/Source/WebKit/win/WebView.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/win/WebView.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/win/WebView.cpp	(working copy)
@@ -5471,15 +5471,11 @@
 void WebView::updateSelectionForIME()
 {
     Frame* targetFrame = m_page->focusController()->focusedOrMainFrame();
-    if (!targetFrame || !targetFrame->editor()->hasComposition())
-        return;
     
-    if (targetFrame->editor()->ignoreCompositionSelectionChange())
+    if (!targetFrame)
         return;
 
-    unsigned start;
-    unsigned end;
-    if (!targetFrame->editor()->getCompositionSelection(start, end))
+    if (!targetFrame->editor()->cancelCompositionIfSelectionIsInvalid())
         resetIME(targetFrame);
 }
 
Index: src/third_party/WebKit/Source/WebKit/mac/WebView/WebHTMLView.mm
===================================================================
--- src/third_party/WebKit/Source/WebKit/mac/WebView/WebHTMLView.mm	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/mac/WebView/WebHTMLView.mm	(working copy)
@@ -6037,12 +6037,9 @@
 
     [self _updateSecureInputState];
 
-    if (!coreFrame->editor()->hasComposition())
+    if (!coreFrame->editor()->hasComposition() || coreFrame->editor()->ignoreCompositionSelectionChange())
         return;
 
-    if (coreFrame->editor()->ignoreCompositionSelectionChange())
-        return;
-
     unsigned start;
     unsigned end;
     if (coreFrame->editor()->getCompositionSelection(start, end))
Index: src/third_party/WebKit/Source/WebKit/efl/WebCoreSupport/EditorClientEfl.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/efl/WebCoreSupport/EditorClientEfl.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebKit/efl/WebCoreSupport/EditorClientEfl.cpp	(working copy)
@@ -152,14 +152,7 @@
     Evas_Object* webFrame = EWKPrivate::kitFrame(coreFrame);
     ewk_frame_editor_client_selection_changed(webFrame);
 
-    if (!coreFrame->editor()->hasComposition() || coreFrame->editor()->ignoreCompositionSelectionChange())
-        return;
-
-    unsigned start;
-    unsigned end;
-
-    if (!coreFrame->editor()->getCompositionSelection(start, end))
-        coreFrame->editor()->cancelComposition();
+    coreFrame->editor()->cancelCompositionIfSelectionIsInvalid();
 }
 
 void EditorClientEfl::didEndEditing()
Index: src/third_party/WebKit/Source/WebCore/inspector/InspectorPageAgent.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/InspectorPageAgent.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/InspectorPageAgent.h	(working copy)
@@ -111,6 +111,8 @@
     virtual void setShowPaintRects(ErrorString*, bool show);
     virtual void canShowFPSCounter(ErrorString*, bool*);
     virtual void setShowFPSCounter(ErrorString*, bool show);
+    virtual void canContinuouslyPaint(ErrorString*, bool*);
+    virtual void setContinuousPaintingEnabled(ErrorString*, bool enabled);
     virtual void getScriptExecutionStatus(ErrorString*, PageCommandHandler::Result::Enum*);
     virtual void setScriptExecutionDisabled(ErrorString*, bool);
     virtual void setGeolocationOverride(ErrorString*, const double*, const double*, const double*);
Index: src/third_party/WebKit/Source/WebCore/inspector/front-end/Settings.js
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/front-end/Settings.js	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/front-end/Settings.js	(working copy)
@@ -58,7 +58,8 @@
     timelineCanMonitorMainThread: false,
     canOverrideGeolocation: false,
     canOverrideDeviceOrientation: false,
-    canShowFPSCounter: false
+    canShowFPSCounter: false,
+    canContinuouslyPaint: false
 }
 
 /**
@@ -97,6 +98,7 @@
     this.showScriptFolders = this.createSetting("showScriptFolders", true);
     this.emulateTouchEvents = this.createSetting("emulateTouchEvents", false);
     this.showPaintRects = this.createSetting("showPaintRects", false);
+    this.continuousPainting = this.createSetting("continuousPainting", false);
     this.showFPSCounter = this.createSetting("showFPSCounter", false);
     this.showShadowDOM = this.createSetting("showShadowDOM", false);
     this.zoomLevel = this.createSetting("zoomLevel", 0);
Index: src/third_party/WebKit/Source/WebCore/inspector/front-end/SettingsScreen.js
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/front-end/SettingsScreen.js	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/front-end/SettingsScreen.js	(working copy)
@@ -293,6 +293,10 @@
         p.appendChild(this._createCheckboxSetting(WebInspector.UIString("Show FPS meter"), WebInspector.settings.showFPSCounter));
         WebInspector.settings.showFPSCounter.addChangeListener(this._showFPSCounterChanged, this);
     }
+    if (Capabilities.canContinuouslyPaint) {
+        p.appendChild(this._createCheckboxSetting(WebInspector.UIString("Enable continuous page repainting"), WebInspector.settings.continuousPainting));
+        WebInspector.settings.continuousPainting.addChangeListener(this._continuousPaintingChanged, this);
+    }
 
     p = this._appendSection(WebInspector.UIString("Sources"));
     p.appendChild(this._createCheckboxSetting(WebInspector.UIString("Show folders"), WebInspector.settings.showScriptFolders));
@@ -341,6 +345,11 @@
         PageAgent.setShowFPSCounter(WebInspector.settings.showFPSCounter.get());
     },
 
+    _continuousPaintingChanged: function()
+    {
+        PageAgent.setContinuousPaintingEnabled(WebInspector.settings.continuousPainting.get());
+    },
+
     _updateScriptDisabledCheckbox: function()
     {
         function executionStatusCallback(error, status)
Index: src/third_party/WebKit/Source/WebCore/inspector/front-end/inspector.js
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/front-end/inspector.js	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/front-end/inspector.js	(working copy)
@@ -372,6 +372,7 @@
     TimelineAgent.supportsFrameInstrumentation(WebInspector._initializeCapability.bind(WebInspector, "timelineSupportsFrameInstrumentation", null));
     TimelineAgent.canMonitorMainThread(WebInspector._initializeCapability.bind(WebInspector, "timelineCanMonitorMainThread", null));
     PageAgent.canShowFPSCounter(WebInspector._initializeCapability.bind(WebInspector, "canShowFPSCounter", null));
+    PageAgent.canContinuouslyPaint(WebInspector._initializeCapability.bind(WebInspector, "canContinuouslyPaint", null));
     PageAgent.canOverrideDeviceMetrics(WebInspector._initializeCapability.bind(WebInspector, "canOverrideDeviceMetrics", null));
     PageAgent.canOverrideGeolocation(WebInspector._initializeCapability.bind(WebInspector, "canOverrideGeolocation", null));
     PageAgent.canOverrideDeviceOrientation(WebInspector._initializeCapability.bind(WebInspector, "canOverrideDeviceOrientation", WebInspector._doLoadedDoneWithCapabilities.bind(WebInspector)));
@@ -484,6 +485,9 @@
     if (WebInspector.settings.showPaintRects.get())
         PageAgent.setShowPaintRects(true);
 
+    if (WebInspector.settings.continuousPainting.get())
+        PageAgent.setContinuousPaintingEnabled(true);
+
     if (WebInspector.settings.javaScriptDisabled.get())
         PageAgent.setScriptExecutionDisabled(true);
 
Index: src/third_party/WebKit/Source/WebCore/inspector/InspectorClient.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/InspectorClient.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/InspectorClient.h	(working copy)
@@ -76,6 +76,9 @@
     virtual bool canShowFPSCounter() { return false; }
     virtual void setShowFPSCounter(bool) { }
 
+    virtual bool canContinuouslyPaint() { return false; }
+    virtual void setContinuousPaintingEnabled(bool) { }
+
     virtual bool supportsFrameInstrumentation() { return false; }
 
     virtual void getAllocatedObjects(HashSet<const void*>&) { }
Index: src/third_party/WebKit/Source/WebCore/inspector/InspectorPageAgent.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/InspectorPageAgent.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/InspectorPageAgent.cpp	(working copy)
@@ -93,6 +93,7 @@
 static const char pageAgentFontScaleFactorOverride[] = "pageAgentFontScaleFactorOverride";
 static const char pageAgentFitWindow[] = "pageAgentFitWindow";
 static const char pageAgentShowFPSCounter[] = "pageAgentShowFPSCounter";
+static const char pageAgentContinuousPaintingEnabled[] = "pageAgentContinuousPaintingEnabled";
 static const char pageAgentShowPaintRects[] = "pageAgentShowPaintRects";
 #if ENABLE(TOUCH_EVENTS)
 static const char touchEventEmulationEnabled[] = "touchEventEmulationEnabled";
@@ -366,6 +367,8 @@
         setShowFPSCounter(0, showFPSCounter);
         String emulatedMedia = m_state->getString(PageAgentState::pageAgentEmulatedMedia);
         setEmulatedMedia(0, emulatedMedia);
+        bool continuousPaintingEnabled = m_state->getBoolean(PageAgentState::pageAgentContinuousPaintingEnabled);
+        setContinuousPaintingEnabled(0, continuousPaintingEnabled);
 
         int currentWidth = static_cast<int>(m_state->getLong(PageAgentState::pageAgentScreenWidthOverride));
         int currentHeight = static_cast<int>(m_state->getLong(PageAgentState::pageAgentScreenHeightOverride));
@@ -401,6 +404,7 @@
     setShowPaintRects(0, false);
     setShowFPSCounter(0, false);
     setEmulatedMedia(0, "");
+    setContinuousPaintingEnabled(0, false);
 
     // When disabling the agent, reset the override values.
     m_state->setLong(PageAgentState::pageAgentScreenWidthOverride, 0);
@@ -754,6 +758,20 @@
         mainFrame()->view()->invalidate();
 }
 
+void InspectorPageAgent::canContinuouslyPaint(ErrorString*, bool* outParam)
+{
+    *outParam = m_client->canContinuouslyPaint();
+}
+
+void InspectorPageAgent::setContinuousPaintingEnabled(ErrorString*, bool enabled)
+{
+    m_state->setBoolean(PageAgentState::pageAgentContinuousPaintingEnabled, enabled);
+    m_client->setContinuousPaintingEnabled(enabled);
+
+    if (!enabled && mainFrame() && mainFrame()->view())
+        mainFrame()->view()->invalidate();
+}
+
 void InspectorPageAgent::getScriptExecutionStatus(ErrorString*, PageCommandHandler::Result::Enum* status)
 {
     bool disabledByScriptController = false;
Index: src/third_party/WebKit/Source/WebCore/inspector/Inspector.json
===================================================================
--- src/third_party/WebKit/Source/WebCore/inspector/Inspector.json	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/inspector/Inspector.json	(working copy)
@@ -366,6 +366,22 @@
                 "hidden": true
             },
             {
+                "name": "canContinuouslyPaint",
+                "description": "Tells if backend supports continuous painting",
+                "returns": [
+                    { "name": "value", "type": "boolean", "description": "True if continuous painting is available" }
+                ],
+                "hidden": true
+            },
+            {
+                "name": "setContinuousPaintingEnabled",
+                "description": "Requests that backend enables continuous painting",
+                "parameters": [
+                    { "name": "enabled", "type": "boolean", "description": "True for enabling cointinuous painting" }
+                ],
+                "hidden": true
+            },
+            {
                 "name": "getScriptExecutionStatus",
                 "description": "Determines if scripts can be executed in the page.",
                 "returns": [
Index: src/third_party/WebKit/Source/WebCore/testing/InternalSettings.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/testing/InternalSettings.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/testing/InternalSettings.cpp	(working copy)
@@ -471,6 +471,8 @@
         settings()->setEditingBehaviorType(EditingMacBehavior);
     else if (equalIgnoringCase(editingBehavior, "unix"))
         settings()->setEditingBehaviorType(EditingUnixBehavior);
+    else if (equalIgnoringCase(editingBehavior, "android"))
+        settings()->setEditingBehaviorType(EditingAndroidBehavior);
     else
         ec = SYNTAX_ERR;
 }
Index: src/third_party/WebKit/Source/WebCore/rendering/RenderLayer.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/rendering/RenderLayer.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/rendering/RenderLayer.cpp	(working copy)
@@ -1121,8 +1121,10 @@
         RenderLayer* positionedParent = enclosingPositionedAncestor();
 
         // For positioned layers, we subtract out the enclosing positioned layer's scroll offset.
-        LayoutSize offset = positionedParent->scrolledContentOffset();
-        localPoint -= offset;
+        if (positionedParent->renderer()->hasOverflowClip()) {
+            LayoutSize offset = positionedParent->scrolledContentOffset();
+            localPoint -= offset;
+        }
         
         if (renderer()->isOutOfFlowPositioned() && positionedParent->renderer()->isInFlowPositioned() && positionedParent->renderer()->isRenderInline()) {
             LayoutSize offset = toRenderInline(positionedParent->renderer())->offsetForInFlowPositionedInline(toRenderBox(renderer()));
@@ -1141,8 +1143,10 @@
             localPoint += columnOffset;
         }
 
-        IntSize scrollOffset = parent()->scrolledContentOffset();
-        localPoint -= scrollOffset;
+        if (parent()->renderer()->hasOverflowClip()) {
+            IntSize scrollOffset = parent()->scrolledContentOffset();
+            localPoint -= scrollOffset;
+        }
     }
     
     bool positionOrOffsetChanged = false;
@@ -1938,10 +1942,10 @@
     scrollByRecursively(adjustedScrollDelta(delta), ScrollOffsetClamped);
 }
 
-void RenderLayer::scrollByRecursively(const IntSize& delta, ScrollOffsetClamping clamp)
+bool RenderLayer::scrollByRecursively(const IntSize& delta, ScrollOffsetClamping clamp)
 {
     if (delta.isZero())
-        return;
+        return false;
 
     bool restrictedByLineClamp = false;
     if (renderer()->parent())
@@ -1953,21 +1957,30 @@
 
         // If this layer can't do the scroll we ask the next layer up that can scroll to try
         IntSize remainingScrollOffset = newScrollOffset - scrollOffset();
+        bool didScroll = true;
         if (!remainingScrollOffset.isZero() && renderer()->parent()) {
             if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
-                scrollableLayer->scrollByRecursively(remainingScrollOffset);
+                didScroll = scrollableLayer->scrollByRecursively(remainingScrollOffset, clamp);
 
             Frame* frame = renderer()->frame();
             if (frame)
                 frame->eventHandler()->updateAutoscrollRenderer();
         }
+        return didScroll;
     } else if (renderer()->view()->frameView()) {
         // If we are here, we were called on a renderer that can be programmatically scrolled, but doesn't
         // have an overflow clip. Which means that it is a document node that can be scrolled.
-        renderer()->view()->frameView()->scrollBy(delta);
+        FrameView* view = renderer()->view()->frameView();
+        IntPoint scrollPositionBefore = view->scrollPosition();
+        view->scrollBy(delta);
+        IntPoint scrollPositionAfter = view->scrollPosition();
+        return scrollPositionBefore != scrollPositionAfter;
+
         // FIXME: If we didn't scroll the whole way, do we want to try looking at the frames ownerElement? 
         // https://bugs.webkit.org/show_bug.cgi?id=28237
     }
+
+    return false;
 }
 
 IntSize RenderLayer::clampScrollOffset(const IntSize& scrollOffset) const
Index: src/third_party/WebKit/Source/WebCore/rendering/RenderLayerBacking.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/rendering/RenderLayerBacking.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/rendering/RenderLayerBacking.cpp	(working copy)
@@ -946,7 +946,11 @@
             layer->setPosition(hBar->frameRect().location() - offsetFromRoot - offsetFromRenderer);
             layer->setSize(hBar->frameRect().size());
         }
+#if OS(ANDROID)
+        layer->setDrawsContent(false);
+#else
         layer->setDrawsContent(hBar);
+#endif
     }
     
     if (GraphicsLayer* layer = layerForVerticalScrollbar()) {
@@ -955,7 +959,11 @@
             layer->setPosition(vBar->frameRect().location() - offsetFromRoot - offsetFromRenderer);
             layer->setSize(vBar->frameRect().size());
         }
+#if OS(ANDROID)
+        layer->setDrawsContent(false);
+#else
         layer->setDrawsContent(vBar);
+#endif
     }
 
     if (GraphicsLayer* layer = layerForScrollCorner()) {
Index: src/third_party/WebKit/Source/WebCore/rendering/RenderLayer.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/rendering/RenderLayer.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/rendering/RenderLayer.h	(working copy)
@@ -327,7 +327,7 @@
     };
 
     // Scrolling methods for layers that can scroll their overflow.
-    void scrollByRecursively(const IntSize&, ScrollOffsetClamping = ScrollOffsetUnclamped);
+    bool scrollByRecursively(const IntSize&, ScrollOffsetClamping = ScrollOffsetUnclamped);
     void scrollToOffset(const IntSize&, ScrollOffsetClamping = ScrollOffsetUnclamped);
     void scrollToXOffset(int x, ScrollOffsetClamping clamp = ScrollOffsetUnclamped) { scrollToOffset(IntSize(x, scrollYOffset()), clamp); }
     void scrollToYOffset(int y, ScrollOffsetClamping clamp = ScrollOffsetUnclamped) { scrollToOffset(IntSize(scrollXOffset(), y), clamp); }
Index: src/third_party/WebKit/Source/WebCore/rendering/RenderLayerCompositor.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/rendering/RenderLayerCompositor.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/rendering/RenderLayerCompositor.cpp	(working copy)
@@ -1149,7 +1149,7 @@
 {
     if (m_clipLayer) {
         FrameView* frameView = m_renderView->frameView();
-        m_clipLayer->setSize(frameView->visibleContentRect(false /* exclude scrollbars */).size());
+        m_clipLayer->setSize(frameView->unscaledVisibleContentSize(false /* exclude scrollbars */));
 
         frameViewDidScroll();
         updateOverflowControlsLayers();
@@ -1502,7 +1502,7 @@
     }
     if (m_clipLayer) {
         FrameView* frameView = m_renderView->frameView();
-        m_clipLayer->setSize(frameView->visibleContentRect(false /* exclude scrollbars */).size());
+        m_clipLayer->setSize(frameView->unscaledVisibleContentSize(false /* exclude scrollbars */));
     }
 
 #if ENABLE(RUBBER_BANDING)
@@ -1900,6 +1900,9 @@
     // If we can't reliably know the size of the iframe yet, don't change compositing state.
     if (renderer->needsLayout())
         return frameRenderer->hasLayer() && frameRenderer->layer()->isComposited();
+
+    if (renderer->style()->visibility() == HIDDEN)
+        return false;
     
     // Don't go into compositing mode if height or width are zero.
     IntRect contentBox = pixelSnappedIntRect(frameRenderer->contentBoxRect());
@@ -2012,6 +2015,8 @@
         if (!viewBounds.intersects(enclosingIntRect(layerBounds))) {
             if (viewportConstrainedNotCompositedReason)
                 *viewportConstrainedNotCompositedReason = RenderLayer::NotCompositedForBoundsOutOfView;
+            // Reevaluate compositing after layout because the layer bounds may change and become composited.
+            m_reevaluateCompositingAfterLayout = true;
             return false;
         }
     }
Index: src/third_party/WebKit/Source/WebCore/rendering/TextAutosizer.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/rendering/TextAutosizer.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/rendering/TextAutosizer.h	(working copy)
@@ -39,6 +39,7 @@
 class RenderObject;
 class RenderText;
 struct TextAutosizingWindowInfo;
+struct TextAutosizingClusterInfo;
 
 class TextAutosizer {
     WTF_MAKE_NONCOPYABLE(TextAutosizer);
@@ -49,6 +50,7 @@
     virtual ~TextAutosizer();
 
     bool processSubtree(RenderObject* layoutRoot);
+    void recalculateMultipliers();
 
     static float computeAutosizedFontSize(float specifiedSize, float multiplier);
 
@@ -60,20 +62,26 @@
 
     explicit TextAutosizer(Document*);
 
-    void processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo&);
-    void processContainer(float multiplier, RenderBlock* container, const RenderBlock* blockContainingAllText, RenderObject* subtreeRoot, const TextAutosizingWindowInfo&);
+    void processClusterInternal(TextAutosizingClusterInfo&, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo&, float textWidth, bool shouldBeAutosized);
+    void processCluster(TextAutosizingClusterInfo&, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo&);
+    void processCompositeCluster(Vector<TextAutosizingClusterInfo>&, const TextAutosizingWindowInfo&);
+    void processContainer(float multiplier, RenderBlock* container, TextAutosizingClusterInfo&, RenderObject* subtreeRoot, const TextAutosizingWindowInfo&);
 
     void setMultiplier(RenderObject*, float);
 
     static bool isAutosizingContainer(const RenderObject*);
-    static bool isAutosizingCluster(const RenderBlock*, const RenderBlock* parentBlockContainingAllText);
-    static bool isAutosizingCluster(const RenderObject*);
+    static bool isNarrowDescendant(const RenderBlock*, TextAutosizingClusterInfo& parentClusterInfo);
+    static bool isWiderDescendant(const RenderBlock*, const TextAutosizingClusterInfo& parentClusterInfo);
+    static bool isIndependentDescendant(const RenderBlock*);
+    static bool isAutosizingCluster(const RenderBlock*, TextAutosizingClusterInfo& parentClusterInfo);
 
     static bool containerShouldBeAutosized(const RenderBlock* container);
     static bool containerContainsOneOfTags(const RenderBlock* cluster, const Vector<QualifiedName>& tags);
+    static bool containerIsRowOfLinks(const RenderObject* container);
     static bool contentHeightIsConstrained(const RenderBlock* container);
-    static bool clusterShouldBeAutosized(const RenderBlock* blockContainingAllText, float blockWidth);
-    static void measureDescendantTextWidth(const RenderBlock* container, const RenderBlock* blockContainingAllText, float minTextWidth, float& textWidth);
+    static bool clusterShouldBeAutosized(TextAutosizingClusterInfo&, float blockWidth);
+    static bool compositeClusterShouldBeAutosized(Vector<TextAutosizingClusterInfo>&, float blockWidth);
+    static void measureDescendantTextWidth(const RenderBlock* container, TextAutosizingClusterInfo&, float minTextWidth, float& textWidth);
 
     // Use to traverse the tree of descendants, excluding descendants of containers (but returning the containers themselves).
     static RenderObject* nextInPreOrderSkippingDescendantsOfContainers(const RenderObject*, const RenderObject* stayWithin);
@@ -84,6 +92,11 @@
     // belong to any cluster.
     static const RenderObject* findFirstTextLeafNotInCluster(const RenderObject*, size_t& depth, TraversalDirection);
 
+    // Returns groups of narrow descendants of a given autosizing cluster. The groups are combined
+    // by the difference between the width of the descendant and the width of the parent cluster's
+    // |blockContainingAllText|.
+    static void getNarrowDescendantsGroupedByWidth(const TextAutosizingClusterInfo& parentClusterInfo, Vector<Vector<TextAutosizingClusterInfo> >&);
+
     Document* m_document;
 };
 
Index: src/third_party/WebKit/Source/WebCore/rendering/TextAutosizer.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/rendering/TextAutosizer.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/rendering/TextAutosizer.cpp	(working copy)
@@ -37,6 +37,7 @@
 
 #include <algorithm>
 #include <wtf/StdLibExtras.h>
+#include <wtf/Vector.h>
 
 namespace WebCore {
 
@@ -47,7 +48,28 @@
     IntSize minLayoutSize;
 };
 
+// Represents cluster related data. Instances should not persist between calls to processSubtree.
+struct TextAutosizingClusterInfo {
+    explicit TextAutosizingClusterInfo(RenderBlock* root)
+        : root(root)
+        , blockContainingAllText(0)
+        , maxAllowedDifferenceFromTextWidth(150)
+    {
+    }
 
+    RenderBlock* root;
+    const RenderBlock* blockContainingAllText;
+
+    // Upper limit on the difference between the width of the cluster's block containing all
+    // text and that of a narrow child before the child becomes a separate cluster.
+    float maxAllowedDifferenceFromTextWidth;
+
+    // Descendants of the cluster that are narrower than the block containing all text and must be
+    // processed together.
+    Vector<TextAutosizingClusterInfo> narrowDescendants;
+};
+
+
 static const Vector<QualifiedName>& formInputTags()
 {
     // Returns the tags for the form input elements.
@@ -69,6 +91,16 @@
 {
 }
 
+void TextAutosizer::recalculateMultipliers()
+{
+    RenderObject* renderer = m_document->renderer();
+    while (renderer) {
+        if (renderer->style() && renderer->style()->textAutosizingMultiplier() != 1)
+            setMultiplier(renderer, 1);
+        renderer = renderer->nextInPreOrder();
+    }
+}
+
 bool TextAutosizer::processSubtree(RenderObject* layoutRoot)
 {
     // FIXME: Text Autosizing should only be enabled when m_document->page()->mainFrame()->view()->useFixedLayout()
@@ -84,7 +116,7 @@
     windowInfo.windowSize = m_document->settings()->textAutosizingWindowSizeOverride();
     if (windowInfo.windowSize.isEmpty()) {
         bool includeScrollbars = !InspectorInstrumentation::shouldApplyScreenWidthOverride(mainFrame);
-        windowInfo.windowSize = mainFrame->view()->visibleContentRect(includeScrollbars).size();
+        windowInfo.windowSize = mainFrame->view()->unscaledVisibleContentSize(includeScrollbars);
         if (!m_document->settings()->applyDeviceScaleFactorInCompositor())
             windowInfo.windowSize.scale(1 / m_document->page()->deviceScaleFactor());
     }
@@ -103,27 +135,20 @@
         container = container->containingBlock();
 
     RenderBlock* cluster = container;
-    while (cluster && !isAutosizingCluster(cluster))
+    while (cluster && (!isAutosizingContainer(cluster) || !isIndependentDescendant(cluster)))
         cluster = cluster->containingBlock();
 
-    processCluster(cluster, container, layoutRoot, windowInfo);
+    TextAutosizingClusterInfo clusterInfo(cluster);
+    processCluster(clusterInfo, container, layoutRoot, windowInfo);
     return true;
 }
 
-void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
+void TextAutosizer::processClusterInternal(TextAutosizingClusterInfo& clusterInfo, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo, float textWidth, bool shouldBeAutosized)
 {
-    // Many pages set a max-width on their content. So especially for the
-    // RenderView, instead of just taking the width of |cluster| we find
-    // the lowest common ancestor of the first and last descendant text node of
-    // the cluster (i.e. the deepest wrapper block that contains all the text),
-    // and use its width instead.
-    const RenderBlock* blockContainingAllText = findDeepestBlockContainingAllText(cluster);
-    float textWidth = blockContainingAllText->contentLogicalWidth();
-
     float multiplier = 1;
-    if (clusterShouldBeAutosized(blockContainingAllText, textWidth)) {
-        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
-        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
+    if (shouldBeAutosized) {
+        int logicalWindowWidth = clusterInfo.root->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
+        int logicalLayoutWidth = clusterInfo.root->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
         // Ignore box width in excess of the layout width, to avoid extreme multipliers.
         float logicalClusterWidth = std::min<float>(textWidth, logicalLayoutWidth);
 
@@ -132,11 +157,41 @@
         multiplier = std::max(1.0f, multiplier);
     }
 
-    processContainer(multiplier, container, blockContainingAllText, subtreeRoot, windowInfo);
+    processContainer(multiplier, container, clusterInfo, subtreeRoot, windowInfo);
+
+    Vector<Vector<TextAutosizingClusterInfo> > narrowDescendantsGroups;
+    getNarrowDescendantsGroupedByWidth(clusterInfo, narrowDescendantsGroups);
+    for (size_t i = 0; i < narrowDescendantsGroups.size(); ++i)
+        processCompositeCluster(narrowDescendantsGroups[i], windowInfo);
 }
 
-void TextAutosizer::processContainer(float multiplier, RenderBlock* container, const RenderBlock* blockContainingAllText, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
+void TextAutosizer::processCluster(TextAutosizingClusterInfo& clusterInfo, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
 {
+    // Many pages set a max-width on their content. So especially for the RenderView, instead of
+    // just taking the width of |cluster| we find the lowest common ancestor of the first and last
+    // descendant text node of the cluster (i.e. the deepest wrapper block that contains all the
+    // text), and use its width instead.
+    clusterInfo.blockContainingAllText = findDeepestBlockContainingAllText(clusterInfo.root);
+    float textWidth = clusterInfo.blockContainingAllText->contentLogicalWidth();
+    processClusterInternal(clusterInfo, container, subtreeRoot, windowInfo, textWidth, clusterShouldBeAutosized(clusterInfo, textWidth));
+}
+
+void TextAutosizer::processCompositeCluster(Vector<TextAutosizingClusterInfo>& clusterInfos, const TextAutosizingWindowInfo& windowInfo)
+{
+    float maxTextWidth = 0;
+    for (size_t i = 0; i < clusterInfos.size(); ++i) {
+        TextAutosizingClusterInfo& clusterInfo = clusterInfos[i];
+        clusterInfo.blockContainingAllText = findDeepestBlockContainingAllText(clusterInfo.root);
+        maxTextWidth = max<float>(maxTextWidth, clusterInfo.blockContainingAllText->contentLogicalWidth());
+    }
+
+    bool shouldBeAutosized = compositeClusterShouldBeAutosized(clusterInfos, maxTextWidth);
+    for (size_t i = 0; i < clusterInfos.size(); ++i)
+        processClusterInternal(clusterInfos[i], clusterInfos[i].root, clusterInfos[i].root, windowInfo, maxTextWidth, shouldBeAutosized);
+}
+
+void TextAutosizer::processContainer(float multiplier, RenderBlock* container, TextAutosizingClusterInfo& clusterInfo, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
+{
     ASSERT(isAutosizingContainer(container));
 
     float localMultiplier = containerShouldBeAutosized(container) ? multiplier: 1;
@@ -144,17 +199,22 @@
     RenderObject* descendant = nextInPreOrderSkippingDescendantsOfContainers(subtreeRoot, subtreeRoot);
     while (descendant) {
         if (descendant->isText()) {
-            if (localMultiplier != descendant->style()->textAutosizingMultiplier()) {
+            if (localMultiplier != 1 && descendant->style()->textAutosizingMultiplier() == 1) {
                 setMultiplier(descendant, localMultiplier);
                 setMultiplier(descendant->parent(), localMultiplier); // Parent does line spacing.
             }
             // FIXME: Increase list marker size proportionately.
         } else if (isAutosizingContainer(descendant)) {
             RenderBlock* descendantBlock = toRenderBlock(descendant);
-            if (isAutosizingCluster(descendantBlock, blockContainingAllText))
-                processCluster(descendantBlock, descendantBlock, descendantBlock, windowInfo);
-            else
-                processContainer(multiplier, descendantBlock, blockContainingAllText, descendantBlock, windowInfo);
+            TextAutosizingClusterInfo descendantClusterInfo(descendantBlock);
+            if (isWiderDescendant(descendantBlock, clusterInfo) || isIndependentDescendant(descendantBlock))
+                processCluster(descendantClusterInfo, descendantBlock, descendantBlock, windowInfo);
+            else if (isNarrowDescendant(descendantBlock, clusterInfo)) {
+                // Narrow descendants are processed together later to be able to apply the same multiplier
+                // to each of them if necessary.
+                clusterInfo.narrowDescendants.append(descendantClusterInfo);
+            } else
+                processContainer(multiplier, descendantBlock, clusterInfo, descendantBlock, windowInfo);
         }
         descendant = nextInPreOrderSkippingDescendantsOfContainers(descendant, subtreeRoot);
     }
@@ -217,8 +277,48 @@
     return true;
 }
 
-bool TextAutosizer::isAutosizingCluster(const RenderBlock* renderer, const RenderBlock* parentBlockContainingAllText)
+bool TextAutosizer::isNarrowDescendant(const RenderBlock* renderer, TextAutosizingClusterInfo& parentClusterInfo)
 {
+    ASSERT(isAutosizingContainer(renderer));
+
+    // Autosizing containers that are significantly narrower than the |blockContainingAllText| of
+    // their enclosing cluster may be acting as separate columns, hence must be autosized
+    // separately. For example the 2nd div in:
+    // <body>
+    //     <div style="float: right; width: 50%"></div>
+    //     <div style="width: 50%"></div>
+    // <body>
+    // is the left column, and should be autosized differently from the body.
+    // If however the container is only narrower by 150px or less, it's considered part of
+    // the enclosing cluster. This 150px limit is adjusted whenever a descendant container is
+    // less than 50px narrower than the current limit.
+    const float differenceFromMaxWidthDifference = 50;
+    float contentWidth = renderer->contentLogicalWidth();
+    float clusterTextWidth = parentClusterInfo.blockContainingAllText->contentLogicalWidth();
+    float widthDifference = clusterTextWidth - contentWidth;
+
+    if (widthDifference - parentClusterInfo.maxAllowedDifferenceFromTextWidth > differenceFromMaxWidthDifference)
+        return true;
+
+    parentClusterInfo.maxAllowedDifferenceFromTextWidth = std::max(widthDifference, parentClusterInfo.maxAllowedDifferenceFromTextWidth);
+    return false;
+}
+
+bool TextAutosizer::isWiderDescendant(const RenderBlock* renderer, const TextAutosizingClusterInfo& parentClusterInfo)
+{
+    ASSERT(isAutosizingContainer(renderer));
+
+    // Autosizing containers that are wider than the |blockContainingAllText| of their enclosing
+    // cluster are treated the same way as autosizing clusters to be autosized separately.
+    float contentWidth = renderer->contentLogicalWidth();
+    float clusterTextWidth = parentClusterInfo.blockContainingAllText->contentLogicalWidth();
+    return contentWidth > clusterTextWidth;
+}
+
+bool TextAutosizer::isIndependentDescendant(const RenderBlock* renderer)
+{
+    ASSERT(isAutosizingContainer(renderer));
+
     // "Autosizing clusters" are special autosizing containers within which we
     // want to enforce a uniform text size multiplier, in the hopes of making
     // the major sections of the page look internally consistent.
@@ -238,22 +338,6 @@
     // from the box's parent (we want to avoid having significantly different
     // width blocks within a cluster, since the narrower blocks would end up
     // larger than would otherwise be necessary).
-    // Additionally, any containers that are wider or at least 200px narrower than
-    // the |blockContainingAllText| of their enclosing cluster also become clusters,
-    // since they need special treatment due to their width.
-    ASSERT(isAutosizingContainer(renderer));
-
-    // Upper limit on the difference between the width of the parent block containing all
-    // text and that of a narrow child before the child becomes a cluster.
-    const float maxWidthDifference = 200;
-
-    if (parentBlockContainingAllText) {
-        float contentWidth = renderer->contentLogicalWidth();
-        float clusterTextWidth = parentBlockContainingAllText->contentLogicalWidth();
-        if (contentWidth > clusterTextWidth || (clusterTextWidth - contentWidth) > maxWidthDifference)
-            return true;
-    }
-
     return renderer->isRenderView()
         || renderer->isFloating()
         || renderer->isOutOfFlowPositioned()
@@ -268,9 +352,13 @@
     // containers, and probably flexboxes...
 }
 
-bool TextAutosizer::isAutosizingCluster(const RenderObject* object)
+bool TextAutosizer::isAutosizingCluster(const RenderBlock* renderer, TextAutosizingClusterInfo& parentClusterInfo)
 {
-    return isAutosizingContainer(object) && isAutosizingCluster(toRenderBlock(object), 0);
+    ASSERT(isAutosizingContainer(renderer));
+
+    return isNarrowDescendant(renderer, parentClusterInfo)
+        || isWiderDescendant(renderer, parentClusterInfo)
+        || isIndependentDescendant(renderer);
 }
 
 bool TextAutosizer::containerShouldBeAutosized(const RenderBlock* container)
@@ -278,6 +366,9 @@
     if (containerContainsOneOfTags(container, formInputTags()))
         return false;
 
+    if (containerIsRowOfLinks(container))
+        return false;
+
     // Don't autosize block-level text that can't wrap (as it's likely to
     // expand sideways and break the page's layout).
     if (!container->style()->autoWrap())
@@ -301,6 +392,46 @@
     return false;
 }
 
+bool TextAutosizer::containerIsRowOfLinks(const RenderObject* container)
+{
+    // A "row of links" is a container for which holds:
+    //  1. it should not contain non-link text elements longer than 3 characters
+    //  2. it should contain min. 3 inline links and all links should
+    //     have the same specified font size
+    //  3. it should not contain <br> elements
+    //  4. it should contain only inline elements unless they are containers,
+    //     children of link elements or children of sub-containers.
+    int linkCount = 0;
+    RenderObject* renderer = container->nextInPreOrder(container);
+    float matchingFontSize = -1;
+
+    while (renderer) {
+        if (!isAutosizingContainer(renderer)) {
+            if (renderer->isText() && toRenderText(renderer)->text()->stripWhiteSpace()->length() > 3)
+                return false;
+            if (!renderer->isInline())
+                return false;
+            if (renderer->isBR())
+                return false;
+        }
+        if (renderer->style()->isLink()) {
+            if (matchingFontSize < 0)
+                matchingFontSize = renderer->style()->specifiedFontSize();
+            else {
+                if (matchingFontSize != renderer->style()->specifiedFontSize())
+                    return false;
+            }
+
+            linkCount++;
+            // Skip traversing descendants of the link.
+            renderer = renderer->nextInPreOrderAfterChildren(container);
+        } else
+            renderer = nextInPreOrderSkippingDescendantsOfContainers(renderer, container);
+    }
+
+    return (linkCount >= 3);
+}
+
 bool TextAutosizer::contentHeightIsConstrained(const RenderBlock* container)
 {
     // FIXME: Propagate constrainedness down the tree, to avoid inefficiently walking back up from each box.
@@ -321,8 +452,14 @@
     return false;
 }
 
-bool TextAutosizer::clusterShouldBeAutosized(const RenderBlock* blockContainingAllText, float blockWidth)
+bool TextAutosizer::clusterShouldBeAutosized(TextAutosizingClusterInfo& clusterInfo, float blockWidth)
 {
+    Vector<TextAutosizingClusterInfo> clusterInfos(1, clusterInfo);
+    return compositeClusterShouldBeAutosized(clusterInfos, blockWidth);
+}
+
+bool TextAutosizer::compositeClusterShouldBeAutosized(Vector<TextAutosizingClusterInfo>& clusterInfos, float blockWidth)
+{
     // Don't autosize clusters that contain less than 4 lines of text (in
     // practice less lines are required, since measureDescendantTextWidth
     // assumes that characters are 1em wide, but most characters are narrower
@@ -333,16 +470,18 @@
     // if a cluster contains very few lines of text then it's ok to have to zoom
     // in and pan from side to side to read each line, since if there are very
     // few lines of text you'll only need to pan across once or twice.
+    float totalTextWidth = 0;
     const float minLinesOfText = 4;
     float minTextWidth = blockWidth * minLinesOfText;
-    float textWidth = 0;
-    measureDescendantTextWidth(blockContainingAllText, blockContainingAllText, minTextWidth, textWidth);
-    if (textWidth >= minTextWidth)
-        return true;
+    for (size_t i = 0; i < clusterInfos.size(); ++i) {
+        measureDescendantTextWidth(clusterInfos[i].blockContainingAllText, clusterInfos[i], minTextWidth, totalTextWidth);
+        if (totalTextWidth >= minTextWidth)
+            return true;
+    }
     return false;
 }
 
-void TextAutosizer::measureDescendantTextWidth(const RenderBlock* container, const RenderBlock* blockContainingAllText, float minTextWidth, float& textWidth)
+void TextAutosizer::measureDescendantTextWidth(const RenderBlock* container, TextAutosizingClusterInfo& clusterInfo, float minTextWidth, float& textWidth)
 {
     bool skipLocalText = !containerShouldBeAutosized(container);
 
@@ -352,8 +491,8 @@
             textWidth += toRenderText(descendant)->renderedTextLength() * descendant->style()->specifiedFontSize();
         } else if (isAutosizingContainer(descendant)) {
             RenderBlock* descendantBlock = toRenderBlock(descendant);
-            if (!isAutosizingCluster(descendantBlock, blockContainingAllText))
-                measureDescendantTextWidth(descendantBlock, blockContainingAllText, minTextWidth, textWidth);
+            if (!isAutosizingCluster(descendantBlock, clusterInfo))
+                measureDescendantTextWidth(descendantBlock, clusterInfo, minTextWidth, textWidth);
         }
         if (textWidth >= minTextWidth)
             return;
@@ -427,7 +566,7 @@
     ++depth;
     const RenderObject* child = (direction == FirstToLast) ? parent->firstChild() : parent->lastChild();
     while (child) {
-        if (!isAutosizingCluster(child)) {
+        if (!isAutosizingContainer(child) || !isIndependentDescendant(toRenderBlock(child))) {
             const RenderObject* leaf = findFirstTextLeafNotInCluster(child, depth, direction);
             if (leaf)
                 return leaf;
@@ -439,6 +578,43 @@
     return 0;
 }
 
+namespace {
+
+// Compares the width of the specified cluster's roots in descending order.
+bool clusterWiderThanComparisonFn(const TextAutosizingClusterInfo& first, const TextAutosizingClusterInfo& second)
+{
+    return first.root->contentLogicalWidth() > second.root->contentLogicalWidth();
+}
+
+} // namespace
+
+void TextAutosizer::getNarrowDescendantsGroupedByWidth(const TextAutosizingClusterInfo& parentClusterInfo, Vector<Vector<TextAutosizingClusterInfo> >& groups)
+{
+    ASSERT(parentClusterInfo.blockContainingAllText);
+    ASSERT(groups.isEmpty());
+
+    Vector<TextAutosizingClusterInfo> clusterInfos(parentClusterInfo.narrowDescendants);
+    if (clusterInfos.isEmpty())
+        return;
+
+    std::sort(clusterInfos.begin(), clusterInfos.end(), &clusterWiderThanComparisonFn);
+    groups.grow(1);
+
+    // If the width difference between two consecutive elements of |clusterInfos| is greater than
+    // this empirically determined value, the next element should start a new group.
+    const float maxWidthDifferenceWithinGroup = 100;
+    for (size_t i = 0; i < clusterInfos.size(); ++i) {
+        groups.last().append(clusterInfos[i]);
+
+        if (i + 1 < clusterInfos.size()) {
+            float currentWidth = clusterInfos[i].root->contentLogicalWidth();
+            float nextWidth = clusterInfos[i + 1].root->contentLogicalWidth();
+            if (currentWidth - nextWidth > maxWidthDifferenceWithinGroup)
+                groups.grow(groups.size() + 1);
+        }
+    }
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(TEXT_AUTOSIZING)
Index: src/third_party/WebKit/Source/WebCore/English.lproj/localizedStrings.js
===================================================================
--- src/third_party/WebKit/Source/WebCore/English.lproj/localizedStrings.js	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/English.lproj/localizedStrings.js	(working copy)
@@ -177,6 +177,7 @@
 localizedStrings["Emulate touch events"] = "Emulate touch events";
 localizedStrings["Enable Breakpoint"] = "Enable Breakpoint";
 localizedStrings["Enable breakpoint"] = "Enable breakpoint";
+localizedStrings["Enable continuous page repainting"] = "Enable continuous page repainting";
 localizedStrings["Enable Debugging"] = "Enable Debugging";
 localizedStrings["Enable Profiling"] = "Enable Profiling";
 localizedStrings["Enabling debugging will make scripts run slower."] = "Enabling debugging will make scripts run slower.";
Index: src/third_party/WebKit/Source/WebCore/editing/Editor.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/editing/Editor.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/editing/Editor.h	(working copy)
@@ -294,6 +294,7 @@
     void confirmComposition();
     void confirmComposition(const String&); // if no existing composition, replaces selection
     void cancelComposition();
+    bool cancelCompositionIfSelectionIsInvalid();
     PassRefPtr<Range> compositionRange() const;
     bool getCompositionSelection(unsigned& selectionStart, unsigned& selectionEnd) const;
     bool setSelectionOffsets(int selectionStart, int selectionEnd);
Index: src/third_party/WebKit/Source/WebCore/editing/EditingBehaviorTypes.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/editing/EditingBehaviorTypes.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/editing/EditingBehaviorTypes.h	(working copy)
@@ -39,7 +39,8 @@
 enum EditingBehaviorType {
     EditingMacBehavior,
     EditingWindowsBehavior,
-    EditingUnixBehavior
+    EditingUnixBehavior,
+    EditingAndroidBehavior
 };
 
 } // WebCore namespace
Index: src/third_party/WebKit/Source/WebCore/editing/EditingBehavior.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/editing/EditingBehavior.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/editing/EditingBehavior.h	(working copy)
@@ -39,7 +39,10 @@
     // When extending a selection beyond the top or bottom boundary of an editable area,
     // maintain the horizontal position on Windows but extend it to the boundary of the editable
     // content on Mac.
-    bool shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom() const { return m_type != EditingWindowsBehavior; }
+    bool shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom() const
+    {
+        return m_type != EditingWindowsBehavior && m_type != EditingAndroidBehavior;
+    }
 
     // On Windows, selections should always be considered as directional, regardless if it is
     // mouse-based or keyboard-based.
@@ -61,7 +64,10 @@
     bool shouldSelectOnContextualMenuClick() const { return m_type == EditingMacBehavior; }
     
     // On Mac and Windows, pressing backspace (when it isn't handled otherwise) should navigate back.
-    bool shouldNavigateBackOnBackspace() const { return m_type != EditingUnixBehavior; }
+    bool shouldNavigateBackOnBackspace() const
+    {
+        return m_type != EditingUnixBehavior && m_type != EditingAndroidBehavior;
+    }
 
     // On Mac, selecting backwards by word/line from the middle of a word/line, and then going
     // forward leaves the caret back in the middle with no selection, instead of directly selecting
Index: src/third_party/WebKit/Source/WebCore/editing/Editor.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/editing/Editor.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/editing/Editor.cpp	(working copy)
@@ -1335,6 +1335,17 @@
     setComposition(emptyString(), CancelComposition);
 }
 
+bool Editor::cancelCompositionIfSelectionIsInvalid()
+{
+    unsigned start;
+    unsigned end;
+    if (!hasComposition() || ignoreCompositionSelectionChange() || getCompositionSelection(start, end))
+        return false;
+
+    cancelComposition();
+    return true;
+}
+
 void Editor::confirmComposition(const String& text)
 {
     setComposition(text, ConfirmComposition);
Index: src/third_party/WebKit/Source/WebCore/svg/graphics/SVGImageCache.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/svg/graphics/SVGImageCache.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/svg/graphics/SVGImageCache.cpp	(working copy)
@@ -144,7 +144,7 @@
     // FIXME (85335): This needs to take CSS transform scale into account as well.
     Page* page = renderer->document()->page();
     if (!scale)
-        scale = page->deviceScaleFactor() * page->pageScaleFactor();
+        scale = page->pageScaleFactor();
 
     ASSERT(!size.isEmpty());
 
@@ -172,7 +172,7 @@
 
     m_svgImage->drawSVGToImageBuffer(newBuffer.get(), size, zoom, scale, SVGImage::DontClearImageBuffer);
 
-    RefPtr<Image> newImage = newBuffer->copyImage(CopyBackingStore);
+    RefPtr<Image> newImage = newBuffer->copyImage(DontCopyBackingStore);
     Image* newImagePtr = newImage.get();
     ASSERT(newImagePtr);
 
Index: src/third_party/WebKit/Source/WebCore/loader/HistoryController.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/loader/HistoryController.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/loader/HistoryController.cpp	(working copy)
@@ -87,8 +87,10 @@
     else
         item->setScrollPoint(m_frame->view()->scrollPosition());
 
-    item->setPageScaleFactor(m_frame->frameScaleFactor());
-    
+    Page* page = m_frame->page();
+    if (page && page->mainFrame() == m_frame)
+        item->setPageScaleFactor(page->pageScaleFactor());
+
     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling through to the client.
     m_frame->loader()->client()->saveViewStateToItem(item);
 }
Index: src/third_party/WebKit/Source/WebCore/page/FrameView.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/FrameView.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/FrameView.cpp	(working copy)
@@ -449,6 +449,17 @@
     if (newRect == oldRect)
         return;
 
+#if ENABLE(TEXT_AUTOSIZING)
+    // Autosized font sizes depend on the width of the viewing area.
+    if (newRect.width() != oldRect.width()) {
+        Page* page = m_frame ? m_frame->page() : 0;
+        if (page && page->mainFrame() == m_frame && page->settings()->textAutosizingEnabled()) {
+            for (Frame* frame = page->mainFrame(); frame; frame = frame->tree()->traverseNext())
+                m_frame->document()->textAutosizer()->recalculateMultipliers();
+        }
+    }
+#endif
+
     ScrollView::setFrameRect(newRect);
 
     updateScrollableAreaSet();
@@ -1992,7 +2003,7 @@
     if (!frame()->view())
         return;
 
-    if (needsLayout())
+    if (!useFixedLayout() && needsLayout())
         layout();
 
 #if USE(ACCELERATED_COMPOSITING)
@@ -2802,6 +2813,17 @@
     return page->chrome()->windowResizerRect();
 }
 
+float FrameView::visibleContentScaleFactor() const
+{
+    if (!m_frame || !m_frame->page())
+        return 1;
+
+    if (!m_frame->settings()->applyPageScaleFactorInCompositor() || m_frame != m_frame->page()->mainFrame())
+        return 1;
+
+    return m_frame->page()->pageScaleFactor();
+}
+
 void FrameView::setVisibleScrollerThumbRect(const IntRect& scrollerThumb)
 {
     Page* page = m_frame->page();
Index: src/third_party/WebKit/Source/WebCore/page/Settings.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/Settings.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/Settings.cpp	(working copy)
@@ -40,6 +40,7 @@
 #include "PageCache.h"
 #include "ResourceHandle.h"
 #include "StorageMap.h"
+#include "TextAutosizer.h"
 #include <limits>
 
 using namespace std;
@@ -107,7 +108,8 @@
 // NOTEs
 //  1) EditingMacBehavior comprises Tiger, Leopard, SnowLeopard and iOS builds, as well QtWebKit and Chromium when built on Mac;
 //  2) EditingWindowsBehavior comprises Win32 and WinCE builds, as well as QtWebKit and Chromium when built on Windows;
-//  3) EditingUnixBehavior comprises all unix-based systems, but Darwin/MacOS (and then abusing the terminology);
+//  3) EditingUnixBehavior comprises all unix-based systems, but Darwin/MacOS/Android (and then abusing the terminology);
+//  4) EditingAndroidBehavior comprises Android builds.
 // 99) MacEditingBehavior is used a fallback.
 static EditingBehaviorType editingBehaviorTypeForPlatform()
 {
@@ -116,6 +118,8 @@
     EditingMacBehavior
 #elif OS(WINDOWS)
     EditingWindowsBehavior
+#elif OS(ANDROID)
+    EditingAndroidBehavior
 #elif OS(UNIX)
     EditingUnixBehavior
 #else
@@ -354,6 +358,11 @@
 void Settings::setTextAutosizingFontScaleFactor(float fontScaleFactor)
 {
     m_textAutosizingFontScaleFactor = fontScaleFactor;
+
+    // FIXME: I wonder if this needs to traverse frames like in WebViewImpl::resize, or whether there is only one document per Settings instance?
+    for (Frame* frame = m_page->mainFrame(); frame; frame = frame->tree()->traverseNext())
+        frame->document()->textAutosizer()->recalculateMultipliers();
+
     m_page->setNeedsRecalcStyleInAllFrames();
 }
 
Index: src/third_party/WebKit/Source/WebCore/page/EventHandler.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/EventHandler.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/EventHandler.cpp	(working copy)
@@ -281,7 +281,7 @@
     // If the platform we're on supports GestureTapDown and GestureTapCancel then we'll
     // rely on them to set the active state. Unfortunately there's no generic way to
     // know in advance what event types are supported.
-#if PLATFORM(CHROMIUM) && !OS(ANDROID)
+#if PLATFORM(CHROMIUM)
     return true;
 #else
     return false;
@@ -339,6 +339,10 @@
     , m_originatingTouchPointTargetKey(0)
     , m_touchPressed(false)
 #endif
+#if ENABLE(GESTURE_EVENTS)
+    , m_scrollGestureHandlingNode(0)
+    , m_lastHitTestResultOverWidget(false)
+#endif
     , m_maxMouseMovedDuration(0)
     , m_baseEventType(PlatformEvent::NoType)
     , m_didStartDrag(false)
@@ -396,6 +400,7 @@
 #endif
 #if ENABLE(GESTURE_EVENTS)
     m_scrollGestureHandlingNode = 0;
+    m_lastHitTestResultOverWidget = false;
     m_scrollbarHandlingScrollGesture = 0;
 #endif
     m_maxMouseMovedDuration = 0;
@@ -2440,12 +2445,9 @@
 
     if (eventTarget) {
         bool eventSwallowed = eventTarget->dispatchGestureEvent(gestureEvent);
-
-        if (gestureEvent.type() == PlatformEvent::GestureScrollBegin) {
+        if (gestureEvent.type() == PlatformEvent::GestureScrollBegin || gestureEvent.type() == PlatformEvent::GestureScrollEnd) {
             if (eventSwallowed)
                 m_scrollGestureHandlingNode = eventTarget;
-            else
-                m_scrollGestureHandlingNode = 0;
         }
 
         if (eventSwallowed)
@@ -2458,7 +2460,7 @@
 
     switch (gestureEvent.type()) {
     case PlatformEvent::GestureScrollBegin:
-        return handleGestureScrollCore(gestureEvent, ScrollByPixelWheelEvent, false);
+        return handleGestureScrollBegin(gestureEvent);
     case PlatformEvent::GestureScrollUpdate:
         return handleGestureScrollUpdate(gestureEvent);
     case PlatformEvent::GestureTap:
@@ -2574,33 +2576,112 @@
     return handleGestureForTextSelectionOrContextMenu(gestureEvent);
 }
 
-bool EventHandler::handleGestureScrollUpdate(const PlatformGestureEvent& gestureEvent)
+bool EventHandler::passGestureEventToWidget(const PlatformGestureEvent& gestureEvent, Widget* widget)
 {
-    return handleGestureScrollCore(gestureEvent, ScrollByPixelWheelEvent, true);
+    if (!widget)
+        return false;
+
+    if (!widget->isFrameView())
+        return false;
+
+    return static_cast<FrameView*>(widget)->frame()->eventHandler()->handleGestureEvent(gestureEvent);
 }
 
-bool EventHandler::isScrollbarHandlingGestures() const
+bool EventHandler::passGestureEventToWidgetIfPossible(const PlatformGestureEvent& gestureEvent, RenderObject* renderer)
 {
-    return m_scrollbarHandlingScrollGesture.get();
+    if (m_lastHitTestResultOverWidget && renderer && renderer->isWidget()) {
+        Widget* widget = toRenderWidget(renderer)->widget();
+        return widget && passGestureEventToWidget(gestureEvent, widget);
+    }
+    return false;
 }
 
-bool EventHandler::handleGestureScrollCore(const PlatformGestureEvent& gestureEvent, PlatformWheelEventGranularity granularity, bool latchedWheel)
+static const Node* closestScrollableNodeInDocumentIfPossibleOrSelfIfNotScrollable(const Node* node)
 {
-    const float tickDivisor = (float)WheelEvent::tickMultiplier;
+    for (const Node* scrollableNode = node; scrollableNode; scrollableNode = scrollableNode->parentNode()) {
+        if (scrollableNode->isDocumentNode())
+            break;
+        RenderObject* renderer = scrollableNode->renderer();
+        if (renderer && renderer->isBox() && toRenderBox(renderer)->canBeScrolledAndHasScrollableArea())
+            return scrollableNode;
+    }
+    return node;
+}
+
+bool EventHandler::handleGestureScrollBegin(const PlatformGestureEvent& gestureEvent)
+{
+    Document* document = m_frame->document();
+    RenderObject* documentRenderer = document->renderer();
+    if (!documentRenderer)
+        return false;
+
+    FrameView* view = m_frame->view();
+    if (!view)
+        return false;
+
+    LayoutPoint viewPoint = view->windowToContents(gestureEvent.position());
+    HitTestRequest request(HitTestRequest::ReadOnly);
+    HitTestResult result(viewPoint);
+    document->renderView()->hitTest(request, result);
+
+    m_lastHitTestResultOverWidget = result.isOverWidget(); 
+    m_scrollGestureHandlingNode = result.innerNode();
+
+    Node* node = m_scrollGestureHandlingNode.get();
+    if (node)
+        passGestureEventToWidgetIfPossible(gestureEvent, node->renderer());
+    
+    return node && node->renderer();
+}
+
+bool EventHandler::handleGestureScrollUpdate(const PlatformGestureEvent& gestureEvent)
+{
+    // Ignore this event if we don't already have a targeted node with a valid renderer.
+    const Node* node = m_scrollGestureHandlingNode.get();
+    if (!node)
+        return false;
+
+    RenderObject* latchedRenderer = node->renderer();
+    if (!latchedRenderer)
+        return false;
+
+    IntSize delta(-gestureEvent.deltaX(), -gestureEvent.deltaY());
+    if (delta.isZero())
+        return false;
+
+    RefPtr<FrameView> protector(m_frame->view());
+
+    // Try to send the event to the correct view.
+    if (passGestureEventToWidgetIfPossible(gestureEvent, latchedRenderer))
+        return true;
+
+    // Otherwise if this is the correct view for the event, find the closest scrollable
+    // ancestor of the targeted node and scroll the layer that contains this node's renderer.
+    node = closestScrollableNodeInDocumentIfPossibleOrSelfIfNotScrollable(node);
+    if (!node)
+        return false;
+
+    latchedRenderer = node->renderer();
+    if (!latchedRenderer)
+        return false;
+
     const float scaleFactor = m_frame->pageZoomFactor() * m_frame->frameScaleFactor();
-    float scaledDeltaX = gestureEvent.deltaX() / scaleFactor;
-    float scaledDeltaY = gestureEvent.deltaY() / scaleFactor;
-    IntPoint point(gestureEvent.position().x(), gestureEvent.position().y());
-    IntPoint globalPoint(gestureEvent.globalPosition().x(), gestureEvent.globalPosition().y());
-    PlatformWheelEvent syntheticWheelEvent(point, globalPoint,
-        scaledDeltaX, scaledDeltaY, scaledDeltaX / tickDivisor, scaledDeltaY / tickDivisor,
-        granularity,
-        gestureEvent.shiftKey(), gestureEvent.ctrlKey(), gestureEvent.altKey(), gestureEvent.metaKey());
-    syntheticWheelEvent.setUseLatchedEventNode(latchedWheel);
-    return handleWheelEvent(syntheticWheelEvent);
+    delta.scale(1 / scaleFactor, 1 / scaleFactor);
+
+    bool result = latchedRenderer->enclosingLayer()->scrollByRecursively(delta, RenderLayer::ScrollOffsetClamped);
+
+    if (result)
+        setFrameWasScrolledByUser();
+
+    return result;
 }
-#endif
 
+bool EventHandler::isScrollbarHandlingGestures() const
+{
+    return m_scrollbarHandlingScrollGesture.get();
+}
+#endif // ENABLE(GESTURE_EVENTS)
+
 #if ENABLE(TOUCH_ADJUSTMENT)
 bool EventHandler::shouldApplyTouchAdjustment(const PlatformGestureEvent& event) const
 {
Index: src/third_party/WebKit/Source/WebCore/page/FrameView.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/FrameView.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/FrameView.h	(working copy)
@@ -180,6 +180,8 @@
 
     virtual IntRect windowResizerRect() const;
 
+    virtual float visibleContentScaleFactor() const OVERRIDE;
+
     virtual void setFixedVisibleContentRect(const IntRect&) OVERRIDE;
     virtual void setScrollPosition(const IntPoint&) OVERRIDE;
     void scrollPositionChangedViaPlatformWidget();
Index: src/third_party/WebKit/Source/WebCore/page/Page.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/Page.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/Page.cpp	(working copy)
@@ -694,7 +694,8 @@
 
     if (scale == m_pageScaleFactor) {
         if (view && (view->scrollPosition() != origin || view->delegatesScrolling())) {
-            document->updateLayoutIgnorePendingStylesheets();
+            if (!m_settings->applyPageScaleFactorInCompositor())
+                document->updateLayoutIgnorePendingStylesheets();
             view->setScrollPosition(origin);
         }
         return;
@@ -702,20 +703,22 @@
 
     m_pageScaleFactor = scale;
 
-    if (document->renderer())
-        document->renderer()->setNeedsLayout(true);
+    if (!m_settings->applyPageScaleFactorInCompositor()) {
+        if (document->renderer())
+            document->renderer()->setNeedsLayout(true);
 
-    document->recalcStyle(Node::Force);
+        document->recalcStyle(Node::Force);
 
-    // Transform change on RenderView doesn't trigger repaint on non-composited contents.
-    mainFrame()->view()->invalidateRect(IntRect(LayoutRect::infiniteRect()));
+        // Transform change on RenderView doesn't trigger repaint on non-composited contents.
+        mainFrame()->view()->invalidateRect(IntRect(LayoutRect::infiniteRect()));
+    }
 
 #if USE(ACCELERATED_COMPOSITING)
     mainFrame()->deviceOrPageScaleFactorChanged();
 #endif
 
     if (view && view->scrollPosition() != origin) {
-        if (document->renderer() && document->renderer()->needsLayout() && view->didFirstLayout())
+        if (!m_settings->applyPageScaleFactorInCompositor() && document->renderer() && document->renderer()->needsLayout() && view->didFirstLayout())
             view->layout();
         view->setScrollPosition(origin);
     }
Index: src/third_party/WebKit/Source/WebCore/page/TouchDisambiguation.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/TouchDisambiguation.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/TouchDisambiguation.h	(working copy)
@@ -38,7 +38,7 @@
 class Frame;
 class IntRect;
 
-void findGoodTouchTargets(const IntRect& touchBox, Frame* mainFrame, float pageScaleFactor, Vector<IntRect>& goodTargets);
+void findGoodTouchTargets(const IntRect& touchBox, Frame* mainFrame, Vector<IntRect>& goodTargets);
 
 } // namespace WebCore
 
Index: src/third_party/WebKit/Source/WebCore/page/TouchDisambiguation.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/TouchDisambiguation.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/TouchDisambiguation.cpp	(working copy)
@@ -86,14 +86,14 @@
     float score;
 };
 
-void findGoodTouchTargets(const IntRect& touchBox, Frame* mainFrame, float pageScaleFactor, Vector<IntRect>& goodTargets)
+void findGoodTouchTargets(const IntRect& touchBox, Frame* mainFrame, Vector<IntRect>& goodTargets)
 {
     goodTargets.clear();
 
     int touchPointPadding = ceil(max(touchBox.width(), touchBox.height()) * 0.5);
     // FIXME: Rect-based hit test doesn't transform the touch point size.
-    //        We have to pre-apply page scale factor here.
-    int padding = ceil(touchPointPadding / pageScaleFactor);
+    //        We have to pre-apply frame scale factor here.
+    int padding = ceil(touchPointPadding / mainFrame->frameScaleFactor());
 
     IntPoint touchPoint = touchBox.center();
     IntPoint contentsPoint = mainFrame->view()->windowToContents(touchPoint);
@@ -106,9 +106,12 @@
     // This heuristic avoids excessive disambiguation in that case.
     HashSet<Node*> blackList;
     for (ListHashSet<RefPtr<Node> >::const_iterator it = hitResults.begin(); it != hitResults.end(); ++it) {
+        // Ignore any Nodes that can't be clicked on.
         RenderObject* renderer = it->get()->renderer();
-        if (!renderer)
+        if (!renderer || !it->get()->willRespondToMouseClickEvents())
             continue;
+
+        // Blacklist all of the Node's containers.
         for (RenderBlock* container = renderer->containingBlock(); container; container = container->containingBlock()) {
             Node* containerNode = container->node();
             if (!containerNode)
@@ -122,7 +125,7 @@
     float bestScore = 0;
     for (ListHashSet<RefPtr<Node> >::const_iterator it = hitResults.begin(); it != hitResults.end(); ++it) {
         for (Node* node = it->get(); node; node = node->parentNode()) {
-            if (blackList.contains(it->get()))
+            if (blackList.contains(node))
                 continue;
             if (node->isDocumentNode() || node->hasTagName(HTMLNames::htmlTag) || node->hasTagName(HTMLNames::bodyTag))
                 break;
Index: src/third_party/WebKit/Source/WebCore/page/EventHandler.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/page/EventHandler.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/page/EventHandler.h	(working copy)
@@ -182,6 +182,7 @@
     bool handleGestureLongTap(const PlatformGestureEvent&);
     bool handleGestureTwoFingerTap(const PlatformGestureEvent&);
     bool handleGestureScrollUpdate(const PlatformGestureEvent&);
+    bool handleGestureScrollBegin(const PlatformGestureEvent&);
     bool isScrollbarHandlingGestures() const;
 #endif
 
@@ -375,9 +376,10 @@
 #endif
 
 #if ENABLE(GESTURE_EVENTS)
-    bool handleGestureScrollCore(const PlatformGestureEvent&, PlatformWheelEventGranularity, bool latchedWheel);
     bool handleGestureTapDown();
     bool handleGestureForTextSelectionOrContextMenu(const PlatformGestureEvent&);
+    bool passGestureEventToWidget(const PlatformGestureEvent&, Widget*);
+    bool passGestureEventToWidgetIfPossible(const PlatformGestureEvent&, RenderObject*);
 #endif
 
     void setLastKnownMousePosition(const PlatformMouseEvent&);
@@ -468,6 +470,7 @@
 
 #if ENABLE(GESTURE_EVENTS)
     RefPtr<Node> m_scrollGestureHandlingNode;
+    bool m_lastHitTestResultOverWidget;
     RefPtr<Scrollbar> m_scrollbarHandlingScrollGesture;
 #endif
 
Index: src/third_party/WebKit/Source/WebCore/platform/ScrollView.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/ScrollView.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/ScrollView.cpp	(working copy)
@@ -225,14 +225,13 @@
     delegatesScrollingDidChange();
 }
 
-#if !PLATFORM(GTK)
-IntRect ScrollView::visibleContentRect(bool includeScrollbars) const
+IntSize ScrollView::unscaledVisibleContentSize(bool includeScrollbars) const
 {
     if (platformWidget())
-        return platformVisibleContentRect(includeScrollbars);
+        return platformVisibleContentRect(includeScrollbars).size();
 
     if (!m_fixedVisibleContentRect.isEmpty())
-        return m_fixedVisibleContentRect;
+        return m_fixedVisibleContentRect.size();
 
     int verticalScrollbarWidth = 0;
     int horizontalScrollbarHeight = 0;
@@ -244,26 +243,28 @@
             horizontalScrollbarHeight = !horizontalBar->isOverlayScrollbar() ? horizontalBar->height() : 0;
     }
 
-    return IntRect(m_scrollOffset.width(),
-                   m_scrollOffset.height(),
-                   max(0, width() - verticalScrollbarWidth), 
+    return IntSize(max(0, width() - verticalScrollbarWidth),
                    max(0, height() - horizontalScrollbarHeight));
 }
-#endif
 
-IntSize ScrollView::layoutSize() const
+#if !PLATFORM(GTK)
+IntRect ScrollView::visibleContentRect(bool includeScrollbars) const
 {
-    return m_fixedLayoutSize.isEmpty() || !m_useFixedLayout ? visibleSize() : m_fixedLayoutSize;
-}
+    if (platformWidget())
+        return platformVisibleContentRect(includeScrollbars);
 
-int ScrollView::layoutWidth() const
-{
-    return m_fixedLayoutSize.isEmpty() || !m_useFixedLayout ? visibleWidth() : m_fixedLayoutSize.width();
+    if (!m_fixedVisibleContentRect.isEmpty())
+        return m_fixedVisibleContentRect;
+
+    FloatSize visibleContentSize = unscaledVisibleContentSize(includeScrollbars);
+    visibleContentSize.scale(1 / visibleContentScaleFactor());
+    return IntRect(IntPoint(m_scrollOffset), expandedIntSize(visibleContentSize));
 }
+#endif
 
-int ScrollView::layoutHeight() const
+IntSize ScrollView::layoutSize() const
 {
-    return m_fixedLayoutSize.isEmpty() || !m_useFixedLayout ? visibleHeight() : m_fixedLayoutSize.height();
+    return m_fixedLayoutSize.isEmpty() || !m_useFixedLayout ? unscaledVisibleContentSize(false) : m_fixedLayoutSize;
 }
 
 IntSize ScrollView::fixedLayoutSize() const
@@ -277,6 +278,8 @@
         return;
     m_fixedLayoutSize = newSize;
     updateScrollbars(scrollOffset());
+    if (m_useFixedLayout)
+        contentsResized();
 }
 
 bool ScrollView::useFixedLayout() const
@@ -290,6 +293,7 @@
         return;
     m_useFixedLayout = enable;
     updateScrollbars(scrollOffset());
+    contentsResized();
 }
 
 IntSize ScrollView::contentsSize() const
@@ -905,7 +909,11 @@
         return;
     }
 
+#if OS(ANDROID)
+    graphicsLayer->setDrawsContent(false);
+#else
     graphicsLayer->setDrawsContent(true);
+#endif
     graphicsLayer->setNeedsDisplay();
 }
 
@@ -1050,14 +1058,9 @@
 
     notifyPageThatContentAreaWillPaint();
 
-    IntRect clipRect = frameRect();
-    if (verticalScrollbar() && !verticalScrollbar()->isOverlayScrollbar())
-        clipRect.setWidth(clipRect.width() - verticalScrollbar()->width());
-    if (horizontalScrollbar() && !horizontalScrollbar()->isOverlayScrollbar())
-        clipRect.setHeight(clipRect.height() - horizontalScrollbar()->height());
-
     IntRect documentDirtyRect = rect;
-    documentDirtyRect.intersect(clipRect);
+    IntRect visibleAreaWithoutScrollbars(location(), visibleContentRect(false).size());
+    documentDirtyRect.intersect(visibleAreaWithoutScrollbars);
 
     if (!documentDirtyRect.isEmpty()) {
         GraphicsContextStateSaver stateSaver(*context);
@@ -1086,7 +1089,8 @@
     if (!m_scrollbarsSuppressed && (m_horizontalScrollbar || m_verticalScrollbar)) {
         GraphicsContextStateSaver stateSaver(*context);
         IntRect scrollViewDirtyRect = rect;
-        scrollViewDirtyRect.intersect(frameRect());
+        IntRect visibleAreaWithScrollbars(location(), visibleContentRect(true).size());
+        scrollViewDirtyRect.intersect(visibleAreaWithScrollbars);
         context->translate(x(), y());
         scrollViewDirtyRect.moveBy(-location());
 
Index: src/third_party/WebKit/Source/WebCore/platform/ScrollView.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/ScrollView.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/ScrollView.h	(working copy)
@@ -151,11 +151,18 @@
     virtual int visibleWidth() const OVERRIDE { return visibleContentRect().width(); }
     virtual int visibleHeight() const OVERRIDE { return visibleContentRect().height(); }
 
+    // visibleContentRect().size() is computed from unscaledVisibleContentSize() divided by the value of visibleContentScaleFactor.
+    // visibleContentScaleFactor is usually 1, except when the setting applyPageScaleFactorInCompositor is true and the
+    // ScrollView is the main frame; in that case, visibleContentScaleFactor is equal to the page's pageScaleFactor.
+    // Ports that don't use pageScaleFactor can treat unscaledVisibleContentSize and visibleContentRect().size() as equivalent.
+    IntSize unscaledVisibleContentSize(bool includeScrollbars) const;
+    virtual float visibleContentScaleFactor() const { return 1; }
+
     // Functions for getting/setting the size webkit should use to layout the contents. By default this is the same as the visible
     // content size. Explicitly setting a layout size value will cause webkit to layout the contents using this size instead.
     IntSize layoutSize() const;
-    int layoutWidth() const;
-    int layoutHeight() const;
+    int layoutWidth() const { return layoutSize().width(); }
+    int layoutHeight() const { return layoutSize().height(); }
     IntSize fixedLayoutSize() const;
     void setFixedLayoutSize(const IntSize&);
     bool useFixedLayout() const;
Index: src/third_party/WebKit/Source/WebCore/platform/chromium/ScrollbarThemeChromiumAndroid.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/chromium/ScrollbarThemeChromiumAndroid.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/chromium/ScrollbarThemeChromiumAndroid.cpp	(working copy)
@@ -37,8 +37,8 @@
 
 namespace WebCore {
 
-static const int scrollbarWidth = 8;
-static const int scrollbarMargin = 5;
+static const int scrollbarWidth = 3;
+static const int scrollbarMargin = 4;
 
 ScrollbarTheme* ScrollbarTheme::nativeTheme()
 {
@@ -104,37 +104,6 @@
     return rect;
 }
 
-static void fillSmoothEdgedRect(GraphicsContext* context, const IntRect& rect, const Color& color)
-{
-    Color halfColor(color.red(), color.green(), color.blue(), color.alpha() / 2);
-
-    IntRect topRect = rect;
-    topRect.inflateX(-1);
-    topRect.setHeight(1);
-    context->fillRect(topRect, halfColor, ColorSpaceDeviceRGB);
-
-    IntRect leftRect = rect;
-    leftRect.inflateY(-1);
-    leftRect.setWidth(1);
-    context->fillRect(leftRect, halfColor, ColorSpaceDeviceRGB);
-
-    IntRect centerRect = rect;
-    centerRect.inflate(-1);
-    context->fillRect(centerRect, color, ColorSpaceDeviceRGB);
-
-    IntRect rightRect = rect;
-    rightRect.inflateY(-1);
-    rightRect.setX(centerRect.maxX());
-    rightRect.setWidth(1);
-    context->fillRect(rightRect, halfColor, ColorSpaceDeviceRGB);
-
-    IntRect bottomRect = rect;
-    bottomRect.inflateX(-1);
-    bottomRect.setY(centerRect.maxY());
-    bottomRect.setHeight(1);
-    context->fillRect(bottomRect, halfColor, ColorSpaceDeviceRGB);
-}
-
 void ScrollbarThemeChromiumAndroid::paintThumb(GraphicsContext* context, ScrollbarThemeClient* scrollbar, const IntRect& rect)
 {
     IntRect thumbRect = rect;
@@ -142,7 +111,7 @@
         thumbRect.setHeight(thumbRect.height() - scrollbarMargin);
     else
         thumbRect.setWidth(thumbRect.width() - scrollbarMargin);
-    fillSmoothEdgedRect(context, thumbRect, Color(128, 128, 128, 128));
+    context->fillRect(thumbRect, Color(128, 128, 128, 128), ColorSpaceDeviceRGB);
 }
 
 } // namespace WebCore
Index: src/third_party/WebKit/Source/WebCore/platform/chromium/support/WebTransformOperations.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/chromium/support/WebTransformOperations.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/chromium/support/WebTransformOperations.cpp	(working copy)
@@ -1,394 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-
-#include <public/WebTransformOperations.h>
-
-#include <algorithm>
-#include <wtf/Vector.h>
-
-using namespace std;
-
-namespace {
-const double EPSILON = 1e-4;
-}
-
-namespace WebKit {
-
-struct WebTransformOperation {
-    enum Type {
-        WebTransformOperationTranslate,
-        WebTransformOperationRotate,
-        WebTransformOperationScale,
-        WebTransformOperationSkew,
-        WebTransformOperationPerspective,
-        WebTransformOperationMatrix,
-        WebTransformOperationIdentity
-    };
-
-    WebTransformOperation()
-        : type(WebTransformOperationIdentity)
-    {
-    }
-
-    Type type;
-    WebTransformationMatrix matrix;
-
-    union {
-        double perspectiveDepth;
-
-        struct {
-            double x, y;
-        } skew;
-
-        struct {
-             double x, y, z;
-        } scale;
-
-        struct {
-            double x, y, z;
-        } translate;
-
-        struct {
-            struct {
-                double x, y, z;
-            } axis;
-
-            double angle;
-        } rotate;
-    };
-
-    bool isIdentity() const { return matrix.isIdentity(); }
-};
-
-class WebTransformOperationsPrivate {
-public:
-    Vector<WebTransformOperation> operations;
-};
-
-WebTransformationMatrix WebTransformOperations::apply() const
-{
-    WebTransformationMatrix toReturn;
-    for (size_t i = 0; i < m_private->operations.size(); ++i)
-        toReturn.multiply(m_private->operations[i].matrix);
-    return toReturn;
-}
-
-static bool isIdentity(const WebTransformOperation* operation)
-{
-    return !operation || operation->isIdentity();
-}
-
-static bool shareSameAxis(const WebTransformOperation* from, const WebTransformOperation* to, double& axisX, double& axisY, double& axisZ, double& angleFrom)
-{
-    if (isIdentity(from) && isIdentity(to))
-        return false;
-
-    if (isIdentity(from) && !isIdentity(to)) {
-        axisX = to->rotate.axis.x;
-        axisY = to->rotate.axis.y;
-        axisZ = to->rotate.axis.z;
-        angleFrom = 0;
-        return true;
-    }
-
-    if (!isIdentity(from) && isIdentity(to)) {
-        axisX = from->rotate.axis.x;
-        axisY = from->rotate.axis.y;
-        axisZ = from->rotate.axis.z;
-        angleFrom = from->rotate.angle;
-        return true;
-    }
-
-    double length2 = from->rotate.axis.x * from->rotate.axis.x + from->rotate.axis.y * from->rotate.axis.y + from->rotate.axis.z * from->rotate.axis.z;
-    double otherLength2 = to->rotate.axis.x * to->rotate.axis.x + to->rotate.axis.y * to->rotate.axis.y + to->rotate.axis.z * to->rotate.axis.z;
-
-    if (length2 <= EPSILON || otherLength2 <= EPSILON)
-        return false;
-
-    double dot = to->rotate.axis.x * from->rotate.axis.x + to->rotate.axis.y * from->rotate.axis.y + to->rotate.axis.z * from->rotate.axis.z;
-    double error = fabs(1.0 - (dot * dot) / (length2 * otherLength2));
-    bool result = error < EPSILON;
-    if (result) {
-        axisX = to->rotate.axis.x;
-        axisY = to->rotate.axis.y;
-        axisZ = to->rotate.axis.z;
-        // If the axes are pointing in opposite directions, we need to reverse
-        // the angle.
-        angleFrom = dot > 0 ? from->rotate.angle : -from->rotate.angle;
-    }
-    return result;
-}
-
-static double blendDoubles(double from, double to, double progress)
-{
-    return from * (1 - progress) + to * progress;
-}
-
-static bool blendTransformOperations(const WebTransformOperation* from, const WebTransformOperation* to, double progress, WebTransformationMatrix& result)
-{
-    if (isIdentity(from) && isIdentity(to))
-        return true;
-
-    WebTransformOperation::Type interpolationType = WebTransformOperation::WebTransformOperationIdentity;
-    if (isIdentity(to))
-        interpolationType = from->type;
-    else
-        interpolationType = to->type;
-
-    switch (interpolationType) {
-    case WebTransformOperation::WebTransformOperationTranslate: {
-        double fromX = isIdentity(from) ? 0 : from->translate.x;
-        double fromY = isIdentity(from) ? 0 : from->translate.y;
-        double fromZ = isIdentity(from) ? 0 : from->translate.z;
-        double toX = isIdentity(to) ? 0 : to->translate.x;
-        double toY = isIdentity(to) ? 0 : to->translate.y;
-        double toZ = isIdentity(to) ? 0 : to->translate.z;
-        result.translate3d(blendDoubles(fromX, toX, progress),
-                           blendDoubles(fromY, toY, progress),
-                           blendDoubles(fromZ, toZ, progress));
-        break;
-    }
-    case WebTransformOperation::WebTransformOperationRotate: {
-        double axisX = 0;
-        double axisY = 0;
-        double axisZ = 1;
-        double fromAngle = 0;
-        double toAngle = isIdentity(to) ? 0 : to->rotate.angle;
-        if (shareSameAxis(from, to, axisX, axisY, axisZ, fromAngle))
-            result.rotate3d(axisX, axisY, axisZ, blendDoubles(fromAngle, toAngle, progress));
-        else {
-            WebTransformationMatrix toMatrix;
-            if (!isIdentity(to))
-                toMatrix = to->matrix;
-            WebTransformationMatrix fromMatrix;
-            if (!isIdentity(from))
-                fromMatrix = from->matrix;
-            result = toMatrix;
-            if (!result.blend(fromMatrix, progress))
-                return false;
-        }
-        break;
-    }
-    case WebTransformOperation::WebTransformOperationScale: {
-        double fromX = isIdentity(from) ? 1 : from->scale.x;
-        double fromY = isIdentity(from) ? 1 : from->scale.y;
-        double fromZ = isIdentity(from) ? 1 : from->scale.z;
-        double toX = isIdentity(to) ? 1 : to->scale.x;
-        double toY = isIdentity(to) ? 1 : to->scale.y;
-        double toZ = isIdentity(to) ? 1 : to->scale.z;
-        result.scale3d(blendDoubles(fromX, toX, progress),
-                       blendDoubles(fromY, toY, progress),
-                       blendDoubles(fromZ, toZ, progress));
-        break;
-    }
-    case WebTransformOperation::WebTransformOperationSkew: {
-        double fromX = isIdentity(from) ? 0 : from->skew.x;
-        double fromY = isIdentity(from) ? 0 : from->skew.y;
-        double toX = isIdentity(to) ? 0 : to->skew.x;
-        double toY = isIdentity(to) ? 0 : to->skew.y;
-        result.skewX(blendDoubles(fromX, toX, progress));
-        result.skewY(blendDoubles(fromY, toY, progress));
-        break;
-    }
-    case WebTransformOperation::WebTransformOperationPerspective: {
-        double fromPerspectiveDepth = isIdentity(from) ? numeric_limits<double>::max() : from->perspectiveDepth;
-        double toPerspectiveDepth = isIdentity(to) ? numeric_limits<double>::max() : to->perspectiveDepth;
-        result.applyPerspective(blendDoubles(fromPerspectiveDepth, toPerspectiveDepth, progress));
-        break;
-    }
-    case WebTransformOperation::WebTransformOperationMatrix: {
-        WebTransformationMatrix toMatrix;
-        if (!isIdentity(to))
-            toMatrix = to->matrix;
-        WebTransformationMatrix fromMatrix;
-        if (!isIdentity(from))
-            fromMatrix = from->matrix;
-        result = toMatrix;
-        if (!result.blend(fromMatrix, progress))
-            return false;
-        break;
-    }
-    case WebTransformOperation::WebTransformOperationIdentity:
-        // Do nothing.
-        break;
-    }
-
-    return true;
-}
-
-WebTransformationMatrix WebTransformOperations::blend(const WebTransformOperations& from, double progress) const
-{
-    WebTransformationMatrix toReturn;
-    blendInternal(from, progress, toReturn);
-    return toReturn;
-}
-
-bool WebTransformOperations::matchesTypes(const WebTransformOperations& other) const
-{
-    if (isIdentity() || other.isIdentity())
-        return true;
-
-    if (m_private->operations.size() != other.m_private->operations.size())
-        return false;
-
-    for (size_t i = 0; i < m_private->operations.size(); ++i) {
-        if (m_private->operations[i].type != other.m_private->operations[i].type
-            && !m_private->operations[i].isIdentity()
-            && !other.m_private->operations[i].isIdentity())
-            return false;
-    }
-
-    return true;
-}
-
-bool WebTransformOperations::canBlendWith(const WebTransformOperations& other) const
-{
-    WebTransformationMatrix dummy;
-    return blendInternal(other, 0.5, dummy);
-}
-
-void WebTransformOperations::appendTranslate(double x, double y, double z)
-{
-    WebTransformOperation toAdd;
-    toAdd.matrix.translate3d(x, y, z);
-    toAdd.type = WebTransformOperation::WebTransformOperationTranslate;
-    toAdd.translate.x = x;
-    toAdd.translate.y = y;
-    toAdd.translate.z = z;
-    m_private->operations.append(toAdd);
-}
-
-void WebTransformOperations::appendRotate(double x, double y, double z, double degrees)
-{
-    WebTransformOperation toAdd;
-    toAdd.matrix.rotate3d(x, y, z, degrees);
-    toAdd.type = WebTransformOperation::WebTransformOperationRotate;
-    toAdd.rotate.axis.x = x;
-    toAdd.rotate.axis.y = y;
-    toAdd.rotate.axis.z = z;
-    toAdd.rotate.angle = degrees;
-    m_private->operations.append(toAdd);
-}
-
-void WebTransformOperations::appendScale(double x, double y, double z)
-{
-    WebTransformOperation toAdd;
-    toAdd.matrix.scale3d(x, y, z);
-    toAdd.type = WebTransformOperation::WebTransformOperationScale;
-    toAdd.scale.x = x;
-    toAdd.scale.y = y;
-    toAdd.scale.z = z;
-    m_private->operations.append(toAdd);
-}
-
-void WebTransformOperations::appendSkew(double x, double y)
-{
-    WebTransformOperation toAdd;
-    toAdd.matrix.skewX(x);
-    toAdd.matrix.skewY(y);
-    toAdd.type = WebTransformOperation::WebTransformOperationSkew;
-    toAdd.skew.x = x;
-    toAdd.skew.y = y;
-    m_private->operations.append(toAdd);
-}
-
-void WebTransformOperations::appendPerspective(double depth)
-{
-    WebTransformOperation toAdd;
-    toAdd.matrix.applyPerspective(depth);
-    toAdd.type = WebTransformOperation::WebTransformOperationPerspective;
-    toAdd.perspectiveDepth = depth;
-    m_private->operations.append(toAdd);
-}
-
-void WebTransformOperations::appendMatrix(const WebTransformationMatrix& matrix)
-{
-    WebTransformOperation toAdd;
-    toAdd.matrix = matrix;
-    toAdd.type = WebTransformOperation::WebTransformOperationMatrix;
-    m_private->operations.append(toAdd);
-}
-
-void WebTransformOperations::appendIdentity()
-{
-    m_private->operations.append(WebTransformOperation());
-}
-
-bool WebTransformOperations::isIdentity() const
-{
-    for (size_t i = 0; i < m_private->operations.size(); ++i) {
-        if (!m_private->operations[i].isIdentity())
-            return false;
-    }
-    return true;
-}
-
-void WebTransformOperations::reset()
-{
-    m_private.reset(0);
-}
-
-void WebTransformOperations::initialize()
-{
-    m_private.reset(new WebTransformOperationsPrivate);
-}
-
-void WebTransformOperations::initialize(const WebTransformOperations& other)
-{
-    if (m_private.get() != other.m_private.get())
-        m_private.reset(new WebTransformOperationsPrivate(*other.m_private.get()));
-    else
-        initialize();
-}
-
-bool WebTransformOperations::blendInternal(const WebTransformOperations& from, double progress, WebTransformationMatrix& result) const
-{
-    bool fromIdentity = from.isIdentity();
-    bool toIdentity = isIdentity();
-    if (fromIdentity && toIdentity)
-        return true;
-
-    if (matchesTypes(from)) {
-        size_t numOperations = max(fromIdentity ? 0 : from.m_private->operations.size(),
-                                   toIdentity ? 0 : m_private->operations.size());
-        for (size_t i = 0; i < numOperations; ++i) {
-            WebTransformationMatrix blended;
-            if (!blendTransformOperations(fromIdentity ? 0 : &from.m_private->operations[i],
-                                          toIdentity ? 0 : &m_private->operations[i],
-                                          progress,
-                                          blended))
-                return false;
-            result.multiply(blended);
-        }
-        return true;
-    }
-
-    result = apply();
-    WebTransformationMatrix fromTransform = from.apply();
-    return result.blend(fromTransform, progress);
-}
-
-} // namespace WebKit
Index: src/third_party/WebKit/Source/WebCore/platform/image-decoders/skia/ImageDecoderSkia.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/image-decoders/skia/ImageDecoderSkia.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/image-decoders/skia/ImageDecoderSkia.cpp	(working copy)
@@ -32,7 +32,8 @@
 namespace WebCore {
 
 ImageFrame::ImageFrame()
-    : m_hasAlpha(false)
+    : m_allocator(0)
+    , m_hasAlpha(false)
     , m_status(FrameEmpty)
     , m_duration(0)
     , m_disposalMethod(DisposeNotSpecified)
@@ -49,6 +50,7 @@
     // Keep the pixels locked since we will be writing directly into the
     // bitmap throughout this object's lifetime.
     m_bitmap.bitmap().lockPixels();
+    setMemoryAllocator(other.allocator());
     setOriginalFrameRect(other.originalFrameRect());
     setStatus(other.status());
     setDuration(other.duration());
@@ -93,7 +95,7 @@
     ASSERT(!width() && !height());
 
     m_bitmap.bitmap().setConfig(SkBitmap::kARGB_8888_Config, newWidth, newHeight);
-    if (!m_bitmap.bitmap().allocPixels())
+    if (!m_bitmap.bitmap().allocPixels(m_allocator, 0))
         return false;
 
     zeroFillPixelData();
Index: src/third_party/WebKit/Source/WebCore/platform/image-decoders/ImageDecoder.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/image-decoders/ImageDecoder.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/image-decoders/ImageDecoder.h	(working copy)
@@ -157,6 +157,13 @@
         {
             return m_bitmap.bitmap();
         }
+
+        void setMemoryAllocator(SkBitmap::Allocator* allocator)
+        {
+            m_allocator = allocator;
+        }
+
+        SkBitmap::Allocator* allocator() const { return m_allocator; }
 #endif
 
         // Use fix point multiplier instead of integer division or floating point math.
@@ -212,6 +219,7 @@
 
 #if USE(SKIA)
         NativeImageSkia m_bitmap;
+        SkBitmap::Allocator* m_allocator;
 #else
         Vector<PixelData> m_backingStore;
         PixelData* m_bytes; // The memory is backed by m_backingStore.
@@ -406,6 +414,15 @@
 
         virtual void reportMemoryUsage(MemoryObjectInfo*) const;
 
+#if USE(SKIA)
+        virtual void setMemoryAllocator(SkBitmap::Allocator* allocator)
+        {
+            // FIXME: this doesn't work for images with multiple frames.
+            if (m_frameBufferCache.isEmpty())
+                m_frameBufferCache.resize(1);
+            m_frameBufferCache[0].setMemoryAllocator(allocator);
+        }
+#endif
     protected:
         void prepareScaleDataIfNecessary();
         int upperBoundScaledX(int origX, int searchStart = 0);
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageFrameGenerator.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageFrameGenerator.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageFrameGenerator.h	(working copy)
@@ -26,6 +26,7 @@
 #ifndef ImageFrameGenerator_h
 #define ImageFrameGenerator_h
 
+#include "DiscardablePixelRef.h"
 #include "SkTypes.h"
 #include "SkBitmap.h"
 #include "SkSize.h"
@@ -79,6 +80,7 @@
     SkISize m_fullSize;
     ThreadSafeDataTransport m_data;
     bool m_decodeFailedAndEmpty;
+    DiscardablePixelRefAllocator m_allocator;
 
     OwnPtr<ImageDecoderFactory> m_imageDecoderFactory;
 
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DeferredImageDecoder.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DeferredImageDecoder.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DeferredImageDecoder.cpp	(working copy)
@@ -110,7 +110,8 @@
     if (s_enabled
         && m_actualDecoder
         && m_actualDecoder->repetitionCount() == cAnimationNone
-        && m_actualDecoder->isSizeAvailable()) {
+        && m_actualDecoder->isSizeAvailable()
+        && m_actualDecoder->frameCount() == 1) {
 
         m_size = m_actualDecoder->size();
         m_filenameExtension = m_actualDecoder->filenameExtension();
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/AnimationTranslationUtil.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/AnimationTranslationUtil.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/AnimationTranslationUtil.cpp	(working copy)
@@ -57,10 +57,12 @@
 
 namespace WebCore {
 
-WebTransformOperations toWebTransformOperations(const TransformOperations& transformOperations, const FloatSize& boxSize)
+PassOwnPtr<WebTransformOperations> toWebTransformOperations(const TransformOperations& transformOperations, const FloatSize& boxSize)
 {
     // We need to do a deep copy the transformOperations may contain ref pointers to TransformOperation objects.
-    WebTransformOperations webTransformOperations;
+    OwnPtr<WebTransformOperations> webTransformOperations = adoptPtr(Platform::current()->compositorSupport()->createTransformOperations());
+    if (!webTransformOperations)
+        return nullptr;
     for (size_t j = 0; j < transformOperations.size(); ++j) {
         TransformOperation::OperationType operationType = transformOperations.operations()[j]->getOperationType();
         switch (operationType) {
@@ -70,7 +72,7 @@
         case TransformOperation::SCALE_3D:
         case TransformOperation::SCALE: {
             ScaleTransformOperation* transform = static_cast<ScaleTransformOperation*>(transformOperations.operations()[j].get());
-            webTransformOperations.appendScale(transform->x(), transform->y(), transform->z());
+            webTransformOperations->appendScale(transform->x(), transform->y(), transform->z());
             break;
         }
         case TransformOperation::TRANSLATE_X:
@@ -79,7 +81,7 @@
         case TransformOperation::TRANSLATE_3D:
         case TransformOperation::TRANSLATE: {
             TranslateTransformOperation* transform = static_cast<TranslateTransformOperation*>(transformOperations.operations()[j].get());
-            webTransformOperations.appendTranslate(floatValueForLength(transform->x(), boxSize.width()), floatValueForLength(transform->y(), boxSize.height()), floatValueForLength(transform->z(), 1));
+            webTransformOperations->appendTranslate(floatValueForLength(transform->x(), boxSize.width()), floatValueForLength(transform->y(), boxSize.height()), floatValueForLength(transform->z(), 1));
             break;
         }
         case TransformOperation::ROTATE_X:
@@ -87,35 +89,35 @@
         case TransformOperation::ROTATE_3D:
         case TransformOperation::ROTATE: {
             RotateTransformOperation* transform = static_cast<RotateTransformOperation*>(transformOperations.operations()[j].get());
-            webTransformOperations.appendRotate(transform->x(), transform->y(), transform->z(), transform->angle());
+            webTransformOperations->appendRotate(transform->x(), transform->y(), transform->z(), transform->angle());
             break;
         }
         case TransformOperation::SKEW_X:
         case TransformOperation::SKEW_Y:
         case TransformOperation::SKEW: {
             SkewTransformOperation* transform = static_cast<SkewTransformOperation*>(transformOperations.operations()[j].get());
-            webTransformOperations.appendSkew(transform->angleX(), transform->angleY());
+            webTransformOperations->appendSkew(transform->angleX(), transform->angleY());
             break;
         }
         case TransformOperation::MATRIX: {
             MatrixTransformOperation* transform = static_cast<MatrixTransformOperation*>(transformOperations.operations()[j].get());
             TransformationMatrix m = transform->matrix();
-            webTransformOperations.appendMatrix(WebTransformationMatrix(m));
+            webTransformOperations->appendMatrix(WebTransformationMatrix(m));
             break;
         }
         case TransformOperation::MATRIX_3D: {
             Matrix3DTransformOperation* transform = static_cast<Matrix3DTransformOperation*>(transformOperations.operations()[j].get());
             TransformationMatrix m = transform->matrix();
-            webTransformOperations.appendMatrix(WebTransformationMatrix(m));
+            webTransformOperations->appendMatrix(WebTransformationMatrix(m));
             break;
         }
         case TransformOperation::PERSPECTIVE: {
             PerspectiveTransformOperation* transform = static_cast<PerspectiveTransformOperation*>(transformOperations.operations()[j].get());
-            webTransformOperations.appendPerspective(floatValueForLength(transform->perspective(), 0));
+            webTransformOperations->appendPerspective(floatValueForLength(transform->perspective(), 0));
             break;
         }
         case TransformOperation::IDENTITY:
-            webTransformOperations.appendIdentity();
+            webTransformOperations->appendIdentity();
             break;
         case TransformOperation::NONE:
             // Do nothing.
@@ -123,7 +125,7 @@
         } // switch
     } // for each operation
 
-    return webTransformOperations;
+    return webTransformOperations.release();
 }
 
 template <class Value, class Keyframe, class Curve>
@@ -153,13 +155,17 @@
 bool appendKeyframeWithStandardTimingFunction<TransformAnimationValue, WebTransformKeyframe, WebTransformAnimationCurve>(WebTransformAnimationCurve* curve, double keyTime, const TransformAnimationValue* value, const TransformAnimationValue* lastValue, WebKit::WebAnimationCurve::TimingFunctionType timingFunctionType, const FloatSize& boxSize)
 {
     bool canBlend = !lastValue;
-    WebTransformOperations operations = toWebTransformOperations(*value->value(), boxSize);
+    OwnPtr<WebTransformOperations> operations(toWebTransformOperations(*value->value(), boxSize));
+    if (!operations)
+        return false;
     if (!canBlend) {
-        WebTransformOperations lastOperations = toWebTransformOperations(*lastValue->value(), boxSize);
-        canBlend = lastOperations.canBlendWith(operations);
+        OwnPtr<WebTransformOperations> lastOperations(toWebTransformOperations(*lastValue->value(), boxSize));
+        if (!lastOperations)
+            return false;
+        canBlend = lastOperations->canBlendWith(*operations);
     }
     if (canBlend) {
-        curve->add(WebTransformKeyframe(keyTime, operations), timingFunctionType);
+        curve->add(WebTransformKeyframe(keyTime, operations.leakPtr()), timingFunctionType);
         return true;
     }
     return false;
@@ -169,13 +175,17 @@
 bool appendKeyframeWithCustomBezierTimingFunction<TransformAnimationValue, WebTransformKeyframe, WebTransformAnimationCurve>(WebTransformAnimationCurve* curve, double keyTime, const TransformAnimationValue* value, const TransformAnimationValue* lastValue, double x1, double y1, double x2, double y2, const FloatSize& boxSize)
 {
     bool canBlend = !lastValue;
-    WebTransformOperations operations = toWebTransformOperations(*value->value(), boxSize);
+    OwnPtr<WebTransformOperations> operations(toWebTransformOperations(*value->value(), boxSize));
+    if (!operations)
+        return false;
     if (!canBlend) {
-        WebTransformOperations lastOperations = toWebTransformOperations(*lastValue->value(), boxSize);
-        canBlend = lastOperations.canBlendWith(operations);
+        OwnPtr<WebTransformOperations> lastOperations(toWebTransformOperations(*lastValue->value(), boxSize));
+        if (!lastOperations)
+            return false;
+        canBlend = lastOperations->canBlendWith(*operations);
     }
     if (canBlend) {
-        curve->add(WebTransformKeyframe(keyTime, operations), x1, y1, x2, y2);
+        curve->add(WebTransformKeyframe(keyTime, operations.leakPtr()), x1, y1, x2, y2);
         return true;
     }
     return false;
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageDecodingStore.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageDecodingStore.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageDecodingStore.cpp	(working copy)
@@ -82,37 +82,46 @@
     ASSERT(cachedImage);
 
     CacheEntry* cacheEntry = 0;
+    Vector<OwnPtr<CacheEntry> > cacheEntriesToDelete;
     {
         MutexLocker lock(m_mutex);
         CacheMap::iterator iter = m_cacheMap.find(std::make_pair(generator, scaledSize));
         if (iter == m_cacheMap.end())
             return false;
         cacheEntry = iter->value.get();
-        if (condition == CacheMustBeComplete && !cacheEntry->cachedImage()->isComplete())
+        ScaledImageFragment* image = cacheEntry->cachedImage();
+        if (condition == CacheMustBeComplete && !image->isComplete())
             return false;
 
         // Incomplete cache entry cannot be used more than once.
-        ASSERT(cacheEntry->cachedImage()->isComplete() || !cacheEntry->useCount());
+        ASSERT(image->isComplete() || !cacheEntry->useCount());
 
-        // Increment use count such that it doesn't get evicted.
-        cacheEntry->incrementUseCount();
+        image->bitmap().lockPixels();
+        if (image->bitmap().getPixels()) {
+            // Increment use count such that it doesn't get evicted.
+            cacheEntry->incrementUseCount();
+
+            // Complete cache entry doesn't have a decoder.
+            ASSERT(!image->isComplete() || !cacheEntry->cachedDecoder());
+
+            if (decoder)
+                *decoder = cacheEntry->cachedDecoder();
+            *cachedImage = image;
+        } else {
+            image->bitmap().unlockPixels();
+            removeFromCacheInternal(cacheEntry, &cacheEntriesToDelete);
+            removeFromCacheListInternal(cacheEntriesToDelete);
+            return false;
+        }
     }
 
-    // Complete cache entry doesn't have a decoder.
-    ASSERT(!cacheEntry->cachedImage()->isComplete() || !cacheEntry->cachedDecoder());
-
-    if (decoder)
-        *decoder = cacheEntry->cachedDecoder();
-    *cachedImage = cacheEntry->cachedImage();
-    (*cachedImage)->bitmap().lockPixels();
     return true;
 }
 
 void ImageDecodingStore::unlockCache(const ImageFrameGenerator* generator, const ScaledImageFragment* cachedImage)
 {
+    MutexLocker lock(m_mutex);
     cachedImage->bitmap().unlockPixels();
-
-    MutexLocker lock(m_mutex);
     CacheMap::iterator iter = m_cacheMap.find(std::make_pair(generator, cachedImage->scaledSize()));
     ASSERT(iter != m_cacheMap.end());
 
@@ -129,9 +138,6 @@
     // Prune old cache entries to give space for the new one.
     prune();
 
-    // Lock the underlying SkBitmap to prevent it from being purged.
-    image->bitmap().lockPixels();
-
     ScaledImageFragment* cachedImage = image.get();
     OwnPtr<CacheEntry> newCacheEntry;
 
@@ -142,6 +148,8 @@
         newCacheEntry = CacheEntry::createAndUse(generator, image, decoder);
 
     MutexLocker lock(m_mutex);
+    // Lock the underlying SkBitmap to prevent it from being purged.
+    cachedImage->bitmap().lockPixels();
     ASSERT(!m_cacheMap.contains(newCacheEntry->cacheKey()));
     insertCacheInternal(newCacheEntry.release());
     return cachedImage;
@@ -149,12 +157,11 @@
 
 const ScaledImageFragment* ImageDecodingStore::overwriteAndLockCache(const ImageFrameGenerator* generator, const ScaledImageFragment* cachedImage, PassOwnPtr<ScaledImageFragment> newImage)
 {
-    cachedImage->bitmap().unlockPixels();
-
     OwnPtr<ImageDecoder> trash;
     const ScaledImageFragment* newCachedImage = 0;
     {
         MutexLocker lock(m_mutex);
+        cachedImage->bitmap().unlockPixels();
         CacheMap::iterator iter = m_cacheMap.find(std::make_pair(generator, cachedImage->scaledSize()));
         ASSERT(iter != m_cacheMap.end());
 
@@ -162,12 +169,17 @@
         ASSERT(cacheEntry->useCount() == 1);
         ASSERT(!cacheEntry->cachedImage()->isComplete());
 
+        bool isNewImageDiscardable = DiscardablePixelRef::isDiscardable(newImage->bitmap().pixelRef());
+        if (cacheEntry->isDiscardable() && !isNewImageDiscardable)
+            incrementMemoryUsage(cacheEntry->memoryUsageInBytes());
+        else if (!cacheEntry->isDiscardable() && isNewImageDiscardable)
+            decrementMemoryUsage(cacheEntry->memoryUsageInBytes());
         trash = cacheEntry->overwriteCachedImage(newImage);
         newCachedImage = cacheEntry->cachedImage();
+        // Lock the underlying SkBitmap to prevent it from being purged.
+        newCachedImage->bitmap().lockPixels();
     }
 
-    // Lock the underlying SkBitmap to prevent it from being purged.
-    newCachedImage->bitmap().lockPixels();
     return newCachedImage;
 }
 
@@ -232,7 +244,7 @@
 
         // Walk the list of cache entries starting from the least recently used
         // and then keep them for deletion later.
-        while (cacheEntry && m_memoryUsageInBytes > m_cacheLimitInBytes) {
+        while (cacheEntry && (m_memoryUsageInBytes > m_cacheLimitInBytes || !m_cacheLimitInBytes)) {
             // Cache is not used; Remove it.
             if (!cacheEntry->useCount())
                 removeFromCacheInternal(cacheEntry, &cacheEntriesToDelete);
@@ -246,7 +258,8 @@
 
 void ImageDecodingStore::insertCacheInternal(PassOwnPtr<CacheEntry> cacheEntry)
 {
-    incrementMemoryUsage(cacheEntry->memoryUsageInBytes());
+    if (!cacheEntry->isDiscardable())
+        incrementMemoryUsage(cacheEntry->memoryUsageInBytes());
 
     // m_orderedCacheList is used to support LRU operations to reorder cache
     // entries quickly.
@@ -264,7 +277,8 @@
 
 void ImageDecodingStore::removeFromCacheInternal(const CacheEntry* cacheEntry, Vector<OwnPtr<CacheEntry> >* deletionList)
 {
-    decrementMemoryUsage(cacheEntry->memoryUsageInBytes());
+    if (!cacheEntry->isDiscardable())
+        decrementMemoryUsage(cacheEntry->memoryUsageInBytes());
 
     // Remove from m_cacheMap.
     CacheIdentifier key = cacheEntry->cacheKey();
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageFrameGenerator.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageFrameGenerator.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageFrameGenerator.cpp	(working copy)
@@ -112,8 +112,13 @@
     if (!fullSizeImage && !ImageDecodingStore::instance()->lockCache(this, m_fullSize, ImageDecodingStore::CacheMustBeComplete, &fullSizeImage))
         return 0;
 
-    SkBitmap scaledBitmap = skia::ImageOperations::Resize(
-        fullSizeImage->bitmap(), resizeMethod(), scaledSize.width(), scaledSize.height());
+    DiscardablePixelRefAllocator allocator;
+    // This call allocates the DiscardablePixelRef and lock/unlocks it
+    // afterwards. So the memory allocated to the scaledBitmap can be
+    // discarded after this call. Need to lock the scaledBitmap and
+    // check the pixels before using it next time.
+    SkBitmap scaledBitmap = skia::ImageOperations::Resize(fullSizeImage->bitmap(), resizeMethod(), scaledSize.width(), scaledSize.height(), &allocator);
+
     OwnPtr<ScaledImageFragment> scaledImage = ScaledImageFragment::create(scaledSize, scaledBitmap, fullSizeImage->isComplete());
 
     ImageDecodingStore::instance()->unlockCache(this, fullSizeImage);
@@ -189,7 +194,15 @@
             return nullptr;
     }
 
+    // TODO: this is very ugly. We need to refactor the way how we can pass a
+    // memory allocator to image decoders.
+    (*decoder)->setMemoryAllocator(&m_allocator);
     (*decoder)->setData(data, allDataReceived);
+    // If this call returns a newly allocated DiscardablePixelRef, then
+    // ImageFrame::m_bitmap and the contained DiscardablePixelRef are locked.
+    // They will be unlocked when ImageDecoder is destroyed since ImageDecoder
+    // owns the ImageFrame. Partially decoded SkBitmap is thus inserted into the
+    // ImageDecodingStore while locked.
     ImageFrame* frame = (*decoder)->frameBufferAtIndex(0);
     (*decoder)->setData(0, false); // Unref SharedBuffer from ImageDecoder.
 
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageDecodingStore.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageDecodingStore.h	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/ImageDecodingStore.h	(working copy)
@@ -26,6 +26,7 @@
 #ifndef ImageDecodingStore_h
 #define ImageDecodingStore_h
 
+#include "DiscardablePixelRef.h"
 #include "ImageDecoder.h"
 #include "ScaledImageFragment.h"
 #include "SkTypes.h"
@@ -92,6 +93,7 @@
             , m_cachedImage(image)
             , m_cachedDecoder(decoder)
             , m_useCount(count)
+            , m_isDiscardable(DiscardablePixelRef::isDiscardable(m_cachedImage->bitmap().pixelRef()))
         {
         }
 
@@ -106,6 +108,7 @@
         ImageDecoder* cachedDecoder() const { return m_cachedDecoder.get(); }
         PassOwnPtr<ImageDecoder> overwriteCachedImage(PassOwnPtr<ScaledImageFragment> image)
         {
+            m_isDiscardable = DiscardablePixelRef::isDiscardable(image->bitmap().pixelRef());
             m_cachedImage = image;
             if (m_cachedImage->isComplete())
                 return m_cachedDecoder.release();
@@ -114,6 +117,7 @@
         int useCount() const { return m_useCount; }
         void incrementUseCount() { ++m_useCount; }
         void decrementUseCount() { --m_useCount; ASSERT(m_useCount >= 0); }
+        bool isDiscardable() const { return m_isDiscardable; }
 
         // FIXME: getSafeSize() returns size in bytes truncated to a 32-bits integer.
         //        Find a way to get the size in 64-bits.
@@ -126,6 +130,7 @@
         OwnPtr<ScaledImageFragment> m_cachedImage;
         OwnPtr<ImageDecoder> m_cachedDecoder;
         int m_useCount;
+        bool m_isDiscardable;
     };
 
     ImageDecodingStore();
@@ -163,6 +168,8 @@
     //   m_cachedSizeMap
     //   m_cacheLimitInBytes
     //   m_memoryUsageInBytes
+    // This mutex also protects calls to underlying skBitmap's
+    // lockPixels()/unlockPixels() as they are not threadsafe.
     Mutex m_mutex;
 };
 
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/skia/PlatformContextSkia.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/skia/PlatformContextSkia.cpp	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/skia/PlatformContextSkia.cpp	(working copy)
@@ -224,7 +224,7 @@
 
 SkDevice* PlatformContextSkia::createCompatibleDevice(const IntSize& size, bool hasAlpha)
 {
-    return m_canvas->createCompatibleDevice(bitmap()->config(), size.width(), size.height(), !hasAlpha);
+    return m_canvas->createCompatibleDevice(SkBitmap::kARGB_8888_Config, size.width(), size.height(), !hasAlpha);
 }
 
 bool PlatformContextSkia::isDrawingToImageBuffer() const
Index: src/third_party/WebKit/Source/WebCore/WebCore.gypi
===================================================================
--- src/third_party/WebKit/Source/WebCore/WebCore.gypi	(revision 143973)
+++ src/third_party/WebKit/Source/WebCore/WebCore.gypi	(working copy)
@@ -3823,6 +3823,8 @@
             'platform/graphics/chromium/CrossProcessFontLoading.mm',
             'platform/graphics/chromium/DeferredImageDecoder.cpp',
             'platform/graphics/chromium/DeferredImageDecoder.h',
+            'platform/graphics/chromium/DiscardablePixelRef.cpp',
+            'platform/graphics/chromium/DiscardablePixelRef.h',
             'platform/graphics/chromium/DrawingBufferChromium.cpp',
             'platform/graphics/chromium/Extensions3DChromium.h',
             'platform/graphics/chromium/FontCacheAndroid.cpp',
@@ -7142,7 +7144,7 @@
             'platform/chromium/support/WebScrollbarImpl.h',
             'platform/chromium/support/WebSharedGraphicsContext3D.cpp',
             'platform/chromium/support/WebThreadSafeData.cpp',
-            'platform/chromium/support/WebTransformOperations.cpp',
+            'platform/chromium/support/WebTransformKeyframe.cpp',
             'platform/chromium/support/WebTransformationMatrix.cpp',
             'platform/chromium/support/WebURL.cpp',
             'platform/chromium/support/WebURLError.cpp',
Index: src/third_party/WebKit/Source/Platform/chromium/public/WebDiscardableMemory.h
===================================================================
--- src/third_party/WebKit/Source/Platform/chromium/public/WebDiscardableMemory.h (revision 0)
+++ src/third_party/WebKit/Source/Platform/chromium/public/WebDiscardableMemory.h (revision 0)
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WebDiscardableMemory_h
+#define WebDiscardableMemory_h
+
+namespace WebKit {
+
+// A memory allocation that can be automatically discarded by the operating
+// system under memory pressure.
+//
+// Discardable usage is typically:
+//    WebDiscardableMemory* mem = allocateAndLockedDiscardableMemory(1024*1024);
+//    void* data = mem->data();
+//    memset(data, 3, 1024*1024);
+//    mem->unlock();
+//
+// Later, when you need it again:
+//    if (!mem->lock()) {
+//       ... handle the fact that the memory is gone...
+//       delete mem; // Make sure to destroy it. It is never going to come back.
+//       return;
+//    }
+//    ... use mem->data() as much as you want
+//    mem->unlock();
+//
+class WebDiscardableMemory {
+public:
+    // Must not be called while locked.
+    virtual ~WebDiscardableMemory() { }
+
+    // Locks the memory, prevent it from being discarded. Once locked. you may
+    // obtain a pointer to that memory using the data() method.
+    //
+    // lock() may return false, indicating that the underlying memory was
+    // discarded and that the lock failed. In this case, the
+    // WebDiscardableMemory is effectively dead.
+    //
+    // Nested calls to lock are not allowed.
+    virtual bool lock() = 0;
+
+    // Returns the current pointer for the discardable memory. This call is ONLY
+    // valid when the discardable memory object is locked.
+    virtual void* data() = 0;
+
+    // Unlock the memory so that it can be purged by the system. Must be called
+    // after every successful lock call.
+    virtual void unlock() = 0;
+};
+
+} // namespace WebKit
+
+#endif
Index: src/third_party/WebKit/Source/WebKit/chromium/src/painting/ContinuousPainter.cpp
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/painting/ContinuousPainter.cpp (revision 0)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/painting/ContinuousPainter.cpp (revision 0)
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
+ * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "ContinuousPainter.h"
+
+#include "GraphicsLayer.h"
+#include "PageOverlayList.h"
+
+using namespace WebCore;
+
+namespace WebKit {
+
+void ContinuousPainter::setNeedsDisplayRecursive(GraphicsLayer* layer, PageOverlayList* pageOverlays)
+{
+    if (!layer)
+        return;
+
+    if (pageOverlays && pageOverlays->findGraphicsLayer(layer) != WTF::notFound)
+        return;
+
+    layer->setNeedsDisplay();
+
+    setNeedsDisplayRecursive(layer->maskLayer(), pageOverlays);
+    setNeedsDisplayRecursive(layer->replicaLayer(), pageOverlays);
+
+    const Vector<GraphicsLayer*>& children = layer->children();
+    Vector<GraphicsLayer*>::const_iterator it;
+    for (it = children.begin(); it != children.end(); ++it)
+        setNeedsDisplayRecursive(*it, pageOverlays);
+}
+
+} // namespace WebKit
Index: src/third_party/WebKit/Source/WebKit/chromium/src/painting/ContinuousPainter.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/src/painting/ContinuousPainter.h (revision 0)
+++ src/third_party/WebKit/Source/WebKit/chromium/src/painting/ContinuousPainter.h (revision 0)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
+ * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ContinuousPainter_h
+#define ContinuousPainter_h
+
+namespace WebCore {
+class GraphicsLayer;
+}
+
+namespace WebKit {
+class PageOverlayList;
+
+// This class is responsible for calling setNeedsDisplay on all
+// GraphicsLayers in continuous painting mode.
+class ContinuousPainter {
+public:
+    // Calls setNeedsDisplay on the layer, then recursively calls
+    // on mask layers, replica layers and all child layers.
+    // Overlays are excluded, because they impact the page paint time metric.
+    static void setNeedsDisplayRecursive(WebCore::GraphicsLayer*, PageOverlayList*);
+};
+
+} // namespace WebKit
+
+#endif
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/MockDiscardablePixelRef.h
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/MockDiscardablePixelRef.h (revision 0)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/MockDiscardablePixelRef.h (revision 0)
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MockDiscardablePixelRef_h
+
+#include "SkBitmap.h"
+#include "SkPixelRef.h"
+
+namespace WebCore {
+
+class MockDiscardablePixelRef : public SkPixelRef {
+public:
+    MockDiscardablePixelRef() : discarded(false) { setURI("discardable"); }
+    ~MockDiscardablePixelRef() { }
+
+    void discard()
+    {
+        ASSERT(!m_lockedMemory);
+        discarded = true;
+    }
+
+    SK_DECLARE_UNFLATTENABLE_OBJECT()
+
+protected:
+    // SkPixelRef implementation.
+    virtual void* onLockPixels(SkColorTable**)
+    {
+        if (discarded)
+            return 0;
+        m_lockedMemory = &discarded;
+        return m_lockedMemory;
+    }
+
+    virtual void onUnlockPixels()
+    {
+        m_lockedMemory = 0;
+    }
+
+private:
+    void* m_lockedMemory;
+    bool discarded;
+};
+
+} // namespace WebCore
+
+#endif // MockDiscardablePixelRef_h
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/data/disambiguation_popup_page_scale.html
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/data/disambiguation_popup_page_scale.html (revision 0)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/data/disambiguation_popup_page_scale.html (revision 0)
@@ -0,0 +1,20 @@
+<html>
+<head>
+<title>Disambiguation Popup Test</title>
+<style type="text/css">
+.link {
+    display:block;
+    position:absolute;
+    width:200px;
+    height:30px;
+    background-color:#ccccff;
+}
+</style>
+</head>
+<body>
+<a href="#" class="link" style="left:50px;top:50px;">Link 1</a>
+<a href="#" class="link" style="left:50px;top:80px;">Link 2</a>
+<a href="#" class="link" style="left:200px;top:150px;">Link 3</a>
+<a href="#" class="link" style="left:200px;top:200px;">Link 4</a>
+</body>
+</html>
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/data/disambiguation_popup_blacklist.html
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/data/disambiguation_popup_blacklist.html (revision 0)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/data/disambiguation_popup_blacklist.html (revision 0)
@@ -0,0 +1,36 @@
+<html>
+  <head>
+    <style>
+      div {
+        height: 100px;
+        margin: 0px;
+        text-align: center;
+        width: 100%;
+      }
+      div.tightlyPacked {
+        background-color: pink;
+        border: 1px solid black;
+      }
+      div.bugContainer {
+        background-color: cyan;
+      }
+    </style>
+  </head>
+  <body>
+    <div class="tightlyPacked" onclick="window.location='#first';">
+      <div>Leaf node #1</div>
+    </div>
+    <div class="tightlyPacked" onclick="window.location='#second';">
+      <div>Leaf node #2</div>
+    </div>
+    <div></div>
+    <div class="bugContainer" onclick="window.location='#third';">
+      <p class="title">
+        <a class="title" href="#fourth">Random link</a>
+      </p>
+      <p>
+        Breaking node
+      </p>
+    </div>
+  </body>
+</html>
Index: src/third_party/WebKit/Source/WebKit/chromium/tests/data/move_caret.html
===================================================================
--- src/third_party/WebKit/Source/WebKit/chromium/tests/data/move_caret.html (revision 0)
+++ src/third_party/WebKit/Source/WebKit/chromium/tests/data/move_caret.html (revision 0)
@@ -0,0 +1,15 @@
+<!DOCTYPE html>
+<html>
+<body>
+<input id='target' type='text' value='16-char header. ^^ 16-char footer.'></input>
+<script>
+    function select() {
+        var text = document.getElementById('target');
+        text.focus();
+        text.setSelectionRange(17, 17);
+    }
+    window.onload = select;
+</script>
+</body>
+</html>
+
Index: src/third_party/WebKit/Source/WebCore/platform/chromium/support/WebTransformKeyframe.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/chromium/support/WebTransformKeyframe.cpp (revision 0)
+++ src/third_party/WebKit/Source/WebCore/platform/chromium/support/WebTransformKeyframe.cpp (revision 0)
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include <public/WebTransformKeyframe.h>
+
+namespace WebKit {
+
+WebTransformKeyframe::WebTransformKeyframe(double time, WebTransformOperations* value)
+    : m_time(time)
+    , m_value(value)
+{
+}
+
+WebTransformKeyframe::~WebTransformKeyframe()
+{
+    m_value.reset(0);
+}
+
+double WebTransformKeyframe::time() const
+{
+    return m_time;
+}
+
+const WebTransformOperations& WebTransformKeyframe::value() const
+{
+    return *m_value.get();
+}
+
+
+} // namespace WebKit
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DiscardablePixelRef.h
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DiscardablePixelRef.h (revision 0)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DiscardablePixelRef.h (revision 0)
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DiscardablePixelRef_h
+#define DiscardablePixelRef_h
+
+#include "SkBitmap.h"
+#include "SkPixelRef.h"
+
+#include <public/WebDiscardableMemory.h>
+#include <wtf/OwnPtr.h>
+#include <wtf/PassOwnPtr.h>
+
+namespace WebCore {
+
+// Class for allocating the DiscardablePixelRef object.
+class DiscardablePixelRefAllocator : public SkBitmap::Allocator {
+    // SkBitmap::Allocator implementation. The discardable memory allocated
+    // after this call is locked and will not be purged until next
+    // onUnlockPixels().
+    virtual bool allocPixelRef(SkBitmap*, SkColorTable*);
+};
+
+// PixelRef object whose memory can be discarded when pixels are unlocked.
+class DiscardablePixelRef : public SkPixelRef {
+public:
+    DiscardablePixelRef(SkColorTable*, PassOwnPtr<SkMutex>);
+    ~DiscardablePixelRef();
+
+    static bool isDiscardable(SkPixelRef*);
+    bool allocAndLockDiscardableMemory(size_t);
+
+    SK_DECLARE_UNFLATTENABLE_OBJECT()
+
+protected:
+    // SkPixelRef implementation.
+    virtual void* onLockPixels(SkColorTable**);
+    virtual void onUnlockPixels();
+
+private:
+    SkColorTable* m_colorTable;
+    void* m_lockedMemory;
+    OwnPtr<WebKit::WebDiscardableMemory> m_discardable;
+    OwnPtr<SkMutex> m_mutex;
+};
+
+} // namespace WebCore
+
+#endif
Index: src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DiscardablePixelRef.cpp
===================================================================
--- src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DiscardablePixelRef.cpp (revision 0)
+++ src/third_party/WebKit/Source/WebCore/platform/graphics/chromium/DiscardablePixelRef.cpp (revision 0)
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2013 Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "DiscardablePixelRef.h"
+
+#include <public/Platform.h>
+#include <wtf/StdLibExtras.h>
+
+namespace WebCore {
+
+namespace {
+
+// URI label for a discardable SkPixelRef.
+const char labelDiscardable[] = "discardable";
+
+} // namespace
+
+
+bool DiscardablePixelRefAllocator::allocPixelRef(SkBitmap* dst, SkColorTable* ctable)
+{
+    Sk64 size = dst->getSize64();
+    if (size.isNeg() || !size.is32())
+        return false;
+
+    SkAutoTUnref<DiscardablePixelRef> pixelRef(new DiscardablePixelRef(ctable, adoptPtr(new SkMutex())));
+    if (pixelRef->allocAndLockDiscardableMemory(size.get32())) {
+        pixelRef->setURI(labelDiscardable);
+        dst->setPixelRef(pixelRef.get());
+        // This method is only called when a DiscardablePixelRef is created to back a SkBitmap.
+        // It is necessary to lock this SkBitmap to have a valid pointer to pixels. Otherwise,
+        // this SkBitmap could be assigned to another SkBitmap and locking/unlocking the other
+        // SkBitmap will make this one losing its pixels.
+        dst->lockPixels();
+        return true;
+    }
+
+    // Fallback to heap allocator if discardable memory is not available.
+    return dst->allocPixels(ctable);
+}
+
+DiscardablePixelRef::DiscardablePixelRef(SkColorTable* ctable, PassOwnPtr<SkMutex> mutex)
+    : SkPixelRef(mutex.get())
+    , m_colorTable(ctable)
+    , m_lockedMemory(0)
+    , m_mutex(mutex)
+{
+}
+
+DiscardablePixelRef::~DiscardablePixelRef()
+{
+    SkSafeUnref(m_colorTable);
+}
+
+bool DiscardablePixelRef::allocAndLockDiscardableMemory(size_t bytes)
+{
+    m_discardable = adoptPtr(WebKit::Platform::current()->allocateAndLockDiscardableMemory(bytes));
+    if (m_discardable) {
+        m_lockedMemory = m_discardable->data();
+        return true;
+    }
+    return false;
+}
+
+void* DiscardablePixelRef::onLockPixels(SkColorTable** ctable)
+{
+    if (!m_lockedMemory && m_discardable->lock())
+        m_lockedMemory = m_discardable->data();
+
+    *ctable = m_colorTable;
+    return m_lockedMemory;
+}
+
+void DiscardablePixelRef::onUnlockPixels()
+{
+    if (m_lockedMemory)
+        m_discardable->unlock();
+    m_lockedMemory = 0;
+}
+
+bool DiscardablePixelRef::isDiscardable(SkPixelRef* pixelRef)
+{
+    // FIXME: DEFINE_STATIC_LOCAL is not thread safe.
+    // ImageDecodingStore provides the synchronization for this.
+    DEFINE_STATIC_LOCAL(const SkString, discardable, (labelDiscardable));
+    return pixelRef && pixelRef->getURI() && discardable.equals(pixelRef->getURI());
+}
+
+} // namespace WebCore
Index: src/third_party/WebKit/Tools/DumpRenderTree/chromium/TestRunner/src/TestRunner.cpp
===================================================================
--- src/third_party/WebKit/Tools/DumpRenderTree/chromium/TestRunner/src/TestRunner.cpp	(revision 143973)
+++ src/third_party/WebKit/Tools/DumpRenderTree/chromium/TestRunner/src/TestRunner.cpp	(working copy)
@@ -86,7 +86,6 @@
     bindMethod("addUserScript", &TestRunner::addUserScript);
     bindMethod("addUserStyleSheet", &TestRunner::addUserStyleSheet);
     bindMethod("startSpeechInput", &TestRunner::startSpeechInput);
-    bindMethod("loseCompositorContext", &TestRunner::loseCompositorContext);
     bindMethod("markerTextForListItem", &TestRunner::markerTextForListItem);
     bindMethod("findString", &TestRunner::findString);
     bindMethod("setMinimumTimerInterval", &TestRunner::setMinimumTimerInterval);
@@ -492,16 +491,6 @@
     input->startSpeechInput();
 }
 
-void TestRunner::loseCompositorContext(const CppArgumentList& args, CppVariant*)
-{
-    int numTimes;
-    if (args.size() == 1 || !args[0].isNumber())
-        numTimes = 1;
-    else
-        numTimes = args[0].toInt32();
-    m_webView->loseCompositorContext(numTimes);
-}
-
 void TestRunner::markerTextForListItem(const CppArgumentList& args, CppVariant* result)
 {
     WebElement element;
Index: src/third_party/WebKit/Tools/DumpRenderTree/chromium/TestRunner/src/TestRunner.h
===================================================================
--- src/third_party/WebKit/Tools/DumpRenderTree/chromium/TestRunner/src/TestRunner.h	(revision 143973)
+++ src/third_party/WebKit/Tools/DumpRenderTree/chromium/TestRunner/src/TestRunner.h	(working copy)
@@ -108,8 +108,6 @@
 
     void startSpeechInput(const CppArgumentList&, CppVariant*);
 
-    void loseCompositorContext(const CppArgumentList& args, CppVariant* result);
-
     void markerTextForListItem(const CppArgumentList&, CppVariant*);
     void findString(const CppArgumentList&, CppVariant*);
 
