# Copyright (c) 2012 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
################################################################################
# This file describes instructions from AMD64 Architecture Programmer’s Manual
#                               Volume 3: General-Purpose and System Instruction
#                               Chapter 3: General-Purpose Instruction Reference
################################################################################
# File format:
#     three columns separated by commas.  Each line describes one instruction.
################################################################################
# First column: instruction description.
#   Includes name of the instruction and arguments.
#
#   Arguments consist of four parts:
#      1. Read/write attribute (optional).
#      2. Argument type.
#      3. Argument size.
#      4. Implicit argument mark (optional).
#
#      Read/write attribute:
#       ': Instruction does not use this argument (lea or nop).
#       =: Instruction reads from this argument.
#       !: Instruction writes to this argument.
#       &: Instruction reads this argument and writes the result to it.
#        By default one- and two-operand instructions are assumed to read all
#        operands and store result to the last one, while instructions with
#        three or more operands are assumed to read all operands except last one
#        which is used to store the result of the execution.
#      Possible argument types:
#       a: Accumulator: %al/%ax/%eax/%rax/%es (depending on size).
#       c: Counter register: %cl/%cx/%ecx/%rcx/%cs (depending on size).
#       d: Data register: %dl/%dx/%edx/%rdx/%ss (depending on size).
#       b: Base register: %bl/%bx/%ebx/%rbx/%ds (depending on size).
#       f: Stack pointer: %spl/%sp/%esp/%rsp/%fs (depending on size).
#       g: Base pointer: %bpl/%bp/%ebp/%rbp/%gs (depending on size).
#       i: Second immediate value encoded in the instruction.
#       o: I/O port in %dx (used in “in”/“out” instructions).
#       p: Accumulator pair (%dx:%ax/%edx:%eax/%rdx:%rax depending on size).
#       r: Register in opcode (low 3 bits plus rex.B).
#       t: Top of the x87 stack (%st).
#       x: A memory operand addressed by the %ds:(%[er]bx). See “xlat”.
#       B: General purpose register specified by the VEX/XOP.vvvv field.
#       E: General purpose register or memory operand specified by the r/m
#          field of the ModRM byte.  For memory operands, the ModRM byte may
#          be followed by a SIB byte to specify one of the indexed
#          register-indirect addressing forms.
#       G: General purpose register specified by the reg field of ModRM.
#       H: YMM or XMM register specified by the VEX/XOP.vvvv field.
#       I: Immediate value encoded in the instruction.
#       J: The instruction encoding includes a relative offset that is added to
#          the rIP.
#       L: YMM or XMM register specified using the most-significant 4 bits of an
#          8-bit immediate value.  In legacy or compatibility mode the most
#          significant bit is ignored.
#       M: A memory operand specified by the {mod, r/m} field of the ModRM byte.
#          ModRM.mod ≠ 11b.
#       N: 64-bit MMX register specified by the ModRM.r/m field. The ModRM.mod
#          field must be 11b.
#       O: The offset of an operand is encoded in the instruction. There is no
#          ModRM byte in the instruction encoding. Indexed register-indirect
#          addressing using the SIB byte is not supported.
#       P: 64-bit MMX register specified by the ModRM.reg field.
#       Q: 64-bit MMX-register or memory operand specified by the {mod, r/m}
#          field of the ModRM byte.  For memory operands, the ModRM byte may
#          be followed by a SIB byte to specify one of the indexed
#          register-indirect addressing forms.
#       R: General purpose register specified by the ModRM.r/m field.
#          The ModRM.mod field must be 11b.
#       S: Segment register specified by the ModRM.reg field.
#       U: YMM/XMM register specified by the ModRM.r/m field.
#          The ModRM.mod field must be 11b.
#       V: YMM/XMM register specified by the ModRM.reg field.
#       W: YMM/XMM register or memory operand specified by the {mod, r/m} field
#          of the ModRM byte.   For memory operands, the ModRM byte may be
#          followed by a SIB byte to specify one of the indexed
#          register-indirect addressing forms.
#       X: A memory operand addressed by the %ds:%[er]si registers. Used in
#          string instructions.
#       Y: A memory operand addressed by the %es:%[er]di registers. Used in
#          string instructions.
#      Possible sizes:
#       (no size provided):
#             A byte, word, doubleword, or quadword (in 64-bit mode),
#             depending on the effective operand size.
#       2:    Two bits (see VPERMIL2Px instruction).
#       7:    x87 register %st(N).
#       b:    A byte, irrespective of the effective operand size.
#       d:    A doubleword (32-bit), irrespective of the effective operand size.
#       do:   A double octword (256 bits), irrespective of the effective operand
#             size.
#       dq:   A double quadword (128 bits), irrespective of the effective
#             operand size.
#       fq:   A quadra quadword (256 bits), irrespective of the effective
#             operand size.
#       o:    An octword (128 bits), irrespective of the effective operand size.
#       p:    A 32-bit or 48-bit far pointer, depending on the effective operand
#             size.
#       pb:   A Vector with byte-wide (8-bit) elements (packed byte).
#       pd:   A double-precision (64-bit) floating-point vector operand (packed
#             double-precision).
#       pdw:  Vector composed of 32-bit doublewords.
#       pdwx: Vector composed of 32-bit doublewords. L bit selects 256bit YMM
#             registers.
#       pdx:  A double-precision (64-bit) floating-point vector operand (packed
#             double-precision).  L bit selects 256bit YMM registers.
#       ph:   A half-precision (16-bit) floating-point vector operand (packed
#             half-precision).
#       phx:  A half-precision (16-bit) floating-point vector operand (packed
#             half-precision).  L bit selects 256bit YMM registers.
#       pi:   Vector composed of 16-bit integers (packed integer).
#       pj:   Vector composed of 32-bit integers (packed double integer).
#       pjx:  Vector composed of 32-bit integers (packed double integer).
#             L bit selects 256bit YMM registers.
#       pk:   Vector composed of 8-bit integers (packed half-word integer).
#       pkx:  Vector composed of 8-bit integers (packed half-word integer).
#             L bit selects 256bit YMM registers.
#       pq:   Vector composed of 64-bit integers (packed quadword integer).
#       pqw:  Vector composed of 64-bit quadwords (packed quadword).
#       pqwx: Vector composed of 64-bit quadwords (packed quadword).  L bit
#             selects 256bit YMM registers.
#       pqx:  Vector composed of 64-bit integers (packed quadword integer).
#             L bit selects 256bit YMM registers.
#       ps:   A single-precision floating-point vector operand (packed
#             single-precision).
#       psx:  A single-precision floating-point vector operand (packed
#             single-precision).  L bit selects 256bit YMM registers.
#       pw:   Vector composed of 16-bit words (packed word).
#       q:    A quadword (64-bit), irrespective of the effective operand size.
#       r:    Register size (32bit in 32bit mode, 64bit in 64bit mode).
#       s:    Segment register (if register operand).
#       s:    A 6-byte or 10-byte pseudo-descriptor (if memory operand).
#       sb:   A scalar 10-byte packed BCD value (scalar BCD).
#       sd:   A scalar double-precision floating-point operand (scalar double).
#       se:   A 14-byte or 28-byte x87 environment.
#       si:   A scalar doubleword (32-bit) integer operand (scalar integer).
#       sq:   A scalar quadword (64-bit) integer operand (scalar integer).
#       sr:   A 94-byte or 108-byte x87 state.
#       ss:   A scalar single-precision floating-point operand (scalar single).
#       st:   A scalar 80bit-precision floating-point operand (scalar tenbytes).
#       sw:   A scalar word (16-bit) integer operand (scalar integer).
#       sx:   A 512-byte extended x87/MMX/XMM state.
#       v:    A word, doubleword, or quadword (in 64-bit mode), depending on
#             the effective operand size.
#       w:    A word, irrespective of the effective operand size.
#       y:    A doubleword or quadword depending on effective operand size.
#       z:    A word if the effective operand size is 16 bits, or a doubleword
#             if the effective operand size is 32 or 64 bits.
#      Implicit argument mark:
#       *: This argument is implicit. It's not shown in the diassembly listing.
################################################################################
# Second column: instruction opcodes.
#   Includes all opcode bytes.  If first opcode bytes is 0x66/data16,
#   0xf2/repnz, or 0xf3/rep/repz then they can be moved before other prefixes
#   (and will be moved before REX prefix if it's allowed).  Note: data16, repnz,
#   and rep/repz opcodes will set appropriate flags while 0x66, 0xf2, and 0xf3
#   will not.
#   If part of the opcode is stored in ModRM byte then opcode should include the
#   usual “/0”, “/1”, …, “/7” “bytes”.  Use /s “byte” for segment register
#   operand: it'll make only registers 0..5 valid (there are only six segment
#   registers in total).  Use “/m” or “/r” “byte” to distinguish instructions
#   which have different names for memory and register operands (such as
#   “movlps” or “movhlps”).
################################################################################
# Third column: additional instruction notes.
#   Different kind of notes for the instruction: non-typical prefixes (for
#   example “lock” prefix or “rep” prefix), CPUID checks, etc.
#
#     Possible prefixes:
#       branch_hint: branch hint prefixes are allowed (0x2E, 0x3E)
#       condrep: prefixes “repnz” and “repz” are allowed for the instruction
#       lock: prefix “lock” is allowed for the instruction
#       rep: prefix “rep” is allowed for the instruction (it's alias of “repz”)
#       no_memory_access: command does not access memory in detectable way: lea,
#         nop, prefetch* instructions…
#       norex: “rex” prefix can not be used with this instruction (various “nop”
#         instructions use this flag)
#       norexw: "rex.W" can not be used with this instruction (usually used when
#         instruction with "rex.W" have a different name: e.g. “movd”/“movq”)
#
#     Instruction enabling/disabling:
#       ia32: ia32-only instruction
#       amd64: amd64-only instruction
#       nacl-forbidden: instruction is not supported in NaCl sandbox
#       nacl-ia32-forbidden: instruction is not supported in ia32 NaCl sandbox
#       nacl-amd64-forbidden: instruction is not supported in amd64 NaCl sandbox
#
#     Special marks:
#       nacl-amd64-zero-extends: instruction can be used to zero-extend register
#         in amd64 mode
#       nacl-amd64-modifiable: instruction can be modified in amd64 mode
#       att-show-name-suffix-{b,l,ll,t,s,q,x,y,w}: instruction is shown with the
#         given suffix by objdump in AT&T mode
#       att-show-memory-suffix-{b,l,ll,t,s,q,x,y,w}: instruction is shown in the
#         given suffix by objdump in AT&T mode, but only if it accesses memory
#       spurious-rex.w: instruction ignores rex.w bit (most instructions don't
#         ignore it, that's why it's the default)
#
#     Possible CPUID values:
#       CPUFeature_3DNOW:     Fn8000_0001_EDX[3DNOW]
#       CPUFeature_3DPRFTCH:  Fn8000_0001_ECX[3DNowPrefetch] ||
#                             Fn8000_0001_EDX[LM] ||
#                             Fn8000_0001_EDX[3DNow]
#       CPUFeature_AES:       Fn0000_0001_ECX[AES]
#       CPUFeature_AESAVX:    Fn0000_0001_ECX[AES] && Fn0000_0001_ECX[AVX]
#       CPUFeature_ALTMOVCR8: Fn8000_0001_ECX[ALTMOVCR8] || Fn8000_0001_EDX[LM]
#       CPUFeature_AVX:       Fn0000_0001_ECX[AVX]
#       CPUFeature_BMI1:      Fn0000_0007_EBX_x0[BMI1]
#       CPUFeature_CLFLUSH:   Fn0000_0001_EDX[CLFSH]
#       CPUFeature_CLMUL:     Fn0000_0001_ECX[PCLMULQDQ]
#       CPUFeature_CLMULAVX:  Fn0000_0001_ECX[PCLMULQDQ] &&
#                             Fn0000_0001_ECX[AVX]
#       CPUFeature_CMOV:      Fn0000_0001_EDX[CMOV] || Fn8000_0001_EDX[CMOV]
#       CPUFeature_CMOVx87:  (Fn0000_0001_EDX[CMOV] || Fn8000_0001_EDX[CMOV]) &&
#                             Fn0000_0001_EDX[x87]
#       CPUFeature_CX16:      Fn0000_0001_ECX[CMPXCHG16B]
#       CPUFeature_CX8:       Fn0000_0001_EDX[CMPXCHG8B] ||
#                             Fn8000_0001_EDX[CMPXCHG8B]
#       CPUFeature_E3DNOW:    Fn8000_0001_EDX[E3DNOW]
#       CPUFeature_EMMX:      Fn8000_0001_EDX[EMMX]
#       CPUFeature_EMMXSSE:   Fn8000_0001_EDX[EMMX] ||
#                             Fn0000_0001_EDX[SSE]
#       CPUFeature_F16C:      Fn0000_0001_ECX[F16C]
#       CPUFeature_FMA:       Fn0000_0001_ECX[FMA]
#       CPUFeature_FMA4:      Fn8000_0001_ECX[FMA4]
#       CPUFeature_FXSR:      Fn0000_0001_ECX[XSAVE]
#       CPUFeature_LAHF:      Fn8000_0001_ECX[LahfSahf]
#       CPUFeature_LWP:       Fn8000_0001_ECX[LWP]
#       CPUFeature_LZCNT:     Fn8000_0001_EXC[ABM]
#       CPUFeature_MMX:       Fn0000_0001_EDX[MMX]
#       CPUFeature_MON:       Fn0000_0001_ECX[Monitor]
#       CPUFeature_MOVBE:     Fn0000_0001_ECX[MOVBE]
#       CPUFeature_MSR:       Fn0000_0001_EDX[MSR]
#       CPUFeature_POPCNT:    Fn0000_0001_ECX[POPCNT]
#       CPUFeature_SEP:       Fn0000_0001_EDX[SYSENTER]
#       CPUFeature_SSE:       Fn0000_0001_EDX[SSE]
#       CPUFeature_SSE2:      Fn0000_0001_EDX[SSE2]
#       CPUFeature_SSE3:      Fn0000_00001_ECX[SSE3]
#       CPUFeature_SSE41:     Fn0000_0001_ECX[SSE41]
#       CPUFeature_SSE42:     Fn0000_0001_ECX[SSE42]
#       CPUFeature_SSE4A:     Fn8000_0001_ECX[SSE4A]
#       CPUFeature_SSSE3:     Fn0000_00001_ECX[SSSE3]
#       CPUFeature_SKINIT:   (Fn8000_0001_ECX[SVM] && EFER.SVME) ||
#                             Fn8000_0001_ECX[SKINIT]
#       CPUFeature_SVM:       Fn8000_0001_ECX[SVM] && EFER.SVME
#       CPUFeature_SYSCALL:   Fn8000_0001_EDX[SYSCALL]
#       CPUFeature_TBM:       Fn8000_0001_ECX[TBM]
#       CPUFeature_TSC:       Fn0000_0001_EDX[RDTSC] || Fn8000_0001_EDX[RDTSC]
#       CPUFeature_TSCP:      Fn8000_0001_EDX[RDTSCP]
#       CPUFeature_TZCNT:     Fn0000_0007_EBX_x0[BMI1]
#       CPUFeature_x87:       Fn0000_0001_EDX[x87]
#       CPUFeature_XOP:       Fn8000_0001_ECX[XOP]
######## ADC ###################################################################
# “adc” is not marked as nacl-amd64-zero-extends since borrows/carries should
# not be need when calculating an address.
adc I a, 0x14
adc I E, 0x80 /2, lock
adc Ib Ev, 0x83 /2, lock
adc G E, 0x10, lock
adc E G, 0x12
######## ADD ###################################################################
add I a, 0x04, nacl-amd64-zero-extends
add I E, 0x80 /0, lock nacl-amd64-zero-extends
add Ib Ev, 0x83 /0, lock nacl-amd64-zero-extends
add G E, 0x00, lock nacl-amd64-zero-extends
add E G, 0x02, nacl-amd64-zero-extends
######## AND ###################################################################
and I a, 0x24, nacl-amd64-zero-extends
and I E, 0x80 /4, lock nacl-amd64-zero-extends
and Ib Ev, 0x83 /4, lock nacl-amd64-zero-extends
and G E, 0x20, lock nacl-amd64-zero-extends
and E G, 0x22, nacl-amd64-zero-extends
######## ANDN ##################################################################
andn Ey By Gy, 0xc4 RXB.02 W.src1.0.00 0xf2, CPUFeature_BMI1
######## BEXTR #################################################################
bextr By Ey Gy, 0xc4 RXB.02 W.cntl.0.00 0xf7, CPUFeature_BMI1
bextr Id Ey Gy, 0x8f RXB.0A W.1111.0.00 0x10, CPUFeature_BMI1
######## BLCFILL ###############################################################
# “blcfill” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blcfill Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /1, CPUFeature_TBM
######## BLCI ##################################################################
# “blci” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blci Ey By, 0x8f RXB.09 W.dest.0.00 0x02 /6, CPUFeature_TBM
######## BLCIC #################################################################
# “blcic” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blcic Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /5, CPUFeature_TBM
######## BLCMSK ################################################################
# “blcmsk” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blcmsk Ey By, 0x8f RXB.09 W.dest.0.00 0x02 /1, CPUFeature_TBM
######## BLCS ##################################################################
# “blcs” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blcs Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /3, CPUFeature_TBM
######## BLSFILL ###############################################################
# “blsfill” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blsfill Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /2, CPUFeature_TBM
######## BLSI ##################################################################
# “blsi” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blsi Ey By, 0xc4 RXB.02 W.dest.0.00 0xf3 /3, CPUFeature_BMI1
######## BLSIC #################################################################
# “blsic” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blsic Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /6, CPUFeature_TBM
######## BLSMSK ################################################################
# “blsmsk” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blsmsk Ey By, 0xc4 RXB.02 W.dest.0.00 0xf3 /2, CPUFeature_BMI1
######## BLSSR #################################################################
# “blsr” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
blsr Ey By, 0xc4 RXB.02 W.dest.0.00 0xf3 /1, CPUFeature_BMI1
######## BSF ###################################################################
# Textbook definition of “bsf” as per AMD/Intel manuals looks like this:
#  bsf Ev Gv, 0x0f 0xbc
# For consistency with the production validators, drop support for the 16-bit
#  version of “bsf” in ia32 mode.
# Note that the former 32- and 64-bit validators treat “bsf” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2972
#
# “bsf” is not marked as nacl-amd64-zero-extends because it does not always
# writes to it's second operand:
#  http://code.google.com/p/nativeclient/issues/detail?id=2010
bsf Ew Gw, data16 0x0f 0xbc, norexw nacl-ia32-forbidden
bsf Ed Gd, 0x0f 0xbc, norexw
bsf Eq Gq, rexw 0x0f 0xbc, amd64
bsf Eq Gq, data16 rexw 0x0f 0xbc, amd64 nacl-forbidden
######## BSR ###################################################################
# Textbook definition of “bsr” as per AMD/Intel manuals looks like this:
#  bsr Ev Gv, 0x0f 0xbd
# For consistency with the production validators, drop support for the 16-bit
#  version of “bsr” in ia32 mode.
# Note that the former 32- and 64-bit validators treat “bsr” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2973
#
# “bsr” is not marked as nacl-amd64-zero-extends because it does not always
# writes to it's second operand:
#  http://code.google.com/p/nativeclient/issues/detail?id=2010
bsr Ew Gw, data16 0x0f 0xbd, norexw nacl-ia32-forbidden
bsr Ed Gd, 0x0f 0xbd, norexw
bsr Eq Gq, rexw 0x0f 0xbd, amd64
bsr Eq Gq, data16 rexw 0x0f 0xbd, amd64 nacl-forbidden
######## BSWAP #################################################################
# “bswap” is not marked as nacl-amd64-zero-extends because we don't really think
# that swapping the bottom bytes is a good thing to do to mask a memory
# reference.
bswap ry, 0x0f 0xc8
######## BT ####################################################################
# “bt” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
bt Gv =Ev, 0x0f 0xa3, nacl-forbidden
bt Ib =Ev, 0x0f 0xba /4, nacl-ia32-forbidden
######## BTC ###################################################################
# “btc” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
btc Gv Ev, 0x0f 0xbb, lock nacl-forbidden
btc Ib Ev, 0x0f 0xba /7, lock nacl-ia32-forbidden
######## BTR ###################################################################
# “btr” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
btr Gv Ev, 0x0f 0xb3, lock nacl-forbidden
btr Ib Ev, 0x0f 0xba /6, lock nacl-ia32-forbidden
######## BTS ###################################################################
# “bts” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
bts Gv Ev, 0x0f 0xab, lock nacl-forbidden
bts Ib Ev, 0x0f 0xba /5, lock nacl-ia32-forbidden
######## CALL (Near) ###########################################################
call Jw, data16 0xe8, att-show-name-suffix-w nacl-forbidden
call Jd, 0xe8, ia32
call Jd, 0xe8, amd64 att-show-name-suffix-q nacl-amd64-modifiable
call Jd, data16 rexw 0xe8, amd64 att-show-name-suffix-q nacl-forbidden
# “call” does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# separately.
call Ew, data16 0xff /2, norexw att-show-name-suffix-w nacl-forbidden
call Ed, 0xff /2, ia32 nacl-forbidden
call Eq, 0xff /2, amd64 att-show-name-suffix-q nacl-forbidden
call Eq, data16 rexw 0xff /2, amd64 att-show-name-suffix-q nacl-forbidden
######## CALL (Far) ############################################################
# “lcall” does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# separately.
lcall Mp, data16 0xff /3, norexw att-show-name-suffix-w nacl-forbidden
lcall Mp, 0xff /3, ia32 nacl-forbidden
lcall Mp, 0xff /3, amd64 att-show-name-suffix-q nacl-forbidden
lcall Mp, data16 rexw 0xff /3, amd64 att-show-name-suffix-q nacl-forbidden
######## CBW/CWDE/CDQE #########################################################
cwtl, 0x98, norexw
cbtw, data16 0x98, norexw
cltq, data16 rexw 0x98, amd64 nacl-forbidden
cltq, rexw 0x98, amd64
######## CWD/CDQ/CQO ###########################################################
cltd, 0x99, norexw
cwtd, data16 0x99, norexw
cqto, data16 rexw 0x99, amd64 nacl-forbidden
cqto, rexw 0x99, amd64
######## CLC ###################################################################
clc, 0xf8
######## CLD ###################################################################
cld, 0xfc
######## CLFLUSH ###############################################################
clflush Mb, 0x0f 0xae /7, CPUFeature_CLFLUSH
######## CMC ###################################################################
cmc, 0xf5
######## CMOVCC ################################################################
# “cmovcc” instructions are not marked as nacl-amd64-zero-extends out of caution.
# AMD/Intel manual state that these instrucitons always zero extends 32 bit
# register results to 64 bits, and that this occurs even if the condition is
# false. However, we decided to be safe and omit these instructions anyway.
cmova Ev Gv, 0x0f 0x47, CPUFeature_CMOV
cmovae Ev Gv, 0x0f 0x43, CPUFeature_CMOV
cmovbe Ev Gv, 0x0f 0x46, CPUFeature_CMOV
cmovb Ev Gv, 0x0f 0x42, CPUFeature_CMOV
cmove Ev Gv, 0x0f 0x44, CPUFeature_CMOV
cmovg Ev Gv, 0x0f 0x4f, CPUFeature_CMOV
cmovge Ev Gv, 0x0f 0x4d, CPUFeature_CMOV
cmovle Ev Gv, 0x0f 0x4e, CPUFeature_CMOV
cmovl Ev Gv, 0x0f 0x4c, CPUFeature_CMOV
cmovne Ev Gv, 0x0f 0x45, CPUFeature_CMOV
cmovno Ev Gv, 0x0f 0x41, CPUFeature_CMOV
cmovnp Ev Gv, 0x0f 0x4b, CPUFeature_CMOV
cmovns Ev Gv, 0x0f 0x49, CPUFeature_CMOV
cmovo Ev Gv, 0x0f 0x40, CPUFeature_CMOV
cmovp Ev Gv, 0x0f 0x4a, CPUFeature_CMOV
cmovs Ev Gv, 0x0f 0x48, CPUFeature_CMOV
######## CMP ###################################################################
cmp I =a, 0x3c
cmp I =E, 0x80 /7
cmp Ib =Ev, 0x83 /7
cmp G =E, 0x38
cmp E =G, 0x3a
######## CMPS/CMPSB/CMPSW/CMPSD/CMPSQ ##########################################
cmps Y X, 0xa6, condrep nacl-amd64-forbidden
######## CMPXCHG ###############################################################
# Textbook definition of “cmpxchg” as per AMD/Intel manuals looks like this:
#  cmpxchg G E, 0x0f 0xb0, lock
# For consistency with the production validators:
#  • treat both explicit arguments as read-write
#  • drop support for the 16-bit version
# Note1: “cmpxchg” indeed writes to two arguments, but these areguments are
#  implicit %al/%ax/%eax/%rax and second explicit argument.  First explicit
#  argument is read-only.
# Note2: the former 32- and 64-bit validators treat “cmpxchg” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2974
#
# “cmpxchg” is not marked as nacl-amd64-zero-extends because it conditionally
# writes to different destinations.
cmpxchg &Gb Eb, 0x0f 0xb0, lock
cmpxchg &Gw Ew, data16 0x0f 0xb1, norexw lock nacl-ia32-forbidden
cmpxchg &Gd Ed, 0x0f 0xb1, norexw lock
cmpxchg &Gq Eq, rexw 0x0f 0xb1, amd64 lock
cmpxchg &Gq Eq, data16 rexw 0x0f 0xb1, amd64 lock nacl-forbidden
######## CMPXCHG8B/CMPXCHG16B ##################################################
cmpxchg8b Mq, 0x0f 0xc7 /1, norexw lock CPUFeature_CX8
cmpxchg16b Mo, rexw 0x0f 0xc7 /1, amd64 lock CPUFeature_CX16
######## CPUID #################################################################
# “cpuid” is not marked as nacl-amd64-zero-extends just because it shouldn't be.
cpuid, 0x0f 0xa2
######## CRC32 #################################################################
crc32 E Gy, 0xf2 0x0f 0x38 0xf0, CPUFeature_SSE42
######## DEC ###################################################################
dec E, 0xfe /1, lock nacl-amd64-zero-extends
dec rz, 0x48, ia32
######## DIV ###################################################################
# “div” is not marked as nacl-amd64-zero-extends because we never allowed it.
div =E, 0xf6 /6
######## ENTER #################################################################
# Enter is safe in amd64 mode, but it's safety relies on minute details of
# implementation which can be changed in the future thus we prefer to disable
# it.  It's uncoditionally safe in ia32 mode as per the textbook definition in
# AMD/Intel manual but it does complex manipulations and is very rarely used
# (GCC, in particular, never use it).  As a rule we don't allow complex and
# rarely used instructions such as “aaa” or “bound”.  Disable it for now.
enter iw =Ib, 0xc8, ia32 nacl-forbidden
enter iw =Ib, 0xc8, amd64 att-show-name-suffix-q nacl-forbidden
######## IDIV ##################################################################
# “idiv” is not marked as nacl-amd64-zero-extends because we never allowed it.
idiv =E, 0xf6 /7
######## IMUL ##################################################################
imul =E, 0xf6 /5
imul Ev Gv, 0x0f 0xaf, nacl-amd64-zero-extends
imul Ib Ev Gv, 0x6b, nacl-amd64-zero-extends
imul Iz Ev Gv, 0x69, nacl-amd64-zero-extends
######## IN ####################################################################
# “in” is not marked as nacl-amd64-zero-extends just because it shouldn't be.
in Ib ab, 0xe4, nacl-forbidden
in Ib aw, data16 0xe5, nacl-forbidden
in Ib ad, 0xe5, nacl-forbidden
in Ib ad, rexw 0xe5, spurious-rex.w nacl-forbidden
in Ib ad, data16 rexw 0xe5, nacl-forbidden
in ob ab, 0xec, nacl-forbidden
in ow aw, data16 0xed, nacl-forbidden
in od ad, 0xed, nacl-forbidden
in od ad, rexw 0xed, spurious-rex.w nacl-forbidden
in od ad, data16 rexw 0xed, nacl-forbidden
######## INC ###################################################################
inc E, 0xfe /0, lock nacl-amd64-zero-extends
inc rz, 0x40, ia32
######## INS/INSB/INSW/INSD ####################################################
ins ob Yb, 0x6c, rep att-show-name-suffix-b nacl-forbidden
ins ow Yw, data16 0x6d, rep att-show-name-suffix-w nacl-forbidden
ins od Yd, 0x6d, rep att-show-name-suffix-l nacl-forbidden
ins od Yd, rexw 0x6d, amd64 rep att-show-name-suffix-l nacl-forbidden
ins od Yd, data16 rexw 0x6d, amd64 rep att-show-name-suffix-l nacl-forbidden
######## INT ###################################################################
int =Ib, 0xcd, nacl-forbidden
######## JCXZ/JECXZ/JRCXZ ######################################################
jecxz Jb, 0xe3, ia32 branch_hint nacl-forbidden
jrcxz Jb, 0xe3, amd64 branch_hint
######## Jcc ###################################################################
ja Jb, 0x77, branch_hint
ja Jw, data16 0x0f 0x87, branch_hint nacl-forbidden
ja Jd, 0x0f 0x87, branch_hint
jae Jb, 0x73, branch_hint
jae Jw, data16 0x0f 0x83, branch_hint nacl-forbidden
jae Jd, 0x0f 0x83, branch_hint
jb Jb, 0x72, branch_hint
jb Jw, data16 0x0f 0x82, branch_hint nacl-forbidden
jb Jd, 0x0f 0x82, branch_hint
jbe Jb, 0x76, branch_hint
jbe Jw, data16 0x0f 0x86, branch_hint nacl-forbidden
jbe Jd, 0x0f 0x86, branch_hint
je Jb, 0x74, branch_hint
je Jw, data16 0x0f 0x84, branch_hint nacl-forbidden
je Jd, 0x0f 0x84, branch_hint
jg Jb, 0x7f, branch_hint
jg Jw, data16 0x0f 0x8f, branch_hint nacl-forbidden
jg Jd, 0x0f 0x8f, branch_hint
jge Jb, 0x7d, branch_hint
jge Jw, data16 0x0f 0x8d, branch_hint nacl-forbidden
jge Jd, 0x0f 0x8d, branch_hint
jl Jb, 0x7c, branch_hint
jl Jw, data16 0x0f 0x8c, branch_hint nacl-forbidden
jl Jd, 0x0f 0x8c, branch_hint
jle Jb, 0x7e, branch_hint
jle Jw, data16 0x0f 0x8e, branch_hint nacl-forbidden
jle Jd, 0x0f 0x8e, branch_hint
jne Jb, 0x75, branch_hint
jne Jw, data16 0x0f 0x85, branch_hint nacl-forbidden
jne Jd, 0x0f 0x85, branch_hint
jno Jb, 0x71, branch_hint
jno Jw, data16 0x0f 0x81, branch_hint nacl-forbidden
jno Jd, 0x0f 0x81, branch_hint
jnp Jb, 0x7b, branch_hint
jnp Jw, data16 0x0f 0x8b, branch_hint nacl-forbidden
jnp Jd, 0x0f 0x8b, branch_hint
jns Jb, 0x79, branch_hint
jns Jw, data16 0x0f 0x89, branch_hint nacl-forbidden
jns Jd, 0x0f 0x89, branch_hint
jo Jb, 0x70, branch_hint
jo Jw, data16 0x0f 0x80, branch_hint nacl-forbidden
jo Jd, 0x0f 0x80, branch_hint
jp Jb, 0x7a, branch_hint
jp Jw, data16 0x0f 0x8a, branch_hint nacl-forbidden
jp Jd, 0x0f 0x8a, branch_hint
js Jb, 0x78, branch_hint
js Jw, data16 0x0f 0x88, branch_hint nacl-forbidden
js Jd, 0x0f 0x88, branch_hint
######## JMP (Near) ############################################################
jmp Jb, 0xeb
jmp Jw, data16 0xe9, norexw att-show-name-suffix-w nacl-forbidden
jmp Jd, 0xe9, ia32
jmp Jd, 0xe9, amd64 att-show-name-suffix-q
jmp Jd, data16 rexw 0xe9, amd64 att-show-name-suffix-q nacl-forbidden
# “jmp” does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit jump is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# separately.
jmp Ew, data16 0xff /4, norexw att-show-name-suffix-w nacl-forbidden
jmp Ed, 0xff /4, ia32 nacl-forbidden
jmp Eq, 0xff /4, amd64 att-show-name-suffix-q nacl-forbidden
jmp Eq, data16 rexw 0xff /4, amd64 att-show-name-suffix-q nacl-forbidden
######## JMP (Far) #############################################################
# “ljmp” does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit jump is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# separately.
ljmp Mp, data16 0xff /5, norexw att-show-name-suffix-w nacl-forbidden
ljmp Mp, 0xff /5, ia32 nacl-forbidden
ljmp Mp, 0xff /5, amd64 att-show-name-suffix-q nacl-forbidden
ljmp Mp, data16 rexw 0xff /5, amd64 att-show-name-suffix-q nacl-forbidden
######## LAHF ##################################################################
# LAHF is always available in 16bit/32bit mode, but not always in 64bit mode
lahf, 0x9f, ia32
lahf, 0x9f, amd64 CPUFeature_LAHF nacl-forbidden
######## LDS/LES/LFS/LGS/LSS (AMD version) #####################################
# AMD manual says “executing LFS, LGS, or LSS with a 64-bit operand size only
# loads a 32-bit general purpose register and the specified segment register”.
# lds Mp Gz, 0xc5, ia32 nacl-forbidden
# les Mp Gz, 0xc4, ia32 nacl-forbidden
# lfs Mp Gz, 0x0f 0xb4, nacl-forbidden
# lgs Mp Gz, 0x0f 0xb5, nacl-forbidden
# lss Mp Gz, 0x0f 0xb2, nacl-forbidden
######## LDS/LES/LFS/LGS/LSS (Intel version) ###################################
# Intel manual says: “Using a REX prefix in the form of REX.W promotes operation
# to specify a source operand referencing an 80-bit pointer (16-bit selector,
# 64-bit offset) in memory”.
lds Mp Gv, 0xc5 /m, ia32 nacl-forbidden
les Mp Gv, 0xc4 /m, ia32 nacl-forbidden
# “lfs”, “lgs”, and “lss” are not marked as nacl-amd64-zero-extends because
# segment addresses shouldn't be used.
lfs Mp Gv, 0x0f 0xb4, nacl-forbidden
lgs Mp Gv, 0x0f 0xb5, nacl-forbidden
lss Mp Gv, 0x0f 0xb2, nacl-forbidden
######## LEA ###################################################################
lea 'Mv !Gv, 0x8d, no_memory_access nacl-amd64-zero-extends
######## LEAVE #################################################################
leave, 0xc9, ia32
leave, 0xc9, amd64 att-show-name-suffix-q nacl-forbidden
######## LFENCE ################################################################
lfence, 0x0f 0xae 0xe8, CPUFeature_SSE2
######## LLWPCB ################################################################
llwpcb =Ry, 0x8f RXB.09 W.1111.0.00 0x12 /0, CPUFeature_LWP
######## LODS/LODSB/LODSW/LODSD/LODSQ ##########################################
# Textbook definition of “lods[bwdq]” as per AMD/Intel manuals looks like this:
#  lods X a, 0xac, rep nacl-amd64-forbidden
# For consistency with the production validators, drop support for the “lods” in
#  ia32 mode.
# Note that the former 32- and 64-bit validators treat “lods” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2975
# It's “special” instruction in amd64 mode (and is accepted with “special”
#  sandboxing), but forbidden instruction in ia32 mode.
lods X a, 0xac, rep nacl-forbidden
######## LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ ########################################
# Manual is quite vague WRT usability of branch prediction prefixes combined
# with “loop/loope/loopne” instructions. Old optimization manual (from P4) says
# about them the following: “These hints take the form of prefixes to any type
# of branch instruction.  Branch hints are not guaranteed to have any effect,
# and their function may vary across implementations. On the Pentium 4
# processor, branch hints are active only for relative conditional branches.”
# And today's manual says:
#   — Branch hints:
#     • 2EH—Branch not taken (used only with Jcc instructions)
#     • 3EH—Branch taken (used only with Jcc instructions)
# Since they never had any effect on the code execution their usability is
# quite limited.  We disable them for now.
loop Jb, 0xe2, nacl-ia32-forbidden
loop Jb, 0xe2, branch_hint nacl-forbidden
loope Jb, 0xe1, nacl-ia32-forbidden
loope Jb, 0xe1, branch_hint nacl-forbidden
loopne Jb, 0xe0, nacl-ia32-forbidden
loopne Jb, 0xe0, branch_hint nacl-forbidden
######## LWPINS ################################################################
lwpins Id Ed =By, 0x8f RXB.0A W.src1.0.00 0x12 /0, CPUFeature_LWP
######## LWPVAL ################################################################
lwpval Id Ed =By, 0x8f RXB.0A W.src1.0.00 0x12 /1, CPUFeature_LWP
######## LZCNT #################################################################
# Textbook definition of “lzcnt” as per AMD/Intel manuals looks like this:
#   lzcnt Ev Gv, 0xf3 0x0f 0xbd, CPUFeature_LZCNT nacl-amd64-zero-extends
# “lzcnt” is not marked as nacl-amd64-zero-extends because it is unlikely to be
# useful for computing an address based on the number of leading zeros of a
# value.
# Also, since f3 opcode extension is counted as rep prefix, it is not allowed
# together with data16 prefix.
# See http://code.google.com/p/nativeclient/issues/detail?id=3076
lzcnt Ew Gw, data16 0xf3 0x0f 0xbd, norexw CPUFeature_LZCNT nacl-forbidden
lzcnt Ed Gd, 0xf3 0x0f 0xbd, norexw CPUFeature_LZCNT
lzcnt Eq Gq, rexw 0xf3 0x0f 0xbd, amd64 CPUFeature_LZCNT
lzcnt Eq Gq, data16 rexw 0xf3 0x0f 0xbd, amd64 CPUFeature_LZCNT nacl-forbidden
######## MFENCE ################################################################
mfence, 0x0f 0xae 0xf0, CPUFeature_SSE2
######## MOV ###################################################################
mov G E, 0x88, nacl-amd64-modifiable nacl-amd64-zero-extends
mov E G, 0x8a, nacl-amd64-modifiable nacl-amd64-zero-extends
mov Sw Mw, 0x8c /s, nacl-forbidden
mov Sw Rv, 0x8c /s, nacl-forbidden
mov Ew Sw, 0x8e /s, nacl-forbidden
mov Ib rb, 0xb0, nacl-amd64-modifiable nacl-amd64-zero-extends
mov Iv rv, 0xb8, nacl-amd64-modifiable nacl-amd64-zero-extends
mov I E, 0xc6 /0, nacl-amd64-modifiable nacl-amd64-zero-extends
mov Ob ab, 0xa0, ia32
mov Ov av, 0xa1, ia32
mov ab Ob, 0xa2, ia32
mov av Ov, 0xa3, ia32
movabs Ob ab, 0xa0, amd64 nacl-forbidden
movabs Ov av, 0xa1, amd64 nacl-forbidden
movabs ab Ob, 0xa2, amd64 nacl-forbidden
movabs av Ov, 0xa3, amd64 nacl-forbidden
######## MOVBE #################################################################
# Textbook definition of “movbe” as per AMD/Intel manuals looks like this:
#  movbe Mv Gv, 0x0f 0x38 0xf0, CPUFeature_MOVBE
#  movbe Gv Mv, 0x0f 0x38 0xf1, CPUFeature_MOVBE
# For consistency with the production validators, drop support for the 16-bit
#  version of “movbe” in ia32 mode.
# Note that the former 32- and 64-bit validators treat “movbe” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2976
movbe Mw Gw, data16 0x0f 0x38 0xf0, norexw CPUFeature_MOVBE nacl-ia32-forbidden
movbe Gw Mw, data16 0x0f 0x38 0xf1, norexw CPUFeature_MOVBE nacl-ia32-forbidden
movbe Md Gd, 0x0f 0x38 0xf0, norexw CPUFeature_MOVBE
movbe Gd Md, 0x0f 0x38 0xf1, norexw CPUFeature_MOVBE
movbe Mq Gq, rexw 0x0f 0x38 0xf0, amd64 CPUFeature_MOVBE
movbe Gq Mq, rexw 0x0f 0x38 0xf1, amd64 CPUFeature_MOVBE
movbe Mq Gq, data16 rexw 0x0f 0x38 0xf0, amd64 CPUFeature_MOVBE nacl-forbidden
movbe Gq Mq, data16 rexw 0x0f 0x38 0xf1, amd64 CPUFeature_MOVBE nacl-forbidden
######## MOVD ##################################################################
# Textbook definition of “movd” as per AMD/Intel manuals looks like this:
#  movd Ey Vy, 0x66 0x0f 0x6e, CPUFeature_SSE2
#  movd Vy Ey, 0x66 0x0f 0x7e, CPUFeature_SSE2
#  movd Ey Py, 0x0f 0x6e, CPUFeature_MMX
#  movd Py Ey, 0x0f 0x7e, CPUFeature_MMX
# Objdump names 64bit version not “movd” but movq”.  We describe 32bit version
#  and 64bit version separately.
movd Ed Vq, 0x66 0x0f 0x6e, norexw CPUFeature_SSE2
movd Vq Ed, 0x66 0x0f 0x7e, norexw CPUFeature_SSE2 nacl-amd64-zero-extends
movd Ed Pq, 0x0f 0x6e, norexw CPUFeature_MMX
movd Pq Ed, 0x0f 0x7e, norexw CPUFeature_MMX nacl-amd64-zero-extends
movq Eq Vq, 0x66 rexw 0x0f 0x6e, amd64 CPUFeature_SSE2
movq Vq Eq, 0x66 rexw 0x0f 0x7e, amd64 CPUFeature_SSE2
movq Eq Pq, rexw 0x0f 0x6e, amd64 CPUFeature_MMX
movq Pq Eq, rexw 0x0f 0x7e, amd64 CPUFeature_MMX
######## MOVMSKPD ##############################################################
# Textbook definition of “movmskpd” as per AMD/Intel manuals looks like this:
#  movmskpd Upd Gd, 0x66 0x0f 0x50, CPUFeature_SSE2
# GNU as accepts this description, but objdump decodes last operand as “Gy”.
# Technically it makes no difference: “movmskpd” clears everything except least
# significant two bits and this operation produces precisely idential output for
# “Gy” and “Gd” operands.  We use objdump's description.
movmskpd Upd Gy, 0x66 0x0f 0x50, CPUFeature_SSE2
######## MOVMSKPS ##############################################################
# Textbook definition of “movmskps” as per AMD/Intel manuals looks like this:
#  movmskps Ups Gd, 0x0f 0x50, CPUFeature_SSE2
# GNU as accepts this description, but objdump decodes last operand as “Gy”.
# Technically it makes no difference: “movmskps” clears everything except least
# significant four bits and this operation produces precisely idential output
# for “Gy” and “Gd” operands.  We use objdump's description.
movmskps Ups Gy, 0x0f 0x50, CPUFeature_SSE
######## MOVNTI ################################################################
movnti Gy My, 0x0f 0xc3, CPUFeature_SSE2
######## MOVS/MOVSB/MOVSW/MOVSD/MOVSQ ##########################################
movs X Y, 0xa4, rep nacl-amd64-forbidden
######## MOVSX #################################################################
# Textbook definition of “movsx” as per AMD/Intel manuals looks like this:
#  movsx Eb Gv, 0x0f 0xbe
#  movsx Ew Gy, 0x0f 0xbf
# Objdump has different names for this instrustion: “movsbw”, “movsbl”, “movsbq”,
# “movswl”, “movswq” depending on operand size.  We describe 32bit versions and
# 64bit version separately.
movsbl Eb Gd, 0x0f 0xbe, norexw nacl-amd64-zero-extends
movsbq Eb Gq, rexw 0x0f 0xbe, amd64
movsbw Eb Gw, data16 0x0f 0xbe, norexw
movswl Ew Gd, 0x0f 0xbf, norexw nacl-amd64-zero-extends
movswq Ew Gq, rexw 0x0f 0xbf, amd64
movsww Ew Gw, data16 0x0f 0xbf, norexw
######## MOVSXD ################################################################
movslq Ed Gv, 0x63, amd64 nacl-amd64-zero-extends
######## MOVZX #################################################################
# Textbook definition of “movzx” as per AMD/Intel manuals looks like this:
#  movzx Eb Gv, 0x0f 0xb6
#  movzx Ew Gy, 0x0f 0xb7
# Objdump has different names for this instrustion: “movzbw”, “movzbl”, “movzbq”,
# “movzwl”, “movzwq” depending on operand size.  We describe 32bit versions and
# 64bit version separately.
movzbl Eb Gd, 0x0f 0xb6, norexw nacl-amd64-zero-extends
movzbq Eb Gq, rexw 0x0f 0xb6, amd64
movzbw Eb Gw, data16 0x0f 0xb6, norexw
movzwl Ew Gd, 0x0f 0xb7, norexw nacl-amd64-zero-extends
movzwq Ew Gq, rexw 0x0f 0xb7, amd64
movzww Ew Gw, data16 0x0f 0xb7, norexw
######## MUL ###################################################################
# “mul” is not marked as nacl-amd64-zero-extends because we never allowed it.
mul =E, 0xf6 /4
######## NEG ###################################################################
neg E, 0xf6 /3, lock nacl-amd64-zero-extends
######## NOP ###################################################################
nop, 0x90, norex
nop, 0x40 0x90, amd64 norex
nop, 0x48 0x90, amd64 norex spurious-rex.w
# Textbook definition of “nop” as per AMD/Intel manuals looks like this:
#  nop 'Ev, 0x0f 0x1f /0, no_memory_access
# For consistency with the production validators, drop support for the 16-bit
#  version of “nop”.
nop 'Ew, data16 0x0f 0x1f /0,
  no_memory_access att-show-memory-suffix-w nacl-forbidden
nop 'Ed, 0x0f 0x1f /0,
  norexw att-show-memory-suffix-l no_memory_access
nop 'Eq, rexw 0x0f 0x1f /0,
  amd64 att-show-memory-suffix-q no_memory_access
nop 'Eq, data16 rexw 0x0f 0x1f /0,
  amd64 no_memory_access att-show-memory-suffix-q nacl-forbidden
######## NOT ###################################################################
not E, 0xf6 /2, lock nacl-amd64-zero-extends
######## OR ####################################################################
or I a, 0x0c, nacl-amd64-zero-extends
or I E, 0x80 /1, lock nacl-amd64-zero-extends
or Ib Ev, 0x83 /1, lock nacl-amd64-zero-extends
or G E, 0x08, lock nacl-amd64-zero-extends
or E G, 0x0a, nacl-amd64-zero-extends
######## OUT ###################################################################
out ab =Ib, 0xe6, nacl-forbidden
out aw =Ib, data16 0xe7, nacl-forbidden
out ad =Ib, 0xe7, nacl-forbidden
out ad =Ib, rexw 0xe7, spurious-rex.w nacl-forbidden
out ad =Ib, data16 rexw 0xe7, nacl-forbidden
out ab =ob, 0xee, nacl-forbidden
out aw =ow, data16 0xef, nacl-forbidden
out ad =od, 0xef, nacl-forbidden
out ad =od, rexw 0xef, spurious-rex.w nacl-forbidden
out ad =od, data16 rexw 0xef, nacl-forbidden
######## OUTS/OUTSB/OUTSW/OUTSD ################################################
outs Xb =ob, 0x6e, rep att-show-name-suffix-b nacl-forbidden
outs Xw =ow, data16 0x6f, rep att-show-name-suffix-w nacl-forbidden
outs Xd =od, 0x6f, rep att-show-name-suffix-l nacl-forbidden
outs Xd =od, rexw 0x6f, amd64 rep att-show-name-suffix-l nacl-forbidden
outs Xd =od, data16 rexw 0x6f, amd64 rep att-show-name-suffix-l nacl-forbidden
######## PAUSE #################################################################
pause, 0xf3 0x90, norex
######## POP ###################################################################
# “pop” does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# separately.
pop Ew, data16 0x8f /0, att-show-memory-suffix-w
pop Er, 0x8f /0, ia32 att-show-memory-suffix-l
pop Er, 0x8f /0, amd64 att-show-memory-suffix-q
pop rw, data16 0x58
pop rr, 0x58
pop as, 0x07, ia32 nacl-forbidden
pop ds, 0x17, ia32 nacl-forbidden
pop bs, 0x1f, ia32 nacl-forbidden
pop fs, 0x0f 0xa1, ia32 nacl-forbidden
pop gs, 0x0f 0xa9, ia32 nacl-forbidden
pop fs, 0x0f 0xa1, amd64 att-show-name-suffix-q nacl-forbidden
pop gs, 0x0f 0xa9, amd64 att-show-name-suffix-q nacl-forbidden
######## POPCNT ################################################################
# Textbook definition of “popcnt” as per AMD/Intel manuals looks like this:
#   popcnt Ev Gv, 0xf3 0x0f 0xb8, CPUFeature_POPCNT nacl-amd64-zero-extends
# “popcnt” is not marked as nacl-amd64-zero-extends because it is unlikely to be
# useful for computing an address based on the number of ones in a value.
# Also, since f3 opcode extension is counted as rep prefix, it is not allowed
# together with data16 prefix.
# See http://code.google.com/p/nativeclient/issues/detail?id=3076
popcnt Ew Gw, data16 0xf3 0x0f 0xb8, norexw CPUFeature_POPCNT nacl-forbidden
popcnt Ed Gd, 0xf3 0x0f 0xb8, norexw CPUFeature_POPCNT
popcnt Eq Gq, rexw 0xf3 0x0f 0xb8, amd64 CPUFeature_POPCNT
popcnt Eq Gq, data16 rexw 0xf3 0x0f 0xb8, amd64 CPUFeature_POPCNT nacl-forbidden
######## POPF/POPFD/POPFQ ######################################################
popf, data16 0x9d, norexw att-show-name-suffix-w nacl-forbidden
popf, 0x9d, ia32 nacl-forbidden
popf, 0x9d, norexw amd64 att-show-name-suffix-q nacl-forbidden
popf, data16 rexw 0x9d, amd64 att-show-name-suffix-q nacl-forbidden
######## PREFETCH/PREFETCHW ####################################################
prefetch Mb, 0x0f 0x0d /0, CPUFeature_3DPRFTCH no_memory_access
prefetchw Mb, 0x0f 0x0d /1, CPUFeature_3DPRFTCH no_memory_access
prefetch Mb, 0x0f 0x0d /2, CPUFeature_3DPRFTCH no_memory_access nacl-forbidden
# AMD manual desribes this opcode as “reserved” in one place (and clarifies that
# it's aliased to prefetch for the compatibility) and as “invalid” in another
# place.  It's textbook definition as per AMD manual looks like this:
#  prefetch Mb, 0x0f 0x0d /3, CPUFeature_3DPRFTCH no_memory_access
# For consistency with the production validators, drop support for this form of
# “prefetch” in ia32 mode but support in in amd64 mode.
# Note that the former 32- and 64-bit validators treat “prefetch” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2977
prefetch Mb, 0x0f 0x0d /3, CPUFeature_3DPRFTCH no_memory_access nacl-ia32-forbidden
prefetch Mb, 0x0f 0x0d /4, CPUFeature_3DPRFTCH no_memory_access nacl-forbidden
prefetch Mb, 0x0f 0x0d /5, CPUFeature_3DPRFTCH no_memory_access nacl-forbidden
prefetch Mb, 0x0f 0x0d /6, CPUFeature_3DPRFTCH no_memory_access nacl-forbidden
prefetch Mb, 0x0f 0x0d /7, CPUFeature_3DPRFTCH no_memory_access nacl-forbidden
######## PREFETCHlevel #########################################################
prefetchnta Mb, 0x0f 0x18 /0, CPUFeature_SSE no_memory_access
prefetcht0 Mb, 0x0f 0x18 /1, CPUFeature_SSE no_memory_access
prefetcht1 Mb, 0x0f 0x18 /2, CPUFeature_SSE no_memory_access
prefetcht2 Mb, 0x0f 0x18 /3, CPUFeature_SSE no_memory_access
# AMD manual claims this opcode is “nop”.  Intel manual says it's “reserved”.
# Real silicon accepts it and seemingly doing nothing.
"nop/reserved" Mb, 0x0f 0x18 /4, CPUFeature_SSE no_memory_access nacl-forbidden
"nop/reserved" Mb, 0x0f 0x18 /5, CPUFeature_SSE no_memory_access nacl-forbidden
"nop/reserved" Mb, 0x0f 0x18 /6, CPUFeature_SSE no_memory_access nacl-forbidden
"nop/reserved" Mb, 0x0f 0x18 /7, CPUFeature_SSE no_memory_access nacl-forbidden
######## PUSH ##################################################################
# “push” does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# separately.
push =Ew, data16 0xff /6, att-show-memory-suffix-w
push =Er, 0xff /6, ia32 att-show-memory-suffix-l
push =Er, 0xff /6, amd64 att-show-memory-suffix-q
push =rw, data16 0x50
push =rr, 0x50
push =Iw, data16 0x68, att-show-name-suffix-w
push =Id, 0x68, ia32
push =Id, 0x68, amd64 att-show-name-suffix-q
push =Id, data16 rexw 0x68, amd64 att-show-name-suffix-q nacl-forbidden
push =Ib, 0x6a, ia32
push =Ib, 0x6a, amd64 att-show-name-suffix-q
push =as, 0x06, ia32 nacl-forbidden
push =cs, 0x0e, ia32 nacl-forbidden
push =ds, 0x16, ia32 nacl-forbidden
push =bs, 0x1e, ia32 nacl-forbidden
push =fs, 0x0f 0xa0, ia32 nacl-forbidden
push =gs, 0x0f 0xa8, ia32 nacl-forbidden
push =fs, 0x0f 0xa0, amd64 att-show-name-suffix-q nacl-forbidden
push =gs, 0x0f 0xa8, amd64 att-show-name-suffix-q nacl-forbidden
######## PUSHF/PUSHFD/PUSHFQ ###################################################
pushf, data16 0x9c, norexw att-show-name-suffix-w nacl-forbidden
pushf, 0x9c, ia32 nacl-forbidden
pushf, 0x9c, norexw amd64 att-show-name-suffix-q nacl-forbidden
pushf, data16 rexw 0x9c, amd64 att-show-name-suffix-q nacl-forbidden
######## RCL ###################################################################
# “rcl” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
rcl E, 0xd0 /2
rcl cb E, 0xd2 /2
rcl Ib E, 0xc0 /2
######## RCR ###################################################################
# “rcr” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
rcr E, 0xd0 /3
rcr cb E, 0xd2 /3
rcr Ib E, 0xc0 /3
######## RET (Near) ############################################################
ret, 0xc3, rep ia32 nacl-forbidden
ret, 0xc3, rep amd64 att-show-name-suffix-q nacl-forbidden
ret =Iw, 0xc2, ia32 nacl-forbidden
ret =Iw, 0xc2, amd64 att-show-name-suffix-q nacl-forbidden
######## RET (Far) #############################################################
lret, 0xcb, norexw nacl-forbidden
lret =Iw, 0xca, norexw nacl-forbidden
lretq, rexw 0xcb, amd64 nacl-forbidden
lretq =Iw, rexw 0xca, amd64 nacl-forbidden
######## ROL ###################################################################
# “rol” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
rol E, 0xd0 /0
rol cb E, 0xd2 /0
rol Ib E, 0xc0 /0
######## ROR ###################################################################
# “ror” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
ror Ib E, 0xc0 /1
ror E, 0xd0 /1
ror cb E, 0xd2 /1
######## SAHF ##################################################################
# SAHF is always awailable in 16bit/32bit mode, but not always in 64bit mode
sahf, 0x9e, ia32
sahf, 0x9e, amd64 CPUFeature_LAHF nacl-forbidden
######## SAL ###################################################################
# AMD manual claims this opcode works identically to shl.  Intel manual
# says it's reserved.  Objdump does not like it.
# sal E, 0xd0 /6
# sal cb E, 0xd2 /6
# sal Ib E, 0xc0 /6
######## SAL/SHL ###############################################################
# “sal”/“shl” is not marked as nacl-amd64-zero-extends out of caution.  We
# assume that this instruction is used for bit manipulation rather than
# computing viable addresses.
shl E, 0xd0 /4
shl cb E, 0xd2 /4
shl Ib E, 0xc0 /4
######## SAR ###################################################################
# “sar” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
sar Ib E, 0xc0 /7
sar E, 0xd0 /7
sar cb E, 0xd2 /7
######## SBB ###################################################################
# “sbb” is not marked as nacl-amd64-zero-extends since borrows/carries should
# not be need when calculating an address.
sbb I a, 0x1c
sbb I E, 0x80 /3, lock
sbb Ib Ev, 0x83 /3, lock
sbb G E, 0x18, lock
sbb E G, 0x1a
######## SCAS/SCASB/SCASW/SCASD/SCASQ ##########################################
scas Y a, 0xae, condrep nacl-amd64-forbidden
######## SETcc #################################################################
seta Eb, 0x0f 0x97, CPUFeature_CMOV
setae Eb, 0x0f 0x93, CPUFeature_CMOV
setbe Eb, 0x0f 0x96, CPUFeature_CMOV
setb Eb, 0x0f 0x92, CPUFeature_CMOV
sete Eb, 0x0f 0x94, CPUFeature_CMOV
setg Eb, 0x0f 0x9f, CPUFeature_CMOV
setge Eb, 0x0f 0x9d, CPUFeature_CMOV
setle Eb, 0x0f 0x9e, CPUFeature_CMOV
setl Eb, 0x0f 0x9c, CPUFeature_CMOV
setne Eb, 0x0f 0x95, CPUFeature_CMOV
setno Eb, 0x0f 0x91, CPUFeature_CMOV
setnp Eb, 0x0f 0x9b, CPUFeature_CMOV
setns Eb, 0x0f 0x99, CPUFeature_CMOV
seto Eb, 0x0f 0x90, CPUFeature_CMOV
setp Eb, 0x0f 0x9a, CPUFeature_CMOV
sets Eb, 0x0f 0x98, CPUFeature_CMOV
######## SFENCE ################################################################
sfence, 0x0f 0xae 0xf8, CPUFeature_EMMXSSE
######## SHLD ##################################################################
# Textbook definition of “shrd” as per AMD/Intel manuals looks like this:
#  shld Ib Gv Ev, 0x0f 0xa4
#  shld cb Gv Ev, 0x0f 0xa5
# For consistency with the production validators, drop support for the 16-bit
#  version of “shld” in ia32 mode.
# Note that the former 32- and 64-bit validators treat “shld” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2978
#
# “shld” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
shld Ib Gw Ew, data16 0x0f 0xa4, norexw nacl-ia32-forbidden
shld cb Gw Ew, data16 0x0f 0xa5, norexw nacl-ia32-forbidden
shld Ib Gd Ed, 0x0f 0xa4, norexw
shld cb Gd Ed, 0x0f 0xa5, norexw
shld Ib Gq Eq, rexw 0x0f 0xa4, amd64
shld cb Gq Eq, rexw 0x0f 0xa5, amd64
shld Ib Gq Eq, data16 rexw 0x0f 0xa4, amd64 nacl-forbidden
shld cb Gq Eq, data16 rexw 0x0f 0xa5, amd64 nacl-forbidden
######## SHR ###################################################################
# “shr” is not marked as nacl-amd64-zero-extends out of caution.  We assume that
# this instruction is used for bit manipulation rather than computing viable
# addresses.
shr E, 0xd0 /5
shr cb E, 0xd2 /5
shr Ib E, 0xc0 /5
######## SHRD ##################################################################
# Textbook definition of “shrd” as per AMD/Intel manuals looks like this:
#  shld Ib Gv Ev, 0x0f 0xa4
#  shld cb Gv Ev, 0x0f 0xa5
# For consistency with the production validators, drop support for the 16-bit
#  version of “shrd” in ia32 mode.
# Note that the former 32- and 64-bit validators treat “shrd” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2980
#
# “shrd” is not marked as nacl-amd64-zero-extends out of caution.  We assume
# that this instruction is used for bit manipulation rather than computing
# viable addresses.
shrd Ib Gw Ew, data16 0x0f 0xac, norexw nacl-ia32-forbidden
shrd cb Gw Ew, data16 0x0f 0xad, norexw nacl-ia32-forbidden
shrd Ib Gd Ed, 0x0f 0xac, norexw
shrd cb Gd Ed, 0x0f 0xad, norexw
shrd Ib Gq Eq, rexw 0x0f 0xac, amd64
shrd cb Gq Eq, rexw 0x0f 0xad, amd64
shrd Ib Gq Eq, data16 rexw 0x0f 0xac, amd64 nacl-forbidden
shrd cb Gq Eq, data16 rexw 0x0f 0xad, amd64 nacl-forbidden
######## SLWPCB ################################################################
slwpcb Ry, 0x8f RXB.09 W.1111.0.00 0x12 /1, CPUFeature_LWP
######## STC ###################################################################
stc, 0xf9
######## STD ###################################################################
std, 0xfd
######## STOS/STOSB/STOSW/STOSD/STOSQ ##########################################
stos a Y, 0xaa, rep nacl-amd64-forbidden
######## SUB ###################################################################
sub I a, 0x2c, nacl-amd64-zero-extends
sub I E, 0x80 /5, lock nacl-amd64-zero-extends
sub Ib Ev, 0x83 /5, lock nacl-amd64-zero-extends
sub G E, 0x28, lock nacl-amd64-zero-extends
sub E G, 0x2a, nacl-amd64-zero-extends
######## T1MSKC ################################################################
t1mskc Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /7, CPUFeature_TBM
######## TEST ##################################################################
test I =a, 0xa8
test I =E, 0xf6 /0
# AMD manual claims this opcode works identically to “/0”.  Intel manual
# says it's reserved.  Objdump does not like it.
# test I =E, 0xf6 /1
test G =E, 0x84
######## TZCNT #################################################################
# Textbook definition of “tzcnt” as per AMD/Intel manuals looks like this:
#   tzcnt Ev Gv, 0xf3 0x0f 0xbc, CPUFeature_TZCNT nacl-amd64-zero-extends
# “tzcnt” is not marked as nacl-amd64-zero-extends because it is unlikely to be
# useful for computing an address based on the number of trailing zeros of a
# value.
# We mark tzcnt specially to allow it independently from CPUID
# See http://code.google.com/p/nativeclient/issues/detail?id=2869
# Also, since f3 opcode extension is counted as rep prefix, it is not allowed
# together with data16 prefix.
# See http://code.google.com/p/nativeclient/issues/detail?id=3076
tzcnt Ew Gw, data16 0xf3 0x0f 0xbc, norexw CPUFeature_TZCNT nacl-forbidden
tzcnt Ed Gd, 0xf3 0x0f 0xbc, norexw CPUFeature_TZCNT
tzcnt Eq Gq, rexw 0xf3 0x0f 0xbc, amd64 CPUFeature_TZCNT
tzcnt Eq Gq, data16 rexw 0xf3 0x0f 0xbc, amd64 CPUFeature_TZCNT nacl-forbidden
######## TZMSK #################################################################
tzmsk Ey By, 0x8f RXB.09 W.dest.0.00 0x01 /4, CPUFeature_TBM
######## XADD ##################################################################
# Textbook definition of “xadd” as per AMD/Intel manuals looks like this:
#  xadd &G E, 0x0f 0xc0, lock nacl-amd64-zero-extends
# For consistency with the production validators, drop support for the 16-bit
#  version of “xadd” in ia32 mode.
# Also, don't consider xadd with memory zero-extending.
#  See http://code.google.com/p/nativeclient/issues/detail?id=3077
# Note that the former 32- and 64-bit validators treat “xadd” inconsistently:
#  http://code.google.com/p/nativeclient/issues/detail?id=2981
xadd &Gb Eb, 0x0f 0xc0, lock
xadd &Gw Ew, data16 0x0f 0xc1, norexw lock nacl-ia32-forbidden
xadd &Gd Rd, 0x0f 0xc1, norexw lock nacl-amd64-zero-extends
xadd &Gd Md, 0x0f 0xc1, norexw lock
xadd &Gq Eq, rexw 0x0f 0xc1, lock amd64
xadd &Gq Eq, data16 rexw 0x0f 0xc1, lock amd64 nacl-forbidden
######## XCHG ##################################################################
# For consistency with prod. validator, don't consider exchange with memory
# zero-extending.
# See http://code.google.com/p/nativeclient/issues/detail?id=3071
xchg &av rv, 0x90, nacl-amd64-zero-extends
xchg &G R, 0x86, lock nacl-amd64-zero-extends
xchg &G M, 0x86, lock
######## XLAT ##################################################################
xlat xb, 0xd7, nacl-forbidden
######## XOR ###################################################################
xor I a, 0x34, nacl-amd64-zero-extends
xor I E, 0x80 /6, lock nacl-amd64-zero-extends
xor Ib Ev, 0x83 /6, lock nacl-amd64-zero-extends
xor G E, 0x30, lock nacl-amd64-zero-extends
xor E G, 0x32, nacl-amd64-zero-extends
################################################################################
